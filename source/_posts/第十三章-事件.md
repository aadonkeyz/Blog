---
title: 第十三章 事件
categories:
    - JavaScript
    - 《JavaScript高级程序设计》
abbrlink: 9c2b83ad
date: 2019-04-25 14:31:19
---

JavaScript与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间，比如：点击按钮、拖动鼠标等。

# 事件流

## 事件冒泡

事件冒泡是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的HTML页面为例：

```html
<!DOCTYPE html>
<html>
    <head>
        <title>Event Bubbling Example</title>
    </head>
    <body>
        <div id="myDiv">Click Me</div>
    </body>
</html>
```

如果你单击了页面中的`<div>`元素，那么这个click事件会按照如下顺序传播：

![13-1事件冒泡](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/13-1%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1.png)

## 事件捕获

事件捕获的顺序与事件冒泡的顺序正好相反，以前面的HTML页面为例，它的顺序为：

![13-2事件捕获](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/13-2%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7.png)

## DOM事件流

“DOM2级事件”规定的事件流包括三个阶段：**事件捕获阶段**、**处于目标阶段**和**事件冒泡阶段**。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。还是以前面的HTML页面为例，它的顺序如下所示：

![13-3DOM事件流](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/13-3DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.png)

在DOM事件流中，实际的目标（`<div>`元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从`document`到`<html>`再到`<body>`后就停止了。下一个阶段是“处于目标”阶段，于是事件在`<div>`上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。

多数支持DOM事件流的浏览器都实现了一种特定的行为：即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果就是有两个机会在目标对象上面操作事件。

# 事件处理程序

事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做**事件处理程序**（或**事件侦听器**）。事件处理程序的名字就是在事件名前面加上`"on"`，因此click事件的事件处理程序就是`onclick`，load事件的事件处理程序就是`onload`。为事件注册处理程序的方式有好几种，下面一一进行介绍。

## HTML事件处理程序

某个元素支持的每种事件，都拥有一个与相应事件处理程序同名的HTML特性，可以通过这个特性来注册事件处理程序。下面以`onclick`事件为例：

```js
// test.js
function showAnother (that) {
    alert(that.value)
}
```
```html
<!DOCTYPE html>
<html>
    <head>
        <title>test</title>
    </head>
    <body>
        <!-- 直接在HTML中指定具体动作 -->
        <input type="button" value="1" onclick="alert(this.value)" />

        <!-- 调用在<script>标签内定义的函数 -->
        <input type="button" value="2" onclick="showMessage(this, event)" />

        <!-- 调用外部js文件中定义的函数 -->
        <input type="button" value="3" onclick="showAnother(this)" />

        <script type="text/javascript" src="./test.js"></script>
        <script type="text/javascript">
            function showMessage (that, event) {
                alert(that.value)
                console.log(that)
                console.log(event)
            }
        </script>
    </body>
</html>
```

在HTML中注册事件处理程序，会创建一个封装着元素属性值的函数。这个函数中有一个局部变量`event`，也就是事件对象（后面将会讨论这个概念），通过`event`变量可以直接访问事件对象。并且在这个函数内部，`this`值等于事件的目标元素。所以你可以将`event`和`this`当做参数，传递给要调用的函数。关于这一点，你可以查看上面例子中`showMessage()`函数打印的内容来验证。

{% note info %}
HTML事件处理程序的缺点：
- 如果用户在页面解析`showMessage()`和`showAnother()`之前就点击了对应的按钮，会抛出错误。可以使用`onclick="try {showMessage()} catch(ex) {}"`的形式来解决这个问题；
- 事件处理程序的作用域链在不同的浏览器中会有不同的结果；
- HTML和JS代码紧密耦合。
{% endnote %}

## DOM0级事件处理程序

使用DOM0级方法注册的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行。换句话说，如果事件处理程序不是通过[**箭头函数**](https://aadonkeyz.com/posts/9595c646/#箭头函数)注册的，那么它的`this`引用的是当前元素。

在添加的事件处理程序函数内部，可以直接通过`event`变量访问事件对象。

以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。你可以通过将事件处理程序属性的值设置为`null`来删除添加的事件处理程序。

来看一个例子：

```html
<!DOCTYPE html>
<html>
    <head>
        <title>test</title>
    </head>
    <body>
        <input id="myButton" type="button" value="1" />
        <script type="text/javascript">
            var button = document.getElementById('myButton')
            button.onclick = function () {
                console.log(this)
                console.log(event)

                // 删除添加的事件处理程序
                button.onclick = null
            }
        </script>
    </body>
</html>
```

这个例子中的按钮，只有第一次点击时会打印内容，之后就没有任何反应，因为事件处理程序在第一次触发之后，就被删除了。

## DOM2级事件处理程序

“DOM2级事件”定义了两个方法，`addEventListener()`和`removeEventListener()`，分别用于注册和删除事件处理程序，所有DOM节点都包含这两个方法。

**关于`this`和`event`的使用规则，与DOM0级事件处理程序一致。**

{% note info %}
首先介绍`addEventListener()`方法，它的参数如下：
- **type**：表示监听事件类型的字符串，**需要注意的是没有`on`前缀**；
- **listener**：作为事件处理程序的函数；
- **options（可选）**：一个对象。其属性如下：
    1. **capture**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在事件捕获阶段时被调用；
    2. **once**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在其被调用之后自动移除；
    3. **passive**：一个布尔值，默认为`false`。当值为`true`时，`listener`内部不允许调用`event.preventDefault()`，否则会抛出错误。
- **useCapture（可选）**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在事件捕获阶段时被调用。

**对于`options`和`useCapture`参数，它们都是该方法的第三个参数，`options`是新标准，而`useCapture`是老标准。**

---
接着介绍`removeEventListener()`方法，它的参数如下：
- **type**：表示监听事件类型的字符串，**需要注意的是没有`on`前缀**；
- **listener**：作为事件处理程序的函数；
- **options（可选）**：一个对象。其属性如下：
    1. **capture**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在事件捕获阶段时被调用。
- **useCapture（可选）**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在事件捕获阶段时被调用。

**如果一个事件处理程序一共注册了两次，一次在事件捕获阶段，一次在事件冒泡阶段，那么这两次注册需要分别移除，两者不会互相干扰。**
{% endnote %}

下面的例子用于观察`options.capture`和`useCapture`的效果。

```html
<!DOCTYPE html>
<html>
    <head>
        <title>test</title>
        <style>
            #outer, #inner {
                display: block;
                width: 500px;
                height: 500px;
                text-decoration: none;
            }
            #outer{
                border: 1px solid red;
                color: red;
            }
            #inner{
                border: 1px solid green;
                color: green;
                width: 250px;
                height: 250px;
                margin: 125px auto;
            }
        </style>
    </head>
    <body>
        <div id="outer">
            outer, capture & none-capture
            <div id="inner">
                inner
            </div>
        </div>
        <script type="text/javascript">
            var outer = document.getElementById('outer')
            var inner = document.getElementById('inner')

            function captureListener1 () {
                console.log('outer, capture1')
                outer.removeEventListener('click', captureListener1, true)
            }
            function captureListener2 () {
                console.log('outer, capture2')
            }
            function noneCaptureListener () {
                console.log('outer, none-capture')
            }
            function innerListener () {
                console.log('inner')
            }

            outer.addEventListener('click', captureListener1, { capture: true })
            outer.addEventListener('click', captureListener2, true)
            outer.addEventListener('click', noneCaptureListener)
            inner.addEventListener('click', innerListener)
        </script>
    </body>
</html>
```

上例中`captureListener1`和`captureListener2`都是注册在`outer`的捕获阶段，而`noneCaptureListener`和`innerListener`分别注册在`outer`和`inner`的冒泡阶段。并且`captureListener1`会在第一次调用后被移除。请多点击几次inner框，查看打印的结果。

# 事件对象

在触发DOM上的某个事件时，会产生一个事件对象`event`，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。这里只介绍DOM中的事件对象，忽略IE的。

无论注册事件处理程序时使用的是DOM0级还是DOM2级方法，兼容DOM的浏览器都会将一个`event`对象传入到事件处理程序中，这样就可以直接在函数内部访问到`event`对象了。

{% note info %}
`event`对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都会有下面列出的成员：
- 这里实在是整理不动了，如果根据名字判断不出怎么用，去[**MDN**](https://developer.mozilla.org/en-US/docs/Web/API/Event)看看吧。
- **bubbles**
- **cancelBubble**
- **cancelable**
- **composed**
- **currentTarget**
- **defaultPrevented**
- **eventPhase**
- **returnValue**
- **target**
- **timeStamp**
- **type**
- **isTrusted**
- **composedPath( )**
- **preventDefault( )**
- **stopImmediatePropagation( )**
- **stopPropagation( )**
{% endnote %}

# 事件类型
{% note info %}
下面我只简单的介绍一下我认为比较常用的事件，如果你想比较全面的了解这里，点击下面的链接！

[**MDN，只有你想不到，没有找不到**](https://developer.mozilla.org/en-US/docs/Web/Events)
{% endnote %}
## UI事件

{% note success %}
一般来说，在`window`上面发生的任何事件都可以在`<body>`元素中通过相应的特性来指定事件处理程序，因为在HTML中无法访问window元素。实际上，这只是为了保证向后兼容的一种权宜之计，但所有浏览器都能很好地支持这种方式。我们建议尽可能使用DOM的方式来注册事件处理程序。
{% endnote %}

### load事件

{% note info %}
- 当页面完全加载后（包括所有图像、js文件、css文件等外部资源），就会触发`window`上面的load事件。你可以通过在`<body>`元素上添加一个`onload`特性或者使用DOM的方法为`window`注册`onload`事件处理程序；
- 图像上也可以注册`onload`事件处理程序。**需要注意的是，图像元素不一定要从添加到文档后才开始下载，而是只要设置了`src`属性就会开始下载**；
- 在IE9、Firefox、Opera、Chrome和Safari3+及更高版本中，`<script>`元素也会触发load事件。**与图像不同，只有在设置了`src`属性并将`<script>`元素添加到文档后，才会开始下载js文件**；
- IE和Opera还支持`<link>`元素上的load事件，与`<script>`元素类似，**在未指定`href`属性并将`<link>`元素添加到文档之前也不会开始下载样式表**。
{% endnote %}

下面说个有关图像元素的题外话，下面这两种方式是完全等价的：

```html
<img width="100" height="200" src="picture.jpg">
```
```js
var myImage = new Image(100, 200)
myImage.src = 'picture.jpg'
document.body.appendChild(myImage)
```

### unload事件

与load事件对应的是unload事件，这个事件在文档完全卸载后触发。只要用户从一个页面切换到另一个页面，就会触发unload事件。而利用这个事件最多的情况是消除引用，以避免内存泄露。

既然unload事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。此时，操作DOM节点或元素的样式就会导致错误。

### resize事件

当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件，这个事件在`window`上面触发。

关于何时会触发resize事件，不同浏览器有不同的机制。IE、Safari、Chrome和Opera会在浏览器窗口变化了1像素时就触发resize事件，然后随着变化不断重复触发。Firefox则只会在用户停止调整窗口大小时才会触发resize事件。

### scroll事件

虽然scroll事件是在`window`对象上发生的，但它实际表示的则是页面中相应元素的变化。在混杂模式下，可以通过`<body>`元素的`scrollLeft`和`scrollTop`来监控到这一变化；而在标准模式下，除Safari之外的所有浏览器都会通过`<html>`元素来反映这一变化（Safari仍然基于`<body>`跟踪滚动位置）。

与resize事件事件类似，scroll事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件处理程序的代码简单。

## 焦点事件

{% note info %}
焦点事件会在页面获得或失去焦点时触发。利用这些事件并与`document.hasFocus()`方法及`document.activeElement`属性的配合，可以知晓用户在页面上的行踪。有以下焦点事件：
- **blur**：在元素失去焦点时触发，这个事件不会冒泡，所有浏览器都支持它；
- **focus**：在元素获得焦点时触发，这个事件不会冒泡，所有浏览器都支持它；
- **focusin**：在元素获得焦点时触发，会冒泡。支持这个事件的浏览器有IE5.5+、Safari5.1+、Opera11.5+和Chrome；
- **focusout**：在元素失去焦点时触发，会冒泡。支持这个事件的浏览器有IE5.5+、Safari5.1+、Opera11.5+和Chrome。

---
当焦点从页面中的一个元素移动到另一个元素，会一次触发下例事件：
1. **focusout**：在失去焦点的元素上触发；
2. **focusin**：在获得元素的焦点上触发；
3. **blur**：在失去焦点的元素上触发；
4. **focus**：在获得元素的焦点上触发。
{% endnote %}

## 鼠标与滚轮事件

{% note info %}
鼠标事件是Web开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。DOM3级事件中定义了9个鼠标事件，简介如下：
- **click**：在用户单击鼠标钮（一般是左边的按钮）或者按下回车键时触发；
- **dblclick**：在用户双击鼠标按钮（一般是左边的按钮）时触发；
- **contextmenu**：在用户点击鼠标右键时触发；
- **mousedown**：在用户按下了任意鼠标按钮时触发；
- **mouseenter**：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且当光标移动到后代元素上时不会触发；
- **mouseleave**：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且当光标移动到后代元素上时不会触发；
- **mousemove**：当鼠标指针在元素内部移动时重复地触发；
- **mouseout**：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素；
- **mouseover**：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发；
- **mouseup**：在用户释放鼠标按钮时触发。

---
- 页面上的所有元素都支持鼠标事件。除了mouseenter和mouseleave，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为；
- 只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click事件；如果mousedown或mouseup中的一个被取消，就不会触发click事件。类似地，只有触发两次click事件，才会触发一次dblclick事件。
{% endnote %}

## 键盘与文本事件

{% note info %}
- **keydown**：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件；
- **keyup**：当用户释放键盘上的键时触发。
{% endnote %}

# 内存和性能

在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。

## 事件委托

对“事件处理程序过多”问题的解决方案就是**事件委托**。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click事件会一直冒泡到`document`层次。也就是说，我们可以为整个页面指定一个`onclick`事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。

## 移除事件处理程序

每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。如前所述，可以采用事件委托技术，限制建立的连接数量。另外，在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的“空事件处理程序”，也是造成Web应用程序内存与性能问题的主要原因。

在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的DOM操作，例如使用`removeChild()`方法，但更多地是发生在使用`innerHTML`替换页面中某一部分的时候。如果带有事件处理程序的元素被`innerHTML`删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。**所以如果你知道某个元素即将被移除，那么最好在此之前手工移除事件处理程序。**

另一种情况，就是卸载页面的时候。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。每次加载完页面在卸载页面时（可能是在两个页面间来回切换，也可能是单击了“刷新”按钮），内存中滞留的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。**因此最好的做法就是在页面卸载之前，先通过`onunload`事件处理程序移除所有事件处理程序。**
