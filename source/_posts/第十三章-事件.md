---
title: 第十三章 事件
categories:
  - JavaScript
  - 《JavaScript高级程序设计》
abbrlink: 9c2b83ad
date: 2019-04-25 14:31:19
---

JavaScript与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间，比如：点击按钮、拖动鼠标等。

# 事件流

## 事件冒泡

事件冒泡是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的HTML页面为例：

```html
<!DOCTYPE html>
<html>
    <head>
        <title>Event Bubbling Example</title>
    </head>
    <body>
        <div id="myDiv">Click Me</div>
    </body>
</html>
```

如果你单击了页面中的`<div>`元素，那么这个click事件会按照如下顺序传播：

![13-1事件冒泡](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/13-1%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1.png)

## 事件捕获

事件捕获的顺序与事件冒泡的顺序正好相反，以前面的HTML页面为例，它的顺序为：

![13-2事件捕获](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/13-2%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7.png)

## DOM事件流

“DOM2级事件”规定的事件流包括三个阶段：**事件捕获阶段**、**处于目标阶段**和**事件冒泡阶段**。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。还是以前面的HTML页面为例，它的顺序如下所示：

![13-3DOM事件流](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/13-3DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.png)

在DOM事件流中，实际的目标（`<div>`元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从`document`到`<html>`再到`<body>`后就停止了。下一个阶段是“处于目标”阶段，于是事件在`<div>`上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。

多数支持DOM事件流的浏览器都实现了一种特定的行为：即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果就是有两个机会在目标对象上面操作事件。

# 事件处理程序

事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做**事件处理程序**（或**事件侦听器**）。事件处理程序的名字以`"on"`开头，因此click事件的事件处理程序就是`onclick`，load事件的事件处理程序就是`onload`。为事件注册处理程序的方式有好几种，下面一一进行介绍。

## HTML事件处理程序

某个元素支持的每种事件，都拥有一个与相应事件处理程序同名的HTML特性，可以通过这个特性来注册事件处理程序。下面以`onclick`事件为例：

```js
// test.js
function showAnother (that) {
    alert(that.value)
}
```
```html
<!DOCTYPE html>
<html>
    <head>
        <title>test</title>
    </head>
    <body>
        <!-- 直接在HTML中指定具体动作 -->
        <input type="button" value="1" onclick="alert(this.value)" />

        <!-- 调用在<script>标签内定义的函数 -->
        <input type="button" value="2" onclick="showMessage(this, event)" />

        <!-- 调用外部js文件中定义的函数 -->
        <input type="button" value="3" onclick="showAnother(this)" />

        <script type="text/javascript" src="./test.js"></script>
        <script type="text/javascript">
            function showMessage (that, event) {
                alert(that.value)
                console.log(that)
                console.log(event)
            }
        </script>
    </body>
</html>
```

在HTML中注册事件处理程序，会创建一个封装着元素属性值的函数。这个函数中有一个局部变量`event`，也就是事件对象（后面将会讨论这个概念），通过`event`变量可以直接访问事件对象。并且在这个函数内部，`this`值等于事件的目标元素。所以你可以将`event`和`this`当做参数，传递给要调用的函数。关于这一点，你可以查看上面例子中`showMessage()`函数打印的内容来验证。

{% note info %}
HTML事件处理程序的缺点：
- 如果用户在页面解析`showMessage()`和`showAnother()`之前就点击了对应的按钮，会抛出错误。可以使用`onclick="try {showMessage()} catch(ex) {}"`的形式来解决这个问题；
- 事件处理程序的作用域链在不同的浏览器中会有不同的结果；
- HTML和JS代码紧密耦合。
{% endnote %}

## DOM0级事件处理程序

使用DOM0级方法注册的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行。换句话说，如果事件处理程序不是通过[**箭头函数**](https://aadonkeyz.com/posts/9595c646/#箭头函数)注册的，那么它的`this`引用的是当前元素。

在添加的事件处理程序函数内部，可以直接通过`event`变量访问事件对象。

以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。你可以通过将事件处理程序属性的值设置为`null`来删除添加的事件处理程序。

来看一个例子：

```html
<!DOCTYPE html>
<html>
    <head>
        <title>test</title>
    </head>
    <body>
        <input id="myButton" type="button" value="1" />
        <script type="text/javascript">
            var button = document.getElementById('myButton')
            button.onclick = function () {
                console.log(this)
                console.log(event)

                // 删除添加的事件处理程序
                button.onclick = null
            }
        </script>
    </body>
</html>
```

这个例子中的按钮，只有第一次点击时会打印内容，之后就没有任何反应，因为事件处理程序在第一次触发之后，就被删除了。

## DOM2级事件处理程序

“DOM2级事件”定义了两个方法，`addEventListener()`和`removeEventListener()`，分别用于注册和删除事件处理程序，所有DOM节点都包含这两个方法。

**关于`this`和`event`的使用规则，与DOM0级事件处理程序一致。**

{% note info %}
首先介绍`addEventListener()`方法，它的参数如下：
- **type**：表示监听事件类型的字符串，**需要注意的是没有`on`前缀**；
- **listener**：作为事件处理程序的函数；
- **options（可选）**：一个对象。其属性如下：
    1. **capture**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在事件捕获阶段时被调用；
    2. **once**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在其被调用之后自动移除；
    3. **passive**：一个布尔值，默认为`false`。当值为`true`时，`listener`内部不允许调用`event.preventDefault()`，否则会抛出错误。
- **useCapture（可选）**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在事件捕获阶段时被调用。

**对于`options`和`useCapture`参数，它们都是该方法的第三个参数，`options`是新标准，而`useCapture`是老标准。**

---
接着介绍`removeEventListener()`方法，它的参数如下：
- **type**：表示监听事件类型的字符串，**需要注意的是没有`on`前缀**；
- **listener**：作为事件处理程序的函数；
- **options（可选）**：一个对象。其属性如下：
    1. **capture**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在事件捕获阶段时被调用。
- **useCapture（可选）**：一个布尔值，默认为`false`。当值为`true`时，`listener`会在事件捕获阶段时被调用。

**如果一个事件处理程序一共注册了两次，一次在事件捕获阶段，一次在事件冒泡阶段，那么这两次注册需要分别移除，两者不会互相干扰。**
{% endnote %}

下面的例子用于观察`options.capture`和`useCapture`的效果。

```html
<!DOCTYPE html>
<html>
    <head>
        <title>test</title>
        <style>
            #outer, #inner {
                display: block;
                width: 500px;
                height: 500px;
                text-decoration: none;
            }
            #outer{
                border: 1px solid red;
                color: red;
            }
            #inner{
                border: 1px solid green;
                color: green;
                width: 250px;
                height: 250px;
                margin: 125px auto;
            }
        </style>
    </head>
    <body>
        <div id="outer">
            outer, capture & none-capture
            <div id="inner">
                inner
            </div>
        </div>
        <script type="text/javascript">
            var outer = document.getElementById('outer')
            var inner = document.getElementById('inner')

            function captureListener1 () {
                console.log('outer, capture1')
                outer.removeEventListener('click', captureListener1, true)
            }
            function captureListener2 () {
                console.log('outer, capture2')
            }
            function noneCaptureListener () {
                console.log('outer, none-capture')
            }
            function innerListener () {
                console.log('inner')
            }

            outer.addEventListener('click', captureListener1, { capture: true })
            outer.addEventListener('click', captureListener2, true)
            outer.addEventListener('click', noneCaptureListener)
            inner.addEventListener('click', innerListener)
        </script>
    </body>
</html>
```

上例中`captureListener1`和`captureListener2`都是注册在`outer`的捕获阶段，而`noneCaptureListener`和`innerListener`分别注册在`outer`和`inner`的冒泡阶段。并且`captureListener1`会在第一次调用后被移除。请多点击几次inner框，查看打印的结果。

# 事件对象

在触发DOM上的某个事件时，会产生一个事件对象`event`，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。这里只介绍DOM中的事件对象，忽略IE的。

无论注册事件处理程序时使用的是DOM0级还是DOM2级方法，兼容DOM的浏览器都会将一个`event`对象传入到事件处理程序中，这样就可以直接在函数内部访问到`event`对象了。

{% note info %}
`event`对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都会有下面列出的成员：
- 这里实在是整理不动了，如果根据名字判断不出怎么用，去[**MDN**](https://developer.mozilla.org/en-US/docs/Web/API/Event)看看吧。
- **bubbles**
- **cancelBubble**
- **cancelable**
- **composed**
- **currentTarget**
- **defaultPrevented**
- **eventPhase**
- **returnValue**
- **target**
- **timeStamp**
- **type**
- **isTrusted**
- **composedPath( )**
- **preventDefault( )**
- **stopImmediatePropagation( )**
- **stopPropagation( )**
{% endnote %}

# 事件类型


