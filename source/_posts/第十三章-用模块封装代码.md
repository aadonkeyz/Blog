---
title: 第十三章 用模块封装代码
categories:
  - JavaScript
  - 《深入理解ES6》
abbrlink: 588c1481
date: 2019-04-17 16:05:23
---

# 何为模块？

{% note info %}
模块是使用不同方式加载的JS文件（与JS原先的脚本加载方式相对）。这种不同模式很有必要，因为它与脚本有大大不同的语义：
- 模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式；
- 在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域内部存在；
- 模块顶级作用域的`this`值为`undefined`；
- 模块不允许在代码中使用HTML风格的注释；
- 对于需要让模块外部代码访问的内容，模块必须导出它们；
- 允许模块从其他模块导入绑定。
{% endnote %}

CommonJs是在ES6之前的模块规范，至今仍然被广泛使用。[**点击这里了解CommonJs**](https://aadonkeyz.com/posts/b3fe2fad/)！

# 导出

ES6的导出有两种形式：命名导出和默认导出。

## 命名导出

命名导出要求导出的内容必须有自己的标识符，这就意味着不能使用这种方式来导出匿名函数或匿名类。

你可以将`export`放置在任意变量、函数或类声明之前，从模块中将它们公开出去，就像这样：

```js
export var color = 'red'

export let name = 'Nicholas'

export const magicNumber = 7

export function sum(num1, num2) {
    return num1 + num1
}

export class Rectangle {
    constructor (length, width) {
        this.length = length
        this.width = width
    }
}
```

或者使用花括号包裹想要导出内容的标识符，一起将它们导出。在使用这种方式的时候，允许你对导出的内容进行重命名：

```js
function multiply (num1, num2) {
    return num1 * num2
}

function sum (num1, num2) {
    return num1 + num2
}

export { multiply, sum as add }
```

## 默认导出

模块的默认值是使用`default`关键字所指定的单个变量、函数或类，而你在每个模块中最多只能设置一个默认导出，将`default`关键字用于多个导出会是语法错误。

使用`default`可以导出匿名函数或匿名类，实际上默认导出并不在乎导出内容的标识符，就算导出的内容原本是有标识符的，在其他模块中引入时，也会忽略它原本的标识符。

以下三种用法都是正确的：

```js
export default function (num1, num2) {
    return num1 + num2
}
```
```js
function sum (num1, num2) {
    return num1 + num2
}

export default sum
```
```js
function sum (num1, num2) {
    return num1 + num2
}

export { sum as default }
```

**不要将`default`和赋值表达式一起使用，否则会抛出错误：**

```js
export default sum = function () {}    // ReferenceError: sum is not defined
```

# 导入

## 导入的语法

创建了a.js文件用于导出，b.js文件用于导入：

```js
// a.js
export var count = 0
export var color = 'red'

export function multiply (num1, num2) {
    return num1 * num2
}

export function sum (num1, num2) {
    return num1 + num2
}

var num = 666
export default num
```
```js
// b.js
import { count } from './a.js'
import { sum as add, multiply } from './a.js'
console.log(count)          // 0
console.log(add)            // [Function: sum]
console.log(multiply)       // [Function: multiply]

import * as moduleA from './a.js'
console.log(moduleA)        // {
                            //      multiply: [Function: multiply],
                            //      sum: [Function: sum],
                            //      count: 0,
                            //      color: 'red',
                            //      default: 666
                            // }

import default1 from './a.js'
console.log(default1)       // 666

import { default as default2 } from './a.js'
console.log(default2)       //666

import default3, { color } from './a.js'
console.log(default3)       // 666
console.log(color)          // red
```

{% note info %}
根据上面例子，总结以下几点注意事项：
- 在使用`import`引入一个模块的内容时，除了默认导出，其他导出均需要根据标识符来进行匹配；
- 默认导出是一个特立独行的存在，它在原模块中的标识符是被忽略的。比如上面例子中的`moduleA`对象不包含`num`属性，但是包含`default`属性。

另外需要记住的是，**无论你对同一个模块使用了多少次`import`语句，该模块都只会被执行一次。在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他`import`所引用。**
{% endnote %}

## 导入绑定的一个微妙怪异点

ES6的`import`语句为变量、函数与类创建了**只读绑定**，而不像普通变量那样简单引用了原始绑定。并且不允许修改这个只读绑定的值，否则会抛出错误。

```js
// a.js
export var name = 'Nicholas'

export function setName (newName) {
    name = newName
}
```
```js
// b.js
import { name, setName } from './a.js'

console.log(name)       // Nicholas

setName('Greg')
console.log(name)       // Greg

name = 'Nicholas'       // SyntaxError: "name" is read-only
```

调用`setName('Greg')`会回到导出`setName()`的模块内部，并在那里执行，从而将a.js文件内的`name`设置为`'Greg'`，注意这个变化会自动反映到b.js文件内所导入的`name`绑定上。

# 绑定的在导出

也许有时你会想将当前模块已导入的内容重新再导出，你可以这样做：

```js
import { sum } from './example.js'
export { sum }
```

此方法能奏效，但还可以使用单个语句来完成相同的任务：

```js
export { sum } from './example.js'
```

这种形式的`export`会进入指定模块查看`sum`的定义，随后将其导出。当然，你也可以选择一个值用不同名称导出：

```js
export { sum as add } from './example.js'
```

若你想将来自另一个模块的所有值完全导出，可以使用星号（`*`）模式：

```js
export * from './example.js'
```

使用完全导出，就可以导出目标模块的默认值及所有具名导出，但这可能影响你从当前模块所能导出的值。例如，假设example.js具有一个默认导出，当你使用这种语法时，你就无法为当前模块另外再定义一个默认导出。

# 无绑定的导入

# import/export的限制

# 循环
