---
title: 动态规划
abbrlink: a80d0031
date: 2020-10-07 15:42:23
categories:
  - 数据结构与算法
---

# 最长有效括号

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。
`"(()" => 2`
`")()())" => 4`
`"()(())" => 6`

```js
/**
 * s => 01234567...i
 * 1. 定义 dp[i]:
 *    存在 0 <= x <= i, x...i 为以 i 结尾的最长有效括号子串, dp[i] 为子串长度
 * 2. 确定状态转移方程:
 *    2.1 若 s[i] = '(', 则 dp[i] = 0
 *    2.2 若 s[i] = ')'
 *      2.2.1 若 s[i - 1] = '(', 则 dp[i] = dp[i - 2] + 2
 *      2.2.2 若 s[i - 1] = ')'
 *        2.2.2.1 若 dp[i - 1] = 0, 则 dp[i] = 0
 *        2.2.2.2 若 dp[i - 1] > 0
 *          2.2.2.2.1 若 s[i - 1 - dp[i - 1]] = '(', 则 dp[i] = dp[i - 1] + 2 + dp[i - 2 - dp[i - 1]]
 *          2.2.2.2.2 若 s[i - 1 - dp[i - 1]] = ')', 则 dp[i] = 0
 * 3. 确定初始条件:
 *    dp[0] = 0
 * 4. 确定边界条件: 由 2、3 推导可得
 */
function longestValidParentheses (s) {
  let maxLen = 0;
  const dp = [0];

  for (let i = 1; i < s.length; i++) {
    if (s[i] === '(') {
      dp[i] = 0;
      continue;
    }

    /**
     * s[i] === ')'
     */
    if (s[i - 1] === '(') {
      if (i - 2 >= 0) {
        dp[i] = dp[i - 2] + 2;
      } else {
        dp[i] = 2;
      }

      maxLen = Math.max(dp[i], maxLen);
      continue;
    }

    /**
     * s[i] === ')'
     * s[i - 1] === ')'
     */
    if (dp[i - 1] === 0) {
      dp[i] = 0;
      continue;
    }

    /**
     * s[i] === ')'
     * s[i - 1] === ')'
     * dp[i - 1] > 0
     */
    if (s[i - 1 - dp[i - 1]] === '(') {
      if (i - 2 - dp[i - 1] >= 0) {
        dp[i] = dp[i - 1] + 2 + dp[i - 2 - dp[i - 1]];
      } else {
        dp[i] = dp[i - 1] + 2;
      }
      maxLen = Math.max(dp[i], maxLen);
    } else {
      dp[i] = 0;
    }
  }

  return maxLen;
};
```