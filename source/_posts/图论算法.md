---
title: 图论算法
abbrlink: 7de55cdc
date: 2019-07-13 09:49:23
categories:
    - 数据结构与算法
mathjax: true
---

# 若干定义

{% note info %}
- 一个**图**G = (V, E) 由**顶点**的集V和**边**的集E组成。每一条边就是一个点对（v, w），有时也把边称作**弧**。
- 如果点对是有序的，那么图就叫作有向的。有向的图叫作**有向图（digraph）**。
- 当且仅当$(w, v) \in E$时，称w邻接到v。在一个具有边（v, w）从而具有边（w, v）的无向图中，w邻接到v且v也邻接到w。
- 有时候，边上还有第三种成分，称做**权**或**值**。
- 图中的一条**路径**是一个顶点序列$w_1, w_2, w_3, ... , w_n$，使得$(w_i, w_{i+1}) \in E, 1 \leq i < n$。这样一条路径的长为该路径上的边数（不存在权的情况下）。
- 有向图中的**圈**是满足$w_1=w_n$且长至少为1的一条路径。如果有一个有向图没有圈，则称其为**无圈的**。一个有向无圈图也称为**DAG**。
- 如果在一个无向图中从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是**连通的**。
- 如果在一个有向图中从每一个顶点到每个其他顶点都存在一条路径，则称该有向图是**强连通的**。
- 如果一个有向图不是强连通的，但是它的**基础图**（即其弧上去掉方向所形成的图）是连通的，那么该有向图称为是**弱连通的**。
- **完全图**是其每一对顶点间都存在一条边的图。
{% endnote %}

为了表示一个图，可以使用**邻接矩阵**或者**邻接表**。对于边数较多（即**稠密**）的图，推荐使用邻接矩阵。如果图是**稀疏**的，推荐使用邻接表。

![图的表示](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA.svg)

# 拓扑排序

**拓扑排序**是对有向无圈图的顶点的一种排序，使得如果存在一条从$v_i$到$v_j$的路径，那么在排序中$v_j$就在$v_i$的之后出现。它的原理比较简单，直接用下面的图片进行展示了。图片来源与[**拓扑排序（Topological Sorting）**](https://blog.csdn.net/lisonglisonglisong/article/details/45543451)

![拓扑排序原理图](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86%E5%9B%BE.png)

{% note warning %}
**需要注意的是，在实现拓扑排序时，首先要检查输入是否为有向无圈图。**
{% endnote %}

# 用Dijkstra算法求解最短路径

{% note info %}
- 对于一个有向附权图，它的边$(v_i, v_j)$上的权是$c_{i, j+1}$，因此，一条路径$v_1v_2...v_n$的值为$\sum_{i=1}^{n-1}c_{i,j+1}$，叫作**赋权路径长**。而**无权路径长**只是路径上的边数，即n-1。
- **单源最短路径问题**：给定一个有向附权图G和一个特定的顶点s作为输入，找出从s到G中每一个其他顶点的最短赋权路径。
- 单源最短路径问题的解可能不唯一。
- **负值圈**：如果存在圈，且圈上存在某个边的权值为负数，则称这个圈为负值圈。
- 求解单源最短路径问题时，需要分情况进行讨论，分别是：
    1. 无权。
    2. 有权，但是不存在负值圈。
    3. 有权，且存在负值圈。这种情况下，在求解最短路径过程中会陷入无限循环，即不存在最短路径。
{% endnote %}

在这里，我们介绍Dijkstra算法，用该算法来解决情况1和情况2时的最短路径，本质上，情况1等价于情况2。首先，用一张我在网上发现的图片展示Dijkstra算法的原理。图片来源[**轻松搞懂dijkstra算法+堆优化 || 原理+实战**](https://zhuanlan.zhihu.com/p/34624812)

![Dijkstra算法原理gif图](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86gif%E5%9B%BE.gif)

{% note info %}
Dijkstra算法实现步骤：
1. 对于每一个顶点，有3条必要信息：
    - `distance`：代表从开始顶点s到当前顶点的最短距离。s的`distance = 0`，其他顶点在初始时`distance`为无穷大。
    - `path`：与`distance`对应的路径上的前一个顶点。
    - `known`：该值为`true`时表示当前顶点的`distance`值已经是最小的，后续不会再进行更新。**初始时，包括s在内的所有顶点`known = false`。**
2. 从s开始遍历每个顶点，将当前顶点的`known`标识为`true`。找出当前顶点可以邻接到的其他顶点，然后依次根据情况更新这些被邻接到的顶点的`distance`和`path`。最后在所有`known = false`的顶点中找出`distance`最小的一个，让它成为下一个当前顶点。
3. 当所有顶点的`known`均为`true`时，算法运行结束。

---
**如果有向图是无圈的，则可以改进Dijkstra算法原有的顶点选择方式，按照拓扑排序的顺序选择顶点的遍历顺序。**
{% endnote %}

{% note warning %}
**如果想确保Dijkstra算法可以正确工作，必须保证有向图中没有负值圈，否则`known`将失去存在的意义。**
{% endnote %}



