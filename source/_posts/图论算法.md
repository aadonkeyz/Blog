---
title: 图论算法
abbrlink: 7de55cdc
date: 2019-07-13 09:49:23
categories:
    - 数据结构与算法
mathjax: true
---

# 若干定义

{% note info %}
- 一个**图**G = (V, E) 由**顶点**的集V和**边**的集E组成。每一条边就是一个点对（v, w），有时也把边称作**弧**。
- 如果点对是有序的，那么图就叫作有向的。有向的图叫作**有向图（digraph）**。
- 当且仅当$(w, v) \in E$时，称w邻接到v。在一个具有边（v, w）从而具有边（w, v）的无向图中，w邻接到v且v也邻接到w。
- 有时候，边上还有第三种成分，称做**权**或**值**。
- 图中的一条**路径**是一个顶点序列$w_1, w_2, w_3, ... , w_n$，使得$(w_i, w_{i+1}) \in E, 1 \leq i < n$。这样一条路径的长为该路径上的边数（不存在权的情况下）。
- 有向图中的**圈**是满足$w_1=w_n$且长至少为1的一条路径。如果有一个有向图没有圈，则称其为**无圈的**。一个有向无圈图也称为**DAG**。
- 如果在一个无向图中从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是**连通的**。
- 如果在一个有向图中从每一个顶点到每个其他顶点都存在一条路径，则称该有向图是**强连通的**。
- 如果一个有向图不是强连通的，但是它的**基础图**（即其弧上去掉方向所形成的图）是连通的，那么该有向图称为是**弱连通的**。
- **完全图**是其每一对顶点间都存在一条边的图。
{% endnote %}

为了表示一个图，可以使用**邻接矩阵**或者**邻接表**。对于边数较多（即**稠密**）的图，推荐使用邻接矩阵。如果图是**稀疏**的，推荐使用邻接表。

![图的表示](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA.svg)

# 拓扑排序

**拓扑排序**是对有向无圈图的顶点的一种排序，使得如果存在一条从$v_i$到$v_j$的路径，那么在排序中$v_j$就在$v_i$的之后出现。它的原理比较简单，直接用下面的图片进行展示了。图片来源与[拓扑排序（Topological Sorting）](https://blog.csdn.net/lisonglisonglisong/article/details/45543451)

![拓扑排序原理图](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86%E5%9B%BE.png)

{% note warning %}
**需要注意的是，在实现拓扑排序时，首先要检查输入是否为有向无圈图。**
{% endnote %}

# 最短路径问题

{% note info %}
- 对于一个有向附权图，它的边$(v_i, v_j)$上的权是$c_{i, j+1}$，因此，一条路径$v_1v_2...v_n$的值为$\sum_{i=1}^{n-1}c_{i,j+1}$，叫作**赋权路径长**。而**无权路径长**只是路径上的边数，即n-1。
- **单源最短路径问题**：给定一个有向附权图G和一个特定的顶点s作为输入，找出从s到G中每一个其他顶点的最短赋权路径。
- 单源最短路径问题的解可能不唯一。
- **负值圈**：如果存在圈，且圈上存在某个边的权值为负数，则称这个圈为负值圈。
- 求解单源最短路径问题时，需要分情况进行讨论，分别是：
    1. 无权或者权值均为非负。
    2. 无负值圈但有负权。
    3. 存在负值圈。这种情况下，在求解最短路径过程中会陷入无限循环，即不存在最短路径。
{% endnote %}

## Dijkstra算法

在这里，我们介绍Dijkstra算法，用它来求解情况1下的最短路径。首先，用一张我在网上发现的图片展示Dijkstra算法的原理。图片来源[轻松搞懂dijkstra算法+堆优化 || 原理+实战](https://zhuanlan.zhihu.com/p/34624812)

![Dijkstra算法原理gif图](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86gif%E5%9B%BE.gif)

{% note info %}
Dijkstra算法实现步骤：
1. 对于每一个顶点，有3条必要信息：
    - `distance`：代表从开始顶点s到当前顶点的最短距离。s的`distance = 0`，其他顶点在初始时`distance`为无穷大。
    - `path`：与`distance`对应的路径上的前一个顶点。
    - `known`：该值为`true`时表示当前顶点的`distance`值已经是最小的，后续不会再进行更新。**初始时，包括s在内的所有顶点`known = false`。**
2. 从s开始遍历每个`known = false`的顶点，将当前顶点的`known`标识为`true`。找出当前顶点可以邻接到的其他顶点，然后依次根据情况决定是否更新这些被邻接到的顶点的`distance`和`path`。最后在所有`known = false`的顶点中找出`distance`最小的一个，让它成为下一个当前顶点。
3. 当所有顶点的`known`均为`true`时，算法运行结束。

---
**如果有向图是无圈的，则可以改进Dijkstra算法原有的顶点选择方式，按照拓扑排序的顺序选择顶点。**
{% endnote %}

{% note warning %}
**如果想要Dijkstra算法可以正常工作，必须保证有向图中没有负的权值，否则`known`将失去存在的意义。**
{% endnote %}

## 无负值圈但有负权

{% note warning %}
**有的人想到在这种情况下给每个边上的权值都加上一个相同的常数，从而消除负权值，再使用Dijkstra算法进行计算。这样做是行不通的，因为这样做会导致边数多的路径相对于边数少的路径，权重更重了。**
{% endnote %}

{% note info %}
这种情况的新算法步骤如下所示：
1. 每个顶点都有`distance`和`path`属性。同时算法还需要维护一个队列，它里面保存的是需要被遍历的顶点。
2. 将开始顶点s加入队列中。
3. 取出队列中的第一个顶点，找到所有可以被它邻接到的其他顶点，然后依次根据情况决定是否更新这些被邻接到的顶点的`distance`和`path`。
4. 在进行步骤3时，如果决定更新某个顶点的`distance`和`path`，并且这个被更新的顶点不在队列之中，那么就在更新的同时，将它加入到队列中。
5. 重复步骤3和步骤4，直到队列为空。

**这个算法的重点在于加顶点加入队列的判断机制。**
{% endnote %}

# 网络流问题

设给定有向图G，其任意边$(v_i, v_j)$上的容量为$c_{i,j}$。这里有两个顶点，一个是**发点s**，一个是**收点t**。在既不是发点s又不是收点t的任意顶点v，总的进入流必须等于总的发出流。**最大流问题**就是确定从s到t可以通过的最大流量。例如，下图展示了一个有向图和它的最大流。

![一个图和它的最大流](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%92%8C%E5%AE%83%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81.png)

从图中看到，顶点s有容量为4和2的两条边流出，而顶点t有容量为3和3的两条边进入。因此，最大流也许可能是6而不是5。然而，下图指出如何证明最大流就是5。我们把图切割成两部分：一部分包含顶点s，而另一部分包含顶点t。既然流必须通过切口，于是切口上所有的边的总容量就是最大流的一个界。从图中恰好可以看到，5就是最大流的一个界。

![切割图](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%88%87%E5%89%B2%E5%9B%BE.png)

求解最大流问题的首要想法是分阶段进行。我们从图G开始并构造一个**流图（flow graph）**$G_f$。$G_f$表示在求解的任意阶段已经达到的流。开始时$G_f$的所有的边都是没有流的，我们希望当算法终止时$G_f$包含最大流。另外，我们还构造一个图$G_r$，称为**残余图（residual graph）**，它表示对于每条边还能再添加上多少流。对于每一条边，可以从容量中减去当前的流而计算除残余的流。$G_r$的边叫作**残余边（residual edge）**。在每个阶段，我们寻找图$G_r$中从s到t的一条路径，这条路径叫作**增长通路（augmenting path）**。这条路径上的最小容量就是可以添加到路径每一边上的流的量。下面用一个图展示这些概念。

![图、流图以及残余图](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E3%80%81%E6%B5%81%E5%9B%BE%E4%BB%A5%E5%8F%8A%E6%AE%8B%E4%BD%99%E5%9B%BE.png)

下面给出求解最大流问题的具体步骤：

{% note info %}
1. 在$G_r$中找到任意一条增长通路，根据该增长通路，更新$G_f$中的的流信息，然后在$G_r$将该增长路径调整为相反方向。
2. 重复步骤1，直到在$G_r$中找不到增长通路位置。

其实步骤1中的增长通路的选择上可以做一些文章从而减少时间复杂度，这里暂时不进行详细分析了。
{% endnote %}

![图、流图以及残余图](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E3%80%81%E6%B5%81%E5%9B%BE%E4%BB%A5%E5%8F%8A%E6%AE%8B%E4%BD%99%E5%9B%BE.png)

![求解过程](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.png)
