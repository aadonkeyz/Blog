---
title: 算法-树
abbrlink: c6704b4
date: 2020-08-27 23:43:56
categories:
  - 算法练习
---

# 完全二叉树的转换

## 一维数组 -> 完全二叉树

如 `[1, null, 2, null, null, 3, null]`

```js
function isValid (val) {
  return typeof val === 'number';
}

/**
 * 假设树已经存在，接着只需在层序遍历的过程中，从数组中将值取出，并填充进对应的位置
 */
function buildTreeWithArray (array) {
  if (!array || array.length < 1 || !isValid(array[0])) {
    return null
  }

  const root = {
    val: array.shift()
  };
  const queue = [root];

  while (array.length > 0) {
    const preLevelNode = queue.shift();
    
    const leftVal = array.shift();
    const rightVal = array.shift();

    if (preLevelNode) {
      preLevelNode.left = isValid(leftVal) ? { val: leftVal } : null;
      preLevelNode.right = isValid(rightVal) ? { val: rightVal } : null;
      queue.push(preLevelNode.left, preLevelNode.right);
    } else {
      queue.push(null, null);
    }
  }

  return root;
}
```

## 完全二叉树 -> 一维数组

```js
function buildArrayWithTree (tree) {
  if (!tree) {
    return [];
  }

  const array = [tree.val];
  const queue = [tree];

  let level = 0;
  let countdown = 0;

  while (countdown >= 0) {
    if (countdown === 0) {
      if (queue.every(item => !item)) {
        /**
         * 这里才是出口 ！！！
         */
        return array;
      } else {
        level += 1;
        countdown = Math.pow(2, level);
      }
    }

    const preLevelNode = queue.shift();

    if (preLevelNode) {
      if (preLevelNode.left) {
        array.push(preLevelNode.left.val);
        queue.push(preLevelNode.left);
      } else {
        array.push(null);
        queue.push(null);
      }

      if (preLevelNode.right) {
        array.push(preLevelNode.right.val);
        queue.push(preLevelNode.right);
      } else {
        array.push(null);
        queue.push(null);
      }
    } else {
      array.push(null, null);
      queue.push(null, null);
    }

    countdown -= 2;
  }
}
```

# 非完全二叉树的转换

## 一维数组 => 非完全二叉树

如 `[1, null, 2, 3, null]`

```js
function isValid (val) {
  return typeof val === 'number';
}

function buildTreeWithArray (array) {
  if (!array || array.length < 1 || !isValid(array[0])) {
    return null
  }

  const root = {
    val: array.shift()
  };
  const queue = [root];

  while (array.length > 0) {
    const preLevelNode = queue.shift();
    
    if (preLevelNode) {
      const leftVal = array.shift();
      const rightVal = array.shift();

      preLevelNode.left = isValid(leftVal) ? { val: leftVal } : null;
      preLevelNode.right = isValid(rightVal) ? { val: rightVal } : null;
      queue.push(preLevelNode.left, preLevelNode.right);
    }
  }

  return root;
}
```

## 非完全二叉树 -> 二维数组

```js
function buildArrayWithTree (tree) {
  if (!tree) {
    return [];
  }

  const array = [];
  const queue = [tree];

  let level = 0;
  let countdown = 0;
  array[0] = [tree.val];

  while (countdown >= 0) {
    if (countdown === 0) {
      if (queue.every(item => !item)) {
        array.pop();
        /**
         * 这里才是出口 ！！！
         */
        return array;
      } else {
        level += 1;
        countdown = 2 * queue.length;
        array[level] = [];
      }
    }

    const preLevelNode = queue.shift();

    if (preLevelNode) {
      if (preLevelNode.left) {
        array[level].push(preLevelNode.left.val);
        queue.push(preLevelNode.left);
      } else {
        array[level].push(null);
      }

      if (preLevelNode.right) {
        array[level].push(preLevelNode.right.val);
        queue.push(preLevelNode.right);
      } else {
        array[level].push(null);
      }
    }

    countdown -= 2;
  }
}
```

# 平衡二叉树的判断

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

## 递归

```js
function calculateHeight (node) {
  if (!node) {
    return -1;
  }

  const leftHeight = calculateHeight(node.left);
  const rightHeight = calculateHeight(node.right);

  if ((leftHeight === -2) || (rightHeight === -2)) {
    return -2;
  }

  if (Math.abs(leftHeight - rightHeight) > 1) {
    return -2;
  }

  return Math.max(leftHeight, rightHeight) + 1;
}

function isAVL (root) {
  const height = calculateHeight(root);

  // 定义高度为 -2 代表不平衡
  if (height === -2) {
    return false
  }

  return true
}
```

## 非递归

```js
function isAVL (root) {
  if (!root) {
    return true;
  }

  const stack = [];
  let cur = root;
  
  while (cur || stack.length > 0) {
    while (cur) {
      stack.push(cur);
      if (cur.left) {
        cur = cur.left;
      } else {
        cur.leftChildHeight = -1;
        cur = null;
      }
    }

    /**
    * 将节点从 stack pop 出的时候，要保证该节点已经被赋予了 height 属性
    */
    if (stack.length > 0) {
      const lastVisited = stack[stack.length - 1];

      if (typeof lastVisited.leftChildHeight !== 'number') {
      	lastVisited.leftChildHeight = lastVisited.left.height;
      }

      if (!lastVisited.right) {
        lastVisited.rightChildHeight = -1;
        if (Math.abs(lastVisited.leftChildHeight - lastVisited.rightChildHeight) > 1) {
          return false;
        }

        lastVisited.height = Math.max(lastVisited.leftChildHeight, lastVisited.rightChildHeight) + 1;
        stack.pop();
      } else {
        if (typeof lastVisited.right.height !== 'number') {
          // 开始遍历 lastVisited.right
          cur = lastVisited.right;
        } else {
          // 已经遍历过 lastVisited.right 了
          if (Math.abs(lastVisited.leftChildHeight - lastVisited.right.height) > 1) {
            return false;
          }

          lastVisited.height = Math.max(lastVisited.leftChildHeight, lastVisited.right.height) + 1;
          stack.pop();
        }
      }
    }
  }

  return true;
};
```

# 子树的判断

输入两棵二叉树 A 和 B，判断 B 是不是 A 的子树。B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。
**约定空树不是任意一个树的子树**

## 递归

```js
/**
 * 为了逻辑清晰，isSubTreeFromBegin 会判定空树是任意一个树的子树
 */
function isSubTreeFromBegin (A, B) {
  if (A === B || !B) {
    return true;
  }

  if (!A) {
    return false;
  }

  if (A.val !== B.val) {
    return false;
  }

  return isSubTreeFromBegin(A.left, B.left) && isSubTreeFromBegin(A.right, B.right)
}

function isSubTree (A, B) {
  if (!A || !B) {
    return false;
  }

  if (isSubTreeFromBegin(A, B)) {
    return true;
  }

  if (isSubTree(A.left, B)) {
    return true;
  }

  if (isSubTree(A.right, B)) {
    return true;
  }

  return false
};
```

## 非递归

```js
function isValid (val) {
  return typeof val === 'number';
}

function buildArrayWithTree (tree) {
  if (!tree) {
    return [];
  }

  const array = [tree.val];
  const queue = [tree];

  while (queue.length > 0) {
    const cur = queue.shift();

    if (cur) {
      if (cur.left) {
        array.push(cur.left.val);
        queue.push(cur.left);
      } else {
        array.push(null);
        queue.push(null);
      }

      if (cur.right) {
        array.push(cur.right.val);
        queue.push(cur.right);
      } else {
        array.push(null);
        queue.push(null);
      }
    } else {
      array.push(null, null);
    }
  }

  while (array.length > 0 && !isValid(array[array.length - 1])) {
    array.pop();
  }

  return array;
}

function isSubTree (A, B) {
  if (!A || !B) {
    return false;
  }

  const basicArray = buildArrayWithTree(B);

  const stack = [];
  let cur = A;

  while (cur || stack.length > 0) {
    while (cur) {
      stack.push(cur);

      if (cur.val === B.val) {
        const curArray = buildArrayWithTree(cur);
        const isSame = basicArray.every((val, i) => {
          if (!isValid(val)) {
            return true;
          }

          return val === curArray[i];
        })

        if (isSame) {
          return true;
        }
      }
      
      cur = cur.left;
    }

    if (stack.length > 0) {
      cur = stack.pop().right;
    }
  }

  return false;
}
```

# 根据遍历结果确定二叉树结构

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

## 递归

```js
function rebuildTree (preorder, inorder) {
  if (preorder.length === 0 || inorder.length === 0) {
    return null
  }

  const root = {
    val: preorder[0],
    left: null,
    right: null
  };
  
  const splitIndex = inorder.indexOf(preorder[0]);
  if (splitIndex > 0) {
    root.left = rebuildTree(preorder.slice(1, splitIndex + 1), inorder.slice(0, splitIndex));
  }

  if (splitIndex < inorder.length - 1) {
    root.right = rebuildTree(preorder.slice(splitIndex + 1), inorder.slice(splitIndex + 1));
  }

  return root
};
```
## 非递归

```js
function rebuildTree (preorder, inorder) {
  if (preorder.length === 0 || inorder.length === 0) {
    return null
  }

  const root = {
    val: preorder[0],
    left: null,
    right: null,
    preorder: preorder,
    inorder: inorder,
  };

  const stack = [];
  let cur = root;

  while (cur || stack.length > 0) {
    while (cur) {
      const curPreorder = cur.preorder;
      const curInorder = cur.inorder;
      const splitIndex = curInorder.indexOf(cur.val);

      if (splitIndex === 0) {
        cur.left = null;
      } else {
        cur.left = {
          val: curPreorder[1],
          preorder: curPreorder.slice(1, splitIndex + 1),
          inorder: curInorder.slice(0, splitIndex)
        }
      }

      stack.push(cur);

      cur = cur.left;
    }

    if (stack.length > 0) {
      const lastVisited = stack.pop();
      const curPreorder = lastVisited.preorder;
      const curInorder = lastVisited.inorder;
      const splitIndex = curInorder.indexOf(lastVisited.val);

      if (splitIndex >= curPreorder.length - 1) {
        lastVisited.right = null;
      } else {
        lastVisited.right = {
          val: curPreorder[splitIndex + 1],
          preorder: curPreorder.slice(splitIndex + 1),
          inorder: curInorder.slice(splitIndex + 1),
        }
      }

      cur = lastVisited.right;
    }
  }

  return root
};
```

# 二叉树的深度

## 递归

```js
function calculateHeight (root) {
  if (!root) {
    return -1;
  }

  const leftHeight = calculateHeight(root.left);
  const rightHeight = calculateHeight(root.right);

  return Math.max(leftHeight, rightHeight) + 1;
}

function calculateDepth (root) {
  return calculateHeight(root);
}
```

## 非递归

```js
function calculateDepth (root) {
  if (!root) {
    return -1
  }

  root.depth = 0;

  const stack = [];
  let cur = root;
  let max = 0;

  while (cur || stack.length > 0) {
    while (cur) {
      stack.push(cur);
      
      if (cur.left) {
        cur.left.depth = cur.depth + 1;
        max = Math.max(max, cur.depth + 1);
      }

      cur = cur.left;
    }

    if (stack.length > 0) {
      const lastVisited = stack.pop();

      if (lastVisited.right) {
        lastVisited.right.depth = lastVisited.depth + 1;
        max = Math.max(max, lastVisited.depth + 1);
      }

      cur = lastVisited.right;
    }
  }

  return max
};
```


