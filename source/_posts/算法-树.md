---
title: 算法-树
abbrlink: c6704b4
date: 2020-08-27 23:43:56
categories:
  - 算法练习
---

# 完全二叉树由数组转换为树

```js
/**
 * 假设树已经存在，接着只需在遍历树的过程中，从数组中将值取出，并填充进对应的位置
 */
function buildTreeWithArray (array) {
  if (!array || array.length < 1 || !array[0]) {
    return null
  }

  const root = {
    i: 0,
    val: array[0]
  };
  const stack = [];

  let cur = root;

  while (cur || stack.length > 0) {
    while (cur) {
      const leftIndex = cur.i * 2 + 1;
      const leftVal = array[leftIndex];

      if (leftVal) {
        cur.left = {
          i: leftIndex,
          val: leftVal,
        };
      } else {
        cur.left = null;
      }
      stack.push(cur);

      cur = cur.left;
    }

    if (stack.length > 0) {
      const lastVisited = stack.pop();
      const rightIndex = lastVisited.i * 2 + 2;
      const rightVal = array[rightIndex];

      if (rightVal) {
        lastVisited.right = {
          i: rightIndex,
          val: rightVal,
        };
        cur = lastVisited.right;
      } else {
        lastVisited.right = null;
      }
    }
  }

  return root;
}
```

# 平衡二叉树的判断

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

## 递归

```js
function calculateHeight (node) {
  if (!node) {
    return -1;
  }

  let left = calculateHeight(node.left);
  let right = calculateHeight(node.right);

  if ((left === -2) || (right === -2)) {
    return -2;
  }

  if (Math.abs(left - right) > 1) {
    return -2;
  }

  return Math.max(left, right) + 1;
}

function isBalanced (root) {
  const height = calculateHeight(root);

  // 定义高度为 -2 代表不平衡
  if (height === -2) {
    return false
  }

  return true
}
```

## 非递归

```js
function isBalanced (root) {
  if (!root) {
    return true;
  }

  const stack = [];
  let cur = root;
  
  while (cur || stack.length > 0) {
    while (cur) {
      stack.push(cur);
      if (cur.left) {
        cur = cur.left;
      } else {
        cur.leftChildHeight = -1;
        cur = null;
      }
    }

    /**
    * 将节点从 stack pop 出的时候，要保证该节点已经被赋予了 height 属性
    */
    if (stack.length > 0) {
      const lastVisited = stack[stack.length - 1];

      if (typeof lastVisited.leftChildHeight !== 'number') {
      	lastVisited.leftChildHeight = lastVisited.left.height;
      }

      if (!lastVisited.right) {
        lastVisited.rightChildHeight = -1;
        if (Math.abs(lastVisited.leftChildHeight - lastVisited.rightChildHeight) > 1) {
          return false;
        }

        lastVisited.height = Math.max(lastVisited.leftChildHeight, lastVisited.rightChildHeight) + 1;
        stack.pop();
      } else {
        if (typeof lastVisited.right.height !== 'number') {
          // 开始遍历 lastVisited.right
          cur = lastVisited.right;
        } else {
          // 已经遍历过 lastVisited.right 了
          if (Math.abs(lastVisited.leftChildHeight - lastVisited.right.height) > 1) {
            return false;
          }

          lastVisited.height = Math.max(lastVisited.leftChildHeight, lastVisited.right.height) + 1;
          stack.pop();
        }
      }
    }
  }

  return true;
};
```
