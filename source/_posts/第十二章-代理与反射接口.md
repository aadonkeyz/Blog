---
title: 第十二章 代理与反射接口
categories:
  - JavaScript
  - 《深入理解ES6》
abbrlink: 27777a89
date: 2019-04-14 10:32:54
---

ES6让开发者能进一步接近JS引擎的能力，这些能力原先只存在于内置对象上。语言通过代理（proxy）暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变JS引擎的底层操作。

# 代理与反射是什么？

**`Proxy`对象用于在目标对象上定义一些基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。**

{% note info %}
**语法**：`let proxy = new Proxy(target, handler)`。`target`与`handler`参数都是必填项。
- **`target`**：用`Proxy`包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）；
- **`handler`**：一个包含特定方法的对象，这些特定的方法又叫做**陷阱函数**；
- **陷阱函数**：用来拦截`target`对象上的特定操作、并用自定义行为替代这些特定操作的默认行为。陷阱函数内部的`this`指向`handler`。
{% endnote %}

观察下面的例子：

```js
let targetObj =  {
    name: 'target object'
}

let handlerObj = {
    // get陷阱函数，用于拦截对象的属性访问操作
    get () {
        return 'change the underlying operation'
    }
}

let proxy = new Proxy(targetObj, handlerObj)

console.log(targetObj.name)     // target object
console.log(proxy.name)         // change the underlying operation

console.log(targetObj.notExist) // undefined
console.log(proxy.notExist)     // change the underlying operation
```

上面的例子中，`proxy`是通过Proxy对`targetObj`进行了包装得到的代理对象，在对`proxy`的属性进行访问时，调用的是`handlerObj`中的`get`方法，因为陷阱函数`get`的存在，拦截了所有对`proxy`属性进行访问的操作。

**`Reflect`对象是一个内置的对象，它是给底层操作提供默认行为的方法的集合。每个陷阱函数都可以在`Reflect`对象上找到与之对应的同名方法，这个方法也叫做反射接口，陷阱函数与反射接口之间是一一对应的，并且它们接收的参数是相同的。**

**另外需要注意的是，`Reflect`不是一个函数对象，因此它不可以被当作构造器使用。**

{% note info %}
**每个陷阱函数都可以重写JS对象的一个特定默认行为，允许你拦截并修改它。如果你仍然需要使用原先的默认行为，则可使用`Reflect`的对应反射接口。**
{% endnote %}

下面表格中列出了陷阱函数、对应的操作和对应的默认行为：

| 代理陷阱 | 对应操作 | 默认行为 |
| :----: | :----: | :----: |
| **get**                      | **读取一个属性的值** | **Reflect.get()** |
| **set**                      | **写入一个属性的值** | **Reflect.set()** |
| **has**                      | **in运算符** | **Reflect.has()** |
| **deleteProperty**           | **delete运算符** | **Reflect.deleteProperty()** |
| **getPrototypeOf**            | **Object.getPrototypeOf()** | **Reflect.getPrototypeOf()** |
| **setPrototypeOf**            | **Object.setPrototypeOf()** | **Reflect.setPrototypeOf()** |
| **isExtensible**             | **Object.isExtensible()** | **Reflect.isExtensible()** |
| **preventExtensions**        | **Object.preventExtensions()** | **Reflect.preventExtensions()** |
| **getOwnPropertyDescriptor** | **Object.getOwnPropertyDescriptor()**    | **Reflect.getOwnPropertyDescriptor()** |
| **defineProperty**           | **Object.defineProperty()** | **Reflect.defineProperty()** |
| **ownKeys**                  | **Object.keys()**、<br/>**Object.getOwnPropertyNames()**、<br/>**Object.getOwnPropertySymbols()** | **Reflect.ownKeys()** |
| **apply**                    | **调用一个函数** | **Reflect.apply()** |
| **construct**                | **使用new调用一个函数**  | **Reflect.construct()** |

# get

{% note info %}
1. **`handle.get()`/`Reflect.get()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键；
    - **`receiver`**：最初被调用的对象（通常是代理对象，但也可能是继承了代理对象的其他对象）。


2. **`handle.get()`的返回值：**
    - 可以返回任何值。


3. **`handle.get()`的限制：**
    - 如果目标属性是目标对象的自有属性、不可写且不可配置，那么返回值必须与该目标属性的值相同，否则会抛出错误；
    - 如果目标属性是目标对象的自有属性、不可配置且没有定义`getter`，那么返回值必须为`undefined`，否则会抛出错误。
{% endnote %}

# set

{% note info %}
1. **`handle.set()`/`Reflect.set()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键；
    - **`value`**：目标属性的值；
    - **`receiver`**：最初被调用的对象（通常是代理对象，但也可能是继承了代理对象的其他对象）。


2. **`handle.set()`的返回值：**
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败；
    - 在严格模式下，如果返回`false`，会抛出错误。


3. **`handle.set()`的限制：**
    - 如果目标属性是不可写且不可配置的，那么不允许改变它的值，否则会抛出错误；
    - 如果目标属性是不可配置，并且没有定义`setter`，那么不允许设置它的值，否则会抛出错误；
    - **关于上面两个限制，是对象自己的限制，跟`handle.set()`没啥关系。**
{% endnote %}

# has

{% note info %}
1. **`handle.has()`/`Reflect.has()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键。


2. **`handle.has()`的返回值：**
    - 会自动将返回值转换为对应的布尔值。


3. **`handle.has()`的限制：**
    - 如果目标属性是目标对象的自有属性，且是不可配置的，那么不允许返回`false`，否则会抛出错误；
    - 如果目标属性是目标对象的自有属性，且目标对象是不可扩展的，那么不允许返回`false`，否则会抛出错误。
{% endnote %}

# deleteProperty

{% note info %}
1. **`handle.deleteProperty()`/`Reflect.deleteProperty()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键。


2. **`handle.deleteProperty()`的返回值：**
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败。
    - 在严格模式下，如果返回`false`，会抛出错误。


3. **`handle.deleteProperty()`的限制：**
    - 如果目标属性是目标对象的自有属性，且是不可配置的，那么不允许删除该属性，否则会返回`false`。
{% endnote %}

# Object与Reflect的区别

`Object`对象和`Reflect`对象上存在着一些同名方法，比如`getPrototypeOf()`、`setPrototypeOf()`、`isExtensible`等等。它们不仅名称相同，功能也大致相同，这会让人产生疑惑，会有一种“既然有了`Object`，何必又出现`Reflect`”的感觉。

{% note info %}
**`Reflect`对象上的方法属于底层方法、是对JS语言内部方法进行封装（并附加了一些输入验证）后得到的；而`Object`对象上的方法属于高级方法，它们会在调用JS语言内部方法之前添加一些步骤、并检查返回值。**。
{% endnote %}

# getPrototypeOf

{% note info %}
1. **`handle.getPrototypeOf()`/`Reflect.getPrototypeOf()`的参数：**
    - **`trapTarget`**：目标对象。


2. **`handle.getPrototypeOf()`的返回值：**
    - 返回值必须是一个对象或者`null`，否则会抛出错误。


3. **`handle.getPrototypeOf()`的限制：**
    - 如果目标对象是不可扩展的，那么返回值必须是目标对象的原型（即`Object.getPrototypeOf(target)`），否则会抛出错误。
{% endnote %}

{% note warning %}
**`Object.getPrototypeOf`与`Reflect.getPrototypeOf`的区别：**

| Object.getPrototypeOf | Reflect.getPrototypeOf |
| :-------------------: | :--------------------: |
| **接收的参数不是对象时，会先将其转换为对象** | **接收的参数不是对象时，会抛出错误** |
{% endnote %}

# setPrototypeOf

{% note info %}
1. **`handle.setPrototypeOf()`/`Reflect.setPrototypeOf()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`proto`**：需要被用作原型的对象。


2. **`handle.setPrototypeOf()`的返回值：**
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败;
    - 如果返回`false`，会导致`Object.setPrototypeOf()`抛出错误。


3. **`handle.setPrototypeOf()`的限制：**
    - 如果目标对象是不可扩展的，那么必须保证传入的`proto`参数就是目标对象的原型（即`Object.getPrototypeOf(target)`），否则会抛出错误。
{% endnote %}

{% note warning %}
**`Object.setPrototype`与`Reflect.setPrototype`的区别：**

| Object.setPrototype | Reflect.setPrototype |
| :-------------------: | :--------------------: |
| **接收的第一个参数不是对象时，会先将其转换为对象** | **接收的第一个参数不是对象时，会抛出错误** |
| **操作成功会将接收的第一个参数作为自身的返回值，操作失败会抛出错误** | **操作成功返回true，操作失败返回false** |
{% endnote %}

# isExtensible

{% note info %}
1. **`handle.isExtensible()`/`Reflect.isExtensible()`的参数：**
    - **`trapTarget`**：目标对象。


2. **`handle.isExtensible()`的返回值：**
    - 会自动将返回值转换为对应的布尔值。


3. **`handle.isExtensible()`的限制：**
    - 返回值必须与`Object.isExtensible(target)`的值相同，否则会抛出错误。
{% endnote %}

{% note warning %}
**`Object.isExtensible`与`Reflect.isExtensible`的区别：**

| Object.isExtensible | Reflect.isExtensible |
| :-------------------: | :--------------------: |
| **接收的参数不是对象时，会返回false** | **接收的参数不是对象时，会抛出错误** |
{% endnote %}

# preventExtensions

{% note info %}
1. **`handle.preventExtensions()`/`Reflect.preventExtensions()`的参数：**
    - **`trapTarget`**：目标对象。


2. **`handle.preventExtensions()`的返回值：**
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败；
    - 如果返回`false`，会抛出错误。


3. **`handle.preventExtensions()`的限制：**
    - 只有当`Object.isExtensible(target)`的值为`false`时，才允许返回`true`，否则会抛出错误。
{% endnote %}

{% note warning %}
**`Object.preventExtensions`与`Reflect.preventExtensions`的区别：**

| Object.preventExtensions | Reflect.preventExtensions |
| :-------------------: | :--------------------: |
| **总是将接收的参数作为自身的返回值，即使该参数不是一个对象** | **接收的参数不是对象时，会抛出错误；<br/>参数是一个对象时，会在操作成功时返回true，失败时返回false** |
{% endnote %}

# getOwnPropertyDescriptor

{% note info %}
1. **`handle.getOwnPropertyDescriptor()`/`Reflect.getOwnPropertyDescriptor()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键。


2. **`handle.getOwnPropertyDescriptor()`的返回值：**
    - 返回值必须是一个对象或者`undefined`，否则会抛出错误；
    - 如果返回一个对象，会忽略对象中的其他属性，只保留`configurable`、`enumerable`、`writable`、`value`、`get`或`set`；
    - 如果返回一个对象，其中数据属性与访问器属性不能同时存在，否则会抛出错误；
    - 如果返回一个对象，默认`{ value: undefined, writable: false, enumerable: false, configurable: false }`。


3. **`getOwnPropertyDescriptor`陷阱函数的限制：**
    - 如果目标属性是目标对象的自有属性，且是不可配置的，那么返回值必须与`Object.getOwnPropertyDescriptor(target)`相同，否则会抛出错误；
    - 如果目标属性是目标对象的自有属性，且是可配置的，那么只允许返回`undefined`或者`configurable`属性为`true`的对象，否则会抛出错误；
    - 如果目标属性是目标对象的自有属性，且目标对象是不可扩展的，那么不允许返回`undefined`，否则会抛出错误（**注意目标属性是否可配置，然后结合上面两条规则，取交集**）；
    - 如果目标属性不是目标对象的自有属性，且目标对象是不可扩展的，那么必须返回`undefined`，否则会抛出错误；
    - 如果目标属性不是目标对象的自有属性，那么只可以返回`undefined`或者`configurable`属性为`true`的对象，否则会抛出错误。
{% endnote %}

{% note warning %}
**`Object.getOwnPropertyDescriptor`与`Reflect.getOwnPropertyDescriptor`的区别：**

| Object.getOwnPropertyDescriptor | Reflect.getOwnPropertyDescriptor |
| :-------------------: | :--------------------: |
| **接收的第一个参数不是对象时，会先将其转换为对象** | **接收的第一个参数不是对象时，会抛出错误** |
{% endnote %}

# defineProperty

{% note info %}
1. **`handle.defineProperty()`/`Reflect.defineProperty()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键；
    - **`descriptor`**：为该属性准备的描述符对象。


2. **`handle.defineProperty()`的返回值：**
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败；
    - 如果返回`false`，会导致`Object.defineProperty()`抛出错误。


3. **`defineProperty`陷阱函数的限制：**
    - 如果目标对象不可扩展，那么不允许添加属性，否则会抛出错误；
    - 如果目标属性是目标对象的自有属性，且是不可配置，那么不允许修改其描述符，否则会抛出错误。
{% endnote %}

{% note warning %}
**`Object.defineProperty`与`Reflect.defineProperty`的区别：**

| Object.defineProperty | Reflect.defineProperty |
| :-------------------: | :--------------------: |
| **总是返回接收到的第一个参数** | **成功时返回true，失败时返回false** |
{% endnote %}

# ownKeys

{% note info %}
1. **`handle.ownKeys()`/`Reflect.ownKeys()`的参数：**
    - **`trapTarget`**：目标对象。


2. **`handle.ownKeys()`的返回值：**
    - 必须返回一个可枚举对象，否则会抛出错误。


3. **`ownKeys`陷阱函数的限制：**
    - 
{% endnote %}

{% note warning %}
**`Object.ownKeys`与`Reflect.ownKeys`的区别：**

| Object.ownKeys | Reflect.ownKeys |
| :-------------------: | :--------------------: |
| **ad** | **士大夫** |
{% endnote %}





# 使用apply与construct陷阱函数的函数代理
## 验证函数的参数
## 调用构造器而无须使用new
## 重写抽象基础类的构造器
## 可被调用的类构造器

# 可被撤销的代理

# 解决数组的问题
## 检测数组的索引
## 在添加新元素时增加长度属性
## 在减少长度属性时移除元素
## 实现MyArray类

# 将代理对象作为原型使用
## 在原型上使用get陷阱函数
## 在原型上使用set陷阱函数
## 在原型上使用has陷阱函数
## 将代理作为类的原型