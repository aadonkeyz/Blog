---
title: 第十二章 代理与反射接口
categories:
  - JavaScript
  - 《深入理解ES6》
abbrlink: 27777a89
date: 2019-04-14 10:32:54
---

ES6让开发者能进一步接近JS引擎的能力，这些能力原先只存在于内置对象上。语言通过代理（proxy）暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变JS引擎的底层操作。

# 代理与反射是什么？

**`Proxy`对象用于在目标对象上定义一些基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。**

{% note info %}
**语法**：`let p = new Proxy(target, handler)`。`target`与`handler`参数都是必填项。
- **`target`**：用`Proxy`包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）；
- **`handler`**：一个包含特定方法的对象，这些特定的方法又叫做**陷阱函数**；
- **陷阱函数**：用来拦截`target`对象上的特定操作、并用自定义行为替代这些特定操作的默认行为。
{% endnote %}

观察下面的例子：

```js
let targetObj =  {
    name: 'target object'
}

let handlerObj = {
    // get陷阱函数，用于拦截对象的属性访问操作
    get () {
        return 'change the underlying operation'
    }
}

let p = new Proxy(targetObj, handlerObj)

console.log(targetObj.name)     // target object
console.log(p.name)             // change the underlying operation

console.log(targetObj.notExist) // undefined
console.log(p.notExist)         // change the underlying operation
```

上面的例子中，`p`是通过Proxy对`targetObj`进行了包装得到的代理对象，在对`p`的属性进行访问时，调用的是`handlerObj`中的`get`方法，因为陷阱函数`get`的存在，拦截了所有对`p`属性进行访问的操作。

**`Reflect`对象是一个内置的对象，它是给底层操作提供默认行为的方法的集合。每个陷阱函数都可以在`Reflect`对象上找到与之对应的同名方法，这个方法也叫做反射接口，陷阱函数与反射接口之间是一一对应的。另外需要注意的是，`Reflect`不是一个函数对象，因此它不可以被当作构造器使用。**

{% note info %}
**每个陷阱函数都可以重写JS对象的一个特定默认行为，允许你拦截并修改它。如果你仍然需要使用原先的默认行为，则可使用`Reflect`的对应反射接口。**
{% endnote %}

下面表格中列出了陷阱函数、对应的操作和对应的默认行为：

| 代理陷阱 | 对应操作 | 默认行为 |
| :----: | :----: | :----: |
| **get**                      | **读取一个属性的值** | **Reflect.get()** |
| **set**                      | **写入一个属性的值** | **Reflect.set()** |
| **has**                      | **in运算符** | **Reflect.has()** |
| **deleteProperty**           | **delete运算符** | **Reflect.deleteProperty()** |
| **getPropertyOf**            | **Object.getPropertyOf()** | **Reflect.getPropertyOf()** |
| **setPropertyOf**            | **Object.setPropertyOf()** | **Reflect.setPropertyOf()** |
| **isExtensible**             | **Object.isExtensible()** | **Reflect.isExtensible()** |
| **preventExtensions**        | **Object.preventExtensions()** | **Reflect.preventExtensions()** |
| **getOwnPropertyDescriptor** | **Object.getOwnPropertyDescriptor()**    | **Reflect.getOwnPropertyDescriptor()** |
| **defineProperty**           | **Object.defineProperty()** | **Reflect.defineProperty()** |
| **ownKeys**                  | **Object.keys()**、<br/>**Object.getOwnPropertyNames()**、<br/>**Object.getOwnPropertySymbols()** | **Reflect.ownKeys()** |
| **apply**                    | **调用一个函数** | **Reflect.apply()** |
| **construct**                | **使用new调用一个函数**  | **Reflect.construct()** |

# set

{% note info %}
`set`陷阱函数与`Reflect.set()`接受相同的四个参数：
- **`trapTarget`**：将接收属性的对象（即代理的目标对象）；
- **`key`**：需要写入的属性的键（字符串类型或符号类型）；
- **`value`**：将被写入属性的值；
- **`receiver`**：操作发生的对象（通常是代理对象）。
{% endnote %}

假设你想要创建一个对象，并要求其属性值只能是数值，这就意味着该对象的每个新增属性都要被验证，并且在属性值不为数值类型时应当抛出错误。

```js
let target = {
    name: 'target'
}

let proxy = new Proxy(target, {
    set (trapTarget, key, value, receiver) {

        // 忽略已有属性，避免影响它们
        if (!trapTarget.hasOwnProperty(key)) {
            if (isNaN(value)) {
                throw new TypeError('Property must be a number.')
            }
        }

        // 添加属性
        return Reflect.set(trapTarget, key, value, receiver)
    }
})

// 添加一个新属性
proxy.count = 1
console.log(proxy.count)            // 1
console.log(target.count)           // 1

// 你可以为 name 赋一个非数值类型的值，因为该属性已经存在
proxy.name = 'proxy'
console.log(proxy.name)             // proxy
console.log(target.name)            // proxy

// 抛出错误
proxy.anotherName = 'proxy'         // TypeError: Property must be a number.
```

# get

{% note info %}
`get`陷阱函数与`Reflect.get()`接受相同的四个参数：
- **`trapTarget`**：将会被读取属性的对象（即代理的目标对象）；
- **`key`**：需要读取的属性的键（字符串类型或符号类型）；
- **`receiver`**：操作发生的对象（通常是代理对象）。
{% endnote %}

假设你想在访问对象不存在的属性时抛出错误。

```js
let proxy = new Proxy({}, {
    get (trapTarget, key, receiver) {
        if (!(key in receiver)) {
            throw new TypeError('Property ' + key + ' does not exist.')
        }

        return Reflect.get(trapTarget, key, receiver)
    }
})

// 添加属性的功能正常
proxy.name = 'proxy'
console.log(proxy.name)         // proxy

// 读取不存在属性会抛出错误
console.log(proxy.nme)          // TypeError: Property nme does not exist.
```

在本例中，`in`操作符是在`receiver`中进行检查，而不是`trapTarget`，这是因为`receiver`本身就是拥有一个`has`陷阱函数的代理对象，在此处使用`trapTarget`会跳过`has`陷阱函数。

# has

{% note info %}
`has`陷阱函数与`Reflect.has()`接受相同的四个参数：
- **`trapTarget`**：需要读取属性的对象（即代理的目标对象）；
- **`key`**：需要检查的属性的键（字符串类型或符号类型））。
{% endnote %}

假设你想要隐藏对象的某个属性。

```js
let target = {
    name: 'target',
    value: 42
}

let proxy = new Proxy(target, {
    has (trapTarget, key) {
        if (key === 'value') {
            return false
        } else {
            return Reflect.has(trapTarget, key)
        }
    }
})

console.log('value' in proxy)           // false
console.log('name' in proxy)            // true
console.log('toString' in proxy)        // true
```

# deleteProperty

{% note info %}
`deleteProperty`陷阱函数与`Reflect.deleteProperty()`接受相同的两个个参数：
- **`trapTarget`**：需要删除属性的对象（即代理的目标对象）；
- **`key`**：需要删除的属性的键（字符串类型或符号类型））。
{% endnote %}

下面例子中，对象的`value`属性是不能被删除的，因此该操作被`proxy`对象拦截；而`name`则能如期被删除。这么做允许你在严格模式下保护属性避免其被删除，并且不会抛出错误。

```js
let target = {
    name: 'target',
    value: 42
}

let proxy = new Proxy(target, {
    deleteProperty (trapTarget, key) {
        if (key === 'value') {
            return false
        } else {
            return Reflect.deleteProperty(trapTarget, key)
        }
    }
})

// 尝试删除 proxy.value
console.log('value' in proxy)           // true

let result1 = delete proxy.value
console.log(result1)                    // false

console.log('value' in proxy)           // true

// 尝试删除 proxy.name
console.log('name' in proxy)            // true

let result2 = delete proxy.name
console.log(result2)                    // true

console.log('name' in proxy)            // false
```

# Object与Reflect的区别

`Object`对象和`Reflect`对象上存在着一些同名方法，比如`getPropertyOf()`、`setPropertyOf()`、`isExtensible`等等。它们不仅名称相同，功能也大致相同，这会让人产生疑惑，会有一种“既然有了`Object`，何必又出现`Reflect`”的感觉。

有关它们之间的差别，在本文剩下的内容中会分别介绍。这里请读者记住，**在陷阱函数中一定使用`Reflect`对象上的方法，而在其他场合请使用`Object`对象上的方法**。

# getPropertyOf

{% note info %}
`getPropertyOf`陷阱函数与`Reflect.getPropertyOf()`接受相同的单个参数：
- **`trapTarget`**：需要获取原型的对象（即代理的目标对象）。
{% endnote %}

**`getPropertyOf`陷阱函数的返回值必须是一个对象或者`null`，其他任何类型的返回值都会抛出错误。**

```js
let target = Object.create({ a: 1 })
let proxy1 = new Proxy(target, {
    getPrototypeOf (trapTarget) {
        return null
    }
})
let proxy2 = new Proxy(target, {
    getPrototypeOf (trapTarget) {
        return Reflect.getPrototypeOf(trapTarget)
    }
})
let proxy3 = new Proxy(target, {
    getPrototypeOf (trapTarget) {
        return 1
    }
})

console.log(Object.getPrototypeOf(proxy1))      // null
console.log(Object.getPrototypeOf(proxy2))      // { a: 1 }
console.log(Object.getPrototypeOf(proxy3))      // TypeError: 'getPrototypeOf' on proxy: trap returned neither object nor null
```

{% note warning %}
`Reflect.getPropertyOf()`方法在接收到的参数不是一个对象时会抛出错误，而`Object.getPropertyOf()`则会在操作之前先将参数值转换为一个对象。如果你分别传入一个数值给这两个方法，会得到截然不同的结果：

{% code %}
let result1 = Object.getPrototypeOf(1)
console.log(result1 === Number.prototype)   // true

Reflect.getPrototypeOf(1)                   // TypeError: Reflect.getPrototypeOf called on non-object
{% endcode %}

{% endnote %}

# setPropertyOf

# 对象可扩展性的陷阱函数
## 两个基本范例
## 可扩展性的重复方法

# 属性描述符的陷阱函数
## 阻止Object.defineProperty()
## 描述符对象的限制
## 重复的描述符方法
### defineProperty()方法
### getOwnPropertyDescriptor()方法

# ownKeys陷阱函数

# 使用apply与construct陷阱函数的函数代理
## 验证函数的参数
## 调用构造器而无须使用new
## 重写抽象基础类的构造器
## 可被调用的类构造器

# 可被撤销的代理

# 解决数组的问题
## 检测数组的索引
## 在添加新元素时增加长度属性
## 在减少长度属性时移除元素
## 实现MyArray类

# 将代理对象作为原型使用
## 在原型上使用get陷阱函数
## 在原型上使用set陷阱函数
## 在原型上使用has陷阱函数
## 将代理作为类的原型