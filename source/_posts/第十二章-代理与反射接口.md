---
title: 第十二章 代理与反射接口
categories:
  - JavaScript
  - 《深入理解ES6》
abbrlink: 27777a89
date: 2019-04-14 10:32:54
---

ES6让开发者能进一步接近JS引擎的能力，这些能力原先只存在于内置对象上。语言通过代理（proxy）暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变JS引擎的底层操作。

# 代理与反射是什么？

**`Proxy`对象用于在目标对象上定义一些基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。**

{% note info %}
**语法**：`let proxy = new Proxy(target, handler)`。`target`与`handler`参数都是必填项。
- **`target`**：用`Proxy`包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）；
- **`handler`**：一个包含特定方法的对象，这些特定的方法又叫做**陷阱函数**；
- **陷阱函数**：用来拦截`target`对象上的特定操作、并用自定义行为替代这些特定操作的默认行为。陷阱函数内部的`this`指向`handler`。
{% endnote %}

观察下面的例子：

```js
let targetObj =  {
    name: 'target object'
}

let handlerObj = {
    // get陷阱函数，用于拦截对象的属性访问操作
    get () {
        return 'change the underlying operation'
    }
}

let proxy = new Proxy(targetObj, handlerObj)

console.log(targetObj.name)     // target object
console.log(proxy.name)         // change the underlying operation

console.log(targetObj.notExist) // undefined
console.log(proxy.notExist)     // change the underlying operation
```

上面的例子中，`proxy`是通过Proxy对`targetObj`进行了包装得到的代理对象，在对`proxy`的属性进行访问时，调用的是`handlerObj`中的`get`方法，因为陷阱函数`get`的存在，拦截了所有对`proxy`属性进行访问的操作。

**`Reflect`对象是一个内置的对象，它是给底层操作提供默认行为的方法的集合。每个陷阱函数都可以在`Reflect`对象上找到与之对应的同名方法，这个方法也叫做反射接口，陷阱函数与反射接口之间是一一对应的，并且它们接收的参数是相同的。**

**另外需要注意的是，`Reflect`不是一个函数对象，因此它不可以被当作构造器使用。**

{% note info %}
**每个陷阱函数都可以重写JS对象的一个特定默认行为，允许你拦截并修改它。如果你仍然需要使用原先的默认行为，则可使用`Reflect`的对应反射接口。**
{% endnote %}

下面表格中列出了陷阱函数、对应的操作和对应的默认行为：

| 代理陷阱 | 对应操作 | 默认行为 |
| :----: | :----: | :----: |
| **get**                      | **读取一个属性的值** | **Reflect.get()** |
| **set**                      | **写入一个属性的值** | **Reflect.set()** |
| **has**                      | **in运算符** | **Reflect.has()** |
| **deleteProperty**           | **delete运算符** | **Reflect.deleteProperty()** |
| **getPrototypeOf**            | **Object.getPrototypeOf()** | **Reflect.getPrototypeOf()** |
| **setPrototypeOf**            | **Object.setPrototypeOf()** | **Reflect.setPrototypeOf()** |
| **isExtensible**             | **Object.isExtensible()** | **Reflect.isExtensible()** |
| **preventExtensions**        | **Object.preventExtensions()** | **Reflect.preventExtensions()** |
| **getOwnPropertyDescriptor** | **Object.getOwnPropertyDescriptor()**    | **Reflect.getOwnPropertyDescriptor()** |
| **defineProperty**           | **Object.defineProperty()** | **Reflect.defineProperty()** |
| **ownKeys**                  | **Object.keys()**、<br/>**Object.getOwnPropertyNames()**、<br/>**Object.getOwnPropertySymbols()** | **Reflect.ownKeys()** |
| **apply**                    | **调用一个函数** | **Reflect.apply()** |
| **construct**                | **使用new调用一个函数**  | **Reflect.construct()** |

# get

{% note info %}
1. **`handle.get()`/`Reflect.get()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键；
    - **`receiver`**：最初被调用的对象（通常是代理对象，但也可能是继承了代理对象的其他对象）。


2. **`handle.get()`的返回值**：
    - 可以返回任何值。


3. **`handle.get()`的限制**：
    - 如果目标属性是不可写且不可配置的，那么返回值必须与该目标属性的值相同，否则会抛出错误；
    - 如果目标属性是不可配置的，并且没有定义`getter`，那么返回值必须为`undefined`，否则会抛出错误。
{% endnote %}

# set

{% note info %}
1. **`handle.set()`/`Reflect.set()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键；
    - **`value`**：目标属性的值；
    - **`receiver`**：最初被调用的对象（通常是代理对象，但也可能是继承了代理对象的其他对象）。


2. **`handle.set()`的返回值**：
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败。


3. **`handle.set()`的限制**：
    - 如果目标属性是不可写且不可配置的，则没有办法改变它的值；
    - 如果目标属性是不可配置的且没有定义`set`方法，则没有办法设置它的值；
    - 在严格模式下，如果返回`false`，会抛出错误。
{% endnote %}

```js
let proxy = new Proxy({}, {
    set (trapTarget, key, value, receiver) {
        if (key === 'abc') {
            return false
        }

        return Reflect.set(trapTarget, key, value, receiver)
    }
})

proxy.a = 1
proxy.abc = 2
console.log(proxy)  // { a: 1 }
```

# has

{% note info %}
1. **`handle.has()`/`Reflect.has()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键。


2. **`handle.has()`的返回值**：
    - 会自动将返回值转换为对应的布尔值。


3. **`handle.has()`的限制**：
    - 如果目标属性是不可配置的，那么该属性不能被代理隐藏，否则会抛出错误；
    - 如果目标对象是不可扩展的，那么该对象的属性不能被代理隐藏，否则会抛出错误。
{% endnote %}

```js
let target = { normalAttr: 'normal attribute'}

Object.defineProperties(target, {
    banConfigurable: {
        value: 'configurable is false'
    }
})

let proxy1 = new Proxy(target, {
    has (trapTarget, key) {
        return Reflect.has(trapTarget, key)
    }
})

let proxy2 = new Proxy(target, {
    has (trapTarget, key) {
        return false
    }
})

console.log('normalAttr' in proxy1)         // true
console.log('banConfigurable' in proxy1)    // true

console.log('normalAttr' in proxy2)         // false
console.log('banConfigurable' in proxy2)    // TypeError: 'has' on proxy: trap returned falsish for property 'banConfigurable' which exists in the proxy target as non-configurable

Object.preventExtensions(target)
console.log('normalAttr' in proxy2)         // TypeError: 'has' on proxy: trap returned falsish for property 'normalAttr' but the proxy target is not extensible
```

# deleteProperty

{% note info %}
1. **`handle.deleteProperty()`/`Reflect.deleteProperty()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键。


2. **`handle.deleteProperty()`的返回值**：
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败。


3. **`handle.deleteProperty()`的限制**：
    - 如果目标属性是不可配置的，那么该属性不能被删除，否则会抛出错误。
{% endnote %}

```js
let target = { normalAttr: 'normal attribute'}

Object.defineProperties(target, {
    banConfigurable: {
        value: 'configurable is false'
    }
})

let proxy1 = new Proxy(target, {
    deleteProperty (trapTarget, key) {
        return Reflect.deleteProperty(trapTarget, key)
    }
})

let proxy2 = new Proxy(target, {
    deleteProperty (trapTarget, key) {
        return true
    }
})

delete proxy1.normalAttr
console.log('normalAttr' in proxy1)         // false

delete proxy1.banConfigurable
console.log('banConfigurable' in proxy1)    // true

delete proxy2.banConfigurable
console.log('banConfigurable' in proxy2)    // TypeError: 'deleteProperty' on proxy: trap returned truish for property 'banConfigurable' which is non-configurable in the proxy target
```

# Object与Reflect的区别

`Object`对象和`Reflect`对象上存在着一些同名方法，比如`getPrototypeOf()`、`setPrototypeOf()`、`isExtensible`等等。它们不仅名称相同，功能也大致相同，这会让人产生疑惑，会有一种“既然有了`Object`，何必又出现`Reflect`”的感觉。

{% note info %}
**`Reflect`对象上的方法属于底层方法、是对JS语言内部方法进行封装（并附加了一些输入验证）后得到的；而`Object`对象上的方法属于高级方法，它们会在调用JS语言内部方法之前添加一些步骤、并检查返回值。**。
{% endnote %}

# getPrototypeOf

{% note info %}
1. **`handle.getPrototypeOf()`/`Reflect.getPrototypeOf()`的参数：**
    - **`trapTarget`**：目标对象。


2. **`handle.getPrototypeOf()`的返回值**：
    - 返回值必须是一个对象或者`null`，其他任何类型的返回值都会抛出错误。


3. **`handle.getPrototypeOf()`的限制**：
    - 如果目标对象是不可扩展的，那么必须保证`Object.getPrototypeOf(proxy)`的返回值与`Object.getPrototypeOf(target)`的返回值相同，否则会抛出错误。
{% endnote %}

```js
let target = Object.create({ normalAttr: 'normal attribute' })

let proxy1 = new Proxy(target, {
    getPrototypeOf (trapTarget) {
        return Reflect.getPrototypeOf(trapTarget)
    }
})

let proxy2 = new Proxy(target, {
    getPrototypeOf (trapTarget) {
        return 'not object'
    }
})

let proxy3 = new Proxy(target, {
    getPrototypeOf (trapTarget) {
        return {}
    }
})

console.log(Object.getPrototypeOf(proxy1))  // { normalAttr: 'normal attribute' }

console.log(Object.getPrototypeOf(proxy2))  // TypeError: 'getPrototypeOf' on proxy: trap returned neither object nor null

Object.preventExtensions(target)
console.log(Object.getPrototypeOf(proxy3))  // TypeError: 'getPrototypeOf' on proxy: proxy target is non-extensible but the trap did not return its actual prototype
```

{% note warning %}
**`Object.getPrototypeOf`与`Reflect.getPrototypeOf`的区别：**

| Object.getPrototypeOf | Reflect.getPrototypeOf |
| :-------------------: | :--------------------: |
| **接收的参数不是对象时，会先将其转换为对象** | **接收的参数不是对象时，会抛出错误** |
{% endnote %}

# setPrototypeOf

{% note info %}
1. **`handle.setPrototypeOf()`/`Reflect.setPrototypeOf()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`proto`**：需要被用作原型的对象。


2. **`handle.setPrototypeOf()`的返回值**：
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败。


3. **`handle.setPrototypeOf()`的限制**：
    - 如果目标对象是不可扩展的，那么必须保证传入的`proto`参数就是目标对象的原始原型，否则会抛出错误；
    - 返回值为`false`时，`Object.setPrototypeOf()`会抛出错误。
{% endnote %}

```js
let protoObj = { normalAttr: 'normal attribute'}
let target = Object.create(protoObj)
Object.preventExtensions(target)

let proxy1 = new Proxy(target, {
    setPrototypeOf (trapTarget, proto) {
        return Reflect.setPrototypeOf(trapTarget, proto)
    }
})

let proxy2 = new Proxy(target, {
    setPrototypeOf (trapTarget, proto) {
        return false
    }
})

// 传入第二个参数就是目标对象原始原型，故而不报错
Object.setPrototypeOf(proxy1, protoObj)

Object.setPrototypeOf(proxy1, {})             // TypeError: 'setPrototypeOf' on proxy: trap returned falsish

Object.setPrototypeOf(proxy2, protoObj)       // TypeError: 'setPrototypeOf' on proxy: trap returned falsish

```

{% note warning %}
**`Object.setPrototype`与`Reflect.setPrototype`的区别：**

| Object.setPrototype | Reflect.setPrototype |
| :-------------------: | :--------------------: |
| **接收的第一个参数不是对象时，会先将其转换为对象** | **接收的第一个参数不是对象时，会抛出错误** |
| **操作成功会将接收的第一个参数作为自身的返回值，操作失败会抛出错误** | **操作成功返回true，操作失败返回false** |
{% endnote %}

# isExtensible

{% note info %}
1. **`handle.isExtensible()`/`Reflect.isExtensible()`的参数：**
    - **`trapTarget`**：目标对象。


2. **`handle.isExtensible()`的返回值**：
    - 会自动将返回值转换为对应的布尔值。


3. **`handle.isExtensible()`的限制**：
    - 必须保证`Object.isExtensible(proxy)`的返回值与`Object.isExtensible(target)`的返回值相同，否则会抛出错误。
{% endnote %}

```js
let target = { normalAttr: 'normal attribute'}

let proxy1 = new Proxy(target, {
    isExtensible (trapTarget) {
        return Reflect.isExtensible(trapTarget)
    }
})

let proxy2 = new Proxy(target, {
    isExtensible (trapTarget) {
        return false
    }
})

console.log(Object.isExtensible(proxy1))    // true
console.log(Object.isExtensible(proxy2))    // TypeError: 'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')
```

{% note warning %}
**`Object.isExtensible`与`Reflect.isExtensible`的区别：**

| Object.isExtensible | Reflect.isExtensible |
| :-------------------: | :--------------------: |
| **接收的参数不是对象时，总是会返回false** | **接收的参数不是对象时，会抛出错误** |
{% endnote %}

# preventExtensions

{% note info %}
1. **`handle.preventExtensions()`/`Reflect.preventExtensions()`的参数：**
    - **`trapTarget`**：目标对象。


2. **`handle.preventExtensions()`的返回值**：
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败。


3. **`handle.preventExtensions()`的限制**：
    - 如果返回值可以被转换为`false`，就会抛出错误。
{% endnote %}

```js
let target = { normalAttr: 'normal attribute'}

let proxy1 = new Proxy(target, {
    preventExtensions (trapTarget) {
        return Reflect.preventExtensions(trapTarget)
    }
})

let proxy2 = new Proxy(target, {
    preventExtensions (trapTarget) {
        return false
    }
})

Object.preventExtensions(proxy1)    // true
Object.preventExtensions(proxy2)    // TypeError: 'preventExtensions' on proxy: trap returned falsish
```

{% note warning %}
**`Object.preventExtensions`与`Reflect.preventExtensions`的区别：**

| Object.preventExtensions | Reflect.preventExtensions |
| :-------------------: | :--------------------: |
| **总是将接收的参数作为自身的返回值，即使该参数不是一个对象** | **接收的参数不是对象时，会抛出错误；参数是一个对象时，会在操作成功时返回true，失败时返回false** |
{% endnote %}

# getOwnPropertyDescriptor

{% note info %}
1. **`handle.getOwnPropertyDescriptor()`/`Reflect.getOwnPropertyDescriptor()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键。


2. **`handle.getOwnPropertyDescriptor()`的返回值**：
    - 返回值必须是一个对象（且这个对象必须包含`configurable`属性）或者`undefined`，否则会抛出错误。


3. `getOwnPropertyDescriptor`陷阱函数的限制：
    - 如果目标属性是目标对象上的不可配置属性，那么不允许返回`undefined`，否则会抛出错误；
    - 如果目标属性作为目标对象的属性存在，并且目标对象不可扩展，那么不允许返回`undefined`，否则会抛出错误；
    - 如果目标属性不存在于目标对象上，且目标对象不可扩展，那么必须返回`undefined`，否则会抛出错误；
    - 如果目标属性存在于目标对象的原型链上，或者是目标对象上的可配置属性，那么返回对象的`configurable`属性必须为`true`，否则会抛出错误。
{% endnote %}

```js
aaa
```

{% note warning %}
**`Object.getOwnPropertyDescriptor`与`Reflect.getOwnPropertyDescriptor`的区别：**

| Object.getOwnPropertyDescriptor | Reflect.getOwnPropertyDescriptor |
| :-------------------: | :--------------------: |
| **接收的第一个参数不是对象时，会先将其转换为对象** | **接收的第一个参数不是对象时，会抛出错误** |
{% endnote %}

# defineProperty

{% note info %}
1. **`handle.defineProperty()`/`Reflect.defineProperty()`的参数：**
    - **`trapTarget`**：目标对象；
    - **`key`**：目标属性的键；
    - **`descriptor`**：为该属性准备的描述符对象。


2. **`handle.defineProperty()`的返回值**：
    - 会自动将返回值转换为对应的布尔值，`true`代表操作成功，`false`代表操作失败。


3. `defineProperty`陷阱函数的限制：
    - 如果目标对象不可扩展，那么不允许添加属性，否则会抛出错误；
    - 如果目标属性不是作为目标对象上的不可配置属性存在的话，则不能添加或修改为不可配置的，否则会抛出错误。
    - 在严格模式下，如果返回`false`，会抛出错误。
{% endnote %}

```js
aaa
```

{% note warning %}
**`Object.defineProperty`与`Reflect.defineProperty`的区别：**

| Object.defineProperty | Reflect.defineProperty |
| :-------------------: | :--------------------: |
| **总是返回接收到的第一个参数** | **成功时返回true，失败时返回false** |
{% endnote %}

# ownKeys

{% note info %}
1. **`handle.ownKeys()`/`Reflect.ownKeys()`的参数：**
    - **`trapTarget`**：目标对象。


2. **`handle.ownKeys()`的返回值**：
    - 必须返回一个可枚举对象，否则会抛出错误。


3. `ownKeys`陷阱函数的限制：
    - 
{% endnote %}

```js
aaa
```

{% note warning %}
**`Object.ownKeys`与`Reflect.ownKeys`的区别：**

| Object.ownKeys | Reflect.ownKeys |
| :-------------------: | :--------------------: |
| **ad** | **士大夫** |
{% endnote %}





# 使用apply与construct陷阱函数的函数代理
## 验证函数的参数
## 调用构造器而无须使用new
## 重写抽象基础类的构造器
## 可被调用的类构造器

# 可被撤销的代理

# 解决数组的问题
## 检测数组的索引
## 在添加新元素时增加长度属性
## 在减少长度属性时移除元素
## 实现MyArray类

# 将代理对象作为原型使用
## 在原型上使用get陷阱函数
## 在原型上使用set陷阱函数
## 在原型上使用has陷阱函数
## 将代理作为类的原型