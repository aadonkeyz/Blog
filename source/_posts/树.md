---
title: æ ‘
categories:
  - æ•°æ®ç»“æ„ä¸ç®—æ³•
mathjax: true
abbrlink: 7b216a3b
date: 2019-06-14 23:57:31
---

# æ ‘çš„åŸºæœ¬æ¦‚å¿µ

ä¸€æ£µæ ‘æ˜¯ä¸€äº›èŠ‚ç‚¹çš„é›†åˆï¼Œè¿™ä¸ªé›†åˆå¯ä»¥æ˜¯ç©ºé›†ï¼›è‹¥ä¸æ˜¯ç©ºé›†ï¼Œåˆ™æ ‘ç”±ç§°åš**æ ¹ï¼ˆrootï¼‰**çš„èŠ‚ç‚¹$r$åŠ 0 æˆ–å¤šä¸ªéç©ºçš„ï¼ˆå­ï¼‰æ ‘$T_1,T_2, Â·Â·Â·,T_k$ç»„æˆï¼Œè¿™äº›å­æ ‘ä¸­æ¯ä¸€é¢—çš„æ ¹éƒ½è¢«æ¥è‡ªæ ¹$r$çš„ä¸€æ¡æœ‰å‘çš„è¾¹æ‰€è¿æ¥ã€‚æ¯ä¸€é¢—å­æ ‘çš„æ ¹å«ä½œæ ¹$r$çš„**å„¿å­**ï¼Œè€Œ$r$æ˜¯æ¯ä¸€é¢—å­æ ‘çš„æ ¹çš„**çˆ¶äº²**

![ä¸€èˆ¬çš„æ ‘](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%B8%80%E8%88%AC%E7%9A%84%E6%A0%91.png)

ä¸‹å›¾ä¸­ï¼ŒèŠ‚ç‚¹ A æ˜¯æ ¹ã€‚èŠ‚ç‚¹ F æœ‰ä¸€ä¸ªçˆ¶äº² A å¹¶ä¸”æœ‰å„¿å­ Kã€L å’Œ Mã€‚æ¯ä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰ä»»æ„å¤šä¸ªå„¿å­ï¼Œä¹Ÿå¯èƒ½æ˜¯é›¶ä¸ªå„¿å­ã€‚æ²¡æœ‰å„¿å­çš„èŠ‚ç‚¹ç§°ä¸º**æ ‘å¶**ï¼Œä¸‹å›¾ä¸­çš„æ ‘å¶æ˜¯ Bã€Cã€Hã€Iã€Pã€Qã€Kã€Lã€M å’Œ Nã€‚å…·æœ‰ç›¸åŒçˆ¶äº²çš„èŠ‚ç‚¹ä¸º**å…„å¼Ÿ**ã€‚å› æ­¤ï¼ŒKã€L å’Œ M éƒ½æ˜¯å…„å¼Ÿã€‚

![ä¸€é¢—æ ‘](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%B8%80%E6%A3%B5%E6%A0%91.png)

ä»èŠ‚ç‚¹$n_1$åˆ°$n_k$çš„**è·¯å¾„**å®šä¹‰ä¸ºèŠ‚ç‚¹$n_1, n_2, Â·Â·Â·, n_k$çš„ä¸€ä¸ªåºåˆ—ï¼Œä½¿å¾—å¯¹äº$1 \leq i \leq k$çš„èŠ‚ç‚¹$n_i$æ˜¯$n$<sub>$i+1$</sub>çš„çˆ¶äº²ã€‚è¿™æ¡è·¯å¾„çš„é•¿æ˜¯è¯¥è·¯å¾„ä¸Šè¾¹çš„æ¡æ•°ï¼Œå³$k - 1$ã€‚ä»æ¯ä¸€ä¸ªèŠ‚ç‚¹åˆ°å®ƒè‡ªå·±æœ‰ä¸€æ¡é•¿ä¸º 0 çš„è·¯å¾„ã€‚æ³¨æ„ï¼Œåœ¨ä¸€æ£µæ ‘ä¸­ä»æ ¹åˆ°æ¯ä¸ªèŠ‚ç‚¹æ°å¥½å­˜åœ¨ä¸€æ¡è·¯å¾„

å¯¹ä»»æ„èŠ‚ç‚¹$n_i$ï¼Œ$n_i$çš„**æ·±åº¦**ä¸ºä»æ ¹åˆ°$n_i$çš„å”¯ä¸€è·¯å¾„çš„é•¿ã€‚å› æ­¤ï¼Œæ ¹çš„æ·±åº¦ä¸º 0ã€‚èŠ‚ç‚¹$n_i$çš„**é«˜**æ˜¯ä»$n_i$åˆ°ä¸€ç‰‡æ ‘å¶çš„æœ€é•¿è·¯å¾„çš„é•¿ã€‚å› æ­¤æ‰€æœ‰æ ‘å¶çš„é«˜éƒ½æ˜¯ 0ã€‚**ä¸€æ£µæ ‘çš„é«˜ç­‰äºå®ƒçš„æ ¹çš„é«˜**ã€‚ä¸Šå›¾ä¸­çš„æ ‘ï¼ŒE çš„æ·±åº¦ä¸º 1 è€Œé«˜ä¸º 2ï¼›F çš„æ·±åº¦ä¸º 1 è€Œé«˜ä¹Ÿæ˜¯ 1ï¼›è¯¥æ ‘çš„é«˜ä¸º 3ã€‚**ä¸€æ£µæ ‘çš„æ·±åº¦ç­‰äºå…¶æœ€æ·±çš„æ ‘å¶çš„æ·±åº¦ï¼Œè¯¥æ·±åº¦æ€»æ˜¯ç­‰äºè¿™æ£µæ ‘çš„é«˜**

# äºŒå‰æ ‘

## äºŒå‰æ ‘çš„ç§ç±»

{% note info %}

- **äºŒå‰æ ‘**ï¼šæ˜¯ä¸€ç§ç‰¹æ®Šçš„æ ‘ï¼Œå®ƒæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šåªèƒ½æœ‰ä¸¤ä¸ªå„¿å­
- **å®Œç¾äºŒå‰æ ‘**ï¼šé«˜ä¸º hï¼Œä¸”èŠ‚ç‚¹æ•°ä¸º$2^{h+1} - 1$çš„äºŒå‰æ ‘ã€‚ä¹Ÿå°±æ˜¯è¯´é™¤äº†æœ€åä¸€å±‚æ— ä»»ä½•å­èŠ‚ç‚¹ä¹‹å¤–ï¼Œæ¯ä¸€å±‚ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå„¿å­
- **å®Œå…¨äºŒå‰æ ‘**ï¼šä»æ ¹èŠ‚ç‚¹åˆ°å€’æ•°ç¬¬äºŒå±‚æ»¡è¶³å®Œç¾äºŒå‰æ ‘ï¼Œæœ€åä¸€å±‚æ²¡æœ‰å®Œå…¨å¡«æ»¡ï¼Œå…¶å¶å­èŠ‚ç‚¹éƒ½é å·¦å¯¹é½ã€‚ä¸€é¢—é«˜ä¸º h çš„å®Œå…¨äºŒå‰æ ‘æœ‰$2^h$åˆ°$2^{h+1} - 1$ä¸ªèŠ‚ç‚¹ã€‚è¿™æ„å‘³ç€ï¼Œå®Œå…¨äºŒå‰æ ‘çš„é«˜æ˜¯$\lfloor logN \rfloor$ï¼Œæ˜¾ç„¶å®ƒæ˜¯$O(logN)$
- **å®Œæ»¡äºŒå‰æ ‘**ï¼šå¯¹äºä»»æ„èŠ‚ç‚¹ï¼Œè¦ä¸å°±æ˜¯æ‹¥æœ‰ä¸¤ä¸ªå„¿å­ï¼Œè¦ä¸å°±æ˜¯ä¸€ä¸ªå„¿å­éƒ½æ²¡æœ‰
- **å †**ï¼šç‰¹æ®Šçš„å®Œå…¨äºŒå‰æ ‘ï¼Œåç»­æ–‡ç« ä¼šè¯¦ç»†ä»‹ç»
- **äºŒå‰æŸ¥æ‰¾æ ‘**ï¼šä½¿äºŒå‰æ ‘æˆä¸ºäºŒå‰æŸ¥æ‰¾æ ‘çš„æ€§è´¨æ˜¯ï¼Œå¯¹äºæ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ Xï¼Œå®ƒçš„å·¦å­æ ‘ä¸­æ‰€æœ‰é¡¹çš„å€¼å‡å°äº X ä¸­çš„é¡¹ï¼Œè€Œå®ƒçš„å³å­æ ‘ä¸­æ‰€æœ‰é¡¹çš„å€¼å‡å¤§äº X ä¸­çš„é¡¹
- **AVL æ ‘**ï¼šå¸¦æœ‰å¹³è¡¡æ¡ä»¶çš„äºŒå‰æŸ¥æ‰¾æ ‘
  {% endnote %}

## äºŒå‰æ ‘çš„éå†

{% note info %}

- **å…ˆåºéå†**ï¼šé¦–å…ˆå¤„ç†æ ¹èŠ‚ç‚¹ï¼Œç„¶åå†å¤„ç†å®ƒçš„å·¦å„¿å­å’Œå³å„¿å­
- **ä¸­åºéå†**ï¼šé¦–å…ˆå¤„ç†å·¦å„¿å­ï¼Œç„¶åå¤„ç†æ ¹èŠ‚ç‚¹ï¼Œæœ€åå¤„ç†å³å„¿å­
- **ååºéå†**ï¼šé¦–å…ˆå¤„ç†å·¦å„¿å­ï¼Œç„¶åå¤„ç†å³å„¿å­ï¼Œæœ€åå¤„ç†æ ¹èŠ‚ç‚¹
- **å±‚åºéå†**ï¼šæŒ‰ç…§ä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³çš„é¡ºåºå¤„ç†èŠ‚ç‚¹

**æ— è®ºæ˜¯å“ªç§éå†æ–¹å¼ï¼Œå®ƒä»¬è®¿é—®èŠ‚ç‚¹çš„é¡ºåºéƒ½æ˜¯ç›¸åŒçš„ï¼Œä¸åŒçš„æ˜¯å¤„ç†èŠ‚ç‚¹çš„é¡ºåº**
{% endnote %}

ä¸‹é¢å°†ä¾æ¬¡ä»‹ç»å„ç§éå†çš„å®ç°æ–¹å¼ï¼Œå…ˆæŠŠéªŒè¯ç”¨çš„æ•°æ®æ”¾è¿™é‡Œ

```js
let tree = {
  value: 1,
  left: {
    value: 2,
    left: {
      value: 4,
      left: null,
      right: {
        value: 6,
        left: {
          value: 7,
          left: null,
          right: null,
        },
        right: {
          value: 8,
          left: null,
          right: null,
        },
      },
    },
    right: null,
  },
  right: {
    value: 3,
    left: null,
    right: {
      value: 5,
      left: null,
      right: null,
    },
  },
};
```

### å…ˆåºéå†

#### é€’å½’

```js
function preOrderTraverse(node) {
  if (node) {
    console.log(node.value);

    preOrderTraverse(node.left);
    preOrderTraverse(node.right);
  }
}
```

#### éé€’å½’

```js
function preOrderTraverse(node) {
  const stack = [];
  let current = node;

  while (current || stack.length > 0) {
    while (current) {
      console.log(current.value);

      stack.push(current);
      current = current.left;
    }

    if (stack.length > 0) {
      current = stack.pop().right;
    }
  }
}
```

### ä¸­åºéå†

#### é€’å½’

```js
function middleOrderTraverse(node) {
  if (node) {
    middleOrderTraverse(node.left);

    console.log(node.value);

    middleOrderTraverse(node.right);
  }
}
```

#### éé€’å½’

```js
function middleOrderTraverse(node) {
  const stack = [];
  let current = node;

  while (current || stack.length > 0) {
    while (current) {
      stack.push(current);
      current = current.left;
    }

    if (stack.length > 0) {
      current = stack.pop();

      console.log(current.value);

      current = current.right;
    }
  }
}
```

### ååºéå†

#### é€’å½’

```js
function postOrderTraverse(node) {
  if (node) {
    postOrderTraverse(node.left);
    postOrderTraverse(node.right);

    console.log(node.value);
  }
}
```

#### éé€’å½’

```js
function postOrderTraverse(node) {
  const stack = [];

  let current = node;
  let lastHandled = null;

  while (current || stack.length > 0) {
    while (current) {
      stack.push(current);
      current = current.left;
    }

    if (stack.length > 0) {
      const topNode = stack[stack.length - 1];

      if (topNode.right && topNode.right !== lastHandled) {
        current = topNode.right;
      } else {
        lastHandled = stack.pop();
        console.log(lastHandled.value);
      }
    }
  }
}
```

### å±‚åºéå†

```js
function levelOrderTraverse(node) {
  if (node) {
    const queue = [node];

    while (queue.length > 0) {
      const currentNode = queue.shift();
      console.log(currentNode.value);

      if (currentNode.left) {
        queue.push(currentNode.left);
      }

      if (currentNode.right) {
        queue.push(currentNode.right);
      }
    }
  }
}
```

## æ ¹æ®éå†ç¡®å®šç»“æ„

{% note info %}

- **å…ˆåºéå†**ï¼šç¬¬ä¸€ä¸ªå¤„ç†çš„èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ã€‚
- **ä¸­åºéå†**ï¼šæ ¹èŠ‚ç‚¹åœ¨ä¸­é—´ï¼Œå·¦å­æ ‘å’Œå³å­æ ‘çš„ä¸­åºéå†ç»“æœåˆ†åˆ«åˆ†å¸ƒåœ¨æ ¹èŠ‚ç‚¹å·¦å³ä¸¤ä¾§ã€‚
- **ååºéå†**ï¼šæœ€åä¸€ä¸ªå¤„ç†çš„èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ã€‚

ç”±ä¸Šè¿°ç‰¹ç‚¹ï¼Œå¯ä»¥å¾—å‡ºç»“è®ºï¼š**å…ˆåº+ä¸­åºï¼Œæˆ–è€…ä¸­åº+ååºï¼Œå¯ä»¥å¾—å‡ºäºŒå‰æ ‘çš„ç»“æ„ã€‚**
{% endnote %}

```js
function rebuildTree(preorder, inorder) {
  const rootVal = preorder[0];
  const root = {
    val: rootVal,
    left: null,
    right: null,
  };

  if (preorder.length === 0) {
    return null;
  }
  if (preorder.length === 1) {
    return root;
  }

  const splitIndex = inorder.indexOf(rootVal);
  if (splitIndex > 0) {
    root.left = rebuildTree(
      preorder.slice(1, splitIndex + 1),
      inorder.slice(0, splitIndex)
    );
  }

  if (splitIndex < inorder.length - 1) {
    root.right = rebuildTree(
      preorder.slice(splitIndex + 1),
      inorder.slice(splitIndex + 1)
    );
  }

  return root;
}
```

## äºŒå‰æŸ¥æ‰¾æ ‘

{% note info %}
äºŒå‰æŸ¥æ‰¾æ ‘ä¸æ™®é€šçš„äºŒå‰æ ‘ç›¸æ¯”ï¼Œæœ‰å¦‚ä¸‹ç‰¹ç‚¹ï¼š

- æ‰€æœ‰èŠ‚ç‚¹å½¼æ­¤äº’å¼‚ï¼Œå³ä¸å­˜åœ¨ç›¸åŒçš„èŠ‚ç‚¹
- å¯¹äºæ ‘ä¸­çš„ä»»æ„èŠ‚ç‚¹ Xï¼Œå®ƒçš„å·¦å­æ ‘ä¸­æ‰€æœ‰é¡¹çš„å€¼å‡å°äº X ä¸­çš„é¡¹ï¼Œè€Œå®ƒçš„å³å­æ ‘ä¸­æ‰€æœ‰é¡¹çš„å€¼å‡å¤§äº X ä¸­çš„é¡¹
  {% endnote %}

ä¸‹é¢æ˜¯å®ç°ä¸€ä¸ªäºŒå‰æŸ¥æ‰¾æ ‘çš„ä»£ç ï¼š

{% note warning %}
ä»äºŒå‰æŸ¥æ‰¾æ ‘ä¸­ç§»é™¤å…ƒç´ æ˜¯è¿™éƒ¨åˆ†çš„éš¾ç‚¹ï¼Œé¦–å…ˆå®šä½åˆ°è¦ç§»é™¤å…ƒç´ æ‰€åœ¨èŠ‚ç‚¹ï¼Œç„¶åè¿›è¡Œå¦‚ä¸‹ 3 ç§æ“ä½œï¼š

1. å¦‚æœå½“å‰èŠ‚ç‚¹ä¸ºæ ‘å¶ï¼Œé‚£ä¹ˆç›´æ¥åˆ é™¤è¯¥æ ‘å¶
2. å¦‚æœå½“å‰èŠ‚ç‚¹æ‹¥æœ‰ä¸€ä¸ªå­æ ‘ï¼Œé‚£ä¹ˆç”¨è¯¥å­æ ‘çš„æ ¹èŠ‚ç‚¹æ›¿æ¢å½“å‰èŠ‚ç‚¹
3. å¦‚æœå½“å‰èŠ‚ç‚¹æ‹¥æœ‰ä¸¤ä¸ªå­æ ‘ï¼Œé‚£ä¹ˆæ‰¾å‡ºå³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹å¹¶é€’å½’çš„åˆ é™¤è¯¥æœ€å°èŠ‚ç‚¹ï¼Œç„¶åå°†è¿™ä¸ªæœ€å°èŠ‚ç‚¹çš„å€¼èµ‹ç»™å½“å‰èŠ‚ç‚¹çš„å€¼ï¼ˆä¹Ÿå¯ä»¥é‡‡ç”¨ç›¸åçš„æ–¹å¼ï¼Œå»å¯»æ‰¾å·¦å­æ ‘ä¸­çš„æœ€å¤§èŠ‚ç‚¹ï¼‰
   {% endnote %}

```js
class BinarySearchTree {
  constructor(newValue) {
    this.value = newValue;
    this.left = null;
    this.right = null;
    this.isNode = true;
  }

  static makeTree(array) {
    let tree = new BinarySearchTree(array[0]);
    array.slice(1).forEach((item) => {
      tree.insert(item);
    });
    return tree;
  }

  insert(newNode, currentNode = this) {
    if (!newNode.isNode) {
      newNode = new BinarySearchTree(newNode);
    }

    if (newNode.value < currentNode.value) {
      if (currentNode.left) {
        currentNode.insert(newNode, currentNode.left);
      } else {
        currentNode.left = newNode;
      }
    }

    if (newNode.value > currentNode.value) {
      if (currentNode.right) {
        currentNode.insert(newNode, currentNode.right);
      } else {
        currentNode.right = newNode;
      }
    }

    if (newNode.value === currentNode.value) {
      console.log(`${newNode.value} already exists`);
    }
  }

  contains(inputValue, currentNode = this) {
    if (inputValue < currentNode.value) {
      if (currentNode.left) {
        return currentNode.contains(inputValue, currentNode.left);
      } else {
        return false;
      }
    }

    if (inputValue > currentNode.value) {
      if (currentNode.right) {
        return currentNode.contains(inputValue, currentNode.right);
      } else {
        return false;
      }
    }

    if (inputValue === currentNode.value) {
      return true;
    }
  }

  findMin(currentNode = this) {
    if (currentNode.left) {
      return currentNode.findMin(currentNode.left);
    } else {
      return currentNode.value;
    }
  }

  findMax(currentNode = this) {
    if (currentNode.right) {
      return currentNode.findMin(currentNode.right);
    } else {
      return currentNode.value;
    }
  }

  // preNodeå’Œwhereå‚æ•°å®Œå…¨æ˜¯ä¸ºäº†åˆ é™¤æ ‘å¶å‡†å¤‡çš„
  remove(inputValue, currentNode = this, preNode = null, where = "") {
    if (inputValue < currentNode.value) {
      if (currentNode.left) {
        currentNode.remove(inputValue, currentNode.left, currentNode, "left");
      } else {
        console.log(`${inputValue} does not exist`);
      }
    }

    if (inputValue > currentNode.value) {
      if (currentNode.right) {
        currentNode.remove(inputValue, currentNode.right, currentNode, "right");
      } else {
        console.log(`${inputValue} does not exist`);
      }
    }

    if (inputValue === currentNode.value) {
      if (!currentNode.left && !currentNode.right) {
        preNode[where] = null;
        return;
      }

      if (!currentNode.left) {
        currentNode = currentNode.right;
        return;
      } else if (!currentNode.right) {
        currentNode = currentNode.left;
        return;
      }

      if (currentNode.left && currentNode.right) {
        let minValue = currentNode.right.findMin();
        currentNode.remove(minValue, currentNode.right, currentNode, "right");
        currentNode.value = minValue;
        return;
      }
    }
  }
}

let array = [6, 2, 8, 7, 1, 4, 3, 5],
  tree = BinarySearchTree.makeTree(array);

function preOrderTraverse(node, result = "") {
  result += node.value + "  ";

  if (node.left) {
    result = preOrderTraverse(node.left, result);
  }

  if (node.right) {
    result = preOrderTraverse(node.right, result);
  }

  return result;
}

console.log(preOrderTraverse(tree)); // 6  2  1  4  3  5  8  7

tree.remove(4);
console.log(preOrderTraverse(tree)); // 6  2  1  5  3  8  7

tree.insert(4);
console.log(preOrderTraverse(tree)); // 6  2  1  5  3  4  8  7

tree.remove(41); // 41 does not exist
console.log(preOrderTraverse(tree)); // 6  2  1  5  3  4  8  7
```

## AVL æ ‘

### åŸºæœ¬æ¦‚å¿µ

{% note info %}

- AVL æ ‘æ˜¯å¸¦æœ‰å¹³è¡¡æ¡ä»¶çš„äºŒå‰æŸ¥æ‰¾æ ‘
- å¹³è¡¡æ¡ä»¶ä¸ºæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘çš„é«˜åº¦æœ€å¤šå·® 1ï¼ˆç©ºæ ‘çš„é«˜åº¦å®šä¹‰ä¸º-1ï¼‰
  {% endnote %}

å¦‚æœè¦å¯¹ä¸€ä¸ª AVL æ ‘è¿›è¡Œæ’å…¥æ“ä½œï¼Œéœ€è¦æ›´æ–°é€šå‘æ ¹èŠ‚ç‚¹è·¯å¾„ä¸Šé‚£äº›èŠ‚ç‚¹çš„æ‰€æœ‰å¹³è¡¡ä¿¡æ¯ï¼Œè€Œæ’å…¥æ“ä½œéšå«ç€å›°éš¾çš„åŸå› åœ¨äºï¼Œæ’å…¥ä¸€ä¸ªèŠ‚ç‚¹å¯èƒ½ç ´å AVL æ ‘çš„å¹³è¡¡ç‰¹æ€§ã€‚å¦‚æœå‘ç”Ÿè¿™ç§æƒ…å†µï¼Œé‚£ä¹ˆå¯ä»¥é€šè¿‡**æ—‹è½¬**æ¥æ¢å¤ AVL æ ‘çš„å¹³è¡¡

{% note info %}
åœ¨ä¸€æ¬¡æ’å…¥ä¹‹åï¼Œä»æ’å…¥ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šå¯»æ‰¾å…¶ä¸­æ·±åº¦æœ€æ·±ï¼ˆæˆ–é«˜åº¦æœ€å°ï¼‰çš„ä¸å¹³è¡¡èŠ‚ç‚¹ï¼Œç§°è¯¥èŠ‚ç‚¹ä¸º Aï¼Œé€ æˆä¸å¹³è¡¡çš„æ’å…¥åˆ†ä¸ºä¸‹é¢å››ç§æƒ…å†µï¼š

1. å¯¹ A çš„å·¦å„¿å­çš„å·¦å­æ ‘è¿›è¡Œä¸€æ¬¡æ’å…¥
2. å¯¹ A çš„å·¦å„¿å­çš„å³å­æ ‘è¿›è¡Œä¸€æ¬¡æ’å…¥
3. å¯¹ A çš„å³å„¿å­çš„å·¦å­æ ‘è¿›è¡Œä¸€æ¬¡æ’å…¥
4. å¯¹ A çš„å³å„¿å­çš„å³å­æ ‘è¿›è¡Œä¸€æ¬¡æ’å…¥

**åˆ é™¤æ“ä½œä¼šå‡ºç°çš„æƒ…å†µä¸æ’å…¥ç±»ä¼¼ï¼Œä¸å•ç‹¬ä»‹ç»äº†ã€‚**
{% endnote %}

æƒ…å†µ 1 å’Œæƒ…å†µ 4 æ˜¯å…³äº A ç‚¹çš„é•œåƒå¯¹ç§°ï¼Œä½¿ç”¨**å•æ—‹è½¬**æ¥å¤„ç†ï¼ŒåŸç†å¦‚ä¸‹å›¾æ‰€ç¤º

![AVL1](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL1.png)
![AVL4](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL4.png)

æƒ…å†µ 2 å’Œæƒ…å†µ 3 ä¹Ÿæ˜¯å…³äºç‚¹çš„é•œåƒå¯¹ç§°ï¼Œä½¿ç”¨**åŒæ—‹è½¬**æ¥å¤„ç†ï¼ŒåŸç†å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œ**å› ä¸ºå­æ ‘ B å’Œ C ä¸­æœ‰ä¸€é¢—æ¯” D æ·±ä¸¤å±‚ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸èƒ½è‚¯å®šæ˜¯å“ªä¸€é¢—ï¼Œæ‰€ä»¥å›¾ä¸­ B å’Œ C éƒ½è¢«ç”»æˆæ¯” D ä½ 1.5 å±‚**

![AVL2](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL2.png)
![AVL3](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL3.png)

### å®ç°

{% note warning %}
**æˆ‘å®ç°äºŒå‰æŸ¥æ‰¾æ ‘å’Œ AVL æ ‘çš„ä»£ç ä¹¦å†™æ€è·¯ä¸åŒï¼Œæœ€ä¸»è¦çš„åŒºåˆ«æ˜¯æ’å…¥å’Œåˆ é™¤æ“ä½œæ˜¯å¦æœ‰è¿”å›å€¼ã€‚æ™®é€šäºŒå‰æ ‘æ²¡æœ‰åˆ©ç”¨è¿”å›å€¼ï¼Œè€Œ AVL æ ‘çš„æ’å…¥å’Œåˆ é™¤æ“ä½œéƒ½ä¼šè¿”å›æ–°çš„ AVL æ ‘ ğŸŒ²ï¼**
{% endnote %}

```js
class AVLTree {
  constructor(newValue) {
    this.value = newValue;
    this.left = null;
    this.right = null;
    this.height = 0;
    this.isNode = true;
  }

  static makeTree(array) {
    let tree = new AVLTree(array[0]);
    array.slice(1).forEach((item) => {
      tree = tree.insert(item);
    });
    return tree;
  }

  insert(newNode, currentNode = this) {
    if (!newNode.isNode) {
      newNode = new AVLTree(newNode);
    }

    if (newNode.value < currentNode.value) {
      if (currentNode.left) {
        currentNode.left = currentNode.insert(newNode, currentNode.left);
      } else {
        currentNode.left = newNode;
      }
    }

    if (newNode.value > currentNode.value) {
      if (currentNode.right) {
        currentNode.right = currentNode.insert(newNode, currentNode.right);
      } else {
        currentNode.right = newNode;
      }
    }

    if (newNode.value === currentNode.value) {
      console.log(`${newNode.value} already exists`);
    }

    currentNode = currentNode.balanceTree(currentNode);

    return currentNode;
  }

  // åªè¦æ ‘çš„ç»“æ„å‘ç”Ÿæ”¹å˜å°±è¦è§¦å‘è¿™ä¸ªå‡½æ•°
  // è´Ÿè´£ä¿æŒæ ‘çš„å¹³è¡¡å’Œæ›´æ–°èŠ‚ç‚¹çš„é«˜åº¦ä¿¡æ¯
  balanceTree(currentNode) {
    function getTreeHeight(currentNode) {
      if (!currentNode) {
        return -1;
      } else {
        return currentNode.height;
      }
    }

    function rotateWithLeftChild(currentNode) {
      let nextNode = currentNode.left;

      currentNode.left = nextNode.right;
      nextNode.right = currentNode;

      return nextNode;
    }

    function rotateWithRightChild(currentNode) {
      let nextNode = currentNode.right;

      currentNode.right = nextNode.left;
      nextNode.left = currentNode;

      return nextNode;
    }

    function doubleWithLeftChild(currentNode) {
      currentNode.left = rotateWithRightChild(currentNode.left);
      currentNode = rotateWithLeftChild(currentNode);
      return currentNode;
    }

    function doubleWithRightChild(currentNode) {
      currentNode.right = rotateWithLeftChild(currentNode.right);
      currentNode = rotateWithRightChild(currentNode);
      return currentNode;
    }

    if (
      getTreeHeight(currentNode.left) - getTreeHeight(currentNode.right) >
      1
    ) {
      if (
        getTreeHeight(currentNode.left.left) >=
        getTreeHeight(currentNode.left.right)
      ) {
        currentNode = rotateWithLeftChild(currentNode);
      } else {
        currentNode = doubleWithLeftChild(currentNode);
      }
    }

    if (
      getTreeHeight(currentNode.right) - getTreeHeight(currentNode.left) >
      1
    ) {
      if (
        getTreeHeight(currentNode.right.right) >=
        getTreeHeight(currentNode.right.left)
      ) {
        currentNode = rotateWithRightChild(currentNode);
      } else {
        currentNode = doubleWithRightChild(currentNode);
      }
    }

    function updateHeight(currentNode) {
      currentNode.height =
        Math.max(
          getTreeHeight(currentNode.left),
          getTreeHeight(currentNode.right)
        ) + 1;
    }

    if (currentNode.left) {
      updateHeight(currentNode.left);
    }

    if (currentNode.right) {
      updateHeight(currentNode.right);
    }

    updateHeight(currentNode);

    return currentNode;
  }

  remove(inputValue, currentNode = this) {
    if (inputValue < currentNode.value) {
      if (currentNode.left) {
        currentNode.left = currentNode.remove(
          inputValue,
          currentNode.left,
          currentNode,
          "left"
        );
      } else {
        console.log(`${inputValue} does not exist`);
      }
    }

    if (inputValue > currentNode.value) {
      if (currentNode.right) {
        currentNode.right = currentNode.remove(
          inputValue,
          currentNode.right,
          currentNode,
          "right"
        );
      } else {
        console.log(`${inputValue} does not exist`);
      }
    }

    if (inputValue === currentNode.value) {
      switch (true) {
        case !currentNode.left && !currentNode.right:
          currentNode = null;
          break;

        case !currentNode.left:
          currentNode = currentNode.right;
          break;

        case !currentNode.right:
          currentNode = currentNode.left;
          break;

        case currentNode.left && currentNode.right:
          let minValue = currentNode.right.findMin();
          currentNode = currentNode.remove(
            minValue,
            currentNode.right,
            currentNode,
            "right"
          );
          currentNode.value = minValue;
          break;

        default:
          break;
      }
    }

    if (currentNode) {
      currentNode = currentNode.balanceTree(currentNode);
    }

    return currentNode;
  }
}

function preOrderTraverse(node, result = "") {
  result += node.value + "  ";

  if (node.left) {
    result = preOrderTraverse(node.left, result);
  }

  if (node.right) {
    result = preOrderTraverse(node.right, result);
  }

  return result;
}

let array = [1, 2, 3, 4, 5, 6, 7, 16, 15],
  tree = AVLTree.makeTree(array);

console.log(preOrderTraverse(tree)); // 4  2  1  3  6  5  15  7  16

tree = tree.insert(14);
console.log(preOrderTraverse(tree)); // 4  2  1  3  7  6  5  15  14  16

tree = tree.remove(6);
console.log(preOrderTraverse(tree)); // 4  2  1  3  7  5  15  14  16

tree = tree.remove(5);
console.log(preOrderTraverse(tree)); // 4  2  1  3  15  7  14  16
```

### æ˜¯å¦ä¸º AVL æ ‘

```js
function isAVL(root) {
  let height = calculateHeight(root);

  // å®šä¹‰é«˜åº¦ä¸º -2 ä»£è¡¨ä¸å¹³è¡¡
  if (height === -2) {
    return false;
  }

  if (height === -1) {
    return "it is not a tree!";
  }

  return true;
}

function calculateHeight(node) {
  if (!node) {
    return -1;
  }

  let left = calculateHeight(node.left),
    right = calculateHeight(node.right);

  if (left === -2 || right === -2) {
    return -2;
  }

  if (left - right > 1 || left - right < -1) {
    return -2;
  }

  return Math.max(left, right) + 1;
}
```

# B æ ‘

{% note info %}
é˜¶ä¸º $M$ çš„ B æ ‘æ˜¯ä¸€é¢—å…·æœ‰ä¸‹åˆ—ç‰¹æ€§çš„ $M$ å‰æ ‘ï¼š

1. æ•°æ®å…¨éƒ¨å­˜å‚¨åœ¨å¶èŠ‚ç‚¹ä¸Šï¼›
2. éå¶èŠ‚ç‚¹æœ€å¤šå¯ä»¥å­˜å‚¨ $M-1$ ä¸ªå…³é”®å­—ï¼Œä»¥æŒ‡ç¤ºæœç´¢çš„æ–¹å‘ã€‚å…³é”®å­— $i$ ä»£è¡¨å­æ ‘ $i+1$ ä¸­æœ€å°çš„å…³é”®å­—ï¼›
3. æ ‘çš„æ ¹å¦‚æœæœ‰å­èŠ‚ç‚¹ï¼Œåˆ™å­èŠ‚ç‚¹ä¸ªæ•°ä¸€å®šåœ¨ 2 å’Œ $M$ ä¹‹é—´ï¼›
4. é™¤æ ¹å¤–ï¼Œæ‰€æœ‰éå¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä¸ªæ•°åœ¨ $\lceil M/2 \rceil$ å’Œ $M$ ä¹‹é—´ï¼›
5. æ‰€æœ‰æ ‘å¶çš„æ·±åº¦ç›¸åŒï¼Œå¹¶ä¸”æ¯ç‰‡æ ‘å¶ä¸Šå­˜å‚¨çš„æ•°æ®ä¸ªæ•°åœ¨ $\lceil L/2 \rceil$ å’Œ $L$ ä¹‹é—´ã€‚$L = èŠ‚ç‚¹å¯å®¹çº³æ•°æ®ä¸ªæ•° = èŠ‚ç‚¹å®¹é‡/æ•°æ®å¤§å°$
   {% endnote %}

![B-Tree Demo](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/B%20Tree%20Demo.png)
