---
title: 树
categories:
    - 数据结构与算法
mathjax: true
abbrlink: 7b216a3b
date: 2019-06-14 23:57:31
---


# 树的基本概念

一棵树是一些节点的集合，这个集合可以是空集；若不是空集，则树由称做**根（root）**的节点$r$及0或多个非空的（子）树$T_1,T_2, ···,T_k$组成，这些子树中每一颗的根都被来自根$r$的一条有向的边所连接。每一颗子树的根叫作根$r$的**儿子**，而$r$是每一颗子树的根的**父亲**

![一般的树](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%B8%80%E8%88%AC%E7%9A%84%E6%A0%91.png)

下图中，节点A是根。节点F有一个父亲A并且有儿子K、L和M。每一个节点可以有任意多个儿子，也可能是零个儿子。没有儿子的节点称为**树叶**，下图中的树叶是B、C、H、I、P、Q、K、L、M和N。具有相同父亲的节点为**兄弟**。因此，K、L和M都是兄弟。

![一颗树](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%B8%80%E6%A3%B5%E6%A0%91.png)

从节点$n_1$到$n_k$的**路径**定义为节点$n_1, n_2, ···, n_k$的一个序列，使得对于$1 \leq i \leq k$的节点$n_i$是$n_{i + 1}$的父亲。这条路径的长是该路径上边的条数，即$k - 1$。从每一个节点到它自己有一条长为0的路径。注意，在一棵树中从根到每个节点恰好存在一条路径

对任意节点$n_i$，$n_i$的**深度**为从根到$n_i$的唯一路径的长。因此，根的深度为0。节点$n_i$的**高**是从$n_i$到一片树叶的最长路径的长。因此所有树叶的高都是0。**一棵树的高等于它的根的高**。上图中的树，E的深度为1而高为2；F的深度为1而高也是1；该树的高为3。**一棵树的深度等于其最深的树叶的深度，该深度总是等于这棵树的高**

**二叉树**是一种特殊的树，其中每个节点都不能有多于两个的儿子

# 先、中、后序遍历

{% note info %}
- **先序遍历**：首先处理当前节点，然后再处理它的诸子节点
- **中序遍历**：该遍历方式是针对于二叉树的，它会首先处理左子节点，然后处理当前节点，最后处理右子节点
- **后序遍历**：首先处理当前节点的诸子节点，然后再处理当前节点

---
**先、中、后指的是处理节点的顺序，在访问节点的时候，是只有一种顺序的**
{% endnote %}

![节点访问顺序](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F.png)

对于上图中的二叉树，它的先、中、后序遍历代码如下所示

```js
// JavaScript

let tree = {
    value: 1,
    left: {
        value: 2,
        left: {
            value: 4,
            right: {
                value: 6,
                left: {
                    value: 7
                },
                right: {
                    value: 8
                }
            }
        }
    },
    right: {
        value: 3,
        right: {
            value: 5
        }
    }
}

function preOrderTraverse (node, result = '') {
    result += node.value + '  '

    if (node.left) {
        result = preOrderTraverse(node.left, result)
    }

    if (node.right) {
        result = preOrderTraverse(node.right, result)
    }

    return result
}

function middleOrderTraverse (node, result = '') {
    if (node.left) {
        result = middleOrderTraverse(node.left, result)
    }

    result += node.value + '  '

    if (node.right) {
        result = middleOrderTraverse(node.right, result)
    }

    return result
}

function postOrderTraverse (node, result = '') {
    if (node.left) {
        result = postOrderTraverse(node.left, result)
    }

    if (node.right) {
        result = postOrderTraverse(node.right, result)
    }

    result += node.value + '  '

    return result
}

console.log('先序遍历： ' + preOrderTraverse(tree))
console.log('中序遍历： ' + middleOrderTraverse(tree))
console.log('后序遍历： ' + postOrderTraverse(tree))

// 先序遍历： 1  2  4  6  7  8  3  5  
// 中序遍历： 4  7  6  8  2  1  3  5  
// 后序遍历： 7  8  6  4  2  5  3  1  
```

# 二叉查找树

{% note info %}
二叉查找树与普通的二叉树相比，有如下特点：
- 所有节点彼此互异，即不存在相同的节点
- 对于树中的任意节点X，X的左子树中所有节点都“小于”X，而X右子树中的所有节点都“大于”X
{% endnote %}

下面是实现一个二叉查找树的代码：

{% note warning %}
从二叉查找树中移除元素是这部分的难点，首先定位到要移除元素所在节点，然后进行如下3种操作：
1. 如果当前节点为树叶，那么直接删除该树叶
2. 如果当前节点拥有一个子树，那么用该子树的根节点替换当前节点
3. 如果当前节点拥有两个子树，那么找出右子树中的最小节点并递归的删除该最小节点，然后将这个最小节点的值赋给当前节点的值（也可以采用相反的方式，去寻找左子树中的最大节点）
{% endnote %}

```js
class BinarySearchTree {
    constructor (newValue) {
        this.value = newValue
        this.left = null
        this.right = null
        this.isNode = true
    }

    static makeTree (array) {
        let tree = new BinarySearchTree(array[0])
        array.slice(1).forEach(item => {
            tree.insert(item)
        })
        return tree
    }

    insert (newNode, currentNode = this) {
        if (!newNode.isNode) {
            newNode = new BinarySearchTree(newNode)
        }

        if (newNode.value < currentNode.value) {
            if (currentNode.left)  {
                currentNode.insert(newNode, currentNode.left)
            } else {
                currentNode.left = newNode
            }
        }

        if (newNode.value > currentNode.value) {
            if (currentNode.right)  {
                currentNode.insert(newNode, currentNode.right)
            } else {
                currentNode.right = newNode
            }
        }

        if (newNode.value === currentNode.value) {
            console.log(`${newNode.value} already exists`)
        }
    }

    contains (inputValue, currentNode = this) {        
        if (inputValue < currentNode.value) {
            if (currentNode.left) {
                return currentNode.contains(inputValue, currentNode.left)
            } else {
                return false
            }
        }
        
        if (inputValue > currentNode.value) {
            if (currentNode.right) {
                return currentNode.contains(inputValue, currentNode.right)
            } else {
                return false
            }
        }

        if (inputValue === currentNode.value) {
            return true
        }
    }

    findMin (currentNode = this) {
        if (currentNode.left) {
            return currentNode.findMin(currentNode.left)
        } else {
            return currentNode.value
        }
    }

    findMax (currentNode = this) {
        if (currentNode.right) {
            return currentNode.findMin(currentNode.right)
        } else {
            return currentNode.value
        }
    }

    // preNode和where参数完全是为了删除树叶准备的
    remove (inputValue, currentNode = this, preNode = null, where = '') {
        if (inputValue < currentNode.value) {
            if (currentNode.left) {
                currentNode.remove(inputValue, currentNode.left, currentNode, 'left')
            } else {
                console.log(`${inputValue} does not exist`)
            }
        }
        
        if (inputValue > currentNode.value) {
            if (currentNode.right) {
                currentNode.remove(inputValue, currentNode.right, currentNode, 'right')
            } else {
                console.log(`${inputValue} does not exist`)
            }
        }

        if (inputValue === currentNode.value) {
            if ((!currentNode.left) && (!currentNode.right)) {
                preNode[where] = null
                return
            }

            if (!currentNode.left) {
                currentNode = currentNode.right
                return
            } else if (!currentNode.right) {
                currentNode = currentNode.left
                return
            }

            if (currentNode.left && currentNode.right) {
                let minValue = currentNode.right.findMin()
                currentNode.remove(minValue, currentNode.right, currentNode, 'right')
                currentNode.value = minValue
                return
            }
        }
    }
}

let array = [6, 2, 8, 7, 1, 4, 3, 5],
    tree = BinarySearchTree.makeTree(array)

function preOrderTraverse (node, result = '') {
    result += node.value + '  '

    if (node.left) {
        result = preOrderTraverse(node.left, result)
    }

    if (node.right) {
        result = preOrderTraverse(node.right, result)
    }

    return result
}

console.log(preOrderTraverse(tree))     // 6  2  1  4  3  5  8  7  

tree.remove(4)
console.log(preOrderTraverse(tree))     // 6  2  1  5  3  8  7  

tree.insert(4)
console.log(preOrderTraverse(tree))     // 6  2  1  5  3  4  8  7 

tree.remove(41)                         // 41 does not exist
console.log(preOrderTraverse(tree))     // 6  2  1  5  3  4  8  7  
```

# AVL树

{% note info %}
- AVL树是带有平衡条件的二叉查找树
- 平衡条件为每个节点的左子树和右子树的高度最多差1（空树的高度定义为-1）
{% endnote %}

如果要对一个AVL树进行插入操作，需要更新通向根节点路径上那些节点的所有平衡信息，而插入操作隐含着困难的原因在于，插入一个节点可能破坏AVL树的平衡特性。如果发生这种情况，那么可以通过**旋转**来恢复AVL树的平衡

{% note info %}
在一次插入之后，从插入点到根节点的路径上寻找其中深度最深（或高度最小）的不平衡节点，称该节点为A，造成不平衡的插入分为下面四种情况：
1. 对A的左儿子的左子树进行一次插入
2. 对A的左儿子的右子树进行一次插入
3. 对A的右儿子的左子树进行一次插入
4. 对A的右儿子的右子树进行一次插入
{% endnote %}

情况1和情况4是关于A点的镜像对称，使用**单旋转**来处理，原理如下图所示

![AVL1](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL1.png)
![AVL4](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL4.png)

情况2和情况3也是关于点的镜像对称，使用**双旋转**来处理，原理如下图所示，**因为子树B和C中有一颗比D深两层，但是我们不能肯定是哪一颗，所以图中B和C都被画成比D低1.5层**

![AVL2](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL2.png)
![AVL3](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL3.png)

{% note warning %}
**我实现普通二叉树和AVL树的代码书写思路不同，最主要的区别是插入和删除操作是否有返回值。普通二叉树没有利用返回值，而AVL树的插入和删除操作都会返回新的AVL树🌲！**
{% endnote %}

```js
class AVLTree {
    constructor (newValue) {
        this.value = newValue
        this.left = null
        this.right = null
        this.height = 0
        this.isNode = true
    }

    static makeTree (array) {
        let tree = new AVLTree(array[0])
        array.slice(1).forEach(item => {
            tree = tree.insert(item)
        })
        return tree
    }

    insert (newNode, currentNode = this) {
        if (!newNode.isNode) {
            newNode = new AVLTree(newNode)
        }

        if (newNode.value < currentNode.value) {
            if (currentNode.left)  {
                currentNode.left = currentNode.insert(newNode, currentNode.left)
            } else {
                currentNode.left = newNode
            }
        }

        if (newNode.value > currentNode.value) {
            if (currentNode.right)  {
                currentNode.right = currentNode.insert(newNode, currentNode.right)
            } else {
                currentNode.right = newNode
            }
        }

        if (newNode.value === currentNode.value) {
            console.log(`${newNode.value} already exists`)
        }

        currentNode = currentNode.balanceTree(currentNode)

        return currentNode
    }

    // 只要树的结构发生改变就要触发这个函数
    // 负责保持树的平衡和更新节点的高度信息
    balanceTree (currentNode) {
        function getTreeHeight (currentNode) {
            if (!currentNode) {
                return -1
            } else {
                return currentNode.height
            }
        }

        function rotateWithLeftChild (currentNode) {
            let nextNode = currentNode.left

            currentNode.left = nextNode.right
            nextNode.right = currentNode

            return nextNode
        }

        function rotateWithRightChild (currentNode) {
            let nextNode = currentNode.right

            currentNode.right = nextNode.left
            nextNode.left = currentNode

            return nextNode
        }

        function doubleWithLeftChild (currentNode) {
            currentNode.left = rotateWithRightChild(currentNode.left)
            currentNode = rotateWithLeftChild(currentNode)
            return currentNode
        }

        function doubleWithRightChild (currentNode) {
            currentNode.right = rotateWithLeftChild(currentNode.right)
            currentNode = rotateWithRightChild(currentNode)
            return currentNode            
        }

        // 在删除一个节点的时候，可能出现不平衡节点的某个儿子拥有高度相同的两个子树的情况
        // 所以下面判断的时候，加上了“=”的情况
        if (getTreeHeight(currentNode.left) - getTreeHeight(currentNode.right) > 1) {
            if (getTreeHeight(currentNode.left.left) >= getTreeHeight(currentNode.left.right)) {
                currentNode = rotateWithLeftChild(currentNode)
            } else {
                currentNode = doubleWithLeftChild(currentNode)
            }
        }

        if (getTreeHeight(currentNode.right) - getTreeHeight(currentNode.left) > 1) {
            if (getTreeHeight(currentNode.right.right) >= getTreeHeight(currentNode.right.left)) {
                currentNode = rotateWithRightChild(currentNode)
            } else {
                currentNode = doubleWithRightChild(currentNode)
            }
        }

        function updateHeight (currentNode) {
            currentNode.height = Math.max(getTreeHeight(currentNode.left), getTreeHeight(currentNode.right)) + 1
        }

        if (currentNode.left) {
            updateHeight(currentNode.left)
        }

        if (currentNode.right) {
            updateHeight(currentNode.right)
        }

        updateHeight(currentNode)


        return currentNode
    }

    remove (inputValue, currentNode = this) {        
        if (inputValue < currentNode.value) {
            if (currentNode.left) {
                currentNode.left = currentNode.remove(inputValue, currentNode.left, currentNode, 'left')
            } else {
                console.log(`${inputValue} does not exist`)
            }
        }
        
        if (inputValue > currentNode.value) {
            if (currentNode.right) {
                currentNode.right = currentNode.remove(inputValue, currentNode.right, currentNode, 'right')
            } else {
                console.log(`${inputValue} does not exist`)
            }
        }

        if (inputValue === currentNode.value) {
            switch (true) {
                case ((!currentNode.left) && (!currentNode.right)):
                    currentNode = null
                    break

                case !currentNode.left:
                    currentNode = currentNode.right
                    break

                case !currentNode.right:
                    currentNode = currentNode.left
                    break

                case currentNode.left && currentNode.right:
                    let minValue = currentNode.right.findMin()
                    currentNode = currentNode.remove(minValue, currentNode.right, currentNode, 'right')
                    currentNode.value = minValue
                    break

                default:
                    break
            }
        }

        if (currentNode) {
            currentNode = currentNode.balanceTree(currentNode)
        }

        return currentNode
    }
}

function preOrderTraverse (node, result = '') {
    result += node.value + '  '

    if (node.left) {
        result = preOrderTraverse(node.left, result)
    }

    if (node.right) {
        result = preOrderTraverse(node.right, result)
    }

    return result
}


let array = [1, 2, 3, 4, 5, 6, 7, 16, 15],
    tree = AVLTree.makeTree(array)

console.log(preOrderTraverse(tree)) // 4  2  1  3  6  5  15  7  16

tree = tree.insert(14)
console.log(preOrderTraverse(tree)) // 4  2  1  3  7  6  5  15  14  16

tree = tree.remove(6)
console.log(preOrderTraverse(tree)) // 4  2  1  3  7  5  15  14  16

tree = tree.remove(5)
console.log(preOrderTraverse(tree)) // 4  2  1  3  15  7  14  16
```



