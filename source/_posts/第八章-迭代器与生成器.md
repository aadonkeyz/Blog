---
title: 第八章 迭代器与生成器
categories:
  - JavaScript
  - 《深入理解ES6》
abbrlink: 990a6acc
date: 2019-04-03 19:03:47
---

许多编程语言都将迭代数据的方式从使用`for`循环转变到使用迭代器对象，`for`循环需要初始化变量以便追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。迭代器是操作集合变得更简单，JS语言的很多新成分中都有迭代器的身影，如`for-of`和扩展运算符。

# 何为迭代器？

迭代器是被设计专用于迭代的对象，带有特定接口。所有迭代器对象都拥有`next()`方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的`value`，以及一个布尔类型的`done`，其值为`true`时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了`next()`方法，迭代器就会返回相应的下一个值。

若你在最后一个值返回后再调用`next()`，所返回的`done`属性值会是`true`，并且`value`属性值回事迭代器自身的返回值（return value，即使用return语句明确返回的值）。该“返回值”不是元数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用`undefined`。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。

记住这些后，在ES5中创建一个迭代器就相当简单了：

```js
function createIterator (items) {
    var i = 0

    // 返回一个迭代器
    return {
        next () {
            var done = (i >= items.length)
            var value = !done ? items[i++] : undefined

            return {
                done,
                value
            }
        }
    }
}

var iterator = createIterator([1, 2, 3])

console.log(iterator.next())    // { done: false, value: 1 }
console.log(iterator.next())    // { done: false, value: 2 }
console.log(iterator.next())    // { done: false, value: 3 }
console.log(iterator.next())    // { done: true, value: undefined }

// 之后的所有调用
console.log(iterator.next())    // { done: true, value: undefined }
```

正如此例演示，根据迭代器的规则来书写一个迭代器，是有一点复杂的。为此，ES6提供了生成器，让创建迭代器对象变得更简单。

# 何为生成器？

生成器是能返回一个迭代器的函数。生成器由放在`function`关键字之后的一个星号（`*`）来表示，并能使用新的`yield`关键字。将星号紧跟在`function`关键字之后，或是在中间留出空格，都是没问题的，正如下例：

```js
function *createIterator () {
    yield 1
    yield 2
    yield 3

    return 4
}

// 生成器能像正规函数那样被调用，但会返回一个迭代器
var iterator = createIterator()

console.log(iterator.next())    // { value: 1, done: false }
console.log(iterator.next())    // { value: 2, done: false }
console.log(iterator.next())    // { value: 3, done: false }
console.log(iterator.next())    // { value: 4, done: true }

// 之后的所有调用
console.log(iterator.next())    // { value: undefined, done: true }
```

生成器函数最有意思的方面可能就是它们会在每个`yield`语句后停止执行。例如，此代码中`yield 1`执行后，该函数将不会再执行任何操作，直到迭代器的`next()`方法被调用，此时才继续执行`yield 2`。

`yield`关键字可以和值或是表达式一起使用，因此你可以通过生成器给迭代器添加项目，而不是机械化地将项目一个个列出。

```js
function *createIterator (items) {
    for (let i = 0; i < items.length; i++) {
        yield items[i]
    }

    return 'returnValue'
}

var iterator = createIterator([1, 2, 3])

console.log(iterator.next())    // { value: 1, done: false }
console.log(iterator.next())    // { value: 2, done: false }
console.log(iterator.next())    // { value: 3, done: false }
console.log(iterator.next())    // { value: 'returnValue', done: true }

// 之后的所有调用
console.log(iterator.next())    // { value: undefined, done: true }
```

**`yield`关键字只能用在生成器内部，用于其他任意位置都是语法错误，即使在生成器内部的函数中也不行！**例如下面的写法就是错误的：

```js
function *createIterator (items) {
    items.forEach(item => {
        // 语法错误
        yield item + 1
    })
}
```

## 生成器函数表达式

你可以使用函数表达式来创建一个生成器，只要在`function`关键字与圆括号之间使用一个星号（*）即可。例如：

```js
let createIterator = function * (items) {
    for (let i = 0; i < items.length; i++) {
        yield items[i]
    }
}
```

需要注意的是，**不能将箭头函数创建为生成器**。

## 生成器对象方法

由于生成器就是函数，因此也可以被添加到对象中。

```js
var o = {
    createIterator: function *(items) {
        for (let i = 0; i < items.length; i++) {
            yield items[i]
        }
    }
}

// 使用ES6的方法简写形式也是可以的
var o = {
    *createIterator (items) {
        for (let i = 0; i < items.length; i++) {
            yield items[i]
        }
    }
}
```

# 可迭代对象和Symbol.iterator

{% note info %}
1. 首先要记住迭代器是一个对象，是一个专门用来迭代的对象。
2. 生成器是一个用于生成迭代器的函数。
3. 只要具有`Symbol.iterator`方法的对象，就是可迭代对象。
4. `Symbol.iterator`知名符号定义了为指定对象返回迭代器的函数，换句话说，`Symbol.iterator`方法是可迭代对象的生成器方法。
5. 生成器创建的所有迭代器都是可迭代对象，因为生成器默认就会为`Symbol.iterator`属性赋值。
{% endnote %}

在ES6中，所有的集合对象（数组、Set和Map）以及字符串都是可迭代对象，因此它们都被指定了默认的迭代器。

# for-of循环
## 访问默认迭代器
## 创建可迭代对象

# 内置的迭代器
## 集合的迭代器
### entries()迭代器
### values()迭代器
### keys()迭代器
### 集合类型的默认迭代器
## 字符串的迭代器
## NodeList的迭代器

# 扩展运算符与非数组的可迭代对象

# 迭代器高级功能
## 传递参数给迭代器
## 在迭代器中抛出错误
## 生成器的Return语句
## 生成器委托

# 异步任务运行
## 一个简单的任务运行器
## 带数据的任务运行
## 异步任务运行器