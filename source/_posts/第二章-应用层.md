---
title: 第二章 应用层
categories:
    - 计算机网络
    - 《计算机网络-自顶向下方法》
abbrlink: cc8b3032
date: 2019-06-28 22:28:01
---

# 应用层协议原理

## 网络应用程序体系结构

### 客户-服务器体系结构

在**客户-服务器体系结构**中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。值得注意的是利用客户-服务器体系结构，客户相互之间不直接通信。例如，在Web应用中两个浏览器并不直接通信。客户-服务器体系结构的另一个特征是该服务器具有固定的、周知的地址，该地址称为IP地址。

在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。例如，一个流行的社交网络站点如果仅有一台服务器来处理所有请求，将很快变得不堪重负。为此，配备大量主机的**数据中心**常被用于创建强大的虚拟服务器。

### 对等（P2P）体系结构

在一个**P2P体系结构**中，对位于数据中心的专用服务器有最小的（或者没有）依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方。

呃，举个例子就是BT种子下载时，需要在网络中有上传者同时在线的情况下你才能成功下载一样。这就是P2P体系结构的例子。

P2P体系结构的最引人入胜的特性之一是它们的**自扩展性**。例如，在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。P2P体系结构也是成本有效的，因为它们通常不需要庞大的服务器设施和服务器带宽。

## 进程通信

在构建网络应用程序前，还需要对运行在多个端系统上的程序是如何互相通信的情况又一个基本了解。在操作系统的术语中，进行通信的实际上是**进程**而不是程序。在两个不同端系统上的进程，通过跨越计算机网络交换**报文**而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过将报文发送回去进行响应。

**在给定的一对进程之间的通信会话场景中，发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。**

如上所述，多数应用程序是由通信进程对组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为**套接字**（socket）的软件接口向网络发送报文和从网络接收报文。一个进程可以拥有多个套接字。

套接字是同一台主机内应用层与运输层之间的接口。这个接口是可编程的，也被称为应用程序和网络之间的**应用程序编程接口（API）**。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对运输层的控制仅限于：**选择运输层协议**和**设定一些运输层参数**。

在这里只是为了引出套接字的概念，具体如果进行进程通信的，请看[第三章 运输层](https://aadonkeyz.com/posts/f043d83e/)。

# 应用层协议作用

{% note info %}
应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是定义了：
- 交换的报文类型，例如请求报文和响应报文。
- 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。
- 字段的语义，即这些字段中包含的信息的含义。
- 一个进程何时以及如何发送报文，对报文进行响应的规则。
{% endnote %}

# Web和HTTP

## HTTP概况

HTTP全名为超文本传输协议（HyperText Transfer Protocol），它由两个程序实现：一个是客户程序和一个服务程序。HTTP定义了客户想服务器请求数据的方式，以及服务器想客户传送数据的方式。

HTTP使用TCP作为它的支撑运输协议，HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该客户和服务器进行就可以通过套接字接口访问TCP。TCP为HTTP提供可靠的数据传输服务，从这里也能看出分层体系结构最大的有点，即HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节，因为那是TCP以及协议栈较底层协议的工作。

注意到下列现象很重要：服务器向客户发送被请求的数据，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短的几秒钟内两次请求同一个数据，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个**无状态协议**。

## 非持续连接和持续连接

在许多因特网应用程序中，客户和服务器在一个相当长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应。依据应用程序以及该应用程序的使用方式，这一系列请求可以以规则的间隔周期性地或间断性地一个接一个发出。当这种客户-服务器的交互式是经TCP进行的，应用程序的研制者就需要做一个重要决定，即每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送呢？采用前一种方法，该应用程序被称为使用**非持续连接**；采用后一种方法，该应用程序被称为使用**持续连接**。

{% note info %}
相比于持续连接，非持续连接有如下缺点：
- 客户和服务器中都要分配TCP的缓冲区和保持TCP变量。
- 多个请求/响应对会耗费更长的时间。
{% endnote %}

## HTTP请求报文

下面提供了一个典型的HTTP请求报文：

```txt
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

首先，我们看到该报文是用普通的ASCII文本书写的，这样有一定计算机只是的人都能够阅读它。其次，我们看到该报文由5行组成，每行由一个回车和换行符结束。最后一行再附加一个回车换行符。虽然这个特定的报文仅有5行，但一个请求报文能够具有更多的行或者至少为一行。

HTTP请求报文的第一行叫做**请求行**，其后继的行叫做**首部行**。

请求行有3个字段：**方法字段**、**URL字段**和**HTTP版本字段**。方法字段可以取几种不同的值，包括`GET`、`POST`、`HEAD`、`PUT`、`DELETE`等。

首部行的`Host: www.someschool.edu`指明了对象所在的主机。你也许认为该首部行是不必要的，因为在该主机中已经有一条TCP连接存在了，但是后面会介绍，该首部行提供的信息是Web代理告诉缓存所要求的。通过包含`Connection: close`首部行，告诉服务器不希望麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条TCP连接。`User-agent`首部行用来指明用户代理，即向服务器发送请求的浏览器类型。`Accept-language`首部行表示用户想要得到该对象的法语版本。

看过一个例子之后，我们在来看下图展示的请求报文通过格式。你可能已经注意到了在首部行（和附加的回车和换行）后有一个“实体主体”。使用`GET`方法时实体主体为空，而使用`POST`方法时才使用该实体主体。

![HTTP请求报文通用格式](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.png)

## HTTP响应报文

下面我们提供了一条典型的HTTP响应报文。该响应报文可以是对刚刚讨论的例子中请求报文的响应。

```txt
HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3(CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Connect-Length: 6821
Connect-Type: text/html

(data data data data data ...)
```

它有三个部分：一个初始**状态行**、6个**首部行**和**实体主体**。状态行有3个字段：**协议版本字段**、**状态码字段**和**状态信息字段**。首部行字段是一些基础信息，这里就不一一介绍了。实体主体部分是报文的主要部分，即它包含了所请求的对象本身。

响应报文的通用格式如下图所示。

![HTTP响应报文通用格式](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.png)

## cookie

前面提到了HTTP服务器是无状态的。这简化了服务器的设计，并且允许工程师们去开发可以同时处理数以千计的TCP连接的高性能Web服务器。然后一个Web站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP使用了cookie。

这里就不详细介绍了，cookie的原理展示在下图中。

![cookie原理](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/cookie%E5%8E%9F%E7%90%86.png)

# DNS

## DNS提供的服务

因特网的主机有多种标识方式，其中一种就是用它的**主机名**，如cnn.com、www.yahoo.com等，这些名字便于记忆也乐于被人们接收。然而，主机名几乎没有提供（即使有也很少）关于主机在因特网中的文职信息。况且，因为主机名可能由不定长的字母数字组成，路由器难以处理。由于这些原因，主机也可以使用所谓**IP地址**进行标识。

为了折衷这些不同的偏好，我们需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统（Domain Name System， DNS）的主要任务。

DNS也是应用层的协议，它通常是由其他应用层协议所使用的，包括HTTP、SMTP和FTP，将用户提供的主机名解析为IP地址。举一个例子，考虑当某个用户主机上的一个浏览器（即一个HTTP客户）请求URL www.someschool.edu/index.html页面时会发生什么现象。为了使用户的主机能够将一个HTTP请求报文发送到Web服务器www.someschool.edu，该用户主机必须获得www.someschool.edu的IP地址。其做法如下：

{% note info %}
1. 同一台用户主机上运行这DNS应用的客户端。
2. 浏览器从上述URL中抽取出主机名www.someschool.edu，并将这台主机名传给DNS应用的客户端。
3. DNS客户向DNS服务器发送一个包含主机名的请求。
4. DNS客户最终会收到一份回答报文，其中含有对应该主机名的IP地址。
5. 一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。
{% endnote %}

除了进行主机名到IP地址的转换之外，DNS还提供一些重要的服务：
{% note info %}
- **主机别名**：有着复杂主机名的主机能拥有一个或者多个别名。例如，一台名为relay1.west-coast.enterprise.com的主机，可能还有两个别名为enterprise.com和www.enterprise.com。在这种情况下，relay1.west-coast.enterprise.com也称为**规范主机名**。
- **邮件服务器别名**：顾名思义，不介绍了。
- **负载分配**：DNS也用于在冗余的服务器之间进行敷在分配。繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址。DNS数据库中存储着这些IP地址集合，当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常总是向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载。
{% endnote %}

## DNS工作机理概述

未完待续......
