---
title: 第二章 应用层
categories:
    - 计算机网络
    - 《计算机网络-自顶向下方法》
abbrlink: cc8b3032
date: 2019-06-28 22:28:01
---

# 应用层协议原理

## 网络应用程序体系结构

### 客户-服务器体系结构

在**客户-服务器体系结构**中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。值得注意的是利用客户-服务器体系结构，客户相互之间不直接通信。例如，在Web应用中两个浏览器并不直接通信。客户-服务器体系结构的另一个特征是该服务器具有固定的、周知的地址，该地址称为IP地址。

在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。例如，一个流行的社交网络站点如果仅有一台服务器来处理所有请求，将很快变得不堪重负。为此，配备大量主机的**数据中心**常被用于创建强大的虚拟服务器。

### 对等（P2P）体系结构

在一个**P2P体系结构**中，对位于数据中心的专用服务器有最小的（或者没有）依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方。

呃，举个例子就是BT种子下载时，需要在网络中有上传者同时在线的情况下你才能成功下载一样。这就是P2P体系结构的例子。

P2P体系结构的最引人入胜的特性之一是它们的**自扩展性**。例如，在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。P2P体系结构也是成本有效的，因为它们通常不需要庞大的服务器设施和服务器带宽。

## 进程通信

在构建网络应用程序前，还需要对运行在多个端系统上的程序是如何互相通信的情况又一个基本了解。在操作系统的术语中，进行通信的实际上是**进程**而不是程序。在两个不同端系统上的进程，通过跨越计算机网络交换**报文**而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过将报文发送回去进行响应。

**在给定的一对进程之间的通信会话场景中，发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。**

如上所述，多数应用程序是由通信进程对组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为**套接字**（socket）的软件接口向网络发送报文和从网络接收报文。一个进程可以拥有多个套接字。

套接字是同一台主机内应用层与运输层之间的接口。这个接口是可编程的，也被称为应用程序和网络之间的**应用程序编程接口（API）**。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对运输层的控制仅限于：**选择运输层协议**和**设定一些运输层参数**。

在这里只是为了引出套接字的概念，具体如果进行进程通信的，请看[第三章 运输层](https://aadonkeyz.com/posts/f043d83e/)。

# 应用层协议作用

{% note info %}
应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是定义了：
- 交换的报文类型，例如请求报文和响应报文。
- 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。
- 字段的语义，即这些字段中包含的信息的含义。
- 一个进程何时以及如何发送报文，对报文进行响应的规则。
{% endnote %}

# Web和HTTP

## HTTP概况

HTTP全名为超文本传输协议（HyperText Transfer Protocol），它由两个程序实现：一个是客户程序和一个服务程序。HTTP定义了客户想服务器请求数据的方式，以及服务器想客户传送数据的方式。

HTTP使用TCP作为它的支撑运输协议，HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该客户和服务器进行就可以通过套接字接口访问TCP。TCP为HTTP提供可靠的数据传输服务，从这里也能看出分层体系结构最大的有点，即HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节，因为那是TCP以及协议栈较底层协议的工作。

注意到下列现象很重要：服务器向客户发送被请求的数据，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短的几秒钟内两次请求同一个数据，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个**无状态协议**。

## 非持续连接和持续连接

在许多因特网应用程序中，客户和服务器在一个相当长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应。依据应用程序以及该应用程序的使用方式，这一系列请求可以以规则的间隔周期性地或间断性地一个接一个发出。当这种客户-服务器的交互式是经TCP进行的，应用程序的研制者就需要做一个重要决定，即每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送呢？采用前一种方法，该应用程序被称为使用**非持续连接**；采用后一种方法，该应用程序被称为使用**持续连接**。

{% note info %}
相比于持续连接，非持续连接有如下缺点：
- 客户和服务器中都要分配TCP的缓冲区和保持TCP变量。
- 多个请求/响应对会耗费更长的时间。
{% endnote %}

## HTTP请求报文

下面提供了一个典型的HTTP请求报文：

```txt
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

首先，我们看到该报文是用普通的ASCII文本书写的，这样有一定计算机只是的人都能够阅读它。其次，我们看到该报文由5行组成，每行由一个回车和换行符结束。最后一行再附加一个回车换行符。虽然这个特定的报文仅有5行，但一个请求报文能够具有更多的行或者至少为一行。

HTTP请求报文的第一行叫做**请求行**，其后继的行叫做**首部行**。

请求行有3个字段：**方法字段**、**URL字段**和**HTTP版本字段**。方法字段可以取几种不同的值，包括`GET`、`POST`、`HEAD`、`PUT`、`DELETE`等。

首部行的`Host: www.someschool.edu`指明了对象所在的主机。你也许认为该首部行是不必要的，因为在该主机中已经有一条TCP连接存在了，但是后面会介绍，该首部行提供的信息是Web代理告诉缓存所要求的。通过包含`Connection: close`首部行，告诉服务器不希望麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条TCP连接。`User-agent`首部行用来指明用户代理，即向服务器发送请求的浏览器类型。`Accept-language`首部行表示用户想要得到该对象的法语版本。

看过一个例子之后，我们在来看下图展示的请求报文通过格式。你可能已经注意到了在首部行（和附加的回车和换行）后有一个“实体主体”。使用`GET`方法时实体主体为空，而使用`POST`方法时才使用该实体主体。

![HTTP请求报文通用格式](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.png)

## HTTP响应报文

下面我们提供了一条典型的HTTP响应报文。该响应报文可以是对刚刚讨论的例子中请求报文的响应。

```txt
HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3(CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Connect-Length: 6821
Connect-Type: text/html

(data data data data data ...)
```

它有三个部分：一个初始**状态行**、6个**首部行**和**实体主体**。状态行有3个字段：**协议版本字段**、**状态码字段**和**状态信息字段**。首部行字段是一些基础信息，这里就不一一介绍了。实体主体部分是报文的主要部分，即它包含了所请求的对象本身。

响应报文的通用格式如下图所示。

![HTTP响应报文通用格式](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.png)

## cookie

前面提到了HTTP服务器是无状态的。这简化了服务器的设计，并且允许工程师们去开发可以同时处理数以千计的TCP连接的高性能Web服务器。然后一个Web站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP使用了cookie。

这里就不详细介绍了，cookie的原理展示在下图中。

![cookie原理](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/cookie%E5%8E%9F%E7%90%86.png)

# DNS

## DNS提供的服务

因特网的主机有多种标识方式，其中一种就是用它的**主机名**，如cnn.com、www.yahoo.com等，这些名字便于记忆也乐于被人们接收。然而，主机名几乎没有提供（即使有也很少）关于主机在因特网中的文职信息。况且，因为主机名可能由不定长的字母数字组成，路由器难以处理。由于这些原因，主机也可以使用所谓**IP地址**进行标识。

为了折衷这些不同的偏好，我们需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统（Domain Name System， DNS）的主要任务。

DNS也是应用层的协议，它运行在UDP之上，通常是由其他应用层协议所使用，包括HTTP、SMTP和FTP，将用户提供的主机名解析为IP地址。举一个例子，考虑当某个用户主机上的一个浏览器（即一个HTTP客户）请求URL www.someschool.edu/index.html页面时会发生什么现象。为了使用户的主机能够将一个HTTP请求报文发送到Web服务器www.someschool.edu，该用户主机必须获得www.someschool.edu的IP地址。其做法如下：

{% note info %}
1. 同一台用户主机上运行这DNS应用的客户端。
2. 浏览器从上述URL中抽取出主机名www.someschool.edu，并将这台主机名传给DNS应用的客户端。
3. DNS客户向DNS服务器发送一个包含主机名的请求。
4. DNS客户最终会收到一份回答报文，其中含有对应该主机名的IP地址。
5. 一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。
{% endnote %}

除了进行主机名到IP地址的转换之外，DNS还提供一些重要的服务：
{% note info %}
- **主机别名**：有着复杂主机名的主机能拥有一个或者多个别名。例如，一台名为relay1.west-coast.enterprise.com的主机，可能还有两个别名为enterprise.com和www.enterprise.com。在这种情况下，relay1.west-coast.enterprise.com也称为**规范主机名**。
- **邮件服务器别名**：顾名思义，不介绍了。
- **负载分配**：DNS也用于在冗余的服务器之间进行敷在分配。繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址。DNS数据库中存储着这些IP地址集合，当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常总是向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载。
{% endnote %}

## DNS服务器

DNS的一种简单设计是在因特网上只是用一个DNS服务器，该服务器包含所有的映射。这种设计虽然简单，但是有如下致命缺点

{% note info %}
- **单点故障**：如果该DNS服务器崩溃，整个因特网随之瘫痪！
- **通信容量**：单个DNS服务器不得不处理所有的DNS查询。
- **远距离的集中式数据库**：单个DNS服务器不可能“邻近”所有查询客户，所以那些来自远方的查询会有严重的时延。
- **维护**：单个DNS服务器将不得不为所有的因特网主机保留记录。这不仅将使这个中央数据库非常庞大，而且它还不得不为解决每个新添加的主机而频繁更新。
{% endnote %}

正是由于上述原因，所以DNS服务器是以层次方式组织，并且分布在全世界范围内。大致说来，有三种类型的DNS服务器

{% note info %}
- **根DNS服务器**：根服务器中记录着TLD DNS服务器的主机名与IP之间的映射。在全世界，共有13个根DNS服务器的IP，每个IP下是一个由多台根DNS服务器组成的的服务器网络。
- **顶级域（Top-Level Domain, TLD）NDS服务器**：这些服务器负责维护顶级域名如`.com`、`.org`、`.net`等的IP映射。
- **权威DNS服务器**：权威DNS服务器是记录特定域名的DNS服务器，用于特定域名本身的管理（增加、修改、删除等）。权威DNS服务器只对自己所拥有的域名进行域名解析，对于不是自己的域名则拒绝访问。

举一个例子，`.com`TLD DNS服务器是`abc.com`权威DNS服务器的权威DNS服务器。
{% endnote %}

除了上述三种类型的DNS服务器外，还有一类重要的DNS，称为**本地DNS服务器**。每个ISP（如一个大学、一个公司或一个居民区）都有一台本地DNS服务器。当主机与某个ISP连接时，该ISP提供一台主机的IP，该主机具有一台或多台其本地DNS服务器的IP（通过DHCP）。主机的本地DNS服务器通常“邻近”本主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。

下图大概展示了DNS的查询过程：

![DNS查询过程](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png)

上面的例子是基于TLD服务器知道用于主机的权威DNS服务器的IP的前提进行的。在这个例子中，从`cis.poly.edu`到`dns.poly.edu`发出的查询是**递归查询**，而后继的3个查询是**迭代查询**。

{% note info %}
- **递归查询**：DNS服务器接收到客户机请求后，回复一个明确的IP。
- **迭代查询**：DNS服务器接收到客户机请求后，回复另一个DNS服务器的IP，让它去那里查询。
{% endnote %}

为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。DNS缓存的原理非常简单。在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将该回答中的信息缓存在本地存储器中。但是由于主机和主机名与IP间的映射并不是永久的，DNS服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。

## DNS记录和报文

共同实现DNS分布式数据库的所有DNS服务器存储了**资源记录（Resource Record, RR）**，RR提供了主机名到IP之间的映射。每个DNS回答报文包含了一条或多条资源记录。资源记录是一个四元组，格式为`(Name, Value, Type, TTL)`。`TTL`是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。在下面给出的记录例子中，我们忽略掉`TTL`字段。`Name`和`Value`的值取决于`Type`：

{% note info %}
- 如果`Type = A`，则`Name`是主机名，`Value`是该主机名对应的IP。因此，一条类型为A的资源记录提供了标准的主机名到IP映射。例如`(ralay1.bar.foo.com, 145.37.93.126, A)`就是一条类型A记录。
- 如果`Type = NS`，则`Name`是一个域（如`foo.com`），而`Value`是个知道如何获得该域中主机IP的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。例如`(foo.com, dns.com, NS)`就是一条类型为NS的记录。
- 如果`Type = CNAME`，则`Value`是别名为`Name`的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名。例如`(foo.com, relay1.bar.foo.com, CNAME)`就是一条CNAME类型的记录。
- 如果`Type = MX`，则`Value`是个别名为`Name`的邮件服务器的规范主机名。例如`(foo.com, mail.bar.foo.com, MX)`就是一条MX类型的记录。
{% endnote %}

如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含该主机名的类型A记录（即使该DNS服务器不是其权威DNS服务器，它也可能在缓存中包含一条类型A记录）。入股服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应于包含主机名的域；它还将包括一条类型A记录，该记录提供了在NS记录的`Value`字段中的DNS服务器的IP。举例来说，假设一台edu TLD服务器不是主机`gaia.cs.umass.edu`的权威服务器，则该服务器将包含一条包括主机`cs.umass.edu`的域记录，如`(umass.edu, dns.umass.edu, NS)`；该edu TLD服务器还将包含一条类型A记录，如`(dns.umass.com, 128.119.40.111, A)`，该记录将名字`dns.umass.com`映射为一个IP。

DNS只有两种报文，并且，查询和回答报文有着相同的格式，如下所示：

![DNS报文格式](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E5%B1%82/DNS%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png)

{% note info %}
- **标识符字段**：该字段是一个16比特的数，用于标识该查询。这个标识符字段会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。
- **标志字段**：标志字段中还有若干标志。
    - **查询/回答标志**：`0`表示是查询报文，`1`表示是回答报文。
    - **权威标志**：当某DNS服务器是所请求名字的权威DNS服务器时，1比特的“权威的”标志位被置在回答报文中。
    - **希望递归标志**：如果客户在该DNS服务器没有某记录时，希望它执行递归查询时，将设置1比特的“希望递归”标志位。
    - **递归可用标志**：1比特的“递归可用”标志位用于表示DNS服务器是否支持递归查询。
- **问题字段**：该字段包含着正在进行的查询信息。包括：`Name`和`Type`。
- **回答字段**：顾名思义。
- **权威字段**：包含了其他权威服务器的记录。
{% endnote %}