---
title: 第二章 字符串与正则表达式
categories:
    - JavaScript
    - 《深入理解ES6》
abbrlink: 91aa670b
date: 2019-03-25 13:17:19
---

# 字符串的改动

## 识别子字符串的方法

ES6新增了三个方法：

{% note info %}
- **includes()**：在给定文本存在于字符串中的任意位置时返回`true`，否则返回`false`；
- **startsWith()**：在给定文本出现在字符串起始处时返回`true`，否则返回`false`；
- **endsWith()**：在给定文本出现在字符串结尾处时返回`true`，否则返回`false`。
{% endnote %}

每个方法都接收两个参数：需要搜索的文本和可选的搜索起始位置索引。

当提供了第二个参数时，`includes()`和`startsWith()`方法会从该索引位置开始尝试匹配；而`endsWith()`方法会用字符串长度减去该参数，以此为起点开始尝试匹配。

当第二个参数未提供时，`includes()`和`startsWith()`方法会从字符串起始处开始尝试匹配；而`endsWith()`方法则从尾部开始。

**它们三个方法都是从左向右进行匹配！**

```js
var msg = 'hello world!'

console.log(msg.startsWith('hello'))    // true
console.log(msg.endsWith('!'))          // true
console.log(msg.includes('o'))          // true

console.log(msg.startsWith('o'))        // false
console.log(msg.endsWith('world!'))     // true
console.log(msg.includes('x'))          // false

console.log(msg.startsWith('o', 4))     // true
console.log(msg.endsWith('o', 8))       // true
console.log(msg.includes('o', 8))       // false
```

## repeat()方法

该方法接收一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。

```js
console.log('x'.repeat(3))          // xxx
console.log('hello'.repeat(2))      // hellohello
console.log('abc'.repeat(4))        // abcabcabcabc
```

# 正则表达式的改动

## 正则表达式y标志

`y`标志影响正则表达式搜索时的粘连（sticky）属性，它表示从正则表达式的`lastIndex`属性值的位置开始检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索并返回`null`。

```js
var text = 'hello1 hello2 hello3',
    pattern = /hello\d\s?/,
    globalPattern = /hello\d\s?/g,
    stickyPattern = /hello\d\s?/y

var result = pattern.exec(text),
    globalResult = globalPattern.exec(text),
    stickyResult = stickyPattern.exec(text)

console.log(result[0])                  // hello1
console.log(globalResult[0])            // hello1
console.log(stickyResult[0])            // hello1

console.log(pattern.lastIndex)          // 0
console.log(globalPattern.lastIndex)    // 7
console.log(stickyPattern.lastIndex)    // 7

pattern.lastIndex = 1
globalPattern.lastIndex = 1
stickyPattern.lastIndex = 1

result = pattern.exec(text)
globalResult = globalPattern.exec(text)
stickyResult = stickyPattern.exec(text)

console.log(result[0])                  // hello1
console.log(globalResult[0])            // hello2
console.log(stickyResult[0])            // Uncaught TypeError: Cannot read property '0' of null
```

有两个关于粘连标志的微妙细节需要牢记：

{% note info %}
- 只有调用正则表达式对象上的方法（例如`exec()`与`test()`方法），`lastIndex`属性才会生效。而将正则表达式作为参数传递给字符串上的方法（例如`match()`方法），并不会体现粘连特性；
- 当使用`^`字符来匹配字符串的起始处时，粘连的正则表达式只会匹配字符串的起始处（或者在多行模式下匹配行首）。当`lastIndex`为0时，`^`不会让粘连的正则表达式与非粘连的有任何区别；而当`lastIndex`不为0时，粘连的正则表达式永远不会匹配成功。
{% endnote %}

可以使用如下方法来检测粘连标志是否被支持：

```js
function hasRegExpY () {
    try {
        var pattern = new RegExp('.', 'y')
        return true
    } catch (ex) {
        return false
    }
}
```

## 复制正则表达式

在ES5中，你可以将正则表达式传递给`RegExp`构造器来复制它，就像这样：

```js
var re1 = /ab/i,
    re2 = new RegExp(re1)
```

`re2`变量只是`re1`的一个副本。但如果你向`RegExp`构造器传递了第二个参数，即正则表达式的标志，那么该代码就无法正常工作，正如该范例：

```js
var re1 = /ab/i,
    // ES5中会抛出错误，ES6中可用
    re2 = new RegExp(re1, 'g')
```

如果你在ES5中运行这段代码，那么你会收到一条错误信息，表示在第一个参数已经是正则表达式的情况下不能再使用第二个参数。ES6则修改了这个行为，允许使用第二个参数，并且让它覆盖第一个参数中的标志。例如：

```js
var re1 = /ab/i,
    // ES5中会抛出错误，ES6中可用
    re2 = new RegExp(re1, 'g')

console.log(re1.toString())     // /ab/i
console.log(re2.toString())     // /ab/g

console.log(re1.test('ab'))     // true
console.log(re2.test('ab'))     // true

console.log(re1.test('AB'))     // true
console.log(re2.test('AB'))     // false
```

## flags属性

```js
var re = /ab/g

console.log(re.source)      // ab
console.log(re.flags)       // g
```

# 模板字面量

## 基本语法

模板字面量的最简单语法，是使用反引号（`）来包裹普通字符串，而不是用双引号或单引号。若你想在字符串中包含反引号，只需要使用反斜杠（\）转义即可。

```js
let message = `hello \` world`
console.log(message)        // hello ` world
```

## 多行字符串

ES6的模板字面量使多行字符串更易创建，因为它不需要特殊的语法。只需在想要的位置包含换行即可，而且它会显示在结果中。

```js
let message = `Multiline
string`

console.log(message)            // Multiline
                                // string
console.log(message.length)     // 16
```

反斜杠之内的所有空白符都是字符串的一部分，因此需要留意缩进。

```js
let message = `Multiline
              string`

console.log(message)            // Multiline
                                //              string
console.log(message.length)     // 30
```

如果让多行文本保持合适的缩进对你来说很重要，请考虑将多行模板字面量的第一行空置并在此后进行缩进，如下所示：

```js
let html = `
<div>
    <h1>Title</h1>
</div>
`.trim()
```

## 制造替换位

此时模板字面量看上去仅仅是普通JavaScript字符串的升级版，但二者之间真正的区别在于前置的“替换位”。替换位允许你将任何有效的JavaScript表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分。

替换位由起始的`${`与结束的`}`来界定，之间允许放入任意的JavaScript表达式。例如：

```js
var name = 'Nicholas',
    message = `hello, ${name}.`
console.log(message)        // hello, Nicholas.

var count = 10,
    price = 0.25,
    message = `${count} items cost $${(count * price).toFixed(2)}.`
console.log(message)        // 10 items cost $2.50.

var name = 'Nicholas',
    message = `hello, ${
        `my name is ${name}`
    }.`
console.log(message)        // hello, my name is Nicholas.
```

## 标签化模板

一个标签仅是一个函数，只不过这个函数的调用形式有些特别：``tagName`模板字面量数据` ``

标签函数会将调用时接收的模板字面量数据中的非替换位提取出来保存为一个数组，这个数组将作为标签函数的第一个参数；数据中的每个替换位的解释值都将作为标签函数的参数传递进来。为了方便处理，一般在定义标签函数时使用[**剩余参数**](http://aadonkeyz.com/posts/9595c646/#剩余参数)形式。

```js
function passthru (literals, ...substitutions) {
    console.log(literals)           // ["", " items cost $", ""]
    console.log(substitutions)      // [10, "2.50"]
    return '返回啥都行'
}

var count = 10,
    price = 0.25,
    message = passthru`${count} items cost $${(count * price).toFixed(2)}`
```

注意观察上面的例子，**`literals`数组的第一个和最后一个元素均为空字符串，说明标签函数在对传入的模板字面量进行处理时，总是以非替换位形式的字符串作为数据的开始和结尾；如果模板字面量实际上是以替换位作为开始和结尾，那么会自动在开始和结尾处添加上空字符串！所以`literals`的长度总是比`substitutions`的长度多1**。

模板标签也能访问字符串的原始信息，主要指的是可以访问字符在转义之前的形式。获取原始字符串值的最简单方式是使用内置的`String.raw()`标签。不过我按照书中例子试验的时候，关于原始形式这里有些出入，详细的就不介绍了。