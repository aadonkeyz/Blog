---
title: 第三章 运输层
categories:
    - 计算机网络
    - 《计算机网络-自顶向下方法》
abbrlink: f043d83e
date: 2019-06-30 01:06:41
mathjax: true
---


# 应、运、网的配合

运输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**功能。从应用程序的角度看，通过逻辑通信，运行在不同进程的主机好想直接相连一样，而实际上这些主机也许位于地球的两侧，中间通过很多路由器及多种不同类型的链路相连。同理，网络层也为不同主机的运输层提供了逻辑通信。

运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层**报文段**。实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这这些报文段传递给网络层，网络层将其封装为网络层分组（即数据报）并向目的地发送。

注意到下列事实是重要的：网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用。

# 运输层概述

因特网为应用层提供了两种截然不同的可用运输层协议。这些协议一种是UDP（用户数据报协议），它为调用它的应用程序提供了一种不可靠、无连接的服务。另一种是TCP（传输控制协议），它为调用它的应用程序提供了一种可靠的、面向连接的服务。

在对UDP和TCP进行简要介绍之前，简单介绍一下因特网的网路层。因特网网络层协议又一个名字叫IP，即网际协议。IP为主机之间提供了逻辑通信。IP会尽它最大的努力在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为**不可靠服务**。再次还要指出的是，每台主机至少有一个网络层地址，即所谓的IP地址。

在对IP服务模型有了初步了解后，我们总结一下UDP和TCP所提供的服务模型。UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为**运输层的多路复用**与**多路分解**。UDP和TCP还可以通过在其报文段首部中包括差错检查字段而提供完整性检查。进程到进程的数据交付和差错检查是两中最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。特别是，与IP一样，UDP也是一种不可靠的服务，即不能保证一个进程所发送的数据能够完整无缺地到达目的进程。

另一方面，TCP为应用程序提供了几种附加服务。首先，它提供**可靠数据传输**。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程。这样，TCP就将两个端系统间的不可靠IP服务转换成了一种进程间的可靠数据传输服务。TCP还提供**拥塞控制**。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务，这是一种带来通用好处的服务。不太严格地说，TCP拥塞控制防止任何一条TCP连接用过多流量来淹没没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。这可以通过调节TCP连接的发送端发送进网络的流量速率来做到。在另一方面，UDP流量是不可调节的。使用UDP传输的应用程序可以根据其需要以其愿意的任何速率发送数据。

# 多路复用与多路分解

## 基础概念

在目的主机，运输层从紧邻其下的网络层接收报文段。运输层负责将这些报文段中的数据交付给在主机上运行的适当应用程序进程。我们来看一个例子，假定你正坐在计算机前下载Web页面，同时还在运行一个FTP会话和两个Telnet会话。这样你就有4个网络应用进程在运行。当你的计算机中运输层从底层的网络层接受数据时，它需要将所接收到的数据定向到这4个进程中的一个。

回想《计算机网络 自顶向下方法》第二章的内容，一个进程有一个或多个**套接字**，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，下图中，在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。由于在任意时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式取决于它是UDP还是TCP套接字，我们将很快对它们进行讨论。

![多路复用与多路分解](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png)

现在我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字。为此目的，每个运输层报文段中具有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为**多路分解**。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于多路分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为**多路复用**。

既然我们理解了运输层多路复用与多路分解的作用，那就再来看看在主机中它们实际是怎样工作的。通过上述讨论，我们知道运输层多路复用的两个要求：
{% note info %}
- 套接字要有唯一标识符。
- 每个报文段要有特殊字段用来指示该报文段所要交付到的套接字。
{% endnote %}

下面的图片展示了报文段的格式，可以看出，报文段中的特殊字段一定包含**源端口号字段**和**目的端口号字段**。除此之外，UDP报文段和TCP报文段还有其他的一些字段。端口号是一个16比特的数，其大小在0～65535之间。0～1023范围的端口号称为**周知端口号**，是受限制的，这是指它们保留给诸如HTTP和FTP之类的周知应用层协议来使用。

![报文段格式](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F.png)

现在应该清楚运输层是怎样能够实现分解服务的了：在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那样，UDP基本上是这样做的。然后，TCP中的多路复用与多路分解更为复杂。

## UDP实现

假定在主机A中的一个进程具有UDP端口19157，它要发送一个应用程序数据块给位于主机B中的另一进程，该进程具有UDP端口46428。主机A中的运输层创建一个运输层报文段，其中包括应用程序数据、源端口号（19157）、目的端口号（46428）和两个其他值（将在后面讨论，它对当前的讨论不重要）。然后，运输层将得到的报文段传递到网络层。网络层将该报文段封装到一个IP数据报中，并尽力而为地将报文段交付给接收主机。

如果该报文段到达接收主机B，接收主机运输层就检查该报文段中的目的端口号（46428），并将该报文段交付给端口号46428所标识的套接字。值得注意的是，主机B能够运行多个进程，每个进程都有自己的UDP套接字及相应的端口号。当从网络到达UDP报文段时，主机B通过检查该报文段中的目的端口号，将每个报文段定向（分解）到相应的套接字。

注意到下述事实是重要的：**一个UDP套接字是由一个二元祖来全面标识的，该二元祖包含一个目的IP地址和一个目的端口号。因此，如果两个UDP报文段有不同的源IP地址/源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的套接字被定向到相同的目的进程。**

{% note warning %}
套接字的标识符中IP地址是由网络层提供的，而不是运输层。
{% endnote %}

你也许想知道，源端口号的用途是什么呢？下图中，在A到B的报文段中，源端口号用作“返回地址”的一部分，即当B需要回发一个报文段给A时，B到A的报文段中目的端口号便从A到B的报文段中源端口号中取值（完整的返回地址是A的IP地址和源端口号）。

![UDP的多路复用与多路分解](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png)

## TCP实现

TCP套接字和UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识的。这样，当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向（分解）到相应的套接字。特别与UDP不同的是，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。

![TCP多路复用与多路分解](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png)

上图中，主机C向服务器B发起了两个HTTP会话，主机A向服务器B发起一个HTTP会话。主机A要主机C及服务器B都有自己唯一的IP地址，它们分别是A、B、C。主机C为其两个HTTP连接分配了两个不同的源端口号（26145和7532）。因为主机A选择愿端口号时与主机C互不相干，因此它也可以将源端口号26145分配给其HTTP连接。但这不是问题，即服务器B仍然能够正确地分解这两个具有相同源端口号的连接，因为这两条连接有不同的源IP地址。

## Web服务器与TCP

如果客户与服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换HTTP报文。然而，如果客户与服务器使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭，这种套接字的频繁创建和关闭会严重地影响一个繁忙的Web服务器的性能。

# UDP

由[RFC 768]定义的UDP只是做了运输协议能够做的最少的工作。除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。实际上，如果应用程序开发人员选择UDP而不是TCP，则该应用程序差不多就是直接与IP打交道。UDP从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端括号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。网络层将该运输层报文段封装到一个IP数据报中，然后尽力而为地尝试将此报文段交付给接收主机。如果该报文段到达接收主机，UDP使用目的端口号将报文段中的数据交付给正确的应用进程。值得注意的是，使用UDP时，你发送报文段之前，发送方和接收方的运输层实体之间没有握手。整因为如此，**UDP被称为是无连接的**。

DNS是一个通常使用UDP的应用层协议的例子。当一台主机中的DNS应用程序想要进行一次查询时，它构造了一个DNS查询报文并将其交给UDP。无需执行任何与运行在目的端系统中的UDP实体之间的握手，主机端的UDP为此报文添加首部字段，然后将形成的报文段交给网络层。网络层将此UDP报文段封装进一个IP数据报中，然后将其发送给一个DNS服务器。在查询主机中的DNS应用程序则等待对该查询的响应。如果它没有收到响应（可能是由于底层网络丢失查询或响应），则要么试图向另一个DNS服务器发送该查询，要么通知调用的应用程序它不能获得响应。

{% note info %}
现在你也许想知道，为什么应用开发人员宁愿在UDP之上构建应用，而不选择在TCP上构建应用？原因主要有一下几点：
- 关于何时、发送什么数据的应用层控制更为精细。
- 无需建立连接。
- 无需维护连接状态。
- 分组首部开销小。
{% endnote %}

UDP首部只有4个字段，每个字段由两个字节组成。UDP报文段的结构如图所示。

![UDP报文段的结构](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E7%BB%93%E6%9E%84.png)

长度字段指示了在UDP报文段中的字节数（首部+数据）。而检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。

# 可靠数据传输原理

![可靠数据传输的框架](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E6%A1%86%E6%9E%B6.png)

上图说明了我们学习可靠数据传输的框架。为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会收到损坏或丢失，而且所有数据都是按照其发送顺序进行交付的。这恰好就是TCP向调用它的因特网应用所提供的服务模型。

实现这种服务抽象是**可靠数据传输协议（reliable data transfer protocol）**的责任。由于可靠数据传输协议的下层协议也许是不可靠的，因此这是一项困难的任务。

在讨论可靠数据传输时，我们将使用术语“分组”而不是运输层的“报文段”，因为本节内容适用于一般的计算机网络，而不只是用于因特网运输层，所以这时采用通用术语“分组”更为合适。

在本节，我们仅考虑**单向数据传输**的情况，可靠的**双向数据传输**（即全双工数据传输）情况从概念上讲不会更难，但解释起来更为单调乏味。

## 构造可靠数据传输协议

### 经完全可靠信道的可靠数据传输：rdt1.0

首先，我们考虑最简单的情况，即底层信道是完全可靠的。我们称该协议为rdt1.0，该协议本身是简单的。下图显示了rdt1.0发送方和接收方的**有限状态机（Finite-State Machine, FSM）**的定义。**引起状态变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果对一个事件没有动作，或没有就事件发生而采取一个动作，我们将在横线上方或下方使用符号Λ，已分别明确地表示缺少动作或事件。FSM的初始状态用虚线表示。**

![rdt1.0](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt1.0.png)

### 经具有比特差错信道的可靠数据传输：rdt2.0

底层信道更为实际的模型是分组中的比特可能受损。在分组的传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中。我们眼下还将继续假定所有发送的分组（虽然有些比特可能受损）将按其发送的顺序被接收。

在研发一种经这种信道进行可靠通信的协议之前，首先考虑一下人们会怎样处理这类情形。考虑一下你自己是怎样通过电话口述一条长消息的。在通常情况下，报文接收者在听到、理解并记下每句话后可能会说“OK”。如果报文接收者听到一句含糊不清的话时，他可能要求你重复刚才那句话。这种口述报文协议使用了**肯定确认（positive acknowledgement）**与**否定确认（negative acknowledgement）**。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为**自动重传请求（Automatic Repeat reQuest, ARQ）协议。**

{% note info %}
基本上，ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况
- 差错检测。
- 接收方反馈。
- 重传。
{% endnote %}

下图展示了rdt2.0的FSM。

![rdt2.0](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.0.png)

{% note warning %}
当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多的数据。这就是说，`rdt_send()`事件不可能出现。仅当接收到ACK并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt2.0这样的协议被称为**停等**协议。
{% endnote %}

rdt2.0协议看起来似乎可以运行了，但遗憾的是，它存在一个致命的缺陷。尤其是我们没有考虑到ACK或NAK分组受损的可能性！

当发送方收到含糊不清的ACK或NAK分组时，只需重传当前数据分组即可。然而，这种方法在发送方到接收方的信道中引入了**冗余分组**。解决冗余分组的方法是在数据分组中添加一个新字段，让发送方对其数据分组进行编号（从0开始），即将发送数据分组的序号放在该字段。于是，接收方只需要检查序号即可确认收到的分组是否为一次重传。因为目前我们假定信道不丢分组，所以无需对ACK和NAK本身进行编号。

{% note warning %}
分组编号只在0和1之间交替。
{% endnote %}

下面给出rdt2.1的FSM描述。

![rdt2.1发送方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.1%E5%8F%91%E9%80%81%E6%96%B9.png)

![rdt2.1接收方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.1%E6%8E%A5%E6%94%B6%E6%96%B9.png)

呃，除此之外，还有rdt2.2版本的FSM，它跟rdt2.1的FSM的区别在于去掉了NAK，而在ACK中显示指出分组编号。如果发送方接收到的ACK分组编号与刚刚发送的分组编号匹配则OK，否则就重传。FSM图如下所示。

![rdt2.2发送方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.2%E5%8F%91%E9%80%81%E6%96%B9.png)

![rdt2.2接收方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.2%E6%8E%A5%E6%94%B6%E6%96%B9.png)


### 经具有比特差错的丢包信道的可靠数据传输：rdt3.0

现在假定除了比特受损外，底层信道还会丢包。协议现在必须处理另外两个关注的问题：怎样检测丢包以及发生丢包后该做些什么。在rdt2.2中已经研发的技术，如使用检验和、序号、ACK分组和重传等，使我们能给出后一个问题的答案。为解决第一个关注的问题，还需增加一种新的协议机制。

这里，我们让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对该分组的ACK发生了丢失。在这两种情况下，发送方都收不到应当到来的接收方的响应。如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可。你应该相信该协议确实有效。

但是发送方需要等待多久才能确定已丢失了某些东西呢？很明显发送方至少需要等待这样长的时间：即发送方与接收方之间的一个往返时延加上接收方处理一个分组所需的时间。在很多网络中，最坏情况下的最大时延是很难估算的，确定的因素非常少。此外，理想的协议应尽可能块地从丢包中恢复出来。等待一个最坏情况的时延可能意味着需要等待一段较长的时间，直到启动差错恢复为止。因此实践中采取的方法是发送方明智地选择一个时间值，以判定可能发生了丢包。如果在这个时间内没有收到ACK，则重传该分组。注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其ACK都没有丢失。这就在发送方到接收方的信道中引入了**冗余数据分组**的可能性。幸运的事，rdt2.2协议已经有足够的功能（即序号）来处理冗余分组情况。

从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失，还是一个ACK丢失，或者只是该分组或ACK过度延时。在所有这些情况下，动作是同样的：重传。为了实现基于时间的重传机制，需要一个**倒计数定时器**，在一个给定的时间量过期后，可中断发送方。因此，发送方需要能做到：

{% note info %}
1. 每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器。
2. 响应定时器中断。
3. 终止定时器。
{% endnote %}

rdt3.0为最终的版本，且由于分组序号在0和1之间交替，因此也叫它**比特交替协议**。

rdt3.0相比rdt2.2只在发送方有所改动，接收方无变化。所以下面只给出rdt3.0的发送方FSM。

![rdt3.0发送方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt3.0%E5%8F%91%E9%80%81%E6%96%B9.png)

看完FSM，你可以看看下面的比特交替协议可能出现的4种情况（书中给的图有错误）。

![比特交替协议4种情况](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%AF%94%E7%89%B9%E4%BA%A4%E6%9B%BF%E5%8D%8F%E8%AE%AE4%E7%A7%8D%E6%83%85%E5%86%B5.png)

## 流水线可靠数据传输协议

rdt3.0是一个功能正确的协议，但并非人人都对它的性能满意，特别是在今天的高速网络中更是如此。rdt3.0性能问题的核心在于它是一个停等协议。

解决这种特殊的性能问题的一个简单方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。这种技术被称为**流水线**。流水线技术对可靠数据传输协议可带来如下影响：

{% note info %}
- 必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中未确认的报文。
- 协议的发送方和接收方两端也许必须缓存多个分组。发送方最低限度应当能缓存那些已发送但没有确认的分组。接收方或许也需要缓存那些已正确接收的分组。
- 所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：**回退N步（Go-Back-N）**和**选择重传（Selective Repeat, SR）**。
{% endnote %}

![停等协议和流水线协议](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE.png)

![停等操作和流水线操作](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%81%9C%E7%AD%89%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%93%8D%E4%BD%9C.png)

### 回退N步

在**回退N步（GBN）协议**中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限与在流水线中未确认的分组数不能超过某个最大允许数N。下图显示了发送方看到的GBN协议的序号范围。如果我们将基序号（base）定义为最早的未确认分组的序号，将下一个序号（nextseqnum）定义为最小的未使用序号（即下一个待发分组的序号），则可将序号范围分割成4段。在**[0, base - 1]**段内的序号对应于已经发送并被确认的分组。**[base, nextseqnum - 1]**段内对应已经发送但未被确认的分组。**[nextseqnum, base + N -1]**段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。最后，大于或等于**base + N**的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为base的分组）已得到确认为止。

![GBN序号范围](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/GBN%E5%BA%8F%E5%8F%B7%E8%8C%83%E5%9B%B4.png)

图中**[base, base + N -1]**序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向前移动。因此，N常被称为**窗口长度**，GBN协议也常被称为**滑动窗口协议**。

在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是k，则该序号的范围是**[0, $2^k-1$]**。在一个有限的序号范围内，所有涉及序号的运算必须使用模$2^k$运算。（即序号空间可被看作是一个长度为$2^k$的环，其中序号$2^k-1$紧接着序号0）。

{% note info %}
GBN发送方必须响应三种类型的事件：
- **上层的调用**。当上层调用`rdt_send()`时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过一会再试。在实际实现中，发送方更可能缓存（并不立刻发送）这些数据，或者使用同步机制（如一个信号量或标志）允许上层在仅当窗口不满时才调用`rdt_send()`。
- **收到一个ACK**。在GBN协议中，对序号为n的分组的确认采取**累积确认**的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。
- **超时事件**。协议的名字“回退N步”来源于出现丢失和时延过长分组时发送方的行为。就像在停等协议中那样，定时器将再次用于恢复数据或确认分组的丢失。如果出现超时，发送方重传所有已发送但还未被确认过的分组。发送方仅使用一个定时器，它可被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个ACK，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已发送但未被确认的分组，该定时器被终止。

---
在GBN中，接收方的动作也很简单。如果一个序号为n的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为n-1的分组），则接收方为分组n发送一个ACK，并将该分组中的数据部分交付给上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。

在GBN协议中，接收方丢弃所有失序分组。尽管丢弃一个正确接收（但失序）的分组有点愚蠢和浪费，但这样做是有理由的。前面讲过，接收方必须按序将数据交付给上层。假定现在期望接收分组n，而分组n+1却到了。因为数据必须按序交付，接收方可能缓存（保存）分组n+1，然后，在它收到并交付分组n后，再将该分组交付到上层。然而，如果分组n丢失，则该分组已分组n+1最后总将在发送方根据GBN重传规则而被重传。因此，接收方只需丢弃分组n+1即可。这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。因此，虽然发送方必须维护窗口的上下边界及nextseqnum在该窗口中的位置，但是接收方需要维护的唯一信息就是下一个按序接收的分组的序号。该值保存在expectedseqnum变量中。当然，丢失一个正确接收的分组的缺点是随后对该分组的重传也许会丢失或出错，因此甚至需要更多的重传。
{% endnote %}

![GBN发送方的扩展FSM](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/GBN%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E6%89%A9%E5%B1%95FSM.png)

![GBN接收方的扩展FSM](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/GBN%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84%E6%89%A9%E5%B1%95FSM.png)

![运行中的GBN](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84GBN.png)

### 选择重传

GBN协议中当窗口长度和带宽时延都很大时，在流水线中会有很多分组，此时其中单个分组的差错就会引起GBN重传大量分组，许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。

选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。这种个别的、按需的重传要求接收发逐个地确认正确接收的分组。再次用窗口长度N来限制流水线中未完成、未被确认的分组书。然而，与GBN不同的是，发送方已经收到了对窗口中给某些分组的ACK。

下面图中分不清颜色了，不过这都不重要，你只要知道rcv_base在哪里就好了，因为它决定接收方窗口的移动。另外，发送方和接收方的窗口并不总是一致的，下图中的就不一致。

![SR的序号空间](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/SR%E7%9A%84%E5%BA%8F%E5%8F%B7%E7%A9%BA%E9%97%B4.png)

{% note info %}
发送方响应事件：
- **从上层收到数据**。当从上层接收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在GBN中一样，要么将数据缓存，要么将其返回给上层以便以后传输。
- **超时**。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有自己的定时器，因为超时发生后只能发送一个分组。
- **收到ACK**。如果收到ACK，倘若该分组序号在窗口内，则SR发送方将哪个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处（即修改send_base值）。如果窗口移动了并且有序号落在窗口内的为发送分组，则发送这些分组。

---
接收方响应事件：
- **序号在[rcv_base, rcv_base + N - 1]内的分组被正确接收**。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。如果该分组以前没有收到过，则缓存该分组。如果该分组的序号等于rcv_base，则该分组以及以前缓存的序号连续的（起始于rcv_base的）分组交付给上层。然后，rcv_base向前移动到对应的新位置。
- **序号在[rcv_base - N, rcv_base - 1]内的分组被正确接收**。在此情况下，必须产生一个ACK，即使该分组是接收方以前已确认过的分组。这种情况发生在发送方没有成功接收到ACK的时候，如果接收方不重新发送ACK，则发送方将一直重发对应分组，发送方窗口也将永远不能向前移动。
- **其他情况的时候均忽略该分组。**
{% endnote %}

![SR操作](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/SR%E6%93%8D%E4%BD%9C.png)

当我们面对有限序号范围的现实时，发送方和接收方窗口间缺乏同步会产生严重的后果。考虑下面例子中的两种情况，会让接收方分不清最后接收的序号0分组是重传的，还是新发送的。

![SR窗口太大](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/SR%E7%AA%97%E5%8F%A3%E5%A4%AA%E5%A4%A7.png)

{% note info %}
避免这个问题的办法是：**永远保证SR的窗口长度小于或等于序号空间大小的一半。**
{% endnote %}

# TCP

