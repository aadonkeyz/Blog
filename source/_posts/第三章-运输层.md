---
title: 第三章 运输层
categories:
    - 计算机网络
    - 《计算机网络-自顶向下方法》
abbrlink: f043d83e
date: 2019-06-30 01:06:41
mathjax: true
---


# 应、运、网的配合

运输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**功能。从应用程序的角度看，通过逻辑通信，运行在不同进程的主机好想直接相连一样，而实际上这些主机也许位于地球的两侧，中间通过很多路由器及多种不同类型的链路相连。同理，网络层也为不同主机的运输层提供了逻辑通信。

运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层**报文段**。实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这这些报文段传递给网络层，网络层将其封装为网络层分组（即数据报）并向目的地发送。

注意到下列事实是重要的：网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用。

# 运输层概述

因特网为应用层提供了两种截然不同的可用运输层协议。这些协议一种是UDP（用户数据报协议），它为调用它的应用程序提供了一种不可靠、无连接的服务。另一种是TCP（传输控制协议），它为调用它的应用程序提供了一种可靠的、面向连接的服务。

在对UDP和TCP进行简要介绍之前，简单介绍一下因特网的网路层。因特网网络层协议又一个名字叫IP，即网际协议。IP为主机之间提供了逻辑通信。IP会尽它最大的努力在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为**不可靠服务**。再次还要指出的是，每台主机至少有一个网络层地址，即所谓的IP地址。

在对IP服务模型有了初步了解后，我们总结一下UDP和TCP所提供的服务模型。UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为**运输层的多路复用**与**多路分解**。UDP和TCP还可以通过在其报文段首部中包括差错检查字段而提供完整性检查。进程到进程的数据交付和差错检查是两中最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。特别是，与IP一样，UDP也是一种不可靠的服务，即不能保证一个进程所发送的数据能够完整无缺地到达目的进程。

另一方面，TCP为应用程序提供了几种附加服务。首先，它提供**可靠数据传输**。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程。这样，TCP就将两个端系统间的不可靠IP服务转换成了一种进程间的可靠数据传输服务。TCP还提供**拥塞控制**。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务，这是一种带来通用好处的服务。不太严格地说，TCP拥塞控制防止任何一条TCP连接用过多流量来淹没没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。这可以通过调节TCP连接的发送端发送进网络的流量速率来做到。在另一方面，UDP流量是不可调节的。使用UDP传输的应用程序可以根据其需要以其愿意的任何速率发送数据。

# 多路复用与多路分解

## 基础概念

在目的主机，运输层从紧邻其下的网络层接收报文段。运输层负责将这些报文段中的数据交付给在主机上运行的适当应用程序进程。我们来看一个例子，假定你正坐在计算机前下载Web页面，同时还在运行一个FTP会话和两个Telnet会话。这样你就有4个网络应用进程在运行。当你的计算机中运输层从底层的网络层接受数据时，它需要将所接收到的数据定向到这4个进程中的一个。

回想《计算机网络 自顶向下方法》第二章的内容，一个进程有一个或多个**套接字**，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，下图中，在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。由于在任意时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式取决于它是UDP还是TCP套接字，我们将很快对它们进行讨论。

![多路复用与多路分解](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png)

现在我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字。为此目的，每个运输层报文段中具有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为**多路分解**。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于多路分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为**多路复用**。

既然我们理解了运输层多路复用与多路分解的作用，那就再来看看在主机中它们实际是怎样工作的。通过上述讨论，我们知道运输层多路复用的两个要求：
{% note info %}
- 套接字要有唯一标识符。
- 每个报文段要有特殊字段用来指示该报文段所要交付到的套接字。
{% endnote %}

下面的图片展示了报文段的格式，可以看出，报文段中的特殊字段一定包含**源端口号字段**和**目的端口号字段**。除此之外，UDP报文段和TCP报文段还有其他的一些字段。端口号是一个16比特的数，其大小在0～65535之间。0～1023范围的端口号称为**周知端口号**，是受限制的，这是指它们保留给诸如HTTP和FTP之类的周知应用层协议来使用。

![报文段格式](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F.png)

现在应该清楚运输层是怎样能够实现分解服务的了：在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那样，UDP基本上是这样做的。然后，TCP中的多路复用与多路分解更为复杂。

## UDP实现

假定在主机A中的一个进程具有UDP端口19157，它要发送一个应用程序数据块给位于主机B中的另一进程，该进程具有UDP端口46428。主机A中的运输层创建一个运输层报文段，其中包括应用程序数据、源端口号（19157）、目的端口号（46428）和两个其他值（将在后面讨论，它对当前的讨论不重要）。然后，运输层将得到的报文段传递到网络层。网络层将该报文段封装到一个IP数据报中，并尽力而为地将报文段交付给接收主机。

如果该报文段到达接收主机B，接收主机运输层就检查该报文段中的目的端口号（46428），并将该报文段交付给端口号46428所标识的套接字。值得注意的是，主机B能够运行多个进程，每个进程都有自己的UDP套接字及相应的端口号。当从网络到达UDP报文段时，主机B通过检查该报文段中的目的端口号，将每个报文段定向（分解）到相应的套接字。

注意到下述事实是重要的：**一个UDP套接字是由一个二元祖来全面标识的，该二元祖包含一个目的IP地址和一个目的端口号。因此，如果两个UDP报文段有不同的源IP地址/源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的套接字被定向到相同的目的进程。**

{% note warning %}
套接字的标识符中IP地址是由网络层提供的，而不是运输层。
{% endnote %}

你也许想知道，源端口号的用途是什么呢？下图中，在A到B的报文段中，源端口号用作“返回地址”的一部分，即当B需要回发一个报文段给A时，B到A的报文段中目的端口号便从A到B的报文段中源端口号中取值（完整的返回地址是A的IP地址和源端口号）。

![UDP的多路复用与多路分解](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png)

## TCP实现

TCP套接字和UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识的。这样，当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向（分解）到相应的套接字。特别与UDP不同的是，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。

![TCP多路复用与多路分解](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png)

上图中，主机C向服务器B发起了两个HTTP会话，主机A向服务器B发起一个HTTP会话。主机A要主机C及服务器B都有自己唯一的IP地址，它们分别是A、B、C。主机C为其两个HTTP连接分配了两个不同的源端口号（26145和7532）。因为主机A选择愿端口号时与主机C互不相干，因此它也可以将源端口号26145分配给其HTTP连接。但这不是问题，即服务器B仍然能够正确地分解这两个具有相同源端口号的连接，因为这两条连接有不同的源IP地址。

## Web服务器与TCP

如果客户与服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换HTTP报文。然而，如果客户与服务器使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭，这种套接字的频繁创建和关闭会严重地影响一个繁忙的Web服务器的性能。

# UDP

由[RFC 768]定义的UDP只是做了运输协议能够做的最少的工作。除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。实际上，如果应用程序开发人员选择UDP而不是TCP，则该应用程序差不多就是直接与IP打交道。UDP从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端括号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。网络层将该运输层报文段封装到一个IP数据报中，然后尽力而为地尝试将此报文段交付给接收主机。如果该报文段到达接收主机，UDP使用目的端口号将报文段中的数据交付给正确的应用进程。值得注意的是，使用UDP时，你发送报文段之前，发送方和接收方的运输层实体之间没有握手。整因为如此，**UDP被称为是无连接的**。

DNS是一个通常使用UDP的应用层协议的例子。当一台主机中的DNS应用程序想要进行一次查询时，它构造了一个DNS查询报文并将其交给UDP。无需执行任何与运行在目的端系统中的UDP实体之间的握手，主机端的UDP为此报文添加首部字段，然后将形成的报文段交给网络层。网络层将此UDP报文段封装进一个IP数据报中，然后将其发送给一个DNS服务器。在查询主机中的DNS应用程序则等待对该查询的响应。如果它没有收到响应（可能是由于底层网络丢失查询或响应），则要么试图向另一个DNS服务器发送该查询，要么通知调用的应用程序它不能获得响应。

{% note info %}
现在你也许想知道，为什么应用开发人员宁愿在UDP之上构建应用，而不选择在TCP上构建应用？原因主要有一下几点：
- 关于何时、发送什么数据的应用层控制更为精细。
- 无需建立连接。
- 无需维护连接状态。
- 分组首部开销小。
{% endnote %}

UDP首部只有4个字段，每个字段由两个字节组成。UDP报文段的结构如图所示。

![UDP报文段的结构](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E7%BB%93%E6%9E%84.png)

长度字段指示了在UDP报文段中的字节数（首部+数据）。而检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。

# 可靠数据传输原理

![可靠数据传输的框架](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E6%A1%86%E6%9E%B6.png)

上图说明了我们学习可靠数据传输的框架。为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会收到损坏或丢失，而且所有数据都是按照其发送顺序进行交付的。这恰好就是TCP向调用它的因特网应用所提供的服务模型。

实现这种服务抽象是**可靠数据传输协议（reliable data transfer protocol）**的责任。由于可靠数据传输协议的下层协议也许是不可靠的，因此这是一项困难的任务。

在讨论可靠数据传输时，我们将使用术语“分组”而不是运输层的“报文段”，因为本节内容适用于一般的计算机网络，而不只是用于因特网运输层，所以这时采用通用术语“分组”更为合适。

在本节，我们仅考虑**单向数据传输**的情况，可靠的**双向数据传输**（即全双工数据传输）情况从概念上讲不会更难，但解释起来更为单调乏味。

## 构造可靠数据传输协议

### 经完全可靠信道的可靠数据传输：rdt1.0

首先，我们考虑最简单的情况，即底层信道是完全可靠的。我们称该协议为rdt1.0，该协议本身是简单的。下图显示了rdt1.0发送方和接收方的**有限状态机（Finite-State Machine, FSM）**的定义。**引起状态变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果对一个事件没有动作，或没有就事件发生而采取一个动作，我们将在横线上方或下方使用符号Λ，已分别明确地表示缺少动作或事件。FSM的初始状态用虚线表示。**

![rdt1.0](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt1.0.png)

### 经具有比特差错信道的可靠数据传输：rdt2.0

底层信道更为实际的模型是分组中的比特可能受损。在分组的传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中。我们眼下还将继续假定所有发送的分组（虽然有些比特可能受损）将按其发送的顺序被接收。

在研发一种经这种信道进行可靠通信的协议之前，首先考虑一下人们会怎样处理这类情形。考虑一下你自己是怎样通过电话口述一条长消息的。在通常情况下，报文接收者在听到、理解并记下每句话后可能会说“OK”。如果报文接收者听到一句含糊不清的话时，他可能要求你重复刚才那句话。这种口述报文协议使用了**肯定确认（positive acknowledgement）**与**否定确认（negative acknowledgement）**。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为**自动重传请求（Automatic Repeat reQuest, ARQ）协议。**

{% note info %}
基本上，ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况
- 差错检测。
- 接收方反馈。
- 重传。
{% endnote %}

下图展示了rdt2.0的FSM。

![rdt2.0](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.0.png)

{% note warning %}
当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多的数据。这就是说，`rdt_send()`事件不可能出现。仅当接收到ACK并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt2.0这样的协议被称为**停等**协议。
{% endnote %}

rdt2.0协议看起来似乎可以运行了，但遗憾的是，它存在一个致命的缺陷。尤其是我们没有考虑到ACK或NAK分组受损的可能性！

当发送方收到含糊不清的ACK或NAK分组时，只需重传当前数据分组即可。然而，这种方法在发送方到接收方的信道中引入了**冗余分组**。解决冗余分组的方法是在数据分组中添加一个新字段，让发送方对其数据分组进行编号（从0开始），即将发送数据分组的序号放在该字段。于是，接收方只需要检查序号即可确认收到的分组是否为一次重传。因为目前我们假定信道不丢分组，所以无需对ACK和NAK本身进行编号。

{% note warning %}
分组编号只在0和1之间交替。
{% endnote %}

下面给出rdt2.1的FSM描述。

![rdt2.1发送方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.1%E5%8F%91%E9%80%81%E6%96%B9.png)

![rdt2.1接收方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.1%E6%8E%A5%E6%94%B6%E6%96%B9.png)

呃，除此之外，还有rdt2.2版本的FSM，它跟rdt2.1的FSM的区别在于去掉了NAK，而在ACK中显示指出分组编号。如果发送方接收到的ACK分组编号与刚刚发送的分组编号匹配则OK，否则就重传。FSM图如下所示。

![rdt2.2发送方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.2%E5%8F%91%E9%80%81%E6%96%B9.png)

![rdt2.2接收方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt2.2%E6%8E%A5%E6%94%B6%E6%96%B9.png)


### 经具有比特差错的丢包信道的可靠数据传输：rdt3.0

现在假定除了比特受损外，底层信道还会丢包。协议现在必须处理另外两个关注的问题：怎样检测丢包以及发生丢包后该做些什么。在rdt2.2中已经研发的技术，如使用检验和、序号、ACK分组和重传等，使我们能给出后一个问题的答案。为解决第一个关注的问题，还需增加一种新的协议机制。

这里，我们让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对该分组的ACK发生了丢失。在这两种情况下，发送方都收不到应当到来的接收方的响应。如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可。你应该相信该协议确实有效。

但是发送方需要等待多久才能确定已丢失了某些东西呢？很明显发送方至少需要等待这样长的时间：即发送方与接收方之间的一个往返时延加上接收方处理一个分组所需的时间。在很多网络中，最坏情况下的最大时延是很难估算的，确定的因素非常少。此外，理想的协议应尽可能块地从丢包中恢复出来。等待一个最坏情况的时延可能意味着需要等待一段较长的时间，直到启动差错恢复为止。因此实践中采取的方法是发送方明智地选择一个时间值，以判定可能发生了丢包。如果在这个时间内没有收到ACK，则重传该分组。注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其ACK都没有丢失。这就在发送方到接收方的信道中引入了**冗余数据分组**的可能性。幸运的事，rdt2.2协议已经有足够的功能（即序号）来处理冗余分组情况。

从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失，还是一个ACK丢失，或者只是该分组或ACK过度延时。在所有这些情况下，动作是同样的：重传。为了实现基于时间的重传机制，需要一个**倒计数定时器**，在一个给定的时间量过期后，可中断发送方。因此，发送方需要能做到：

{% note info %}
1. 每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器。
2. 响应定时器中断。
3. 终止定时器。
{% endnote %}

rdt3.0为最终的版本，且由于分组序号在0和1之间交替，因此也叫它**比特交替协议**。

rdt3.0相比rdt2.2只在发送方有所改动，接收方无变化。所以下面只给出rdt3.0的发送方FSM。

![rdt3.0发送方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/rdt3.0%E5%8F%91%E9%80%81%E6%96%B9.png)

看完FSM，你可以看看下面的比特交替协议可能出现的4种情况（书中给的图有错误）。

![比特交替协议4种情况](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%AF%94%E7%89%B9%E4%BA%A4%E6%9B%BF%E5%8D%8F%E8%AE%AE4%E7%A7%8D%E6%83%85%E5%86%B5.png)

## 流水线可靠数据传输协议

rdt3.0是一个功能正确的协议，但并非人人都对它的性能满意，特别是在今天的高速网络中更是如此。rdt3.0性能问题的核心在于它是一个停等协议。

解决这种特殊的性能问题的一个简单方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。这种技术被称为**流水线**。流水线技术对可靠数据传输协议可带来如下影响：

{% note info %}
- 必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中未确认的报文。
- 协议的发送方和接收方两端也许必须缓存多个分组。发送方最低限度应当能缓存那些已发送但没有确认的分组。接收方或许也需要缓存那些已正确接收的分组。
- 所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：**回退N步（Go-Back-N）**和**选择重传（Selective Repeat, SR）**。
{% endnote %}

![停等协议和流水线协议](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE.png)

![停等操作和流水线操作](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%81%9C%E7%AD%89%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%93%8D%E4%BD%9C.png)

### 回退N步

在**回退N步（GBN）协议**中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限与在流水线中未确认的分组数不能超过某个最大允许数N。下图显示了发送方看到的GBN协议的序号范围。如果我们将基序号（base）定义为最早的未确认分组的序号，将下一个序号（nextseqnum）定义为最小的未使用序号（即下一个待发分组的序号），则可将序号范围分割成4段。在**[0, base - 1]**段内的序号对应于已经发送并被确认的分组。**[base, nextseqnum - 1]**段内对应已经发送但未被确认的分组。**[nextseqnum, base + N -1]**段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。最后，大于或等于**base + N**的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为base的分组）已得到确认为止。

![GBN序号范围](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/GBN%E5%BA%8F%E5%8F%B7%E8%8C%83%E5%9B%B4.png)

图中**[base, base + N -1]**序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向右移动。因此，N常被称为**窗口长度**，GBN协议也常被称为**滑动窗口协议**。

在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是k，则该序号的范围是**[0, $2^k-1$]**。在一个有限的序号范围内，所有涉及序号的运算必须使用模$2^k$运算。（即序号空间可被看作是一个长度为$2^k$的环，其中序号$2^k-1$紧接着序号0）。

{% note info %}
GBN发送方必须响应三种类型的事件：
- **上层的调用**。当上层调用`rdt_send()`时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过一会再试。在实际实现中，发送方更可能缓存（并不立刻发送）这些数据，或者使用同步机制（如一个信号量或标志）允许上层在仅当窗口不满时才调用`rdt_send()`。
- **收到一个ACK**。在GBN协议中，对序号为n的分组的确认采取**累积确认**的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。
- **超时事件**。协议的名字“回退N步”来源于出现丢失和时延过长分组时发送方的行为。就像在停等协议中那样，定时器将再次用于恢复数据或确认分组的丢失。如果出现超时，发送方重传所有已发送但还未被确认过的分组。发送方仅使用一个定时器，它可被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个ACK，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已发送但未被确认的分组，该定时器被终止。

---
在GBN中，接收方的动作也很简单。如果一个序号为n的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为n-1的分组），则接收方为分组n发送一个ACK，并将该分组中的数据部分交付给上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。

在GBN协议中，接收方丢弃所有失序分组。尽管丢弃一个正确接收（但失序）的分组有点愚蠢和浪费，但这样做是有理由的。前面讲过，接收方必须按序将数据交付给上层。假定现在期望接收分组n，而分组n+1却到了。因为数据必须按序交付，接收方可能缓存（保存）分组n+1，然后，在它收到并交付分组n后，再将该分组交付到上层。然而，如果分组n丢失，则该分组已分组n+1最后总将在发送方根据GBN重传规则而被重传。因此，接收方只需丢弃分组n+1即可。这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。因此，虽然发送方必须维护窗口的上下边界及nextseqnum在该窗口中的位置，但是接收方需要维护的唯一信息就是下一个按序接收的分组的序号。该值保存在expectedseqnum变量中。当然，丢失一个正确接收的分组的缺点是随后对该分组的重传也许会丢失或出错，因此甚至需要更多的重传。
{% endnote %}

![GBN发送方的扩展FSM](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/GBN%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E6%89%A9%E5%B1%95FSM.png)

![GBN接收方的扩展FSM](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/GBN%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84%E6%89%A9%E5%B1%95FSM.png)

![运行中的GBN](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84GBN.png)

### 选择重传

GBN协议中当窗口长度和带宽时延都很大时，在流水线中会有很多分组，此时其中单个分组的差错就会引起GBN重传大量分组，许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。

选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。这种个别的、按需的重传要求接收发逐个地确认正确接收的分组。再次用窗口长度N来限制流水线中未完成、未被确认的分组书。然而，与GBN不同的是，发送方已经收到了对窗口中给某些分组的ACK。

下面图中分不清颜色了，不过这都不重要，你只要知道rcv_base在哪里就好了，因为它决定接收方窗口的移动。另外，发送方和接收方的窗口并不总是一致的，下图中的就不一致。

![SR的序号空间](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/SR%E7%9A%84%E5%BA%8F%E5%8F%B7%E7%A9%BA%E9%97%B4.png)

{% note info %}
发送方响应事件：
- **从上层收到数据**。当从上层接收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在GBN中一样，要么将数据缓存，要么将其返回给上层以便以后传输。
- **超时**。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有自己的定时器，因为超时发生后只能发送一个分组。
- **收到ACK**。如果收到ACK，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向右移动到具有最小序号的未确认分组处（即修改send_base值）。如果窗口移动了并且有序号落在窗口内的为发送分组，则发送这些分组。

---
接收方响应事件：
- **序号在[rcv_base, rcv_base + N - 1]内的分组被正确接收**。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。如果该分组以前没有收到过，则缓存该分组。如果该分组的序号等于rcv_base，则该分组以及以前缓存的序号连续的（起始于rcv_base的）分组交付给上层。然后，rcv_base向右移动到对应的新位置。
- **序号在[rcv_base - N, rcv_base - 1]内的分组被正确接收**。在此情况下，必须产生一个ACK，即使该分组是接收方以前已确认过的分组。这种情况发生在发送方没有成功接收到ACK的时候，如果接收方不重新发送ACK，则发送方将一直重发对应分组，发送方窗口也将永远不能向右移动。
- **其他情况的时候均忽略该分组。**
{% endnote %}

![SR操作](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/SR%E6%93%8D%E4%BD%9C.png)

当我们面对有限序号范围的现实时，发送方和接收方窗口间缺乏同步会产生严重的后果。考虑下面例子中的两种情况，会让接收方分不清最后接收的序号0分组是重传的，还是新发送的。

![SR窗口太大](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/SR%E7%AA%97%E5%8F%A3%E5%A4%AA%E5%A4%A7.png)

{% note info %}
避免这个问题的办法是：**永远保证SR的窗口长度小于或等于序号空间大小的一半。**
{% endnote %}

# TCP

## TCP连接原理

TCP被称为是**面向连接的**，这是因为在使用TCP从一个应用进程向另一个应用进程发送数据之前，这两个进程必须相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。**作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量。**

由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接。

TCP连接提供的是**全双工服务**：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以在从进程B流向进程A的同时，也从进程A流向进程B。TCP连接也总是**点对点**的，即单个发送方与单个接收方之间的连接。所谓“多播”，即在一次发送操作中，从一个发送方将数据传送诶多个接收方，对TCP来说这是不可能的。对于TCP而言，两台主机是一对，而3台主机则太多！

我们现在来看看TCP连接是怎样建立的。假设运行在某台主机上的一个进程想与另一台主机上的一个进程建立一条连接。发起连接的这个进程被称为**客户进程**，而另一个进程被称为**服务器进程**。客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊的报文段作为响应。前两个报文段不承载**有效载荷**，也就是不包含应用层数据。而第三个报文段可以承载有效载荷。由于在这两台主机之间发送了3个报文段，所以这种连接建立过程常被称为**三次握手**。

一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。我们考虑一下从客户进程向服务器进程发送数据的情况。客户进程通过套接字传递数据流，数据一旦通过套接字，它就由客户中运行的TCP控制了。如下图所示，TCP将这些数据引导到该连接的**发送缓存**里，发送缓存是在三次握手初期设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据并以报文段的形式发送出去。TCP可从缓存中取出并放入报文段中的数据数量受限于**最大报文段长度（Maximum Segment Size, MSS）**。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度，即所谓的**最大传输单元（Maximum Transmission Unit, MTU）**来设置。设置该MSS要保证一个TCP报文段加上一个TCP/IP首部长度将适合单个链路层帧。

{% note warning %}
**MSS是指在报文段里应用层数据的最大长度，而不是指包括TCP首部的TCP报文段的最大长度！！！**
{% endnote %}

![TCP发送缓存和接收缓存](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%8F%91%E9%80%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BC%93%E5%AD%98.png)

TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的接收缓存中，应用进程再从此缓存中读取数据流。TCP连接的每一端都有各自的发送和接收缓存。

## TCP报文段结构

TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。如前所属，MSS限制了报文段数据字段的最大长度。当TCP发送一个大文件时，它通常会将该文件划分成长度为MSS的若干块（最后一块除外，它通常小于MSS）。下面展示了TCP报文段的结构。

![TCP报文段的结构](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E7%BB%93%E6%9E%84.png)

{% note info %}
与UDP一样，首部包括**源端口号**和**目的端口号**，它们被用于多路复用/分解。另外，同UDP一样，TCP首部也包括**检验和字段**。除此之外，还包括下列字段：
- 32比特的**序号字段**和32比特的**确认号字段**，这些字段被TCP发送方和接收方用来实现可靠数据传输服务。
- 16比特的**接收窗口字段**，该字段用于流量控制，指示接收方愿意接受的字节数量。
- 4比特的**首部长度字段**，该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。**注意它和UDP首部的长度字段有很大的区别。**
- 可选与变长的**选项字段**，该字段用于发送方与接收方协商最大报文段长度（MSS）时，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。
- 6比特的**标志字段**。**ACK比特**用于指示确认号字段中的值是有效的。**RST、SYN和FIN**比特用于连接建立和拆除。当**PSH比特**被设置的时候，就指示接收方应立即将数据交给上层。最后，**URG比特**用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。
- 16比特的**紧急数据指针字段**是配合**URG比特**使用的。
{% endnote %}

TCP报文段首部中最重要的字段是序号字段和确认号字段。在讨论这两个字段是如何用于提供可靠数据传输之前，首先来解释一下TCP在这两个字段中究竟放置了什么。TCP把数据看成一个无结构的、有序的字节流，**TCP报文段的序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上的。**举例来说，假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如下图所示，该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0，第二个报文段分配序号1000，第三个报文段分配序号2000，以此类推。每一个序号被填入到相应TCP报文段首部的序号字段中。

![TCP报文段序号](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E5%BA%8F%E5%8F%B7.png)

现在我们考虑一下确认号。确认号要比序号难处理一些。前面讲过，TCP是全双工的，因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据（都是同一条TCP连接的一部分）。从主机B到达的每个报文段中也都有一个序号字段用于指示从B流向A的字节流序号。**主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。**

看一些例子有助于理解实际发生的事情。假设主机A已收到了来自主机B的编号为0～535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536。

再举一个例子，假设主机A已收到了一个来自主机B的包含字节0～535的报文段，以及另一个包含字节900～1000的报文段。由于某种原因，主机A还没有收到字节536～899的报文段。在这个例子中，主机A为了重新构建主机B的数据流，仍在等待字节536（和其后的字节）。因此，A到B的下一个报文段将在确认号字段中包含536。因此TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供**累积确认**。

最后一个例子也会引发一个重要而微妙的问题。主机A在收到第二个报文段（字节536～899）之前收到第三个报文段（字节900～1000）。因此，第三个报文段属于失序到达。该微妙的问题是：当主机在一条TCP连接中收到失序报文段时该怎么办？有趣的是，TCP RFC并没有为此问题明确规定任何规则，而是把这一问题留给实现TCP的编程人员去处理。它们有两个基本的选择：回退N步和选择重传。

{% note warning %}
**我们假设初始序号为0，实际上，一条TCP连接的双方均可随机地选择初始序号。这样做可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性（两次连接碰巧使用了相同的端口号）。**
{% endnote %}

下图展示了TCP序号和确认号的使用过程，在这个例子中，每次主机A向主机B发送数据后，主机B都会将收到的数据再重新传给主机A，这种操作称为“回显”。

{% note warning %}
**Seq和ACK分别代表序号和确认号，这个ACK不是那个1比特的ACK，呃，有点绕嘴。**。
{% endnote %}

![TCP确认号和序号](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E7%A1%AE%E8%AE%A4%E5%8F%B7%E5%92%8C%E5%BA%8F%E5%8F%B7.png)

## 往返时间的估计与超时

TCP如同前面所讲的rdt协议一样，采用超时/重传机制来处理报文段的丢失问题。尽管这在概念上简单，但是当在如TCP这样的实际协议中实现超时/重传机制时还是会产生许多微妙的问题。也许最明显的一个问题就是超时间隔长度的设置。显然，超时间隔必须大于该连接的往返时间（RTT），即从一个报文段发出到它被确认的时间。否则会造成不必要的重传。

报文段的样本RTT（表示为SampleRTT）就是从某报文段被发出（即交给IP）到对该报文段的确认被收到之间的时间量。大多数TCP的实现仅在某个时刻做一个SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT。这就是说，任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计SampleRTT，从而产生一个接近每个RTT的新SampleRTT值。另外，TCP决不为已被重传的报文段计算SampleRTT，它仅为传输一次的报文段测量SampleRTT。

显然，由于路由器的拥塞和端系统负载的变化，这些报文段的SampleRTT值会随之波动。由于这种波动，任何给定的SampleRTT值也许都是非典型的。因此，为了估计一个典型的RTT，自然要采取某种对SampleRTT取平均的办法。TCP维持一个SampleRTT均值（称为EstimatedRTT）。一旦获得一个新的SampleRTT时，TCP就会根据下列公式来更新EstimatedRTT：

{% note info %}
**EstimatedRTT = (1 - α)·EstimatedRTT + α·SampleRTT，α的参考值是0.125**。
{% endnote %}
除了估算RTT外，测量RTT的变化也是有价值的。DevRTT用于估算SampleRTT一般会偏离EstimatedRTT的程度：

{% note info %}
**DevRTT = (1 - β)·DevRTT + β·|SampleRTT - EstimatedRTT|，β的参考值是0.25**。
{% endnote %}

{% note info %}
- **TimeoutInterval代表超时间隔**。
- **TimeoutInterval = EstimatedRTT + 4·DevRTT**。
- **推荐的初始TimeoutInterval值为1秒**。
{% endnote %}

## 可靠数据传输

TCP在IP不可靠的尽力而为服务之上创建了一种**可靠数据传输服务**。TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流；即该字节流与连接的另一端发送出的字节流是完全相同的。

在我们前面讨论的可靠数据传输原理的SR协议时，曾假定每一个已发送但未确认的报文段都与一个定时器相关联，这在概念上是最简单的。虽然这在理论上很好，但定时器的管理却需要相当大的开销。因此，**推荐即使有多个已发送但还未确认的报文段，也只使用单一的重传定时器。**

下面给出了一个TCP发送方高度简化的描述。我们看到在TCP发送方有3个与发送和重传有关的主要事件：从上层应用程序接收数据、定时器超时和收到ACK。

![简化的TCP发送方](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E7%AE%80%E5%8C%96%E7%9A%84TCP%E5%8F%91%E9%80%81%E6%96%B9.png)

### 一些有趣的情况

第一种情况是主机A向主机B发送一个报文段。假设该报文段的序号是92，而且包含8字节数据。在发出该报文段之后，主机A等待一个来自主机B的确认号为100的报文段。虽然A发出的报文段在主机B上被收到，但从主机B发往主机A的确认报文丢失了。在这种情况下，超时事件就会发生，主机A会重传相同的报文段。当然，当主机B收到该重传的报文段时，它将通过序号发现该报文段包含了早已收到的数据。因此，主机B中的TCP将丢弃该重传的报文段中的这些字节。

![由于确认丢失而重传](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E7%94%B1%E4%BA%8E%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E8%80%8C%E9%87%8D%E4%BC%A0.png)

第二种情况中，主机A连续发挥了两个报文段。第一个报文段序号是92，包含8字节数据。而第二个报文段序号是100，包含20字节数据。假设两个报文段都完好无损地到达主机B，并且主机B为每一个报文段分别发送一个确认。第一个确认报文的确认号是100，第二个确认报文的确认号是120。现在假设在超时之前这两个报文段中没有一个确认报文到达主机A。当超时事件发生时，主机A重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段就不会被重传。

![报文段100没有重传](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%8A%A5%E6%96%87%E6%AE%B5100%E6%B2%A1%E6%9C%89%E9%87%8D%E4%BC%A0.png)

第三种也是最后一种情况中，假设主机A与在第二种情况中完全一样，发送两个报文段。第一个报文段的确认报文在网络丢失，但在超时事件发生之前主机A收到一个确认号为120的确认报文。主机A因而知道主机B已经收到了序号为119及之前的所有字节。所以主机A不会重传这两个报文段中的任何一个。

![累积确认避免了第一个报文段的重传](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E7%B4%AF%E7%A7%AF%E7%A1%AE%E8%AE%A4%E9%81%BF%E5%85%8D%E4%BA%86%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%87%8D%E4%BC%A0.png)

### 超时间隔加倍

我们现在讨论一下在大多数TCP实现中所做的一些修改。在这种修改中，每当超时时间发生时，如前所述，TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从EstimateRtt和DevRtt计算出来的值。

例如，假设当定时器第一次过期时，与最早的未被确认的报文段相关联的TimeoutInterval是0.75秒。TCP就会重传该报文段，并把新的过期时间设置为1.5秒。如果1.5秒后定时器又过期了，则TCP将再次重传该报文段，并把过期时间设置为3.0秒。因此，超时间隔在每次重传后会呈指数型增长。然后，每当定时器在另外两个事件（即收到上层应用的数据和收到ACK）中的任意一个启动时，TimeoutInterval由最近的EstimateRtt和DevRtt计算得到。

### 快速重传

超时出发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前注意所谓冗余ACK来较好地检测到丢包的情况。**冗余ACK**就是对同一个报文段的重复确认。要理解发送方对冗余ACK的响应，需要首先看一下接收方为什么会发送冗余ACK：

| 事件 | TCP接收方动作 |
| --------- | ----------- |
| 具有所期望序号的按序报文段到达，并且所有在期望序号及以前的数据都已经发送过ACK了。 | 最多等待500毫秒，然后发送一个ACK（结合下一条一起看）。 |
| 具有所期望序号的按序报文段到达，并且它的上一个报文段还没有发送ACK。 | 立即发送一个累积ACK，以确认两个按序报文段。 |
| 比期望序号大的失序报文段到达 | 立即发送冗余ACK，指示期待报文段的序号。 |
| 能部分或完全填充接收数据间隔的报文段到达。 | 倘若该报文段起始于间隔的最前面，则立即发送ACK。 |

因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK，它把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。一旦收到3个冗余ACK，TCP就会执行**快速重传**，即在该报文段的定时器过期之前重传丢失的报文段。

{% note warning %}
**第3个冗余ACK是第4个重复ACK。**
{% endnote %}

用下面的事件响应取代之前提过的简化的TCP发送方的收到ACK事件：

![快速重传事件响应](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94.png)

![快速重传例子](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E4%BE%8B%E5%AD%90.png)

### 是GBN还是SR？

TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的。因此TCP发送方仅需维持已发送过但未被确认的字节的最小序号（SendBase）和下一个要发送的字节的序号（NextSeqNum）。在这种意义瞎，TCP看起来更像一个GBN风格的协议，但是TCP和GBN协议之间有着一些显著的区别。许多TCP实现会将正确接收但失序的报文段缓存起来。另外考虑一下，当发送方发送一组报文段1, 2, ..., N，并且所有的报文段都按序无差错地到达接收方时会发生的清咖u难过。进一步假设对分组n<N的确认报文丢失，但是其余N-1个确认报文在分别超时以前到达发送端，这是又会发生的情况。在该例中，GBN不仅会重传分组n，还会重传所有后继的分组。在另一方面，TCP将重传之多一个报文段，即报文段n。此外，如果对报文段n+1的确认报文在报文段n超时之前到达，TCP甚至不会重传报文段n。

对TCP提出的一种修改意见是所谓的**选择确认（selective acknowledge）**，它允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。当将该机制与选择重传机制结合起来使用时（即跳过重传那些已被接收方选择性地确认过的报文段），TCP看起来就很像我们通常的SR协议。因此，TCP的差错恢复机制也许最好被分类为GBN协议与SR协议的混合体。

{% note warning %}
**本篇博客中介绍的TCP是累积确认的，如何实现选择确认的，我也没有学到那里呢。**
{% endnote %}

## 流量控制

一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后，它就将数据放入接收缓存。相关联的应用进程会从该缓存中读取数据，但不必是数据刚一到达就立即读取。事实上，接收方应用也许正忙于其他任务，甚至要过很长时间后才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。

TCP为它的应用程序提供了**流量控制服务**以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。TCP通过让发送方维护一个称为**接收窗口**的变量来提供流量控制。通俗地说，接收窗口用于给发送方一个指示————该接收方还有多少可用的缓存空间。因为TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。我们在文件传输的情况下研究接收窗口。

{% note info %}
假设主机A通过一条TCP连接向主机B发送一个大文件。主机B为该连接分配了一个接收缓存，主机B上的应用进程不时地从该缓存中读取数据。我们定义以下变量：
- **RcvBuffer**：主机B上接收缓存的大小。
- **LastByteRead**：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。
- **LastByteRcvd**：从网络中到达的并且已经放入主机B接收缓存中的数据流的最后一个字节的编号。

---
由于TCP不允许已分配的缓存溢出，下式必须成立：
**LastByteRcvd - LastByteRead <= RcvBuffer**

接收窗口用rwnd表示，根据缓存可用空间的数量来设置：
**rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]**

由于该空间是随时间变化的，所以rwnd是动态的。
{% endnote %}

连接是如何使用变量rwnd提供流量控制服务的呢？主机B通过把当前的rwnd值放入它发给主机A的报文段接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。开始时，主机B设定**rwnd = RcvBuffer**。注意到为了实现这一点，主机B必须跟踪几个与连接有关的变量。

主机A轮流跟踪两个变量：**LastByteSent**和**LastByteAcked**，这两个变量的意义很明显。注意到这两个变量之间的差，就是主机A发送到连接中但未被确认的数据量。通过将未确认的数据量控制在值rwnd以内，就可以保证主机A不会使主机B的接收缓存溢出。

对于这个方案还存在一个小小的技术问题。为了理解这一点，假设主机B的接收缓存已经存满了，使得**rwnd = 0**。在将**rwnd = 0**通告给主机A后，还要假设主机B没有任何数据要发送给主机A。在之后主机B上的应用进程将缓存清空后，主机A没有办法知道主机B的接收缓存已经有了新的空间了，即主机A被阻塞而不能再发送数据了。为了解决这个问题，TCP规范中要求：当主机B的接收缓存无空间后，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值。

## TCP连接管理

{% note info %}
TCP连接过程：
1. 客户端的TCP首部首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据。但是在报文段的首部中的一个标志位（即SYN比特）被置为1。因此，这个特殊报文段被称为SYN报文段。另外，客户会随机地选择一个初始序号（client_isn），并将此初始序号放置于该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。为了避免某些安全性攻击，在适当地随机化选择client_isn方面有着不少有趣的研究。
2. 一旦包含TCP SYN报文段的IP数据报到达服务器主机（假定它的确到达了！），服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3个中重要的信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client_isn + 1。最后，服务器选择自己的初始序号（server_isn），并将其放置到TCP报文段首部的序号字段中。这个允许连接的报文段实际上表明了：“我收到了你发起建立连接的SYN分组，该分组带有初始序号client_isn。我同意建立该连接。我自己的初始序号是server_isn。”该允许连接的报文段有时被称为**SYNACK报文段**。
3. 在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段。这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn + 1放置到TCP报文段首部的确认字段中国呢来完成此项工作）。因为连接已经建立了，所以该SYN比特被置为0。在这一步骤中可以在报文段负载中携带客户到服务器的数据。


一旦完成这3个步骤，客户和服务器主机就可以相互发送包括数据的报文段了。在以后每一个报文段中，SYN比特都被置为0。这个连接过程通常被称为**3次握手**。**之所以是三次握手，是因为三次连接正好可以让客户和服务器彼此确认接受了对方提出的初始序号。**
{% endnote %}

![三次握手](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

参与一条TCP连接的两个进程中任何一个都能终止该连接。当连接结束后，主机中的“资源”（即缓存和变量）将被释放。举一个例子，假设某客户打算关闭连接时，客户向服务器进程发送一个首部中FIN比特被置为1的报文段，当服务器接收到该报文段后，就向发送方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其FIN比特被置为1。最后，客户对这个服务器的终止报文段进行确认。此时，在两台主机上用于该连接的所有资源都被释放了。这个过程被称为**四次挥手**。

![四次挥手](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

在一个TCP连接的生命周期内，运行在每台主机中的TCP协议在各种**TCP状态**之间变迁。下图首先展示的是客户TCP的状态变迁，客户的TIME_WAIT状态中所消耗的时间是与具体实现有关的，而典型值是30秒、1分钟或2分钟。

![客户TCP状态变迁](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%AE%A2%E6%88%B7TCP%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png)

看完了客户TCP的状态变迁，接下来在看看服务器TCP的状态变迁。

![服务器TCP状态变迁](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%9C%8D%E5%8A%A1%E5%99%A8TCP%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png)

我们上面的讨论假定了客户和服务器都准备通信，即服务器正在监听客户发送其SYN报文段的端口。我们来考虑当一台主机接收到一个TCP报文段，其端口号或源IP地址与该主机上进行中的套接字都不匹配的情况。例如，假如一台主机接受了具有目的端口80的一个TCP SYN分组，但该主机在端口80不接受连接。则该主机将向源发送一个特殊的重置报文段。该TCP报文段将RST标志位置为1。因此，当主机发送一个重置报文段时，它告诉该源“我们有那个报文段的套接字。请不要再发送该报文段了”。

## SYN洪范攻击

我们在TCP三次握手的讨论中已经看到，服务器为了响应一个收到的SYN，分配并初始化连续变量和缓存。然后服务器发送给你一个SYNACK进行响应，并等待来自客户的ACK报文段。如果某客户不发送ACK来完成该三次握手的第三步，最终（通常在一分钟之后）服务器将终止该半开连接并回收资源。

这种TCP连接管理协议为DoS（Denial of Service）攻击中的**SYN洪泛攻击**提供了环境。在这种攻击中，攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤。随着这种SYN报文段纷至沓来，服务器不断为这些半开连接分配资源（但从未使用），导致服务器的连接资源被消耗殆尽。幸运的是，现在有一种有效的防御系统，称为**SYN cookie**，它们被部署在大多数主流操作系统中。SYN cookie以下列方式工作：

{% note info %}
- 当服务器接收到一个SYN报文段时，它并不知道该报文段是来自一个合法的用户，还是一个SYN洪泛攻击的一部分。因此服务器不会为该报文段生成一个半开连接。相反，服务器生成一个初始TCP序列号，该序列号是SYN报文段的源和目的IP地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数（散列函数）。这种精心制作的初始序列号被称为“cookie”。服务器则发送具有这种特殊初始化序列号的SYNACK分组。**重要的是，服务器并不记忆该cookie或任何对于SYN的其他状态信息。**
- 如果客户是合法的，则它将返回一个ACK报文段。当服务器收到该ACK，需要验证该ACK是否与前面发送的某些SYN相对应。服务器将使用客户的ACK报文段中的源和目的IP地址与端口号以及刚刚提过的散列函数，如果该函数的结果加1与客户的ACK报文段中的确认号字段值相同的话，服务器认为该ACK对应于较早的SYN报文段，因此它是合法的。服务器则生成一个具有套接字的全开的连接。
- 在另一方面，如果客户没有返回一个ACK报文段，则初始的SYN并没有对服务器产生危害，因为服务器没有为它分配任何资源。
{% endnote %}

# 拥塞控制原理

未完待续......



