---
title: 第十章 增强的数组功能
categories:
  - JavaScript
  - 《深入理解ES6》
abbrlink: 16cef417
date: 2019-04-11 19:33:33
---

# 创建数组

在ES6之前创建数组主要存在两种方式：`Array`构造器和数组字面量语法。这两种方式都需要将数组的项分别列出，并且还要受到其他限制。将“类数组对象”转换为数组也并不自由，经常需要书写额外的代码。为了使数组更易创建，ES6新增了`Array.of()`与`Array.from()`方法。

## Array.of()方法

ES6为数组新增创建方法的目的之一，是帮助开发者在使用`Array`构造器时避开JS语言的一个怪异点。调用`new Array()`构造器时，根据传入参数的类型与数量的不同，实际上会导致一些不同的结果，例如：

```js
let items = new Array(2)
console.log(items.length)   // 2
console.log(items[0])       // undefined
console.log(items[1])       // undefined

items = new Array('2')
console.log(items.length)   // 1
console.log(items[0])       // '2'

items = new Array(1, 2)
console.log(items.length)   // 2
console.log(items[0])       // 1
console.log(items[1])       // 2

items = new Array(3, '2')
console.log(items.length)   // 2
console.log(items[0])       // 3
console.log(items[1])       // '2'
```

当使用单个数值参数来调用`Array`构造器时，数组的长度属性会被设置为该参数；而如果使用单个的非数值型参数来调用，该参数就会成为目标数组的唯一项；如果使用多个参数（无论是否为数值类型）来调用，这些参数也会成为目标数组的项。数组的这种行为既混乱又有风险，因为有时可能不会留意所传参数的类型。

ES6引入了`Array.of()`方法来解决这个问题。该方法的作用非常类似`Array`构造器，但在使用单个数值参数的时候并不会导致特殊结果。`Array.of()`方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。下面例子演示了`Array.of()`的用法：

```js
let items = Array.of(1, 2)
console.log(items.length)       // 2
console.log(items[0])           // 1
console.log(items[1])           // 2

items = Array.of(2)
console.log(items.length)       // 1
console.log(items[0])           // 2

items = Array.of('2')
console.log(items.length)       // 1
console.log(items[0])           // '2'
```

{% note info %}
`Array.of()`方法并没有使用`Symbol.species`属性来决定返回值的类型，而是使用了当前的构造器（即`of()`方法内部的`this`）来做决定。
{% endnote %}

## Array.from()方法

将**可迭代对象**或者**类数组对象**作为第一个参数传入，`Array.from()`就能返回一个数组。这里有个简单的例子：

```js
function doSomething() {
    var args = Array.from(arguments)

    // 使用 args
}
```

此处调用`Array.from()`方法，使用`arguments`对象创建了一个新数组`args`，它是一个数组实例，并且包含了`arguments`对象的所有项，同时还保持了项的顺序。

{% note info %}
`Array.from()`方法同样使用`this`来决定要返回什么类型的数组。
{% endnote %}

如果你想实行进一步的数组转换，你可以向`Array.from()`方法传递一个映射用的函数作为第二个参数。此函数会将类数组对象的每一个值转换为目标形式，并将其存储在目标数组的对应位置上。例如：

```js
function translate () {
    return Array.from(arguments, value => value + 1)
}

let numbers = translate(1, 2, 3)

console.log(numbers)    // [ 2, 3, 4 ]
```

如果映射函数需要在对象上工作，你可以手动传递第三个参数给`Array.from()`方法，从而指定映射函数内部的`this`值。

```js
let helper = {
    diff: 1,
    add (value) {
        return value + this.diff
    }
}

function translate () {
    return Array.from(arguments, helper.add, helper)
}

let numbers = translate(1, 2, 3)

console.log(numbers)        // [ 2, 3, 4 ]
```

# 所有数组上的新方法

## find()与findIndex()方法

`find()`与`findIndex()`方法均接受两个参数：一个回调函数、一个可选值用于指定回调函数内部的`this`。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身。该回调函数应当在给定的元素满足你定义的条件时返回`true`，而`find()`与`findIndex()`方法均会在回调函数第一次返回`true`时停止查找。

二者唯一的区别是：`find()`方法会返回匹配的值，而`findIndex()`方法则会返回匹配位置的索引。这里有个示例：

```js
let numbers = [25, 30, 35, 40, 45]

console.log(numbers.find(n => n > 33))          // 35
console.log(numbers.findIndex(n => n > 33))     // 2
```

## fill()方法

`fill(value, start, end + 1)`方法使用参数`value`去替换数组索引从`start`至`end`的项。请观察下面的例子：

```js
let numbers = [1, 2, 3, 4]

numbers.fill(1)
console.log(numbers)     // [ 1, 1, 1, 1 ]

numbers.fill(2, 1)
console.log(numbers)     // [ 1, 2, 2, 2 ]

numbers.fill(3, 1, 3)
console.log(numbers)     // [ 1, 3, 3, 2 ]
```

{% note info %}
如果提供的起始位置（`start`）或结束位置（`end + 1`）为负数，则它们会被加上数组的长度来算出最终的位置。
{% endnote %}

## copyWithin()方法

# 类型化数组
## 数值数据类型
## 数组缓冲区
## 使用视图操作数组缓冲区
### 获取视图信息
### 读取与写入数据
### 类型化数组即为视图
### 创建特定类型视图

# 类型化数组与常规数组的相似点
## 公共方法
## 相同的迭代器
## of()与from()方法

# 类型化数组与常规数组的区别
## 行为差异
## 遗漏的方法
## 附加的方法
