---
title: 第十章 增强的数组功能
categories:
    - JavaScript
    - 《深入理解ES6》
abbrlink: 16cef417
date: 2019-04-11 19:33:33
---

# 创建数组

在ES6之前创建数组主要存在两种方式：`Array`构造器和数组字面量语法。这两种方式都需要将数组的项分别列出，并且还要受到其他限制。将“类数组对象”转换为数组也并不自由，经常需要书写额外的代码。为了使数组更易创建，ES6新增了`Array.of()`与`Array.from()`方法。

## Array.of()方法

ES6为数组新增创建方法的目的之一，是帮助开发者在使用`Array`构造器时避开JS语言的一个怪异点。调用`new Array()`构造器时，根据传入参数的类型与数量的不同，实际上会导致一些不同的结果，例如：

```js
let items = new Array(2)
console.log(items.length)   // 2
console.log(items[0])       // undefined
console.log(items[1])       // undefined

items = new Array('2')
console.log(items.length)   // 1
console.log(items[0])       // '2'

items = new Array(1, 2)
console.log(items.length)   // 2
console.log(items[0])       // 1
console.log(items[1])       // 2

items = new Array(3, '2')
console.log(items.length)   // 2
console.log(items[0])       // 3
console.log(items[1])       // '2'
```

当使用单个数值参数来调用`Array`构造器时，数组的长度属性会被设置为该参数；而如果使用单个的非数值型参数来调用，该参数就会成为目标数组的唯一项；如果使用多个参数（无论是否为数值类型）来调用，这些参数也会成为目标数组的项。数组的这种行为既混乱又有风险，因为有时可能不会留意所传参数的类型。

ES6引入了`Array.of()`方法来解决这个问题。该方法的作用非常类似`Array`构造器，但在使用单个数值参数的时候并不会导致特殊结果。`Array.of()`方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。下面例子演示了`Array.of()`的用法：

```js
let items = Array.of(1, 2)
console.log(items.length)       // 2
console.log(items[0])           // 1
console.log(items[1])           // 2

items = Array.of(2)
console.log(items.length)       // 1
console.log(items[0])           // 2

items = Array.of('2')
console.log(items.length)       // 1
console.log(items[0])           // '2'
```

{% note info %}
`Array.of()`方法并没有使用`Symbol.species`属性来决定返回值的类型，而是使用了当前的构造器（即`of()`方法内部的`this`）来做决定。例如，`MyArray.of()`返回`MyArray`类型的实例，`Array.of()`返回`Array`类型的实例。
{% endnote %}

## Array.from()方法

将**可迭代对象**或者**类数组对象**作为第一个参数传入，`Array.from()`就能返回一个数组。这里有个简单的例子：

```js
function doSomething() {
    var args = Array.from(arguments)

    // 使用 args
}
```

此处调用`Array.from()`方法，使用`arguments`对象创建了一个新数组`args`，它是一个数组实例，并且包含了`arguments`对象的所有项，同时还保持了项的顺序。

{% note info %}
`Array.from()`方法同样使用`this`来决定要返回什么类型的数组。
{% endnote %}

如果你想实行进一步的数组转换，你可以向`Array.from()`方法传递一个映射用的函数作为第二个参数。此函数会将类数组对象的每一个值转换为目标形式，并将其存储在目标数组的对应位置上。例如：

```js
function translate () {
    return Array.from(arguments, value => value + 1)
}

let numbers = translate(1, 2, 3)

console.log(numbers)    // [ 2, 3, 4 ]
```

如果映射函数需要在对象上工作，你可以手动传递第三个参数给`Array.from()`方法，从而指定映射函数内部的`this`值。

```js
let helper = {
    diff: 1,
    add (value) {
        return value + this.diff
    }
}

function translate () {
    return Array.from(arguments, helper.add, helper)
}

let numbers = translate(1, 2, 3)

console.log(numbers)        // [ 2, 3, 4 ]
```

{% note warning %}
**只要一个对象有`length`属性，`Array.from()`就会可以通过它得到对应长度的数组**
{% endnote %}

```js
let a = {
    length: 3
}
console.log(Array.from(a))  // [ undefined, undefined, undefined ]
```

# 所有数组上的新方法

## find()与findIndex()方法

`find()`与`findIndex()`方法均接受两个参数：一个回调函数、一个可选值用于指定回调函数内部的`this`。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身。该回调函数应当在给定的元素满足你定义的条件时返回`true`，而`find()`与`findIndex()`方法均会在回调函数第一次返回`true`时停止查找。

二者唯一的区别是：`find()`方法会返回匹配的值，而`findIndex()`方法则会返回匹配位置的索引。这里有个示例：

```js
let numbers = [25, 30, 35, 40, 45]

console.log(numbers.find(n => n > 33))          // 35
console.log(numbers.findIndex(n => n > 33))     // 2
```

## fill()方法

{% note info %}
`fill(value, start, end + 1)`方法使用参数`value`去替换数组索引从`start`至`end`的项。如果提供的起始位置（`start`）或结束位置（`end + 1`）为负数，则它们会被加上数组的长度来算出最终的位置。请观察下面的例子：
{% endnote %}

```js
let numbers = [1, 2, 3, 4]

numbers.fill(1)
console.log(numbers)     // [ 1, 1, 1, 1 ]

numbers.fill(2, 1)
console.log(numbers)     // [ 1, 2, 2, 2 ]

numbers.fill(3, 1, 3)
console.log(numbers)     // [ 1, 3, 3, 2 ]
```

{% note warning %}
`fill()`方法是使用浅复制来完成的
{% endnote %}

```js
let a = [1, 2];
a.fill([]);
console.log(a);     // [ [], [] ]
a[1].push(33);
console.log(a);     // [ [ 33 ], [ 33 ] ]
```

## copyWithin()方法

`copyWithin()`方法与`fill()`类似，可以一次性修改数组的多个元素。不过，与`fill()`使用单个值来修改数组不同，`copyWithin()`方法允许你在数组内部复制自身元素。为此你需要传递两个参数给`copyWithin()`方法：从什么位置开始进行修改，以及被用来复制的数据的起始位置索引。

```js
let numbers = [1, 2, 3, 4]

// 从索引2的位置开始粘贴
// 从索引0的位置开始复制数据
numbers.copyWithin(2, 0)
console.log(numbers)     // [ 1, 2, 1, 2 ]
```

这段代码从`numbers`数组索引为2的元素开始进行修改，因此索引值为2与3的元素都会被覆盖；调用`copyWithin()`方法时将第二个参数指定为`0`，表示被赋值的数据从索引值为0的元素开始，一直到没有元素可供复制为止。

默认情况下，`copyWithin()`方法总是会一直复制到数组末尾，不过你还可以提供一个可选参数来限制到底有多少元素会被修改。这第三个参数指定了复制停止的位置（不包括该位置自身），这里有个范例：

```js
let numbers = [1, 2, 3, 4]

// 从索引2的位置开始粘贴
// 从索引0的位置开始复制数据
// 在遇到索引1时停止复制
numbers.copyWithin(2, 0, 1)
console.log(numbers)     // [ 1, 2, 1, 4 ]
```

{% note info %}
类似于`fill()`方法，如果你向`copyWithin()`方法传递负数参数，数组的长度会自动被加到该参数的值上，以便算出正确的索引位置。
{% endnote %}

<!-- # 类型化数组
## 数值数据类型
## 数组缓冲区
## 使用视图操作数组缓冲区
### 获取视图信息
### 读取与写入数据
### 类型化数组即为视图
### 创建特定类型视图

# 类型化数组与常规数组的相似点
## 公共方法
## 相同的迭代器
## of()与from()方法

# 类型化数组与常规数组的区别
## 行为差异
## 遗漏的方法
## 附加的方法 -->
