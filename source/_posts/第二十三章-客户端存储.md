---
title: 第二十三章 客户端存储
categories:
    - JavaScript
    - 《JavaScript高级程序设计》
abbrlink: 4fd0352
date: 2019-05-22 20:39:34
---

# Cookie

## 为什么需要Cookie

以下描述摘抄自[**认识HTTP----Cookie和Session篇**](https://zhuanlan.zhihu.com/p/27669892)

HTTP是无状态协议，说明它不能以状态来区分和管理请求和响应。也就是说，无法根据之前的状态进行本次的请求处理。

我们登陆淘宝的时候首先要登陆，我们看到了一个商品点进去，进行了页面跳转/刷新，按照HTTP的无状态协议岂不是又要登陆一次？

所以为了解决这个问题，Cookie诞生了。

## Cookie简介

{% note info %}
Cookie的使用顺序如下：
1. 浏览器在没有Cookie的状态下向服务器发送请求
2. 服务器在响应头部添加`Set-Cookie`字段，浏览器接收后将其保存下来
3. 浏览器再向该服务器发送请求时，会自动在请求头部添加`Cookie`字段
4. 服务器通过请求头部的`Cookie`认出了发送请求的浏览器

---
Cookie的限制：
- 每个域名下能保存的Cookie个数是有上限的，不同浏览器情况不一样
- Cookie的大小有限制，最好将每个Cookie的限制在4095B（含4095）以内

---
Cookie由浏览器保存的以下几块信息构成：
- **名称**：一个唯一确定Cookie的名称，不区分大小写，然而实践中最好将名称看做是区分大小写的，且名称必须是经过URL编码的
- **值**：储存在Cookie中的字符串值，必须是被URL编码的
- **域**：Cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个Cookie信息
- **路径**：对于指定域中的那个路径，应该向服务器发送Cookie。例如，你可以指定Cookie只有从`https://www.wrox.com/books/`中才能访问，那么`https://www.wrox.com`的页面就不会发送Cookie信息，即使请求都是来自同一个域的
- **失效时间**：表示Cookie何时应该被删除的时间戳。默认情况下，浏览器会话结束时会将所有Cookie删除，不过也可以自己设置删除时间
- **安全标志**：指定后，Cookie只有在使用SSL连接的时候才发送到服务器。例如，Cookie信息只能发送给`https://www.wrox.com`，而`http://www.wrox.com`的请求则不能发送Cookie
- **HttpOnly**：指定后，使用`document.cookie`就无法获取Cookie的内容了

每一段信息都作为`Set-Cookie`的一部分，使用分号加空格号分隔每一段
`Set-Cookie: myCookieName=myCookieValue; domain=.wrox.com; path=/; expires=Mon, 22-Jan-20 00:00:00 GMT; secure; HttpOnly`
{% endnote %}

## JavaScript中的Cookie

在JavaScript中处理Cookie有些复杂，因为其众所周知的蹩脚的接口，即BOM的`document.cookie`属性。这个属性的独特之处在于它会因为使用它的方式不同而表现出不同的行为。

### 读取Cookie

当用来获取属性值时，`document.cookie`返回当前页面可用的（根据Cookie的域、路径、失效时间和安全设置）所有Cookie的字符串，一系列由分号隔开的名值对儿，如下所示：

```md
name1=value1;name2=value2;name3=value3
```

所有名字和值都是经过URL编码的，所以必须使用`decodeURIComponent()`来解码

### 设置Cookie

当用于设置值的时候，`document.cookie`属性可以设置为一个新的Cookie字符串。这个Cookie字符串会被解释并添加到现有的Cookie集合中。设置`document.cookie`并不会覆盖Cookie，除非设置的Cookie的名称已经存在。设置Cookie的格式如下，和`Set-Cookie`头中使用的格式一样。

```js
document.cookie = encodeURIComponent(myCookieName) + '=' + encodeURIComponent(myCookieValue) + '; domain=.wrox.com; path=/; expires=Mon, 22-Jan-20 00:00:00 GMT; secure; HttpOnly'
```

这些参数中，只有名称和值是必需的。

由于JavaScript中读写Cookie不是非常直观，常常需需要写一些函数来简化Cookie的功能。基本的Cookie操作有三种：读取、写入和删除。它们在`CookieUtil`对象中如下表示

```js
var CookieUtil = {
    get: function (name) {
        var cookieName = encodeURIComponent(name) + '=',
            cookieStart = document.cookie.indexOf(cookieName),
            cookieValue = null
        
        if (cookieStart > -1) {
            var cookieEnd = document.cookie.indexOf(';', cookieStart)
            if (cookieEnd == -1) {
                cookieEnd = document.cookie.length
            }

            cookieValue = encodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))

            return cookieValue
        }
    },

    set: function (name, value, expires, path, domain, secure, HttpOnly) {
        var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value)

        if (expires instanceof Date) {
            cookieText += '; expires=' + expires.toGMTString()
        }

        if (path) {
            cookieText += '; path=' + path
        }

        if (domain) {
            cookieText += '; domain=' + domain
        }

        if (secure) {
            cookieText += '; secure=' + secure
        }

        if (HttpOnly) {
            cookieText += '; HttpOnly=' + HttpOnly
        }
    },

    unset: function (name, path, domain, secure, HttpOnly) {
        this.set(name, '', new Date(0), path, domain, secure, HttpOnly)
    }
}
```

### 子Cookie

为了绕开浏览器的单域名下的Cookie数限制，一些开发人员使用了一种称为子Cookie的概念。子Cookie是存放在单个Cookie中的更小的数据，也就是使用Cookie值来存储多个名值对儿。子Cookie最常见的格式如下所示

```md
name=name1=value1&name2=value2&name3=value3
```

# Web存储机制

{% note info %}
Web Storage的目的是克服由Cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目标是：
- 提供一种在Cookie之外存储会话数据的途径
- 提供一种存储大量可以跨会话存在的数据的机制

---
Web Storage包含两种对象的定义：`sessionStorage`和`globalStorage`。这两个对象在支持的浏览器中都是以`window`对象属性的形式存在的。
{% endnote %}

## Storage类型



