---
title: 第二部分 this和对象原型
abbrlink: d213b25d
date: 2019-03-21 20:08:09
  - JavaScript
  - 《你不知道的JavaScript（上卷）》
categories:
---

# 关于this

当一个函数被**调用**时，会创建一个活动记录（执行上下文、执行环境、context）。这个活动记录会包含函数在哪里被调用、函数的调用方法、传入的参数等信息。`this`就是活动记录中的一个属性，会在函数执行的过程中用到。

`this`是在运行时绑定的，它的绑定取决于函数调用时的各种方式。**`this`的绑定和函数的声明位置、函数的调用位置没有任何关系，只取决于函数的调用方式**。

关于`this`是什么有很多说法：函数本身、函数作用域、函数的执行上下文等，这里有的说法是错误的，有的说法不够准确。我觉得就不要纠结`this`到底是什么东西了，`this`就是`this`，你只要知道它的绑定规则和用法，就ok了！

# this全面解析

书里介绍了函数的调用位置，并说理解调用位置对理解`this`的绑定很重要。但其实`this`的绑定与**调用位置**没有任何关系，只与**调用方式**有关。

## 绑定规则

因为`this`的绑定取决于函数的调用方式，所以下面我们从函数的调用方式分析`this`的绑定规则。

### 默认绑定

首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。

默认绑定是指当函数被调用时，是直接使用不带任何修饰的函数引用进行调用的，这种情况下，如果运行在非严格模式中，`this`会绑定到全局对象上。如果运行在严格模式下，`this`会绑定到`undefined`上。

```js
function foo () {
    console.log(this.a)
}
var a = 2
foo()   // 2
```

### 隐式绑定

在调用函数的时候，如果以对象方法的形式进行调用，这个时候`this`就会绑定到这个方法所属的对象上。

```js
function foo () {
    console.log(this.a)
}
var obj = {
    a: 2,
    foo: foo
}
obj.foo()   // 2

// 复杂点的
var obj2 = {
    a: 42,
    obj: obj
}
// foo方法是属于obj的
obj2.obj.foo()  // 2
```

一定要区分开默认绑定和隐式绑定，下面的例子里包含了让人容易忽略的情况。再次强调**`this`的绑定和函数的声明位置、函数的调用位置没有任何关系，只取决于函数的调用方式**。

```js
function foo () {
    console.log(this.a)
}
var obj = {
    a: 2,
    foo: foo,
    other: function () {
        console.log(this.a)     // 2

        // 默认绑定
        foo()   // oops, global
    }
}
var bar = obj.foo
var a = 'oops, global'
// 默认绑定！！！
bar()       // oops, global

// 隐式绑定
obj.other()
```

### 显示绑定

