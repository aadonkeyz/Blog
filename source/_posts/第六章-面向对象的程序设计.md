---
title: 第六章 面向对象的程序设计
categories:
  - JavaScript
  - 《JavaScript高级程序设计》
abbrlink: bb5d40f2
date: 2019-03-08 22:46:34
---

# 理解对象

## 属性类型

### 数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。

{% note info %}
- **[[Configurable]]**：表示能否通过`delete`删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Enumerable]]**：表示能够通过`for-in`循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Writable]]**：表示能否修改属性的值。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Value]]**：包含这个属性的数据值。读取属性值得时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为`undefined`。
{% endnote %}

要修改属性默认的特性，必须使用ES5的`Object.defineProperty()`方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中描述符对象的属性必须是：`configurable`、`enumerable`、`writable`和`value`。

**下面观察一下在两种情况下，这些属性描述符的默认值**。
```js
var obj = { test: 1}
var desc = Object.getOwnPropertyDescriptor(obj, 'test')
console.log(desc)   // {value: 1, writable: true, enumerable: true, configurable: true}

Object.defineProperty(obj, 'demo', {
    configurable: false
})
desc = Object.getOwnPropertyDescriptor(obj, 'demo')
console.log(desc)   // {value: undefined, writable: false, enumerable: false, configurable: false}
```

**关于writable**：当`writable`为`false`时，在非严格模式下通过赋值语句修改属性值，赋值操作将被忽略；在严格模式下则会抛出错误。**但是如果通过Object.defineProperty()方法修改value则不会有任何问题**。

```js
var obj = { test: 1}
Object.defineProperty(obj, 'test', {
    writable: false
})
obj.test = 2
console.log(obj)       // {test: 1}
Object.defineProperty(obj, 'test', {
    value: 3
})
console.log(obj)       // {test: 3}
```
**关于configurable**：当`configurable`为`false`时，不允许删除属性，不允许修改属性的`enumerable`、`configurable`，不可以将`writable`由`false`修改为`true`，但是可以将`writable`由`true`修改为`false`，也可以修改属性的`value`。

**当writable和configurable均为false时，不允许通过任何方式修改属性值，直接赋值或者通过value都不可以！**

```js
// ===============下面的实验运行于非严格模式下======================
var obj = { test: 1}
// 在configurable为false时尝试删除属性
Object.defineProperty(obj, 'test', {
    configurable: false
})
delete obj.test
console.log(obj)        // {test: 1}

var desc = Object.getOwnPropertyDescriptor(obj, 'test')
console.log(desc)       // {value: 1, writable: true, enumerable: true, configurable: false}

// 在configurable为false时尝试修改enumerable
Object.defineProperty(obj, 'test', { // Uncaught TypeError: Cannot redefine property: test
    enumerable: false
})

// 在configurable为false时尝试修改configurable
Object.defineProperty(obj, 'test', { // Uncaught TypeError: Cannot redefine property: test
    configurable: true
})

// 在configurable为false时尝试修改value
Object.defineProperty(obj, 'test', {
    value: '此时configurable为false'
})
console.log(obj)    // {test: "此时configurable为false"}

// 在configurable为false时尝试将writable由true修改为false
Object.defineProperty(obj, 'test', {
    writable: false
})
var desc = Object.getOwnPropertyDescriptor(obj, 'test')
console.log(desc)  // {value: "此时configurable为false", writable: false, enumerable: true, configurable: false}

// 在configurable为false时尝试将writable由false修改为true
Object.defineProperty(obj, 'test', { // Uncaught TypeError: Cannot redefine property: test
    writable: true
})

// 在configurable和writable均为false时，尝试修改属性值
obj.test = '直接赋值可以吗'
console.log(obj)       // {test: "此时configurable为false"}
Object.defineProperty(obj, 'test', { // Uncaught TypeError: Cannot redefine property: test
    value: '通过value可以吗'
})
```

### 访问器属性

访问器属性不包含数据值；它们包含一对儿`getter`和`setter`函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用`getter`函数，这个函数负责返回有效的值；在写入访问器属性时，会调用`setter`函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。

{% note info %}
- **[[Configurable]]**：表示能否通过`delete`删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Enumerable]]**：表示能够通过`for-in`循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Get]]**：在读取属性时调用的函数。默认值为`undefined`；
- **[[Set]]**：在写入属性时调用的函数。默认值为`undefined`。
{% endnote %}

**访问器属性不能直接定义，必须使用Object.defineProperty()来定义。**

```js
var book = {
    _year: 2004,
    edition: 1
}
Object.defineProperty(book, 'year', {
    get: function () {
        return _this.year
    },
    set: function (newValue) {
        if (newValue > 2004) {
            this._year = newValue
            this.edition += newValue - 2004
        }
    }
})
book.year = 2005
console.log(book)   // {_year: 2005, edition: 2}
```

不一定非要同时指定`getter`和`setter`。只指定`getter`意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了`getter`函数的属性会抛出错误。类似地，没有指定`setter`函数的属性也不能读，否则在非严格模式下会返回`undefined`，而在严格模式下狐抛出错误。

**可以通过Object.defineProperty()实现数据属性与访问器属性的转换，但是切记不能同时指定数据属性和访问器属性，这样会抛出错误！**

## 定义多个属性

ES5定义了一个`Object.defineProperties()`方法用来为对象定义多个属性。

```js
var book = {}
Object.defineProperties(book, {
    _year: {
        value
    },
    edition: {
        value: 1
    },
    year: {
        get: function () {
            return _this.year
        },
        set: function (newValue) {
            if (newValue > 2004) {
                this._year = newValue
                this.edition += newValue - 2004
            }
        }
    }
})
```

## 读取属性的特性

使用ES5的`Object.getOwnPropertyDescriptor()`方法可以取得给定属性的描述符。该方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。**这个方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用。**

# 创建对象

## 工厂模式

工厂模式就是调用函数返回一个包含特定属性和方法的对象，工厂模式的问题在于**它没有解决对象识别的问题（即怎样知道一个对象的类型）**。

```js
function createPerson(name, age) {
    var o = {
        name: name,
        age: age,
        sayName: function () {
            console.log(this.name)
        }
    }
    return o
}
var person1 = createPerson('Nicholas', 29)
var person2 = createPerson('Greg', 27)
```

## 构造函数模式

ES中可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，下面使用构造函数模式重写工厂模式中的例子。

```js
function Person(name, age) {
    this.name = name,
    this.age = age,
    this.sayName = function () {
        console.log(this.name)
    }
}
var person1 = new Person('Nicholas', 29)
var person2 = new Person('Greg', 27)
console.log(person1 instanceof Person)  // true
console.log(person2 instanceof Person)  // true
```

在`person1`和`person2`中分别保存着`Person`的不同实例，这两个对象都有一个`constructor`属性，该属性指向`Person`。对象的`constructor`属性最初是用来标识对象类型的，但是提到检测对象类型，还是`instanceof`操作符更可靠一些。创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。

**构造函数模式与工厂模式的区别**：

{% note info %}
- 没有显示地创建对象；
- 直接将属性和方法赋给了`this`对象；
- 没有`return`语句。
{% endnote %}

**要创建`Person`的新实例，必须使用`new`操作符**。以这种方式调用构造函数实际上会经历一下4个步骤：

{% note info %}
1. 创建一个新对象（因为用了`new`）；
2. 将构造函数的作用域赋给新对象（因此`this`就指向了这个新对象）；
3. 执行构造函数的代码（为这个新对象添加属性）；
4. 返回新对象。 
{% endnote %}

构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过`new`操作符来调用，那么它就可以作为构造函数。

构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍，但是有的方法是所有实例都应该共享的，没有创建多次的必要。

## 原型模式

我们创建的每一个函数都有一个`prototype`（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特性类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。

### 理解原型对象

**无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个`prototype`属性，这个属性指向函数的原型对象。**在默认情况下，所有原型对象都会自动获得一个`constructor`（构造函数）属性，这个属性包含一个指向`prototype`属性所在函数的指针。

```js
function Person () {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
    console.log(this.name)
}

var person1 = new Person()
person1.sayName()   // Nicholas
var person2 = new Person()
person2.sayName()   // Nicholas
console.log(person1.sayName === person2.sayName)    // true
```

![6-1理解原型对象](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/6-1%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png)

上图展示了`Person`构造函数、`Person`的原型属性以及`Person`现有的两个实例之间的关系。注意`Person`的每个实例————`person1`和`person2`都包含一个内部属性`[[Prototype]]`，该属性仅仅指向了`Person.prototype`；换句话说，**对象实例与构造函数没有直接的关系**。

{% note info %}
- **isPrototypeOf()**：用于检查传入的对象是否是另一个对象的原型，该方法是从`Object`继承而来的；
- **hasOwnProperty()**：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在，该方法是从`Object`继承而来的；
- **Object.getPropertyOf()**：方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。
{% endnote %}

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例开始，如果在实例中找到了具有给定名字的属性，则返回该属性；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性，如果找到了则返回这个属性的值。

### 属性设置和屏蔽

这一部分内容来自《你不知道的JavaScript（上卷）》 5.1.2。

当用赋值语句给实例对象设置已经在原型链上层存在的同名属性时，会有以下三种情况：

{% note info %}
- 如果在原型链上层存在的同名属性没有被标记为只读（`writable: false`），那么会直接在实例中添加一个同名的新属性，它是屏蔽属性；
- 如果在原型链上层存在的同名属性被标记为只读（`writable: false`），那么无法修改已有属性，也无法在实例对象上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。如果在非严格模式下，赋值语句会被忽略；
- 如果在原型链上层存在的同名属性具有`setter`描述符，那么一定会调用这个`setter`。实例对象上并不会添加新的属性，也不会重新定义这个`setter`。
{% endnote %}

**但是JS这门语言就是贼灵活，如果上述所说的存在于原型链上层的同名属性中保存的是某一个引用类型值的引用，那么你还是可以修改这些引用类型的值的（并没有违反规则，因为保存的引用并没有改变）！比如，这个属性保存的是某一个数组的引用，那么我就可以通过`push`方法去改变这个数组。**

**如果你无论如何也想要屏蔽原型链上层的属性，那么你可以使用`Object.defineProperty()`方法！**

有些情况下会隐式产生屏蔽，一定要当心。思考下面的代码：

```js
var anotherObject = { a: 2 }
var myObject = Object.create(anotherObject)

anotherObject.a     // 2
myObject.a          // 2

anotherObject.hasOwnProperty('a')   // true
myObject.hasOwnProperty('a')        // false

myObject.a++    // 隐式屏蔽！

anotherObject.a     // 2
myObject.a          // 3

myObject.hasOwnProperty('a')        // true
```

### 属性的获取

有两种方式使用`in`操作符：单独使用和在`for-in`循环中使用。

在单独使用时，`in`操作符会在通过对象能够访问给定属性时返回`true`，无论该属性存在于实例中还是原型中。

在使用`for-in`循环时返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包含存在于原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在`for-in`循环中返回。

要取得对象上所有可枚举的实例属性，可以使用ES5的`Object.keys()`方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。

如果你想要得到所有实例属性，无论它是否可枚举，都可以使用`Object.getOwnPropertyNames()`方法。

### 更简单的原型语法

简单来说就是用对象字面量形式来重写`Person.prototype`，但是这样会导致新原型对象的`constructor`属性指向`Object`而不是`Person`，尽管此时`instanceof`操作符还能返回正确的结果，但是通过`constructor`已经无法确定对象的类型了，所以还要用`Object.defineProperty()`方法定义`constructor`的数据属性。

```js
function Person () {}

Person.prototype = {
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    sayName: function () {
        console.log(this.name)
    }
}

var friend = new Person()
console.log(friend instanceof Object)       // true
console.log(friend instanceof Person)       // true
console.log(friend.constructor === Object)  // true
console.log(friend.constructor === Person)  // false

Object.defineProperty(Person.prototype, 'constructor', {
    enumerable: false,
    value: Person
})
```

### 原型的动态性

由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来————即使是**先创建了实例后修改原型**也是如此。

```js
function Person () {}
var friend = new Person ()
Person.prototype.sayHi = function () {
    console.log('hi')
}

friend.sayHi()      // hi
```

但是如果**先创建了实例然后重写整个原型对象**，那么情况就不一样了。具体的变化看图吧!

![6-3重写原型对象](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/6-3%E9%87%8D%E5%86%99%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png)

此时`instanceof`操作符已经不好使了！

```js
function Person () {}
var friend = new Person()
Person.prototype = {
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    sayName: function () {
        console.log(this.name)
    }
}
Object.defineProperty(Person.prototype, 'constructor', {
    enumerable: false,
    value: Person
})
console.log(friend instanceof Object)       // true
console.log(friend instanceof Person)       // false
console.log(friend.constructor === Object)  // false
console.log(friend.constructor === Person)  // true
friend.sayName()              // Uncaught TypeError: friend.sayName is not a function
```

### 原型对象的问题

原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型模式的最大问题。原型模式的最大问题是由其共享的本性所导致的（主要针对引用类型值的属性来说）。

## 组合使用构造函数模式和原型模式

