---
title: 第六章 面向对象的程序设计
categories:
  - JavaScript
  - 《JavaScript高级程序设计》
abbrlink: bb5d40f2
date: 2019-03-08 22:46:34
---

# 理解对象

## 属性类型

### 数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。

{% note info %}
- **[[Configurable]]**：表示能否通过`delete`删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Enumerable]]**：表示能够通过`for-in`循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Writable]]**：表示能否修改属性的值。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Value]]**：包含这个属性的数据值。读取属性值得时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为`undefined`。
{% endnote %}

要修改属性默认的特性，必须使用ES5的`Object.defineProperty()`方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中描述符对象的属性必须是：`configurable`、`enumerable`、`writable`和`value`。

**下面观察一下在两种情况下，这些属性描述符的默认值**。
```js
var obj = { test: 1}
var desc = Object.getOwnPropertyDescriptor(obj, 'test')
console.log(desc)   // {value: 1, writable: true, enumerable: true, configurable: true}

Object.defineProperty(obj, 'demo', {
    configurable: false
})
desc = Object.getOwnPropertyDescriptor(obj, 'demo')
console.log(desc)   // {value: undefined, writable: false, enumerable: false, configurable: false}
```

**关于writable**：当`writable`为`false`时，在非严格模式下通过赋值语句修改属性值，赋值操作将被忽略；在严格模式下则会抛出错误。**但是如果通过Object.defineProperty()方法修改value则不会有任何问题**。

```js
var obj = { test: 1}
Object.defineProperty(obj, 'test', {
    writable: false
})
obj.test = 2
console.log(obj)       // {test: 1}
Object.defineProperty(obj, 'test', {
    value: 3
})
console.log(obj)       // {test: 3}
```
**关于configurable**：当`configurable`为`false`时，不允许删除属性，不允许修改属性的`enumerable`、`configurable`，不可以将`writable`由`false`修改为`true`，但是可以将`writable`由`true`修改为`false`，也可以修改属性的`value`。

**当writable和configurable均为false时，不允许通过任何方式修改属性值，直接赋值或者通过value都不可以！**

```js
// ===============下面的实验运行于非严格模式下======================
var obj = { test: 1}
// 在configurable为false时尝试删除属性
Object.defineProperty(obj, 'test', {
    configurable: false
})
delete obj.test
console.log(obj)        // {test: 1}

var desc = Object.getOwnPropertyDescriptor(obj, 'test')
console.log(desc)       // {value: 1, writable: true, enumerable: true, configurable: false}

// 在configurable为false时尝试修改enumerable
Object.defineProperty(obj, 'test', { // Uncaught TypeError: Cannot redefine property: test
    enumerable: false
})

// 在configurable为false时尝试修改configurable
Object.defineProperty(obj, 'test', { // Uncaught TypeError: Cannot redefine property: test
    configurable: true
})

// 在configurable为false时尝试修改value
Object.defineProperty(obj, 'test', {
    value: '此时configurable为false'
})
console.log(obj)    // {test: "此时configurable为false"}

// 在configurable为false时尝试将writable由true修改为false
Object.defineProperty(obj, 'test', {
    writable: false
})
var desc = Object.getOwnPropertyDescriptor(obj, 'test')
console.log(desc)  // {value: "此时configurable为false", writable: false, enumerable: true, configurable: false}

// 在configurable为false时尝试将writable由false修改为true
Object.defineProperty(obj, 'test', { // Uncaught TypeError: Cannot redefine property: test
    writable: true
})

// 在configurable和writable均为false时，尝试修改属性值
obj.test = '直接赋值可以吗'
console.log(obj)       // {test: "此时configurable为false"}
Object.defineProperty(obj, 'test', { // Uncaught TypeError: Cannot redefine property: test
    value: '通过value可以吗'
})
```

### 访问器属性

访问器属性不包含数据值；它们包含一对儿`getter`和`setter`函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用`getter`函数，这个函数负责返回有效的值；在写入访问器属性时，会调用`setter`函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。

{% note info %}
- **[[Configurable]]**：表示能否通过`delete`删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Enumerable]]**：表示能够通过`for-in`循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为`true`；
- **[[Get]]**：在读取属性时调用的函数。默认值为`undefined`；
- **[[Set]]**：在写入属性时调用的函数。默认值为`undefined`。
{% endnote %}

**访问器属性不能直接定义，必须使用Object.defineProperty()来定义。**

```js
var book = {
    _year: 2004,
    edition: 1
}
Object.defineProperty(book, 'year', {
    get: function () {
        return _this.year
    },
    set: function (newValue) {
        if (newValue > 2004) {
            this._year = newValue
            this.edition += newValue - 2004
        }
    }
})
book.year = 2005
console.log(book)   // {_year: 2005, edition: 2}
```

不一定非要同时指定`getter`和`setter`。只指定`getter`意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了`getter`函数的属性会抛出错误。类似地，没有指定`setter`函数的属性也不能读，否则在非严格模式下会返回`undefined`，而在严格模式下狐抛出错误。

**可以通过Object.defineProperty()实现数据属性与访问器属性的转换，但是切记不能同时指定数据属性和访问器属性，这样会抛出错误！**

## 定义多个属性

ES5定义了一个`Object.defineProperties()`方法用来为对象定义多个属性。

```js
var book = {}
Object.defineProperties(book, {
    _year: {
        value
    },
    edition: {
        value: 1
    },
    year: {
        get: function () {
            return _this.year
        },
        set: function (newValue) {
            if (newValue > 2004) {
                this._year = newValue
                this.edition += newValue - 2004
            }
        }
    }
})
```

## 读取属性的特性

使用ES5的`Object.getOwnPropertyDescriptor()`方法可以取得给定属性的描述符。该方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。**这个方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用。**

# 创建对象

## 工厂模式

工厂模式就是调用函数返回一个包含特定属性和方法的对象，工厂模式的问题在于**它没有解决对象识别的问题（即怎样知道一个对象的类型）**。

```js
function createPerson(name, age) {
    var o = {
        name: name,
        age: age,
        sayName: function () {
            console.log(this.name)
        }
    }
    return o
}
var person1 = createPerson('Nicholas', 29)
var person2 = createPerson('Greg', 27)
```

## 构造函数模式

ES中可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，下面使用构造函数模式重写工厂模式中的例子。

```js
function Person(name, age) {
    this.name = name,
    this.age = age,
    this.sayName = function () {
        console.log(this.name)
    }
}
var person1 = new Person('Nicholas', 29)
var person2 = new Person('Greg', 27)
console.log(person1 instanceof Person)  // true
console.log(person2 instanceof Person)  // true
```

在`person1`和`person2`中分别保存着`Person`的不同实例，这两个对象都有一个`constructor`属性，该属性指向`Person`。对象的`constructor`属性最初是用来标识对象类型的，但是提到检测对象类型，还是`instanceof`操作符更可靠一些。创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。

**构造函数模式与工厂模式的区别**：

{% note info %}
- 没有显示地创建对象；
- 直接将属性和方法赋给了`this`对象；
- 没有`return`语句。
{% endnote %}

**要创建`Person`的新实例，必须使用`new`操作符**。以这种方式调用构造函数实际上会经历一下4个步骤：

{% note info %}
1. 创建一个新对象（因为用了`new`）；
2. 将构造函数的作用域赋给新对象（因此`this`就指向了这个新对象）；
3. 执行构造函数的代码（为这个新对象添加属性）；
4. 返回新对象。 
{% endnote %}

构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过`new`操作符来调用，那么它就可以作为构造函数。

构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍，但是有的方法是所有实例都应该共享的，没有创建多次的必要。

## 原型模式

我们创建的每一个函数都有一个`prototype`（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特性类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。

### 理解原型对象

**无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个`prototype`属性，这个属性指向函数的原型对象。**在默认情况下，所有原型对象都会自动获得一个`constructor`（构造函数）属性，这个属性包含一个指向`prototype`属性所在函数的指针。

```js
function Person () {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
    console.log(this.name)
}

var person1 = new Person()
person1.sayName()   // Nicholas
var person2 = new Person()
person2.sayName()   // Nicholas
console.log(person1.sayName === person2.sayName)    // true
```

![6-1理解原型对象](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/6-1%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png)

上图展示了`Person`构造函数、`Person`的原型属性以及`Person`现有的两个实例之间的关系。注意`Person`的每个实例————`person1`和`person2`都包含一个内部属性`[[Prototype]]`，该属性仅仅指向了`Person.prototype`；换句话说，**对象实例与构造函数没有直接的关系**。

{% note info %}
- **isPrototypeOf()**：用于检查传入的对象是否是另一个对象的原型，该方法是从`Object`继承而来的；
- **hasOwnProperty()**：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在，该方法是从`Object`继承而来的；
- **Object.getPropertyOf()**：方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。
{% endnote %}

### 属性设置和屏蔽

每当代码读取某个对象的某个属性时，都会首先从对象实例本身开始搜索，如果没找到就会去原型对象中找。虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。