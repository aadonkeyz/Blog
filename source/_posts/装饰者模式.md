---
title: 装饰者模式
categories:
    - 设计模式
abbrlink: a708a60d
date: 2019-07-14 20:23:28
---

# 基础概念

![装饰者模式结构](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png)

{% note info %}
1. 装饰者模式：动态地给一个对象添加一些额外的职责。
2. 适用性：
    - 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
    - 处理那些可撤销的职责。
    - 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸式增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。
3. 参与者（未考虑发布订阅模式）：
    - **Component：它是ConcreteComponent和Decorator的共同父类。**
        - 装饰者模式不会改变原有对象的内在，只是在原有对象调用某些方法之前/之后，对这个方法进行装饰。所以要为ConcreteComponent和Decorator定义统一的方法接口。这也是ConcreteComponent和Decorator都继承自Component的原因。
    - **ConcreteComponent（被装饰对象）：它是Component的子类**
        - 定义一个与Component接口一致的接口。
    - **Decorator（装饰者）：它是Component的子类。**
        - 维持一个指向Component对象的指针。
        - 定义一个与Component接口一致的接口。
    - **ConcreteDecorator（具体装饰者）：它是Decorator的子类。**
        - 定义一个与Decorator接口一致的接口，在这个接口内添加装饰、调用上层接口。
{% endnote %}

# 如何实现

{% note info %}
未完待续......
{% endnote %}
