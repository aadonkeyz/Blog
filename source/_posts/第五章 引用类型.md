---
title: 第五章 引用类型
categories:
  - JavaScript
  - 《JavaScript高级程序设计》
abbrlink: 71de0ab2
date: 2019-03-03 12:14:38
---

# Object类型

**我们看到的大多数引用类型值都是Object类型的实例！对，连数组、函数等都是Object类型的实例！**
我所知道的例外有`Object.create(null)`返回的空对象。

{% note info %}
- 创建Object实例方式有：`new Object()`和`对象字面量表示法`；
- 对象属性名一定是`字符串`或`符号`，如果不是，会自动转换为字符串；
- 访问对象属性的方式：`点表示法`和`方括号表示法`。
{% endnote %}

# Array类型

数组的每一项都可以保存任何类型的数据，下面用例子展示下几种创建数组的方式：

```js
// new操作可以省略，即Array()和new Array()效果一样
var a = new Array()                     // a = []
var d = new Array('red')                // c = ['red']
var b = new Array(3)                    // b = [empty × 3]，只传递一个数值，会创建该数值长度的空数组
var c = new Array(3, 4)                 // c = [3, 4]
var e = ['red', 'blue', ]               // 不要这样！会创建一个包含2或3项的数组
var f = Array.apply(null, { length: 3 })  // f = [undefined, undefined, undefined]

// 下面使用ES6语法
var g = Array.from(Array(3).keys())       // g = [0, 1, 2]
var h = [...Array(3).keys()]              // h = [0, 1, 2]
```

**Tips：通过数组的length可以清空或截断数组！**

## 检测数组

ES5提出了Array.isArray()方法来检测数组，不过并不是所有版本的浏览器都兼容这个方法。书中给了兼容各种情况的方法：

```js
function isArray (value) {
    return Object.prototype.toString.call(value) == '[object Array]'
}
```

## 转换方法

这里解释下书中的小小问题，省的读者在这种不关键的地方浪费时间。

![5-2-2转换方法的小瑕疵](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/5-2-2%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95%E7%9A%84%E5%B0%8F%E7%91%95%E7%96%B5.png)

`valueOf`返回的确实是个数组，你看到的字符串是`alert()`方法造成的。

我一般使用`join()`方法进行`数组=>字符串`的转换。

## 栈方法

栈是一种后进先出的数据结构，ECMAScript为数组提供了`push()`和`pop()`方法来实现类似栈的行为。

{% note info %}
- `push()`方法接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度；
- `pop()`方法从数组末尾移除最后一项，减少数组的`length`值，然后返回移除的项。
{% endnote %}

## 队列方法

队列的访问规则是先见先出，可以通过`push()`和`shift()`配合实现。

{% note info %}
- `shift()`方法移除数组中的第一项，将数组长度减1，并返回移除的项；
- `unshift()`方法在数组前端添加任意个项并返回新数组的长度。
{% endnote %}

## 重排序方法

`reverse()`方法会反转数组项的顺序。`sort()`方法默认按升序排列数组项，并且可以接收一个比较函数作为参数。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。

```js
var a = [1, 3, 2, 6]
a.reverse()
console.log(a)    // [6, 2, 3, 1]
a.sort()
console.log(a)    // [1, 2, 3, 6]

// 书中例子
function compare (value1, value2) {
    if (value1 < value2) {
        return 1
    } else if (value1 > value2) {
        return -1
    } else {
        return 0
    }
}

var values = [0, 1, 5, 10, 15]
values.sort(compare)
console.log(values)    // [15, 10, 5, 1, 0]
```

## 操作方法

**`concat()`和`slice()`都不会影响原始数组,但是`splice()`会！**

### concat()

`concat()`方法会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。
如果传递的参数是一个或多个数组，则会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单的添加到结果数组的末尾。

```js
var colors = ['red', 'green', 'blue']
var colors2 = colors.concat('yellow', ['black', 'brown'])

console.log(colors)     // ['red', 'green', 'blue']
console.log(colors2)    // ['red', 'green', 'blue', 'yellow', 'black', 'brown']
```

### slice()

`slice(start, end)`方法返回一个由原数组索引从**start**到**end-1**的项组成的新数组。

{% note info %}
- 如果省略start，则默认从0开始；
- 如果省略end或end大于数组长度，则`slice`方法会一直提取到数组末尾（包括最后一个元素）
- 如果start或end中有负数，则用数组长度加上该数来确定相应的索引。
{% endnote %}

```js
var colors = [1, 2, 3, 4]
var colors2 = colors.slice(1, 3)           // colors2 = [2, 3]
var colors3 = colors.slice(undefined, 3)   // colors3 = [1, 2, 3]
var colors4 = colors.slice(1)              // colors4 = [2, 3, 4]
var colors5 = colors.slice(1, 100)         // colors5 = [2, 3, 4]
var colors6 = colors.slice(1, 2)           // colors6 = [2]
var colors7 = colors.slice(-3, -2)         // colors7 = [2]
```

### splice()

`splice(start, deleteNum, ...replaceItems)`方法返回一个数组，该数组包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。它是最灵活的一个数组操作方法，它可以实现对原始数组的删除、插入和替换操作。

{% note info %}
- start：操作起始位置的索引；
- deleteNum：要删除的项数；
- ...replaceItems：要插入的项,一个或多个。
{% endnote %}

```js
var colors = ['red', 'green', 'blue']
var removed = colors.splice(0, 1)
console.log(colors)        // ['green', 'blue']
console.log(removed)       // ['red']

removed = colors.splice(1, 0, 'yellow', 'orange')
console.log(colors)        // ['green', 'yellow', 'orange', 'blue']
console.log(removed)       // []

removed = colors.splice(1, 1, 'red', 'purple')
console.log(colors)        // ['green', 'red', 'purple', 'orange', 'blue']
console.log(removed)       // ['yellow']
```

## 位置方法

`indexOf()`和`lastIndexOf()`都是找到就返回索引，找不到就返回`-1`。

## 迭代方法

ES5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象————影响`this`的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。

{% note info %}
- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true；
- filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；
- forEach()：对数组中的每一项运行给定函数，这个方法没有返回值；
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组；
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
{% endnote %}

### 第一点注意

**不要忘记这5个迭代方法可以接收第二个参数！**

### 第二点注意

**书中说：“以上方法都不会修改数组中的包含的值”！**
这句话是正确的，但是前提是你不在代码中主动的去通过参数修改原数组！
我在实验中通过修改`item`参数想看看原数组的变化，结果发现`every`方法有些与众不同啊！
我也试验过同时通过修改`item`和`array`参数改变原数组，发现`every`方法还是有些与众不同！
**我的建议是，老老实实用这些方法迭代，不要想去改变原数组（也没有这个必要，还没有重新赋值来的简单），否则结果和预期可能不太一样！**

```js
var testEvery = [1, { num: 2 }, { num: 3 }]
testEvery.every((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testEvery)      // [1, { num: 2 }, { num: 3 }]

var testFilter = [1, { num: 2 }, { num: 3 }]
testFilter.filter((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testFilter)     // [1, { num: 222 }, { num: 3 }]

var testForEach = [1, { num: 2 }, { num: 3 }]
testForEach.forEach((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testForEach)        // [1, { num: 222 }, { num: 3 }]

var testMap = [1, { num: 2 }, { num: 3 }]
testMap.map((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testMap)     // [1, { num: 222 }, { num: 3 }]

var testSome = [1, { num: 2 }, { num: 3 }]
testSome.some((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testSome)       // [1, { num: 222 }, { num: 3 }]
```

## 缩小方法

ES5新增了两个缩小数组的方法：`reduce()`和`reduceRight()`。这两个方法都会迭代数组的所有项，然后返回一个最终值。
这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值。调用的函数接收4个参数：前一个值、当前值、当前索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上！

```js
var values = [1, 2, 3]
var sum1 = values.reduce((prev, cur, index, array) => {
    return prev + cur
})
var sum2 = values.reduce((prev, cur, index, array) => {
    return prev + cur
}, 10)
console.log(sum1, sum2)        // 6 16

var objs = [{a: 1}, {a: 2}, {a: 3}]
var sum3 = objs.reduce((prev, cur, index, array) => {
    return {
        a: prev.a + cur.a
    }
})
var sum4 = objs.reduce((prev, cur, index, array) => {
    return {
        a: prev.a + cur.a
    }
}, {a: 10})
console.log(sum3, sum4)         // {a: 6} {a: 16}
```

# Date类型

通过`var now = new Date()`可以创建一个日期对象，在调用`Data`构造函数而不传参数时，新创建的对象自动获得当前日期和时间（**当前日期和时间是浏览器从本机操作系统获取的时间，所以不一定准确！**）。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间2017年1月1日午夜起至该日期经过的毫秒数）。为了简化这一计算过程，ES提出了两个方法：`Date.parse()`和`Date.UTC()`。

{% note info %}
- Date.parse()：接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。但是它支持哪种日期格式并不一定；
- Date.UTC()：同样返回表示日期的毫秒数，但接收参数分别为年份、**基于0的月份**、月中的哪一天、小时、分钟、秒以及毫秒。这些参数中只有年和月是必需的。
{% endnote %}

其实，在使用`Date()`构造函数创建日期对象时，后台会根据传入的参数自动调用`Date.parse()`或`Date.UTC()`方法，所以根本不需要我们去主动的调用它们。
ES5添加了`Date.now()`方法，返回表示调用这个方法是的日期和时间的毫秒数。在不兼容它的情况下可以使用`+ new Date()`来达到相同的效果。

```js
var now = new Date()
now                    // Mon Mar 04 2019 21:45:43 GMT+0800 (中国标准时间)
now.getFullYear()      // 2019
now.getMonth()         // 0-11
now.getDate()          // 1-31
now.getDay()           // 0-6，0代表周日，6代表周六
now.getHours()         // 0-23
now.getMinutes()       // 0-59
now.getSeconds()       // 0-59
now.getMilliseconds()  // 0-59
```

# RegExp类型

未完待续！
