---
title: 第一部分 作用域和闭包
categories:
  - JavaScript
  - 《你不知道的JavaScript（上卷）》
abbrlink: 107d86cd
date: 2019-03-15 20:50:00
---

# 作用域是什么

## 引擎、编译器、作用域

{% note info %}
- **引擎**：从头到尾负责整个JavaScript程序的编译及执行过程；
- **编译器**：JavaScript的编译发生在代码执行前的几微秒（甚至更短！）的时间内，负责语法分析及代码生成的就是编译器；
- **作用域**：一套设计良好的、用来存储变量并能够根据名称方便地查找这些变量的规则。
{% endnote %}

以`var a = 2`为例，实际上引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。

{% note info %}
1. 首先，当遇到`var a`时编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中（也就是说在**当前作用域**中该变量是否已经存在）。如果是，编译器会忽略该声明，否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为`a`;
2. 接下来，编译器会为引擎生成运行时所需的代码，这些代码被用来处理`a = 2`这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做`a`的变量，如果是，引擎会使用这个变量；否则引擎会继续在外层作用域中查找该变量。
{% endnote %}

## 作用域嵌套和作用域链

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。当引擎查找某个变量时，首先从当前作用域开始查找，如果可以找到则返回该变量。如果在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

那么引擎怎么知道当前作用域的外层作用域是谁，又该怎么找到它呢？答案是通过[作用域链](https://aadonkeyz.com/posts/9b1cd8c7/)！

## LHS和RHS

简单地说（不准确的说）：当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。

然而实际中很多情况下用到变量时，并没有赋值操作符，所以我们要更准确的描述。

{% note info %}
- **LHS**：试图找到变量的**容器本身**，并对其进行**赋值**；
- **RHS**：找到该变量**对应的值**，并**使用**这个值。
{% endnote %}

Tips：书中说到将函数声明理解为先声明变量、再进行赋值并不合适。因为这样理解的话这个函数声明将需要进行LHS查询，但实际中并不是这样的。

为什么区分LHS和RHS是一件很重要的事情？因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

如果RHS查询不到所需的变量，引擎就会抛出ReferenceError异常。

相比之下，当LHS查询不到变量时，如果在非严格模式下，就会在**全局作用域**中创建一个具有该名称的变量。但如果是在非严格模式下，就会抛出错误。

# 词法作用域

词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的，不过存在例外）。

**无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。**

词法作用域查找只会查找一级标识符，例如如果代码中引用了`foo.bar.baz`，词法作用域查找只会试图查找`foo`标识符，找到这个变量之后，它就不管了，后续的`bar`和`baz`标识符的查找被交给对象属性访问规则了。

`eval()`和`with`的使用都会欺骗词法作用域，如果引擎在代码中发现了`eval()`或`with`，它只能简单地假设关于标识符为止的判断都是无效的，因为无法确定`eval()`或`with`会带来什么样的影响。这样造成的结果就是引擎无法在编译阶段完成一些性能的优化从而造成性能下降。

# 函数作用域和块作用域

## 函数作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

根据作用域嵌套和作用域链的概念可以知晓，内部作用域可以访问外部作用域中的变量，但是反过来则不可以。

```js
var outter = '我在外面'
function foo () {
    var inner = '我在里面'
    console.log(outter)
}
foo()       // 我在外面
console.log(inner)  // Uncaught ReferenceError: inner is not defined
```

我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。

```js
var a = 2
function foo () {
    var a = 3
    console.log(a)
}
foo()           // 3
console.log(a)  // 2
```

虽然这种技术可以解决一些问题，但是也产生了一些副作用。首先必须声明一个具名函数`foo()`，意味着`foo`这个名称本身“污染”了所在作用域，其次必须显示地调用`foo()`。下面介绍一种解决这两个问题的例子：

```js
var a = 2;
(function foo () {
    var a = 3
    console.log(a)  // 3
    console.log(typeof foo)    // function
})()
console.log(a)  // 2
console.log(foo)    // Uncaught ReferenceError: foo is not defined
```

首先，包装函数的声明是以圆括号开始的，尽管开上去这并不是一个很显眼的细节，但实际上确实非常重要的区别。函数会被当做函数表达式而不是一个标准的函数声明来处理。

**函数声明和函数表达式之间最重要的区别是它们的名称标识符会绑定在何处！**

**函数声明的名称标识符会存在于所在的作用域中。而函数表达式的名称标识符只能在这个函数的内部被访问，外部作用域则不行。**

上面的代码中使用了IIFE：立即执行函数表达式。在一个函数表达式后面加上一对圆括号就表示要立即调用这个函数。

## 块作用域

### with

用`with`从对象中创建出的作用域仅在`with`声明中而非外部作用域中有效。

### try/catch

非常少有人会注意到ES3规范中规定`try/catch`的`catch`分句会创建一个块作用域，其中声明的变量仅在`catch`内部有效。例如：

```js
try {
    undefined()         // 执行一个非法操作来强制制造一个异常
}
catch (err) {
    console.log(err)    // 能够正常执行！
}

console.log(err)        // ReferenceError: err not found
```

### let和const

ES6中引入了新的`let`关键字，提供了除`var`以外的另一种变量声明方式。`let`关键字可以将变量绑定到所在的任意作用域中（通常是{...}内部）。

```js
var foo = true
if (foo) {
    let bar = 2
    console.log(bar)    // 2
}
console.log(bar)        // Uncaught ReferenceError: bar is not defined
```

`const`和`let`的性质类似，唯一的区别在于`const`是用来定义常量的。有关它们的特性后续会在ES6中详细描述。

# 提升

## 如何提升

提升：包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。但是只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。

另外值得注意的是，每个作用域都会进行提升操作。

```js
// ========实际代码=========
foo()
function foo() {
    console.log(a)
    var a = 2
}

// =====编译器眼中的代码=====
function foo() {
    var a
    console.log(a)
    a = 2
}
foo()
```

函数声明会被提升，但是函数表达式不会，即便是具名的函数表达式（命名函数表达式）的名称标识符在赋值之前也无法在所在作用域中使用。

```js
foo()   // TypeError
bar()   // ReferenceError
var foo = function bar () {
    // ...
}

// 提升后
var foo
foo()   // TypeError
bar()   // ReferenceError
foo = function () {
    var bar = ...self...
    // ...
}
```

## 函数优先

函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。

```js
foo ()      // 1
var foo
function foo () {
    console.log(1)
}
foo = function () {
    console.log(2)
}

// 提升后
function foo () {
    console.log(1)
}
foo ()      // 1
foo = function () {
    console.log(2)
}
```

注意到，`var foo`尽管出现在`function foo()`的声明之前，但是函数声明会首先被提升，所以`var foo`被当作重复的声明而忽略了。

如果有重复的函数声明，后面的会覆盖前面的，看下面例子：

```js
foo()       // 3
function foo () {
    console.log(1)
}
var foo = function () {
    console.log(2)
}
function foo () {
    console.log(3)
}
```

# 作用域闭包

## 什么是闭包

闭包：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

```js
function foo () {
    var a = 2
    function bar () {
        console.log(a)
    }
    return bar
}
var baz = foo()
baz()       // 2——————这就是闭包的效果
```

在`foo()`执行后，通常会将`foo()`的整个内部作用域都销毁，但是由于闭包的存在，`foo()`的内部作用域被保存下来了。拜`bar()`所声明的位置所赐，它拥有涵盖`foo()`内部作用域的闭包，使得该作用域能够一直存活，以供`bar()`在之后任何时间进行引用。

## 循环和闭包

要说明闭包，`for`循环是最常见的例子。

```js
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer () {
        console.log(i)
    }, i * 1000)
}
```

我们期望上面的代码会分别输出数字1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次6。不要着急，接着看下面的例子：

```js
for (var i = 1; i <= 5; i++) {
    (function (j) {
        setTimeout(function timer () {
            console.log(j)
        }, j * 1000)
    })(i)
}
```

原因自己寻思一下吧，寻思不明白的话[**点这里**](https://aadonkeyz.com/posts/f1587c53/)，看里面的闭包部分，我有点懒得再写一遍了。

## 模块

```js
function CoolModule () {
    var something = 'cool'
    var another = [1, 2, 3]

    function doSomething () {
        console.log(something)
    }
    funcion doAnother () {
        console.log(another.join('!'))
    }

    return {
        doSomething: doSomething,
        doAnother: doAnother
    }
}

var foo = CoolModule()

foo.doSomething()   // cool
foo.doAnother()     // 1!2!3!
```

上述模式在JavaScript中被称为模块，最常见的实现模块模式的方法被称为模块暴露，这里展示的是其变体。

首先，`CoolModule()`只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。

其次，`CoolModule()`返回一个用对象字面量语法来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看做本质上是模块的公共API。

如果要更简单的描述，模块模式需要具备两个必要条件：

{% note info %}
- 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）；
- 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。
{% endnote %}

基于函数的模块并不是一个能被稳定识别的模式（编译器无法识别），它们的API语义只有在运行时才会被考虑进去。因此可以在运行时修改一个模块的API。相比之下，ES6模块API更加稳定。