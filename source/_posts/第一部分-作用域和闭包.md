---
title: 第一部分 作用域和闭包
categories:
  - JavaScript
  - 《你不知道的JavaScript（上卷）》
abbrlink: 107d86cd
date: 2019-03-15 20:50:00
---

# 作用域是什么

## 引擎、编译器、作用域

{% note info %}
- **引擎**：从头到尾负责整个JavaScript程序的编译及执行过程；
- **编译器**：JavaScript的编译发生在代码执行前的几微秒（甚至更短！）的时间内，负责语法分析及代码生成的就是编译器；
- **作用域**：一套设计良好的、用来存储变量并能够根据名称方便地查找这些变量的规则。
{% endnote %}

以`var a = 2`为例，实际上引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。

{% note info %}
1. 首先，当遇到`var a`时编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中（也就是说在**当前作用域**中该变量是否已经存在）。如果是，编译器会忽略该声明，否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为`a`;
2. 接下来，编译器会为引擎生成运行时所需的代码，这些代码被用来处理`a = 2`这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做`a`的变量，如果是，引擎会使用这个变量；否则引擎会继续在外层作用域中查找该变量。
{% endnote %}

## 作用域嵌套和作用域链

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

那么引擎怎么知道当前作用域的外层作用域是谁，又该怎么找到它呢？答案是通过[作用域链](https://aadonkeyz.com/posts/9b1cd8c7/)！

## LHS和RHS

简单地说（不准确的说）：当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。

然而实际中很多情况下用到变量时，并没有赋值操作符，所以我们要更准确的描述。

{% note info %}
- **LHS**：试图找到变量的**容器本身**，并对其进行**赋值**；
- **RHS**：找到该变量**对应的值**，并**使用**这个值。
{% endnote %}

Tips：书中说到将函数声明理解为先声明变量、再进行赋值并不合适。因为这样理解的话这个函数声明将需要进行LHS查询，但实际中并不是这样的。

为什么区分LHS和RHS是一件很重要的事情？因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

如果RHS查询不到所需的变量，引擎就会抛出ReferenceError异常。

相比之下，当LHS查询不到变量时，如果在非严格模式下，就会在**全局作用域**中创建一个具有该名称的变量。但如果是在非严格模式下，就会抛出错误。