---
title: 第五章 引用类型
categories:
    - JavaScript
    - 《JavaScript高级程序设计》
abbrlink: 71de0ab2
date: 2019-03-03 12:14:38
---

# Object类型

**我们看到的大多数引用类型值都是Object类型的实例！对，连数组、函数等都是Object类型的实例！**

我所知道的例外有`Object.create(null)`返回的空对象。

{% note info %}
- 创建Object实例方式有：`new Object()`和`对象字面量表示法`；
- 对象属性名一定是`字符串`或`符号`，如果不是，会自动转换为字符串；
- 访问对象属性的方式：`点表示法`和`方括号表示法`。
{% endnote %}

# Array类型

数组的每一项都可以保存任何类型的数据，下面用例子展示下几种创建数组的方式：

```js
// new操作可以省略，即Array()和new Array()效果一样
var a = new Array()                     // a = []
var b = Array('red')                    // b = ['red']
var c = Array(3)                        // c = [empty × 3]，只传递一个数值，会创建一个有length属性的数组，但内部空空如也，无法进行迭代等操作
var d = Array(3, 4)                     // d = [3, 4]
var e = ['red', 'blue', ]               // 不要这样！会创建一个包含2或3项的数组
var f = Array.apply(null, { length: 3 })  // f = [undefined, undefined, undefined]

// 下面使用ES6语法
var g = Array.from(Array(3).keys())       // g = [0, 1, 2]
var h = Array.from(Array(3), () => 1)     // h = [1, 1, 1]
var i = [...Array(3).keys()]              // i = [0, 1, 2]
```

**Tips：通过数组的length可以清空或截断数组！**
{% note info %}
- 通过数组的length可以清空或截断数组;
- 数组会自动将字符串索引转换为对应数值索引，即`array['0'] === array[0]`。
{% endnote %}

## 检测数组

ES5提出了Array.isArray()方法来检测数组，不过并不是所有版本的浏览器都兼容这个方法。书中给了兼容各种情况的方法：

```js
function isArray (value) {
    return Object.prototype.toString.call(value) == '[object Array]'
}
```

## 转换方法

这里解释下书中的小小问题，省的读者在这种不关键的地方浪费时间。

![5-2-2转换方法的小瑕疵](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/5-2-2%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95%E7%9A%84%E5%B0%8F%E7%91%95%E7%96%B5.png)

`valueOf`返回的确实是个数组，你看到的字符串是`alert()`方法造成的。

我一般使用`join()`方法进行**数组=>字符串**的转换。`join()`接收一个字符串作为参数，然后以该字符串为分隔符将数组（或类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组中只有一个元素，那么将返回该元素的字符串形式而不使用分隔符。如果没有给`join()`传递参数，则默认使用`,`作为分隔符

```js
var elements = ['Fire', 'Air', 'Water']

console.log(elements.join())
// expected output: "Fire,Air,Water"

console.log(elements.join(''))
// expected output: "FireAirWater"

console.log(elements.join('-'))
// expected output: "Fire-Air-Water"
```

## 栈方法

栈是一种后进先出的数据结构，ECMAScript为数组提供了`push()`和`pop()`方法来实现类似栈的行为。

{% note info %}
- `push()`方法接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度；
- `pop()`方法从数组末尾移除最后一项，减少数组的`length`值，然后返回移除的项。
{% endnote %}

## 队列方法

队列的访问规则是先见先出，可以通过`push()`和`shift()`配合实现。

{% note info %}
- `shift()`方法移除数组中的第一项，将数组长度减1，并返回移除的项；
- `unshift()`方法在数组前端添加任意个项并返回新数组的长度。
{% endnote %}

## 重排序方法

`reverse()`方法会反转数组项的顺序。`sort()`方法默认按升序排列数组项，并且可以接收一个比较函数作为参数。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。

```js
var a = [1, 3, 2, 6]
a.reverse()
console.log(a)    // [6, 2, 3, 1]
a.sort()
console.log(a)    // [1, 2, 3, 6]

// 书中例子
function compare (value1, value2) {
    if (value1 < value2) {
        return 1
    } else if (value1 > value2) {
        return -1
    } else {
        return 0
    }
}

var values = [0, 1, 5, 10, 15]
values.sort(compare)
console.log(values)    // [15, 10, 5, 1, 0]
```

## 操作方法

**`concat()`和`slice()`都不会影响原始数组,但是`splice()`会！**

### concat()

`concat()`方法会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。
如果传递的参数是一个或多个数组，则会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单的添加到结果数组的末尾。

```js
var colors = ['red', 'green', 'blue']
var colors2 = colors.concat('yellow', ['black', 'brown'])

console.log(colors)     // ['red', 'green', 'blue']
console.log(colors2)    // ['red', 'green', 'blue', 'yellow', 'black', 'brown']
```

### slice()

`slice(start, end)`方法返回一个由原数组索引从**start**到**end-1**的项组成的新数组。

{% note info %}
- 如果省略start，则默认从0开始；
- 如果省略end或end大于数组长度，则`slice`方法会一直提取到数组末尾（包括最后一个元素）
- 如果start或end中有负数，则用数组长度加上该数来确定相应的索引。
{% endnote %}

```js
var colors = [1, 2, 3, 4]
var colors2 = colors.slice(1, 3)           // colors2 = [2, 3]
var colors3 = colors.slice(undefined, 3)   // colors3 = [1, 2, 3]
var colors4 = colors.slice(1)              // colors4 = [2, 3, 4]
var colors5 = colors.slice(1, 100)         // colors5 = [2, 3, 4]
var colors6 = colors.slice(1, 2)           // colors6 = [2]
var colors7 = colors.slice(-3, -2)         // colors7 = [2]
```

### splice()

`splice(start, deleteNum, ...replaceItems)`方法返回一个数组，该数组包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。它是最灵活的一个数组操作方法，它可以实现对原始数组的删除、插入和替换操作。

{% note info %}
- start：操作起始位置的索引；
- deleteNum：要删除的项数；
- ...replaceItems：要插入的项,一个或多个。
{% endnote %}

{% note warning %}
**注意它的返回值！！！不要犯低级错误！！！**
{% endnote %}

```js
var colors = ['red', 'green', 'blue']
var removed = colors.splice(0, 1)
console.log(colors)        // ['green', 'blue']
console.log(removed)       // ['red']

removed = colors.splice(1, 0, 'yellow', 'orange')
console.log(colors)        // ['green', 'yellow', 'orange', 'blue']
console.log(removed)       // []

removed = colors.splice(1, 1, 'red', 'purple')
console.log(colors)        // ['green', 'red', 'purple', 'orange', 'blue']
console.log(removed)       // ['yellow']
```

## 位置方法

`indexOf(searchValue[, fromIndex])`和`lastIndexOf(searchValue[, fromIndex])`都是找到就返回索引，找不到就返回`-1`。

## 迭代方法

ES5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象————影响`this`的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。

{% note info %}
- **every()**：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true；
- **filter()**：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；
- **forEach()**：对数组中的每一项运行给定函数，这个方法没有返回值；
- **map()**：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组；
- **some()**：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
{% endnote %}

### 第一点注意

**不要忘记这5个迭代方法可以接收第二个参数！**

### 第二点注意

**书中说：“以上方法都不会修改数组中的包含的值”！**

这句话是正确的，但是前提是你不在代码中主动的去通过参数修改原数组！
我在实验中通过修改`item`参数想看看原数组的变化，结果发现`every`方法有些与众不同啊！
我也试验过同时通过修改`item`和`array`参数改变原数组，发现`every`方法还是有些与众不同！

**我的建议是，老老实实用这些方法迭代，不要想去改变原数组，否则结果和预期可能不太一样！**

```js
var testEvery = [1, { num: 2 }, { num: 3 }]
testEvery.every((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testEvery)      // [1, { num: 2 }, { num: 3 }]

var testFilter = [1, { num: 2 }, { num: 3 }]
testFilter.filter((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testFilter)     // [1, { num: 222 }, { num: 3 }]

var testForEach = [1, { num: 2 }, { num: 3 }]
testForEach.forEach((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testForEach)        // [1, { num: 222 }, { num: 3 }]

var testMap = [1, { num: 2 }, { num: 3 }]
testMap.map((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testMap)     // [1, { num: 222 }, { num: 3 }]

var testSome = [1, { num: 2 }, { num: 3 }]
testSome.some((item, index, array) => {
    if (index === 0) {
        item = 111
    }
    if (index === 1) {
        item.num = 222
    }
    if (index === 2) {
        item = { num: 333 }
    }
})
console.log(testSome)       // [1, { num: 222 }, { num: 3 }]
```

## 缩小方法

{% note info %}
ES5新增了两个缩小数组的方法：`reduce(callback[, initialValue])`和`reduceRight(callback[, initialValue])`。这两个方法都会迭代数组的所有项，然后返回一个最终值。
下面以`reduce()`方法为例进行介绍：
1. **callback(accumulator, currentValue[, index[, array]])**：该回调函数会在数组中进行迭代，它的返回值将传递给下一次迭代的`accumulator`参数，它的参数介绍如下：
    - **accumulator**：上一次迭代的返回值；
    - **currentValue**：迭代的当前值；
    - **index**：当前索引；
    - **array**：数组对象。
2. **initialValue**：作为`callback()`进行第一次迭代时`accumulator`的值。如果没有传入这个参数，那么`callback()`在第一次迭代时会将数组的第一项作为`accumulator`的值。
{% endnote %}

```js
var values = [1, 2, 3]
var sum1 = values.reduce((prev, cur, index, array) => {
    console.log('prev: ' + prev, 'cur: ' + cur, 'index: ' + index)
    return prev + cur
})
// prev: 1 cur: 2 index: 1
// prev: 3 cur: 3 index: 2

var sum2 = values.reduce((prev, cur, index, array) => {
    console.log('prev: ' + prev, 'cur: ' + cur, 'index: ' + index)
    return prev + cur
}, 10)
// prev: 10 cur: 1 index: 0
// prev: 11 cur: 2 index: 1
// prev: 13 cur: 3 index: 2

console.log(sum1)       // 6
console.log(sum2)       // 16
```

# Date类型

通过`var now = new Date()`可以创建一个日期对象，在调用`Data`构造函数而不传参数时，新创建的对象自动获得当前日期和时间（**当前日期和时间是浏览器从本机操作系统获取的时间，所以不一定准确！**）。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间2017年1月1日午夜起至该日期经过的毫秒数）。为了简化这一计算过程，ES提出了两个方法：`Date.parse()`和`Date.UTC()`。

{% note info %}
- **Date.parse()**：接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。但是它支持哪种日期格式并不一定；
- **Date.UTC()**：同样返回表示日期的毫秒数，但接收参数分别为年份、**基于0的月份**、月中的哪一天、小时、分钟、秒以及毫秒。这些参数中只有年和月是必需的。
{% endnote %}

其实，在使用`Date()`构造函数创建日期对象时，后台会根据传入的参数自动调用`Date.parse()`或`Date.UTC()`方法，所以根本不需要我们去主动的调用它们。
ES5添加了`Date.now()`方法，返回表示调用这个方法时的日期和时间的毫秒数。在不兼容它的情况下可以使用`+ new Date()`来达到相同的效果。

```js
var now = new Date()
now                    // Mon Mar 04 2019 21:45:43 GMT+0800 (中国标准时间)
now.getFullYear()      // 2019
now.getMonth()         // 0-11
now.getDate()          // 1-31
now.getDay()           // 0-6，0代表周日，6代表周六
now.getHours()         // 0-23
now.getMinutes()       // 0-59
now.getSeconds()       // 0-59
now.getMilliseconds()  // 0-59
```

# RegExp类型

正则表达式可以通过`var expression = /pattern/flags`的字面量形式来创建。其中的`pattern`代表任何简单或复杂的正则表达式，`flag`代表一个或多个标志。

{% note info %}
- **g**：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
- **i**：表示不区分大小写模式；
- **m**：表示多行模式。
{% endnote %}

同样也支持使用`RegExp`构造函数来创建正则表达式，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。要注意的是，**传递给`RegExp`构造函数的两个参数都是字符串**（不能把正则表达式字面量传递给`RegExp`构造函数）。

```js
// pattern1和pattern2的作用是完全一样的
var pattern1 = /[bc]at/i
var pattern2 = new RegExp('[bc]at', 'i')
```

下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp构造函数定义相同模式时使用的字符串。

| 字面量模式 | 等价的字符串 |
| --------- | ----------- |
| /\\[bc\\]at/ | "\\\\[bc\\\\]at" |
| /\\.at/ | "\\\\.at" |
| /name\\/age/ | "name\\\\/age" |
| /\\d.\\d{1, 2} | "\\\\d.\\\\d{1, 2}" |
| /\\w\\\\hello\\\\123/ | "\\\\w\\\\\\\\hello\\\\\\\\123" |

## exec()方法

`exec()`方法是专门为捕获组而设计的。接收要应用模式的字符串作为参数，返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回`null`。返回的数组虽然是`Array`的实例，但包含两个额外的属性：`index`和`input`。其中，`index`表示匹配项在字符串中的位置，而`input`表示应用正则表达式的字符串。在返回的数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。

```js
// 书中的例子
var text = 'mom and dad and baby'
var pattern = /mom (and dad (and baby)?)?/gi

var matches = pattern.exec(text)
console.log(matches.index)      // 0
console.log(matches.input)      // 'mom and dad and baby'
console.log(matches[0])         // 'mom and dad and baby'
console.log(matches[1])         // 'and dad and baby'
console.log(matches[2])         // 'and baby'
```

对于`exec()`方法而言，它每次只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用`exec()`将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用`exec()`则会在字符串中继续查找新的匹配项。

## test()方法

`test()`方法接收一个字符串参数，在模式与该参数匹配的情况下返回`true`，否则返回`false`。

# Function类型

创建函数有三种方式：函数声明语法、函数表达式和使用`Function`构造函数。

## 函数声明与函数表达式

它们的区别在于使用函数声明创建的函数会经历一个叫做**函数声明提升**的过程，而函数表达式创建的函数则不会。

```js
console.log(sum1(10, 10))       // 20
console.log(sum2(10, 10))       // Uncaught ReferenceError: sum2 is not defined
function sum1(num1, num2) {
    return num1 + num2
}
sum2 = function (num1, num2) {
    return num1 + num2
}
```

## 作为值的函数

ES中函数名本身就是变量，所以可以将一个函数作为参数传递给另一个函数，也可以将一个函数作为另一个函数的返回值。

**函数名后不加圆括号表示的是函数的引用，加上圆括号表示执行函数！**

```js
var a = function (num) {
    return num + 1
}
console.log(a(1))       // 2
console.log(a)          // f (num) { return num + 1 }
```

## 函数属性和方法

ES中的函数是对象，因此函数也有属性和方法。

### 属性

{% note info %}
- **length属性**：表示函数希望接收的命名参数的个数；
- **prototype属性**：后续会详细介绍，此处知道该属性是不可枚举的，使用`for-in`无法发现即可。
{% endnote %}

### 方法

每个函数都包含两个非继承而来的方法：`apply()`和`call()`方法。这两个方法的用途都是在特定的作用于中调用函数，实际上等于设置函数体内的`this`值。关于`this`对象，我们暂时记住，在全局函数中，`this`等于`window`对象，而当函数被作为某个对象方法调用时，`this`等于那个对象。

{% note info %}
- **apply()方法**：接收两个参数：一个是用来指定`this`值，另一个是参数数组。其中第二个参数可以是`Array`的实例，也可以是`arguments`对象。
- **call()方法**：与`apply()`方法的区别在于接收参数的方式，它的第一个参数同样是用来指定`this`值，但是后续传入的所有参数均会直接传递给函数。换句话说，在使用`call()`方法时，传给函数的参数必须逐个列举出来。
- **bind()方法**：该方法会创建一个函数的实例，其`this`值会被绑定到传递给`bind()`函数的值。该方法常常被用于函数柯里化。
{% endnote %}

**如果用来指定`this`值的参数是基本数据类型，那么这个基本类型值会被转换为对应的基本包装类型（new String()、 new Boolean()等）。**

# 基本包装类型

ES提供了3个**特殊的引用类型**：`Boolean`、`Number`和`String`。这些类型与引用类型相似，但同时也具有与各自的基本类型相应的特殊行为，我们称它们为基本包装类型。

**实际上，每当读取一个基本类型值的时候，后台会自动创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。**

**引用类型与基本包装类型的主要区别就是对象的生存期。**使用`new`操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而**自动创建**的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。

```js
var s1 = 'some text'        // 创建了一个基本类型值并保存在s1中
s1.color = 'red'            // 调用对应的基本包装类型
console.log(s1.color)       // undefined，因为基本包装类型的生存期已过
console.log(typeof s1)      // string

var s2 = new String('some text')    // 显示的创建了String的实例对象并保存在s2中，实际上就是创建了一个引用类型值
s2.color = 'red'
console.log(s2)             // String {"some text", color: "red"}
console.log(typeof s2)      // object
```

通过上面例子认识到通过`new`显示创建的就是一个引用类型值，它已经不能称之为基本包装类型了。换句话说，基本包装类型都是后台自己创建的，不存在显示创建的情况。在第六章会介绍，通过`new`显示创建的就是一个引用类型的实例对象。**记住最好别用new将基本包装类型给实例化就行。**

**要注意的是，使用`new`调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。**

```js
var value = '25'
var number = Number(value)      // 转型函数
console.log(typeof number)      // number

var obj = new Number(value)     // 构造函数
console.log(typeof obj)         // object
```

## Boolean类型

没啥说的。

## Number类型

{% note info %}
- **toFixed()方法**：按照指定的小数位返回数值的字符串表示，银行家喜欢用这个方法，这个方法不是真正意义的四舍五入；
- **toExponential()**：返回以指数表示法表示的数值的字符串形式；
- **toPrecision()**：返回固定大小格式，也可能返回指数格式。
{% endnote %}

## String类型

### 字符方法

`charAt()`和`charCodeAt()`方法都接收一个参数，即基于0的字符位置。`charAt()`方法以单字符字符串的形式返回给定位置的那个字符，而`charCodeAt()`方法返回的是字符编码。

```js
var string = 'hello world'
console.log(string.charAt(1))       // e
console.log(string.charCodeAt(1))   // 101
```

ES5还定义了访问个别字符的方法，可以像数组那样使用索引来访问某个位置的字符。

```js
var string = 'hello'
console.log(string[1])      // e
```

### 字符串操作方法

**下面所列的四个方法，返回值均是被操作字符串的子字符串。并且这些方法都不会对原始字符串产生任何影响。**

{% note info %}
- **concat()方法**：类比于数组的`concat()`方法；
- **slice()方法**：类比于数组的`slice()`方法；
- **substr()方法**：第一个参数用于指定子字符串的开始位置，第二个参数用于指定返回的字符个数;
- **substring()方法**：类比于数组的`slice()`方法。
{% endnote %}

当传递负值作为参数时，`slice()`方法会将传入的负值与字符串的长度相加；`substr()`方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0；`substring()`方法会把所有负值参数都转换为0。

**另外需要注意的是，`substring()`方法会将参数中较小的数作为开始位置，将较大的数作为结束位置。即`string.substring(3, 0)`等价于`string.substring(0, 3)`**。

```js
var string = 'hello world'

console.log(string.slice(-3))           // rld
console.log(string.substring(-3))       // hello world
console.log(string.substr(-3))          // rld

console.log(string.slice(3, -4))        // lo w
console.log(string.substring(3, -4))    // hel
console.log(string.substr(3, -4))       // ''
```

### 字符串位置方法

`indexOf(searchValue[, fromIndex])`和`lastIndexOf(searchValue[, fromIndex])`都是找到就返回索引，找不到就返回`-1`。

### trim()方法

ES5定义了这个方法，会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。

### 字符串大小写转换方法

`toLowerCase()`、`toLocaleLowerCase()`、`toUpperCase()`和`toLocaleUpperCase()`方法。

### 字符串的模式匹配方法

{% note info %}
- `match()`：字符串的`match()`方法与正则表达式的`exec()`方法类似，区别在于`string.match(pattern)`和`pattern.exec(string)`；
- `search()`：接收正则表达式作为参数，返回字符串中第一个匹配项的索引，如果没有找到匹配项则返回-1；
- `replace()`：该方法接收两个参数，第一个参数可以是正则表达式或一个字符串，第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的办法就是提供正则表达式作为第一参数，并且要指定全局标志。第二个参数与正则表达式的捕获组有关，[**详情看MDN**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace)；
- `split()`：该方法可以基于指定的分隔符将一个字符串分割成多个子字符串并将结果存放在一个数组中。分隔符可以是字符串，也可以是一个正则表达式。该方法有一个可选的第二参数，用于指定数组的大小。**如果将空字符串作为分隔符传递给`split()`，那么字符串会基于每一个`UTF-16 codeunit`进行划分。如果传递给`split()`的正则表达式中包含捕获组，那么捕获组会被保留下来**
{% endnote %}

```js
var text = 'cat, bat, sat, fat'
var result = text.replace('at', 'ond')
console.log(result)     // cond, bat, sat, fat

result = text.replace(/at/g, 'ond')
console.log(result)     // cond, bond, sond, fond

result = text.replace(/(.at)/g, 'word ($1)')
console.log(result)     // word (cat), word (bat), word (sat), word (fat)


var colorText = 'red,blue,green,yellow'
console.log(colorText.split(','))           // [ 'red', 'blue', 'green', 'yellow' ]
console.log(colorText.split(',', 2))        // [ 'red', 'blue' ]
console.log(colorText.split(/\,/))          // [ 'red', 'blue', 'green', 'yellow' ]
console.log(colorText.split(/(\,)/))        // [ 'red', ',', 'blue', ',', 'green', ',', 'yellow' ]
console.log(colorText.split(/[^\,]+/))      // [ '', ',', ',', ',', '' ]
console.log(colorText.split(/([^\,]+)/))    // [ '', 'red', ',', 'blue', ',', 'green', ',', 'yellow', '' ]
```

### localeCompare()方法

用于给字符串排序用的，规则类似于数组的sort()方法接收的比较函数。

### fromCharCode()方法

该方法接收一个或多个字符编码，然后将它们转换成字符串。

# 单体内置对象

内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显示地实例化内置对象，因为它们已经实例化了。前面介绍的`Object`、`Array`、`String`等都是内置对象，除此之外还有两个单体内置对象：`Global`和`Math`。

## Global对象

`Global`(全局)对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ES中的`Global`对象在某种意义上是作为一个终极的“兜底儿的对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是`Global`对象的属性。

ES虽然没有指出如何直接访问`Global`对象,但Web浏览器都是将这个全局对象作为`window`对象的一部分加以实现的。

```js
// 取得Global对象的方法
var global = function () {
    return this
}
```

### URI编码方法

Gloabl对象的`encodeURI()`和`encodeURIComponent()`方法可以对URI进行编码，以便发送给浏览器

`encodeURI()`主要用于整个URI（例如，`http://www.wrox.com/illegal value.html`），而`encodeURIComponent()`主要用于对URI中的某一段（例如前面URI中的`illegal value.html`）进行编码

它们的主要区别在于，`encodeURI()`不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号。而`encodeURIComponent()`则会对它发现的任何非标准字符串进行编码

与它们相对应的方法是`decodeURI()`和`decodeURIComponent()`

```js
var uri = 'http://www.wrox.com/illegal value.html#start'
console.log(encodeURI(uri))
// http://www.wrox.com/illegal%20value.html#start

console.log(encodeURIComponent(uri))
// http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start
```

## Math对象

### Math对象的属性

{% note info %}
- **Math.E**：自然对数的底数，即常量e的值；
- **Math.LN10**：10的自然对数；
- **Math.LN2**：2的自然对数；
- **Math.LOG2E**：以2为底e的对数；
- **Math.LOG10E**：以10为底e的对数；
- **Math.PI**：π的值；
- **Math.SQRT1_2**：1/2的平方根（即2的平方根的倒数）；
- **Math.SQRT2**：2的平方根。
{% endnote %}

### min()和max()方法

```js
var max = Math.max(3, 54, 32, 16)
var min = Math.min(3, 54, 32, 16)
console.log(max, min)       // 54 3 

var values = [1, 2, 3, 4, 5, 6, 7, 8]
console.log(Math.max.apply(Math, values))   // 8
```

### 舍入方法

{% note info %}
- `Math.ceil()`：执行向上舍入，即它总是将数值向上舍入为最接近的整数；
- `Math.floor()`：执行向下舍入，即它总是将数值向下舍入为最接近的整数；
- `Math.round()`：执行标准舍入，即它总是将数值四舍五入为最接近的整数。

---
`Math.round()`在数值是负数且小数部分恰好是`0.5`时会出现例外，如`Math.round(-1.5)`的值为`-1`
{% endnote %}

### random()方法

`Math.random()`方法返回介于0和1之间的一个随机数，不包活0和1。
