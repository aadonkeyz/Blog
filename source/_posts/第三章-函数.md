---
title: 第三章 函数
categories:
  - JavaScript
  - 《深入理解ES6》
abbrlink: 9595c646
date: 2019-03-26 16:04:30
---

# 带参数默认值的函数

## ES6中的参数默认值

ES6能更容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时使用。在函数声明中能指定任意一个参数的默认值，即使该参数排在未指定默认值的参数之前也是可以的。

**只有在某个参数未传递，或明确传递`undefined`时，才会应用参数的默认值。`null`值被认为是有效的。**

```js
function makeRequest(url, timeout = 2000, callback) {
    // 函数的剩余部分
}

// 使用默认的timeout
makeRequest('/foo', undefined, function (body) {
    doSomething(body)
})

// 使用默认的timeout
makeRequest('/foo')

// 不使用默认值
makeRequest('/foo', null, function (body) {
    doSomething(body)
})
```

## 参数默认值表达式和暂时性死区

参数默认值最有意思的特性或许就是默认值并不要求一定是基本类型的值。例如，你可以执行一个函数来产生参数的默认值：

```js
function getValue () {
	return 5
}

function add (first, second = getValue()) {
	return first + second
}

console.log(add(1, 1))	// 2
console.log(add(1))		// 6
```

需要注意的是，仅在调用`add()`函数而未提供第二个参数时，`getValue()`函数才会被调用，而在`getValue()`函数声明初次被解析时并不会进行调用。另外在书写代码时要小心，将函数调用作为参数的默认值时一定不要遗漏了括号，否则含义就变了。

参数默认值与`let`和`const`声明类似，都存在着暂时性死区。函数每个参数都会创建一个新的标识符绑定，它在初始化之前不允许被访问，否则会抛出错误。参数初始化会在函数被调用时进行，无论是给参数传递了一个值、还是使用了参数的默认值。

所以在为函数参数指定默认值时，后面的参数可以使用前面的参数，反过来则会抛出错误。

```js
// 后面参数使用前面参数
function getValue (value) {
	return value + 5
}
function add1 (first, second = getValue(first)) {
	return first + second
}

console.log(add1(1, 1))	    // 2
console.log(add1(1))		// 7

// 前面参数使用后面参数
function add2 (first = second, second) {
	return first + second
}

console.log(add2(1, 1))	            // 2
console.log(add2(undefined, 1))		// ReferenceError: second is not defined
```

# 剩余参数

剩余参数由三个点(...)与一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组，名称中的“剩余”也由此而来。需要注意的是，函数的`length`属性用于指示具名参数的数量，而剩余参数对其毫无影响。

```js
function pick (string, ...keys) {
	console.log(pick.length)
	console.log(string)
	console.log(keys)
}

pick()      // 1
            // undefined
            // []

pick(1, 2)  // 1
            // 1
            // [2]
```

剩余参数的两个限制条件：

{% note info %}
- 函数只能有一个剩余参数，并且它必须被放在最后；
- 在对象字面量的`setter`属性中，不能使用剩余参数。原因是对象字面量的`setter`被限定只能使用单个参数，而剩余参数按照定义是不限制参数数量的。
{% endnote %}

# 函数构造器的增强能力