---
title: 第七章 函数表达式
abbrlink: f1587c53
date: 2019-03-14 18:57:01
categories:
  - JavaScript
  - 《JavaScript高级程序设计》
---

定义函数的两种常用方式为函数声明和函数表达式。

关于函数声明，它的一个重要特征就是**函数声明提升**，意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。

函数表达式最常见的形式就是创建一个匿名函数，并将它赋给一个变量。匿名函数（拉姆达函数）是在创建时`function`关键字后面有没标识符的函数。函数表达式与其他表达式一样，在使用前必须先赋值。

**无法单独创建匿名函数，它都是和函数表达式结合在一起的**

```js
// 函数声明
function name () {}

// 函数表达式
var name = function () {}

// 会报错，因为JavaScript引擎会将function关键字当作一个函数声明的开始
function () {}

// 由匿名函数构成的函数表达式
(function () {})
```



# 递归

最好使用如下形式的**命名函数表达式**来实现递归：

```js
var factorial = (function f (num) {
    if (num < 1) {
        return 1
    } else {
        return num * f(num - 1)
    }
})
```

**命名函数表达式的名字，只在这个函数的作用域内部有效！！！**

# 闭包

闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

```js
function createComparisonFunction (propertyName) {
    return function (object1, object2) {
        var value1 = object1[propertyName]
        var value2 = object2[propertyName]

        if (value1 < value2) {
            return -1
        } else if (value1 > value2) {
            return 1
        } else {
            return 0
        }
    }
}
```

在上面的例子中,即使内部的匿名函数被返回了，而且以后会在其他地方被调用，但它仍然可以访问变量`propertyName`。之所以还能够访问这个变量，是因为内部函数的作用域链中包含对`createComparisonFunction()`的活动对象（即执行环境的变量对象）的引用。

当`createComparisonFunction()`函数运行结束后，其作用域链被销毁了，但是它的活动对象并没有，它仍然留在内存中等待着被匿名函数调用。直到匿名函数被销毁后，`createComparisonFunction()`的活动对象才会被销毁。

```js
// 创建函数
var compareNames = createComparisonFunction('name')

// 调用函数
var result = compareNames({name: 'Nicholas'}, {name: 'Greg'})

// 接触对匿名函数的引用（以便释放内存）
compareNames = null
```

## 闭包与变量

作用域链的这种配置机制引出了一个值得注意的副作用。

```js
function createFunctions () {
    var result = new Array()

    for (var i = 0; i < 3; i++) {
        result[i] = function () {
            return i
        }
    }
    return result
}
var array = createFunctions()
array[0]()      // 3
array[1]()      // 3
array[2]()      // 3


// 上面的等价形式
function createFunctions () {
    var result = new Array()

    var i = 0
    result[i] = function () {
        return i
    }
    i = 1
    result[i] = function () {
        return i
    }
    i = 2
    result[i] = function () {
        return i
    }
    i = 3
    return result
}
var array = createFunctions()
array[0]()      // 3
array[1]()      // 3
array[2]()      // 3
```

内部函数中使用了`createFunctions`的活动对象的属性`i`，而在真正调用内部函数时，这个`i`的值是3，所以它们返回的都是3。

书中使用函数参数是按值传递的性质，解决这个问题。但是返回的数组中包含的是内部函数的返回值而不是内部函数的引用了。

```js
function createFunctions () {
    var result = new Array()

    for (var i = 0; i < 3; i++) {
        result[i] = function (num) {
            return num
        }(i)
    }
    return result
}
var array = createFunctions()
array[0]       // 0
array[1]       // 1
array[2]       // 2
```

等介绍到ES6的时候，用`let`可以很轻松的解决这里的问题而毫无副作用。

## 关于this对象

想了半天，还是决定放在后续的《你不知道的JavaScript》系列中来说。

# 模仿块级作用域

```js
(function () {
    // 这里是块级作用域
})()
```

以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。

# 私有变量

严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公开的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能再函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。

我们把有权访问私有变量和私有函数的公有方法成为特权方法。可以在构造函数中定义特权方法，基本模式如下：

```js
function MyObject () {
    // 私有变量和私有函数
    var privateVariable = 10
    function privateFunction () {
        return false
    }

    // 特权方法
    this.publicMethod = function () {
        privateVariable++
        return privateFunction()
    }
}
```

在创建`MyObject`的实例后，除了使用`publicMethod()`这一个途径外，没有任何办法可以直接访问`privateVariable`和`privateFunction()`。

不过在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。构造函数的缺点是针对每一个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。

## 静态私有变量

```js
(function () {
    // 私有变量和私有函数
    var privateVariable = 10
    function privateFunction () {
        return false
    }

    // 构造函数
    MyObject = function () {}
    MyObject.prototype.publicMethod = function () {
        privateVariable++
        return privateFunction()
    }
})()
```

这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式，函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明`MyObject`时用`var`关键字（记住：初始化未经声明的变量，在非严格模式下会创建一个全局变量，在严格模式下会抛出错误），这样`MyObject`就成了一个全局变量。而且特权方法是在原型上定义的，因此所有实例都能使用同一个函数。这个特权方法作为一个闭包，总是保存着对包含作用域的引用。

**以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。**

## 模块模式

前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式则是为单例创建私有变量和特权方法。所谓单例，指的就是只有一个实例的对象。

```js
var singleton = function () {
    var privateVariable = 10
    function privateFunction () {
        return false
    }

    // 特权/公有方法和属性
    return {
        publicProperty: true,
        publicMethod: function () {
            privateVariable++
            return privateFunction()
        }
    }
}()
```

## 增强的模块模式

这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。

```js
var singleton = function () {
    var privateVariable = 10
    function privateFunction () {
        return false
    }

    // 创建对象
    var object = new CustomType()

    // 添加特权/公有属性和方法
    object.publicProperty = true
    object.publicMethod = function () {
        privateVariable++
        return privateFunction()
    }

    // 返回这个对象
    return object
}()
```