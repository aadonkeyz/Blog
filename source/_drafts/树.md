---
title: 树
categories:
    - 数据结构与算法
mathjax: true
abbrlink: 7b216a3b
---

# 树的基本概念

一棵树是一些节点的集合，这个集合可以是空集；若不是空集，则树由称做**根（root）**的节点$r$及0或多个非空的（子）树$T_1,T_2, ···,T_k$组成，这些子树中每一颗的根都被来自根$r$的一条有向的边所连接。每一颗子树的根叫作根$r$的**儿子**，而$r$是每一颗子树的根的**父亲**

![一般的树](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%B8%80%E8%88%AC%E7%9A%84%E6%A0%91.png)

下图中，节点A是根。节点F有一个父亲A并且有儿子K、L和M。每一个节点可以有任意多个儿子，也可能是零个儿子。没有儿子的节点称为**树叶**，下图中的树叶是B、C、H、I、P、Q、K、L、M和N。具有相同父亲的节点为**兄弟**。因此，K、L和M都是兄弟。

![一颗树](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%B8%80%E6%A3%B5%E6%A0%91.png)

从节点$n_1$到$n_k$的**路径**定义为节点$n_1, n_2, ···, n_k$的一个序列，使得对于$1 \leq i \leq k$的节点$n_i$是$n_{i + 1}$的父亲。这条路径的长是该路径上边的条数，即$k - 1$。从每一个节点到它自己有一条长为0的路径。注意，在一棵树中从根到每个节点恰好存在一条路径

对任意节点$n_i$，$n_i$的**深度**为从根到$n_i$的唯一路径的长。因此，根的深度为0.节点$n_i$的**高**是从$n_i$到一片树叶的最长路径的长。因此所有树叶的高都是0。**一棵树的高等于它的根的高**。上图中的树，E的深度为1而高为2；F的深度为1而高也是1；该树的高为3。**一棵树的深度等于其最深的树叶的深度，该深度总是等于这棵树的高**

**二叉树**是一种特殊的树，其中每个节点都不能有多于两个的儿子

# 先、中、后序遍历

{% note info %}
- **先序遍历**：首先处理当前节点，然后再处理它的诸子节点
- **中序遍历**：该遍历方式是针对于二叉树的，它会首先处理左子节点，然后处理当前节点，最后处理右子节点
- **后序遍历**：首先处理当前节点的诸子节点，然后再处理当前节点

---
**先、中、后指的是处理节点的顺序，在访问节点的时候，是只有一种顺序的**
{% endnote %}

![节点访问顺序](https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F.png)

对于上图中的二叉树，它的先、中、后序遍历代码如下所示

```js
// JavaScript

let tree = {
    value: 1,
    left: {
        value: 2,
        left: {
            value: 4,
            right: {
                value: 6,
                left: {
                    value: 7
                },
                right: {
                    value: 8
                }
            }
        }
    },
    right: {
        value: 3,
        right: {
            value: 5
        }
    }
}

function preOrderTraverse (node, result = '') {
    result += node.value + '  '

    if (node.left) {
        result = preOrderTraverse(node.left, result)
    }

    if (node.right) {
        result = preOrderTraverse(node.right, result)
    }

    return result
}

function middleOrderTraverse (node, result = '') {
    if (node.left) {
        result = middleOrderTraverse(node.left, result)
    }

    result += node.value + '  '

    if (node.right) {
        result = middleOrderTraverse(node.right, result)
    }

    return result
}

function postOrderTraverse (node, result = '') {
    if (node.left) {
        result = postOrderTraverse(node.left, result)
    }

    if (node.right) {
        result = postOrderTraverse(node.right, result)
    }

    result += node.value + '  '

    return result
}

console.log('先序遍历： ' + preOrderTraverse(tree))
console.log('中序遍历： ' + middleOrderTraverse(tree))
console.log('后序遍历： ' + postOrderTraverse(tree))

// 先序遍历： 1  2  4  6  7  8  3  5  
// 中序遍历： 4  7  6  8  2  1  3  5  
// 后序遍历： 7  8  6  4  2  5  3  1  
```

# 二叉查找树

{% note info %}
二叉查找树与普通的二叉树相比，有如下特点：
- 所有节点彼此互异，即不存在相同的节点
- 对于树中的任意节点X，X的左子树中所有节点都“小于”X，而X右子树中的所有节点都“大于”X
{% endnote %}

下面是实现一个二叉查找树的代码：

{% note warning %}
从二叉查找树中移除元素是这部分的难点，首先定位到要移除元素所在节点，然后进行如下3种操作：
1. 如果当前节点为树叶，那么直接删除该树叶
2. 如果当前节点拥有一个子树，那么用该子树的根节点替换当前节点
3. 如果当前节点拥有两个子树，那么找出右子树中的最小节点并递归的删除该最小节点，然后将这个最小节点的值赋给当前节点的值
{% endnote %}

```js
class BinarySearchTree {
    constructor (newValue) {
        this.value = newValue
        this.left = null
        this.right = null
        this.isNode = true
    }

    static makeTree (array) {
        let tree = new BinarySearchTree(array[0])
        array.slice(1).forEach(item => {
            tree.insert(item)
        })
        return tree
    }

    insert (newNode, currentNode = this) {
        if (!newNode.isNode) {
            newNode = new BinarySearchTree(newNode)
        }

        if (newNode.value < currentNode.value) {
            if (currentNode.left)  {
                currentNode.insert(newNode, currentNode.left)
            } else {
                currentNode.left = newNode
            }
        }

        if (newNode.value > currentNode.value) {
            if (currentNode.right)  {
                currentNode.insert(newNode, currentNode.right)
            } else {
                currentNode.right = newNode
            }
        }

        if (newNode.value === currentNode.value) {
            console.log(`${newNode.value} already exists`)
        }
    }

    contains (inputValue, currentNode = this) {        
        if (inputValue < currentNode.value) {
            if (currentNode.left) {
                return currentNode.contains(inputValue, currentNode.left)
            } else {
                return false
            }
        }
        
        if (inputValue > currentNode.value) {
            if (currentNode.right) {
                return currentNode.contains(inputValue, currentNode.right)
            } else {
                return false
            }
        }

        if (inputValue === currentNode.value) {
            return true
        }
    }

    findMin (currentNode = this) {
        if (currentNode.left) {
            return currentNode.findMin(currentNode.left)
        } else {
            return currentNode.value
        }
    }

    findMax (currentNode = this) {
        if (currentNode.right) {
            return currentNode.findMin(currentNode.right)
        } else {
            return currentNode.value
        }
    }

    // preNode和where参数完全是为了删除树叶准备的
    remove (inputValue, currentNode = this, preNode = null, where = '') {
        if (inputValue < currentNode.value) {
            if (currentNode.left) {
                currentNode.remove(inputValue, currentNode.left, currentNode, 'left')
            } else {
                console.log(`${inputValue} does not exist`)
            }
        }
        
        if (inputValue > currentNode.value) {
            if (currentNode.right) {
                currentNode.remove(inputValue, currentNode.right, currentNode, 'right')
            } else {
                console.log(`${inputValue} does not exist`)
            }
        }

        if (inputValue === currentNode.value) {
            if ((!currentNode.left) && (!currentNode.right)) {
                preNode[where] = null
                return
            }

            if (!currentNode.left) {
                currentNode = currentNode.right
                return
            } else if (!currentNode.right) {
                currentNode = currentNode.left
                return
            }

            if (currentNode.left && currentNode.right) {
                let minValue = currentNode.right.findMin()
                currentNode.remove(minValue, currentNode.right, currentNode, 'right')
                currentNode.value = minValue
                return
            }
        }
    }
}

let array = [6, 2, 8, 7, 1, 4, 3, 5],
    tree = BinarySearchTree.makeTree(array)

function preOrderTraverse (node, result = '') {
    result += node.value + '  '

    if (node.left) {
        result = preOrderTraverse(node.left, result)
    }

    if (node.right) {
        result = preOrderTraverse(node.right, result)
    }

    return result
}

console.log(preOrderTraverse(tree))     // 6  2  1  4  3  5  8  7  

tree.remove(4)
console.log(preOrderTraverse(tree))     // 6  2  1  5  3  8  7  

tree.insert(4)
console.log(preOrderTraverse(tree))     // 6  2  1  5  3  4  8  7 

tree.remove(41)                         // 41 does not exist
console.log(preOrderTraverse(tree))     // 6  2  1  5  3  4  8  7  
```







