---
title: 排序算法总结
categories:
    - 数据结构与算法
mathjax: true
abbrlink: cd65786b
---

# 排序算法基本概念

{% note info %}
排序算法可以分为以下两种类型：
- **比较类非线性时间排序**：通过比较来决定元素间的相对次序，其时间复杂度不能突破`O(nlogn)`
- **非比较类线性时间排序**：不通过比较来决定元素间的相对次序，其时间复杂度最低可以为`O(n)`

---
**稳定性定义**：如果排序前后两个相等元素的相对次序不变，则算法稳定；反之算法不稳定
{% endnote %}

# 冒泡排序

{% note info %}
- **冒泡排序思路（从小到大排序）**：每一次循环时，通过相邻元素的比较和位置互换，让大的元素“浮出水面”
- **时间复杂度**：**O($n^2$)**
- **稳定性**：稳定
{% endnote %}

```js
let list = [13, 44, 12, 15, 47, 16]

function bubbleSort (array) {
    console.log(array.join('   '))

    let len = array.length
    for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
            if (array[j] > array[j+1]) {
                [array[j], array[j+1]] = [array[j+1], array[j]]
            }
        }
        console.log(array.join('   '))
    }
}

bubbleSort(list)
```

![冒泡排序]()

# 选择排序

{% note info %}
- **选择排序思路（从小到大排序）**：每一次循环时，以本次循环的第一个元素为当前元素，找出本次循环中的最小元素，然后交换当前元素和最小元素的位置。与冒泡排序的区别在于，它每一次循环中只交换一次元素位置
- **时间复杂度**：**O($n^2$)**
- **稳定性**：不稳定
{% endnote %}

```js
let list = [13, 44, 12, 15, 47, 16]

function selectionSort (array) {
    console.log(array.join('   '))

    let len = array.length
    let mixIndex
    for (let i = 0; i < len - 1; i++) {
        mixIndex = i
        for (let j = i + 1; j < len; j++) {
            if (array[j] < array[mixIndex]) {
                mixIndex = j
            }
        }
        [array[mixIndex], array[i]] = [array[i], array[mixIndex]]
        console.log(array.join('   '))
    }
}

selectionSort(list)
```

![选择排序]()

# 插入排序

{% note info %}
- **插入排序思路（从小到大排序）**：每一次循环时，以本次循环的第一个元素为当前元素，将当前元素与处于其前方的元素不断比较，然后将其插入应该处于的位置
- **时间复杂度**：**O($n^2$)**
- **稳定性**：稳定
{% endnote %}

```js
let list = [13, 44, 12, 15, 47, 16]

function insertionSort (array) {
    console.log(array.join('   '))

    let len = array.length
    for (let i = 1; i < len; i++) {
        let unsortValue = array[i]
        let currentIndex = i - 1
        while ((currentIndex >= 0) && (array[currentIndex] > unsortValue)) {
            array[currentIndex + 1] = array[currentIndex]
            currentIndex--
        }
        array[currentIndex + 1] = unsortValue
        console.log(array.join('   '))
    }
}

insertionSort(list)
```

![插入排序]()
