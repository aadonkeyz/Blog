<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows下 Node 安装及配置</title>
    <url>/posts/ee28a0bf/</url>
    <content><![CDATA[<h1 id="Node-的安装"><a href="#Node-的安装" class="headerlink" title="Node 的安装"></a>Node 的安装</h1><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">首先附上 Node 的下载链接</a></p>
<p>安装过程中除了对安装位置进行修改外，其他的都选择默认项就可以，我的安装位置选择为 D:\nodejs\，安装之后在命令行中分别输入<code>node -v</code>和<code>npm -v</code>会显示出对应的 node 及 npm 版本号。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/node%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="Node安装成功"></p>
<p>刚刚安装完成之后，nodejs 的目录如下所示。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/node%E5%AE%89%E8%A3%85%E5%90%8E%E7%9B%AE%E5%BD%95.png" alt="Node安装后目录"></p>
<h1 id="Node-路径修改"><a href="#Node-路径修改" class="headerlink" title="Node 路径修改"></a>Node 路径修改</h1><p>接下来要修改 npm 安装全局模块的路径和缓存 cache 的路径，这样做是因为默认路径都在 C 盘，而我们并不想过多的占用 C 盘空间。</p>
<p>在修改路径前先在 D:\nodejs\下创建 node_global 和 node_cache 文件夹。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/nodejs%E4%B8%8B%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="Node下新建文件夹"></p>
<p>然后在命令行中输入以下指令：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">npm config set prefix "D:\nodejs\node_global"</span><br><span class="line">npm config set cache "D:\nodejs\node_cache"</span><br></pre></td></tr></table></figure>
<p>上面的指令为修改路径，现在让我们验证下路径修改是否成功：首先通过 npm 全局安装一个模块，如果这个模块被下载到我们指定的文件夹中，则说明修改成功。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/%E6%A8%A1%E5%9D%97%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="模块全局安装成功"></p>
<p>检查 D:\nodejs\node_global 文件夹，在里面的 node_modules 中发现刚刚全局安装的 express 模块，说明上述对路径的修改已经成功。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/express%E5%AE%89%E8%A3%85%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE.png" alt="express安装在指定位置"></p>
<h1 id="Node-环境变量修改"><a href="#Node-环境变量修改" class="headerlink" title="Node 环境变量修改"></a>Node 环境变量修改</h1><p>因为我们刚刚修改了模块的全局安装路径，所以需要修改相应的环境变量以保证在 Node 使用过程中，可以找到正确的位置来引用模块，操作如下：</p>
<div class="note info">
            <p>我的电脑 - 右键 - 属性 - 高级系统设置 - 高级 - 环境变量</p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/%E8%BF%9B%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84.png" alt="进入环境变量"></p>
<div class="note info">
            <p>在“系统变量”下新建<code>NODE_PATH</code>,输入：<code>D:\nodejs\node_global\node_modules</code>。</p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9.png" alt="系统变量修改"></p>
<div class="note info">
            <p>在“用户变量”下的<code>Path</code>中用<code>D:\nodejs\node_global</code>替换<code>C:\Users\17590\AppData\Roaming\npm</code>。</p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9.png" alt="用户变量修改"></p>
<p>环境变量修改完成之后，打开一个新的命令行窗口，先输入<code>node</code>，按回车进入 nodejs 的交互式命令控制台，然后输入<code>require(&#39;express&#39;)</code>,如果能够正常显示 express 模块的信息，则说明环境变量的修改也成功了。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BNode%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png" alt="环境变量修改成功"></p>
<h1 id="使用淘宝镜像"><a href="#使用淘宝镜像" class="headerlink" title="使用淘宝镜像"></a>使用淘宝镜像</h1><p>接下来修改 npm 配置，使用国内的淘宝镜像以保证模块下载的稳定性和速度，下列两种方式二选一即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装cnpm模块</span></span><br><span class="line"><span class="comment"># 以后使用cnpm替代npm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者修改npm源地址为淘宝镜像</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>Github+Hexo搭建个人博客</title>
    <url>/posts/d4a0c543/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><div class="note info">
            <ul><li><a href="https://aadonkeyz.com/posts/ee28a0bf/#more">Node安装及配置</a></li><li><a href="https://aadonkeyz.com/posts/6749cdaf/#more">Git安装及配置</a></li><li><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">阅读Hexo的文档</a></li></ul>
          </div>
<h1 id="Hexo安装及博客初始化"><a href="#Hexo安装及博客初始化" class="headerlink" title="Hexo安装及博客初始化"></a>Hexo安装及博客初始化</h1><p>在Node安装成功之后，在命令行中使用npm命令安装Hexo，输入：<code>npm install -g hexo-cli</code>。</p>
<p>安装完成后我们自己创建一个空文件夹Blog作为博客的根目录，双击进入文件夹，之后按住shift键并点击鼠标右键，选择菜单中的“在此处打开Powershell窗口”，这样所有的命令行操作都是以Blog为根目录进行的，<strong>后文的所有命令行均是以Blog为根目录！</strong></p>
<p>在新打开的命令行窗口中依次输入：<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<p>完成后就可以在浏览器中输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>来查看我们的本地博客了。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="本地博客初始化"></p>
<h1 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h1><p>我选择的是评价较好的Next主题，首先将主题下载到Blog/themes中，在Blog根目录启动命令行，输入：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>现在先简单的介绍下Blog下的themes文件夹和_config.yml文件，themes下保存的是博客的主题，每一种主题为一个文件夹，例如目前为止我们有两种主题landscape（自带的）和next。下面请仔细注意，每个主题文件夹下都有一个_config.yml文件，我们称之为主题配置文件，而Blog文件夹下的_config.yml称之为站点配置文件。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE.png" alt="主题配置与站点配置"></p>
<p>接下来打开站点配置文件，修改主题为next，保存。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>也可以修改next的主题样式，当前版本的next有四种样式，我选择的是最后一个Gemini。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<p>除此之外有关于博客样式和功能菜单的配置，大部分都可以在这两个配置文件中发现，<a href="https://theme-next.org/docs/theme-settings/" target="_blank" rel="noopener">Next主题也提供了一份配置方面的文档</a>。</p>
<p>都保存之后，连续执行三个命令：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>接着刷新浏览器就可以观察到页面样式的变化。</p>
<h1 id="博客的备份及部署"><a href="#博客的备份及部署" class="headerlink" title="博客的备份及部署"></a>博客的备份及部署</h1><p>到目前为止，已经成功用Hexo建立本地博客，接下来要先将本地博客文件备份至github中，然后再部署博客。</p>
<p>在开始前先介绍一下这部分的安排，打算创建两个分支master和root。</p>
<div class="note info">
            <ul><li><strong>master</strong>：负责博客的部署，所以其中存放的是部署后生成的文件；</li><li><strong>root</strong>：负责存放博客的原始文件，并且要注意将root设置为默认分支。</li></ul>
          </div>
<p>首先在github上创建个人仓库，然后复制仓库的SSH，格式为<code>git@github.com:username/repository_name.git</code>，将username和repository_name分别换为你的github用户名和仓库名。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%BB%93%E5%BA%93%E7%9A%84ssh.png" alt="仓库的SSH"></p>
<p>接着修改github账号的Setting中的Emails设置，取消下图中红线标记的功能。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%BF%AE%E6%94%B9github%E7%9A%84emails%E8%AE%BE%E7%BD%AE.png" alt="修改github的emails设置"></p>
<p>然后通过下列指令将本地博客文件备份至github的root分支上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="comment"># 注意add后面有个“空格”和“.”</span></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%AD%90%E4%BB%93%E5%BA%93%E6%8A%A5%E9%94%99.png" alt="子仓库报错"></p>
<p>备份过程中会遇到一个警告提示，原因是我们前面使用的主题Next也是一个Git仓库，所以在将Blog文件下所有文件加入Git缓存中时会警告我们子仓库不会被添加，解决方式为将这个Git子仓库以我们的本地文件夹形式加入到Git缓存中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git rm --cached themes/next -f</span><br><span class="line"><span class="comment"># next后面的“/”表示添加的是文件夹，一定要加上</span></span><br><span class="line">git add themes/next/</span><br><span class="line">git commit -m <span class="string">"first commit to branch root"</span></span><br><span class="line"><span class="comment"># 将本地master分支重命名为root</span></span><br><span class="line">git branch -m master root</span><br><span class="line">git remote add origin git@github.com:aadonkeyz/Blog.git</span><br><span class="line">git push -u origin root</span><br></pre></td></tr></table></figure>
<p>最后一个指令输完可能会要求我们输入SSH秘钥的密码，如果要求验证，输入密码即可。</p>
<p>上面的操作已经成功将本地博客文件添加到仓库的root分支，接着打开站点配置文件进行如下修改：<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:aadonkeyz/Blog.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p>
<p>保存后开始通过命令行下载并保存一个名为hexo-deployer-git的插件，然后就可以将博客部署到github上了。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>目前已经将博客部署到master分支了，但是还要进行一些修改才可以，进入仓库的Setting中，找到Github Pages，将Source选择为master branch。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%BF%AE%E6%94%B9Github%20Pages%E7%9A%84%E8%AE%BE%E7%BD%AE.png" alt="修改Github Pages的设置"></p>
<p>完成后会发现这部分会有所变化，多出一个链接，格式为<code>https://username.github.io/仓库名/</code>。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%AB%99%E7%82%B9%E9%93%BE%E6%8E%A5.png" alt="站点链接"></p>
<p>回到站点配置文件中将url改为刚刚的链接，root改为<code>/仓库名/</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://aadonkeyz.github.io/Blog/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/Blog/</span></span><br></pre></td></tr></table></figure>
<p>之后将新的修改备份至github并重新部署博客。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m “change URL and Deploy of site config”</span><br><span class="line">git push -u origin root</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>大功告成，等待几秒后（github需要时间来完成更新），在浏览器中输入刚刚的url链接就可以查看我们部署在github上的博客啦！</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/f1601c3e/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="单例模式结构"></p>
<div class="note info">
            <ol><li>单例模式：保证一个类仅有一个实例，并提供一个访问该实例的全局访问点。</li><li>适用性：<ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li></ul></li><li>参与者： - <strong><code>Singleton</code></strong> - 定义了一个<code>Instance</code>操作，允许客户访问它的唯一实例。<code>Instance</code>是一个类操作（即它是一个静态成员方法）。 - 可能负责创建它自己的唯一实例。</li></ol>
          </div>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><div class="note warning">
            <p><strong>基础概念中介绍的是单例模式的原理，而这个 demo 中展示的是使用代理来实现透明单例模式的例子，它们有些许不同。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateSingleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> CreateSingleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Singleton(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Singleton(<span class="string">'b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/posts/78134e07/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="命令模式结构"></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%BA%A4%E4%BA%92.png" alt="命令模式交互"></p>
<div class="note info">
            <ol><li>命令模式：将一个命令封装为一个对象，从而使你可用不同的命令对客户进行参数化。</li><li>适用性：<ul><li>抽象出待执行的命令，以参数化某对象。</li><li>在不同的时刻指定、排列和执行命令。</li><li>支持取消操作。</li><li>支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。</li></ul></li><li>参与者： - <strong><code>Command</code></strong> - 声明<code>Execute()</code>的接口。 - <strong><code>ConcreteCommand</code></strong> - 将一个接收者对象绑定于一个动作。 - 实现<code>Execute()</code>接口，在该接口中会调用接收者相应的动作。 - <strong><code>Client</code></strong> - 创建一个具体命令对象，并设定它的接收者。 - <strong><code>Invoker</code></strong> - 保存着命令队列，且由它去触发命令的执行。 - <strong><code>Receiver</code></strong> - 命令的接收者，命令是由接收者完成执行的。 - 任何类都可能作为一个接收者。</li></ol>
          </div>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><div class="note info">
            <ol><li><strong>一个命令对象应达到何种智能程度</strong>：命令对象的能力可大可小。存在两种极端情况<ul><li>命令对象仅确定一个接收者和一个执行该命令的动作，其他什么也不做。</li><li>命令对象自己实现所有功能，根本不需要额外的接收者对象。</li></ul></li><li><strong>支持取消和重做</strong>：如果<code>Command</code>提供方法逆转命令的执行，就可以支持取消和重做功能。为了达到这个目的，<code>ConcreteCommand</code>类可能需要存储额外的状态信息：<ul><li>接收者对象。</li><li>接收者上执行命令的参数。</li><li>如果执行命令的动作会改变接收者对象中的某些值，那么这些值必须先存储起来。接收者还必须提供一些动作，以使该命令可将接收者恢复到它先前的状态。</li></ul></li><li><strong>避免取消操作过程中的错误累积</strong>：在实现一个可靠的、能确保原先语义的取消/重做机制时，可能会遇到滞后影响问题。由于命令重复的执行、取消执行，和重执行的过程可能会累积错误，以至一个应用的状态最终偏离初始值。这就有必要在<code>Command</code>中存入更多的信息以保证这些对象可被精确地复原成它们的初始状态。这里可使用<a href="https://aadonkeyz.com/posts/c3176455/">备忘录模式</a>来让该<code>Command</code>访问这些信息而不暴露其他对象的内部信息。</li></ol>
          </div>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>呃，懒得想具体的场景了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(receiver, whatToDo) &#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    <span class="keyword">this</span>.whatToDo = whatToDo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execute() &#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver.action.apply(<span class="keyword">this</span>, <span class="keyword">this</span>.whatToDo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setCommand(receiver, whatToDo, invoker) &#123;</span><br><span class="line">    <span class="keyword">let</span> command = <span class="keyword">new</span> Command(receiver, whatToDo);</span><br><span class="line">    invoker.addCommand(command);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.queue = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addCommand(command) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callCommand() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.queue.shift().execute;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  action(whatToDo) &#123;</span><br><span class="line">    <span class="comment">// do whatToDo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Unicode</title>
    <url>/posts/1c0c8dfc/</url>
    <content><![CDATA[<h1 id="字符和码位"><a href="#字符和码位" class="headerlink" title="字符和码位"></a>字符和码位</h1><div class="note info">
            <ul><li>字符：又叫抽象字符，是用于组织、控制 或 表示 文本数据 的 信息单元。</li><li>码位：是分配给单个字符的一个数字。<code>U+&lt;hex&gt;</code> 是码位的格式，其中 <code>U+</code> 代表 Unicode 的前缀，而 <code>&lt;hex&gt;</code> 表示十六进制数字。</li></ul><hr><p>每一个字符都有对应的码位，如 <code>A</code> 对应 <code>U+0041</code>。但是并非所有码位都有关联字符。</p>
          </div>
<h1 id="Unicode-平面"><a href="#Unicode-平面" class="headerlink" title="Unicode 平面"></a>Unicode 平面</h1><div class="note info">
            <p>平面是从 <code>U+n0000</code> 到 <code>U+nFFFF</code> 的 <code>65536</code> 个连续的码位，<code>n</code> 的取值范围从 <code>0</code> 到 <code>16</code>。平面将全部的 Unicode 码位分成了 <code>17</code> 个均等的组。</p>
          </div>
<p>基本多文种平面为 <code>U+0000</code> 到 <code>U+FFFF</code>，简称 BMP（Basic Multilingual Plane）。其余 <code>16</code> 个平面称为星光平面或辅助平面。</p>
<h1 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h1><div class="note info">
            <p>码元是用于以给定编码格式，对每个字符编码的一个二进制位序列。在不同的编码格式中，一个码元有多少字节是不同的。<br>UTF-8 中一个码元可能有 <code>1 - 4</code> 个字节。UTF-16 中一个码元有 <code>2</code> 个字节。UTF-32 中一个码元有 <code>4</code> 个字节。</p>
          </div>
<h1 id="代理对"><a href="#代理对" class="headerlink" title="代理对"></a>代理对</h1><div class="note info">
            <p>在 UTF-16 中代理对是对那些由 <code>2</code> 个 <code>16</code> 位长的码元所组成序列的单个抽象字符的表示方式。代理对中的首个值为高位代理码元，而第二个值为低位代理码元。高位代理码元从 <code>0xD800</code> 到 <code>0xDBFF</code> 取值。低位代理码元从 <code>0xDC00</code> 到 <code>0xDFFF</code> 取值。</p>
          </div>
<p>在 UTF-16 中，对于基本多文种平面，一个 <code>16</code> 位长的码元就可以解决了。但是对星光平面内的码元，如 <code>U+1F600</code>，需要两个 <code>16</code> 位长的码元才能将其表示，这就是代理对。<code>U+1F600</code> 对应的代理对是 <code>0xD83D 0xDE00</code>。转换方法如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSurrogatePair</span>(<span class="params">astralCodePoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> highSurrogate = <span class="built_in">Math</span>.floor((astralCodePoint - <span class="number">0x10000</span>) / <span class="number">0x400</span>) + <span class="number">0xd800</span>;</span><br><span class="line">  <span class="keyword">let</span> lowSurrogate = ((astralCodePoint - <span class="number">0x10000</span>) % <span class="number">0x400</span>) + <span class="number">0xdc00</span>;</span><br><span class="line">  <span class="keyword">return</span> [highSurrogate, lowSurrogate];</span><br><span class="line">&#125;</span><br><span class="line">getSurrogatePair(<span class="number">0x1f600</span>); <span class="comment">// =&gt; [0xD83D, 0xDE00]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAstralCodePoint</span>(<span class="params">highSurrogate, lowSurrogate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (highSurrogate - <span class="number">0xd800</span>) * <span class="number">0x400</span> + lowSurrogate - <span class="number">0xdc00</span> + <span class="number">0x10000</span>;</span><br><span class="line">&#125;</span><br><span class="line">getAstralCodePoint(<span class="number">0xd83d</span>, <span class="number">0xde00</span>); <span class="comment">// =&gt; 0x1F600</span></span><br></pre></td></tr></table></figure>
<h1 id="组合符号"><a href="#组合符号" class="headerlink" title="组合符号"></a>组合符号</h1><div class="note info">
            <p>字位又称形素、字素、或符号，对一些书写系统来说是最小的构成单位。</p>
          </div>
<p>在绝大多数情况下，单个 Unicode 字符表示单个的字位。但也存在单个字位包含一系列字符的情况。例如 å 在丹麦书写系统中是一个原子性的字位，展示它需要使用 <code>U+0061</code> 和 <code>U+030A</code> 组合在一起。</p>
<p>组合字符会被用户认为是单个字符，但开发者必须使用 <code>2</code> 个码位来表示它。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://mp.weixin.qq.com/s/YIJzT7ymxbxNxXYsV8zpVg" target="_blank" rel="noopener">每个 JavaScript 开发者都应该了解的 Unicode</a><br><a href="https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode" target="_blank" rel="noopener">What every JavaScript developer should know about Unicode</a></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/posts/c3176455/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="备忘录模式结构"></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%BA%A4%E4%BA%92.png" alt="备忘录模式交互"></p>
<div class="note info">
            <ol><li>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</li><li>参与者： - <strong><code>Memento</code>（备忘录）</strong> - 备忘录存储原发器对象在某一时刻的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。 - 防止原发器以外的其它对象访问备忘录内部存储的状态。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。 - <strong><code>Originator</code>（原发器）</strong> - 原发器创建一个备忘录，用以记录当前时刻它的内部状态。 - 使用备忘录恢复内部状态到某一时刻。 - <strong><code>Caretaker</code>（管理者）</strong> - 负责保存备忘录。 - 不能对备忘录的内容进行操作或检查。</li></ol>
          </div>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>等我遇到实际需求，我再更新 demo 吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMemento(memento) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = memento.state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createMemento() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(state) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(originator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mementoList = [];</span><br><span class="line">    <span class="keyword">this</span>.originator = originator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addMemento() &#123;</span><br><span class="line">    <span class="keyword">this</span>.mementoList.push(<span class="keyword">this</span>.originator.createMemento());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/posts/54788f73/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="工厂模式结构"></p>
<div class="note info">
            <ol><li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li><li>适用性：<ul><li>当一个类不知道它所必须创建的对象的类的时候。</li><li>当一个类希望由它的子类来指定它所创建的对象的时候。</li><li>当类创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。</li></ul></li><li>参与者： - <strong><code>Product</code></strong> - 定义工厂模式所创建的对象的接口。 - <strong><code>ConcreteProduct</code></strong> - 实现 Product 的接口 - <strong><code>Creator</code></strong> - 声明工厂模式，该方法返回一个<code>Product</code>类型的对象。<code>Creator</code>也可以定义一个工厂模式的缺省实现，它返回一个缺省的 C<code>oncreteProduct</code>对象。 - 可以调用工厂模式创建一个<code>Product</code>对象。 - <strong><code>ConcreteCreator</code></strong> - 重定义工厂模式以返回一个<code>ConcreteProduct</code>实例。</li></ol>
          </div>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><div class="note info">
            <ol><li><strong>主要有三种不同的情况</strong>：<ul><li><code>Creator</code>类是一个抽象类并且不提供它所声明的工厂模式的实现。</li><li><code>Creator</code>类是一个具体的类而且为工厂模式提供一个缺省的实现。</li><li><code>Creator</code>类是一个抽象的类，但为工厂模式提供一个缺省的实现。</li></ul></li><li><strong>参数化工厂模式</strong>：一个工厂模式可以创建多中类型的对象。</li></ol>
          </div>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'产品1'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'产品2'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(typeNum) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeNum === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Product1();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Product2();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Creator(<span class="number">1</span>),</span><br><span class="line">  p2 = <span class="keyword">new</span> Creator(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// Product1 &#123; type: '产品1' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2); <span class="comment">// Product2 &#123; type: '产品2' &#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/posts/a708a60d/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="装饰者模式结构"></p>
<div class="note info">
            <ol><li>装饰者模式：动态地给一个对象添加一些额外的职责。</li><li>适用性：<ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>处理那些可撤销的职责。</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸式增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li></ul></li><li>参与者： - <strong><code>Component</code>：<code>ConcreteComponent</code>和<code>Decorator</code>的父类</strong> - 定义一个对象接口，可以给这些对象动态地添加职责。 - <strong><code>ConcreteComponent</code></strong> - 定义一个对象，可以给这个对象添加一些职责。 - <strong><code>Decorator</code></strong> - 维持一个指向<code>Component</code>对象的指针。 - 定义一个与<code>Component</code>接口一致的接口。 - <strong><code>ConcreteDecorator</code></strong> - 实现添加装饰的接口。</li></ol>
          </div>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><div class="note info">
            <ol><li><strong>接口一致性</strong>：装饰对象的接口必须与它所装饰的对象的接口是一致的。</li><li><strong>省略抽象的<code>Decorator</code>类</strong>：当你仅需要添加一个装饰时，没有必要定义抽象<code>Decorator</code>类。</li><li><strong>保持<code>Component</code>类的简单性</strong>：如果有<code>Component</code>类，保持这个类的简单性是很重要的，即它应集中于定义接口而不是存储数据。</li><li><strong>改变对象外壳与改变对象内核</strong>：我们可以将<code>Decorator</code>看作一个对象的外壳，它可以改变这个对象的行为。另外一种方法是改变对象的内核（通过策略模式）。当需要改变的对象比较庞大时，推荐使用策略模式而不是装饰者模式。</li></ol>
          </div>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">  fire() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发射普通子弹'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnforePlane</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(plane) &#123;</span><br><span class="line">    <span class="keyword">this</span>.plane = plane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fire() &#123;</span><br><span class="line">    <span class="keyword">this</span>.plane.fire();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发射超级导弹'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane();</span><br><span class="line">plane = <span class="keyword">new</span> EnforePlane(plane);</span><br><span class="line">plane.fire(); <span class="comment">// 发射普通子弹</span></span><br><span class="line"><span class="comment">// 发射超级导弹</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式and发布订阅模式</title>
    <url>/posts/9a246216/</url>
    <content><![CDATA[<div class="note warning">
            <p><strong>按照书中的理解，发布订阅模式属于观察者模式。但是现在常常将二者区分开来了，本文首先介绍观察者模式，然后在过程中介绍发布订阅模式。</strong></p>
          </div>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="观察者模式结构"></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BA%A4%E4%BA%92.png" alt="观察者模式交互"></p>
<div class="note info">
            <ol><li>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li><li>适用性：<ul><li>当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当一个对象的改变需要同时改变其它对象，而不知道具体有多少对象待改变。</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。</li></ul></li><li>参与者（未考虑发布订阅模式）： - <strong><code>Subject</code>（目标）</strong> - 目标知道它的观察者。可以有任意多个观察者观察同一个目标。 - 提供注册和删除观察者对象的接口。 - <strong><code>Observer</code>（观察者）</strong> - 为那些在目标发生改变时需获得通知的对象定义一个更新接口。 - <strong><code>ConcreteSubject</code>（具体目标）</strong> - 将有关状态存入各具体观察者中。 - 当它的状态发生改变时，向它的各个具体观察者发出通知。 - <strong><code>ConcreteObserver</code>（具体观察者）</strong> - 存储有关状态，这些状态应与具体目标的状态保持一致。 - 如有需要，可以维护一个指向具体观察者的引用。 - 实现观察者定义的更新接口。</li></ol>
          </div>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><div class="note info">
            <ol><li><strong>创建目标到观察者之间的映射</strong>：<ul><li>可以在每个目标中创建一个列表，用于保存与之关联的观察者的引用。缺点是当目标很多而观察者较少时，存储代价比较高。</li><li>也可以创建一个关联查找机制（例如一个哈希表）用于维护所有目标到观察者的映射。缺点是增加了访问观察者的开销。</li></ul></li><li><strong>观察多个目标</strong>：在某些情况下，一个观察者依赖于多个目标可能是有意义的。在这种情况下，必须扩展观察者的<code>update()</code>接口，以使观察者知道是哪一个目标送来的通知。目标对象可以简单地将自己作为<code>update()</code>的一个参数，让观察者知道应去检查哪一个目标。</li><li><strong>谁调用<code>notify()</code></strong>：目标和它的观察者依赖于通知机制来保持一致。但到底由谁调用<code>notify()</code>来触发更新？<ul><li>可以让目标对象在状态改变后自动调用<code>notify()</code>。</li><li>也可以让观察者在适当时候主动调用目标的<code>notify()</code>。</li></ul></li><li><strong>避免对已删除目标的悬挂引用</strong>：删除一个目标时应注意不要在其观察者中遗留对该目标的悬挂引用。一种避免悬挂引用的方法是，当一个目标被删除时，让它通知它的观察者将对该目标的引用复位。</li><li><strong>在调用<code>notify()</code>前确保目标的状态自身是一致的</strong>。</li><li><strong>避免特定于观察者的更新协议——推/拉模型</strong>：观察者模式的实现经常需要让目标广播关于其改变的其他一些信息。目标将这些信息作为<code>update()</code>的参数传递出去。这些信息的量可能很小，也可能很大。<ul><li><strong>推模型</strong>：目标向观察者发送关于改变的详细信息，而不管它们需要与否。</li><li><strong>拉模型</strong>：目标除最小通知外什么也不送出。</li></ul></li><li><strong>显示地指定感兴趣的改变</strong>：你可以扩展目标的注册接口，让各观察者注册为仅对特定事件感兴趣，以提高更新的效率。当一个事件发生时，目标仅通知那些已注册为对该事件感兴趣的观察者。</li><li><strong>封装复杂的更新语义</strong>：当目标和观察者间的依赖关系特别复杂时，可能需要一个维护这些关系的对象。我们称这样的对象为<strong>更改管理器（<code>ChangeManager</code>）</strong>。它的目的是尽量减少观察者反映其目标状态变化所需的工作量。例如，如果一个操作涉及到对几个相互依赖的目标进行改动，就必须保证仅在所有的目标都已更改完毕后，才一次性地通知它们的观察者，而不是每个目标都通知观察者。<code>ChangeManager</code>有三个责任：<ul><li>它将一个目标映射到它的观察者并提供一个接口来维护这个映射。这就不需要由目标来维护对其观察者的引用，反之亦然。</li><li>它定义一个特定的更新策略。</li><li>根据一个目标的请求，它更新所有依赖于这个目标的观察者。</li></ul></li><li><strong>结合目标类和观察者类</strong>：对于不支持多重继承的语言，可以将目标类和观察者类结合，实现一个既是目标又是观察者的类。</li></ol>
          </div>
<div class="note warning">
            <p><strong>上述第 8 点，就是观察者模式和发布订阅模式的区别所在了。如果不使用<code>ChangeManager</code>则是观察者模式，使用<code>ChangeManager</code>的则是发布订阅模式。</strong></p>
          </div>
<h1 id="观察者模式-demo"><a href="#观察者模式-demo" class="headerlink" title="观察者模式 demo"></a>观察者模式 demo</h1><p>下面是多个客户关注同一个房产中介，从房产中介获取房源信息的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name = '', stateArray = []) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  attach(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(ob);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ob.name&#125;</span>开始关注<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  detach(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.splice(<span class="keyword">this</span>.observers.indexOf(ob), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ob.name&#125;</span>取消关注<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify(info) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      item.update(info);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseAgent</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.houses = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addHouse(&#123; name, price &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.houses[name] = &#123; name, price &#125;;</span><br><span class="line">    <span class="keyword">this</span>.notify(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>新增<span class="subst">$&#123;name&#125;</span>，价格<span class="subst">$&#123;price&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteHouse(name) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.houses[name];</span><br><span class="line">    <span class="keyword">this</span>.notify(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>下架<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update(info) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>知道了<span class="subst">$&#123;info&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> agent = <span class="keyword">new</span> HouseAgent(<span class="string">'房屋中介'</span>),</span><br><span class="line">  customer1 = <span class="keyword">new</span> Observer(<span class="string">'小明'</span>),</span><br><span class="line">  customer2 = <span class="keyword">new</span> Observer(<span class="string">'小李'</span>);</span><br><span class="line"></span><br><span class="line">agent.attach(customer1); <span class="comment">// 小明开始关注房屋中介</span></span><br><span class="line">agent.attach(customer2); <span class="comment">// 小李开始关注房屋中介</span></span><br><span class="line"></span><br><span class="line">agent.addHouse(&#123; <span class="attr">name</span>: <span class="string">'房屋1'</span>, <span class="attr">price</span>: <span class="string">'100万'</span> &#125;); <span class="comment">// 小明知道了房屋中介新增房屋1，价格100万</span></span><br><span class="line"><span class="comment">// 小李知道了房屋中介新增房屋1，价格100万</span></span><br><span class="line"></span><br><span class="line">agent.addHouse(&#123; <span class="attr">name</span>: <span class="string">'房屋2'</span>, <span class="attr">price</span>: <span class="string">'200万'</span> &#125;); <span class="comment">// 小明知道了房屋中介新增房屋2，价格200万</span></span><br><span class="line"><span class="comment">// 小李知道了房屋中介新增房屋2，价格200万</span></span><br><span class="line"></span><br><span class="line">agent.deleteHouse(<span class="string">'房屋1'</span>); <span class="comment">// 小明知道了房屋中介下架房屋1</span></span><br><span class="line"><span class="comment">// 小李知道了房屋中介下架房屋1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/posts/9055d217/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="迭代器模式结构"></p>
<div class="note info">
            <ol><li>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</li><li>适用性：<ul><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口（即，支持多态迭代）。</li></ul></li><li>参与者： - <strong><code>Iterator</code></strong> - 迭代器定义访问和遍历元素的接口。 - <strong><code>ConcreteIterator</code></strong> - 具体迭代器实现迭代器的接口。 - 对该聚合遍历时跟踪当前位置。 - <strong><code>Aggregate</code></strong> - 聚合定义创建相应迭代器对象的接口。 - <strong><code>ConcreteAggregate</code></strong> - 具体聚合实现创建相应迭代器的接口，该操作返回<code>ConcreteAggregate</code>的一个适当的实例。</li></ol>
          </div>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><div class="note info">
            <ol><li><strong>谁控制该迭代</strong>：一个基本的问题是决定由哪一方来控制该迭代，是迭代器还是使用该迭代器的客户。当由客户来控制迭代时，该迭代器称为一个<strong>外部迭代器</strong>，而当由迭代器控制迭代时，该迭代器称为一个<strong>内部迭代器</strong>。使用外部迭代器的客户必须主动推进遍历的步伐，显示地向迭代器请求下一个元素。相反地，若使用内部迭代器，客户只需向其提交一个待执行的操作，而迭代器对聚合中的每一个元素实施该操作。</li><li><strong>谁定义遍历算法</strong>：迭代器不是唯一可定义遍历算法的地方。聚合本身也可以定义遍历算法，并在遍历过程中用迭代器来存储当前迭代的状态。我们称这种迭代器为一个<strong>游标</strong>，因为它仅用来指示当前位置。</li><li><strong>迭代器健壮程度如何</strong>：在遍历一个聚合的同时更改这个聚合可能是危险的。如果在遍历聚合的时候增加或删除该聚合元素，可能会导致两次访问同一个元素或者遗漏掉某个元素。</li></ol>
          </div>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/posts/f5c535ea/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="适配器模式结构"></p>
<div class="note info">
            <ol><li>适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>适用性：<ul><li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li><li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些可能不一定兼容的类）协同工作。</li></ul></li><li>参与者： - <strong><code>Target</code></strong> - 定义<code>Client</code>使用的与特定领域相关的接口。 - <strong><code>Client</code></strong> - 与符合<code>Target</code>接口的对象协同。 - <strong><code>Adaptee</code></strong> - 定义一个已经存在的接口，这个接口需要适配。 - <strong><code>Adapter</code></strong> - 对<code>Adaptee</code>的接口与<code>Target</code>的接口进行适配。</li></ol>
          </div>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/posts/a80d0031/</url>
    <content><![CDATA[<h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。<br><code>&quot;(()&quot; =&gt; 2</code><br><code>&quot;)()())&quot; =&gt; 4</code><br><code>&quot;()(())&quot; =&gt; 6</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 定义 dp[i]:</span></span><br><span class="line"><span class="comment"> *    存在 0 &lt;= x &lt;= i, s[x]...s[i] 为以 s[i] 结尾的最长有效括号子串, dp[i] 为子串长度</span></span><br><span class="line"><span class="comment"> * 2. 确定状态转移方程:</span></span><br><span class="line"><span class="comment"> *    2.1 若 s[i] = '(', 则 dp[i] = 0</span></span><br><span class="line"><span class="comment"> *    2.2 若 s[i] = ')'</span></span><br><span class="line"><span class="comment"> *      2.2.1 若 s[i - 1] = '(', 则 dp[i] = dp[i - 2] + 2</span></span><br><span class="line"><span class="comment"> *      2.2.2 若 s[i - 1] = ')'</span></span><br><span class="line"><span class="comment"> *        2.2.2.1 若 dp[i - 1] = 0, 则 dp[i] = 0</span></span><br><span class="line"><span class="comment"> *        2.2.2.2 若 dp[i - 1] &gt; 0</span></span><br><span class="line"><span class="comment"> *          2.2.2.2.1 若 s[i - 1 - dp[i - 1]] = '(', 则 dp[i] = dp[i - 1] + 2 + dp[i - 2 - dp[i - 1]]</span></span><br><span class="line"><span class="comment"> *          2.2.2.2.2 若 s[i - 1 - dp[i - 1]] = ')', 则 dp[i] = 0</span></span><br><span class="line"><span class="comment"> * 3. 确定初始条件:</span></span><br><span class="line"><span class="comment"> *    dp[0] = 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longestValidParentheses</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> dp = [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'('</span>) &#123;</span><br><span class="line">      dp[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s[i] === ')'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s[i - <span class="number">1</span>] === <span class="string">'('</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      maxLen = <span class="built_in">Math</span>.max(dp[i], maxLen);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s[i] === ')'</span></span><br><span class="line"><span class="comment">     * s[i - 1] === ')'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dp[i - <span class="number">1</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">      dp[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s[i] === ')'</span></span><br><span class="line"><span class="comment">     * s[i - 1] === ')'</span></span><br><span class="line"><span class="comment">     * dp[i - 1] &gt; 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s[i - <span class="number">1</span> - dp[i - <span class="number">1</span>]] === <span class="string">'('</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i - <span class="number">2</span> - dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + dp[i - <span class="number">2</span> - dp[i - <span class="number">1</span>]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      maxLen = <span class="built_in">Math</span>.max(dp[i], maxLen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不同路径条数"><a href="#不同路径条数" class="headerlink" title="不同路径条数"></a>不同路径条数</h1><p>一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步，机器人试图达到网格的右下角。网格中用 0 表示空位置，用 1 表示障碍物。求从左上角到右下角将会有多少条不同的路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * !!! 需要注意横纵坐标与给定数组的对应关系</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 定义dp[i][j]:</span></span><br><span class="line"><span class="comment"> *    从 (0, 0) 出发到 (i, j) 的路径条数</span></span><br><span class="line"><span class="comment"> * 2. 确定状态转移方程:</span></span><br><span class="line"><span class="comment"> *    2.1 若 obstacleGrid[j][i] === 1, 则 dp[i][j] = 0</span></span><br><span class="line"><span class="comment"> *    2.2 若 obstacleGrid[j][i] === 0, 则 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line"><span class="comment"> * 3. 确定初始条件:</span></span><br><span class="line"><span class="comment"> *    dp[0][0] = 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obstacleGrid) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> yLen = obstacleGrid.length;</span><br><span class="line">  <span class="keyword">if</span> (yLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!obstacleGrid[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> xLen = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">if</span> (xLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * i 是横坐标</span></span><br><span class="line"><span class="comment">   * j 是纵坐标</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xLen; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; yLen; j++) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 初始条件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span> &amp;&amp; j === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">          dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dp[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (obstacleGrid[j][i] === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[xLen - <span class="number">1</span>][yLen - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行三种操作：插入一个字符、删除一个字符和替换一个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * !!! 之所以 i, j 代表个数而不代表索引，是考虑到空字符串存在的情况，同时状态转移方程强依赖于空字符串存在的情况</span></span><br><span class="line"><span class="comment"> * 1. 定义dp[i][j]:</span></span><br><span class="line"><span class="comment"> *    word1 的前 i 个子串转换为 word2 的前 j 个子串 所需要的最少操作数</span></span><br><span class="line"><span class="comment"> * 2. 确定状态转移方程:</span></span><br><span class="line"><span class="comment"> *    2.1 若 word[i] === word[j], 则 dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1])</span></span><br><span class="line"><span class="comment"> *    2.2 若 word[i] === word[j], 则 dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + 1)</span></span><br><span class="line"><span class="comment"> * 3. 确定初始条件:</span></span><br><span class="line"><span class="comment"> *    dp[0][j] = j</span></span><br><span class="line"><span class="comment"> *    dp[i][0] = i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minDistance</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = word1.length;</span><br><span class="line">  <span class="keyword">const</span> n = word2.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始条件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    dp[i] = [i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = [j];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 最后一步为插入/删除/替换操作时, 所需的步骤总数</span></span><br><span class="line"><span class="comment">       * 如果 word1[i - 1] === word2[j - 1], 替换操作 = 无操作</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">const</span> insertActions = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> deleteActions = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> replaceActions =</span><br><span class="line">        word1[i - <span class="number">1</span>] === word2[j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      dp[i][j] = <span class="built_in">Math</span>.min(insertActions, deleteActions, replaceActions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>图论算法</title>
    <url>/posts/7de55cdc/</url>
    <content><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p><strong>拓扑排序</strong>是对有向无圈图的顶点的一种排序，使得如果存在一条从 $v_i$ 到 $v_j$ 的路径，那么在排序中 $v_j$ 就在 $v_i$ 的之后出现。它的原理比较简单，直接用下面的图片进行展示了。图片来源与<a href="https://blog.csdn.net/lisonglisonglisong/article/details/45543451" target="_blank" rel="noopener">拓扑排序（Topological Sorting）</a></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="拓扑排序原理图"></p>
<div class="note warning">
            <p><strong>拓扑排序的结果不是唯一的。</strong></p>
          </div>
<h1 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h1><div class="note info">
            <ul><li>对于一个有向附权图，它的边$(v<em>i, v_j)$上的权是$c</em>{i, j+1}$，因此，一条路径$v<em>1v_2…v_n$的值为$\sum</em>{i=1}^{n-1}c_{i,j+1}$，叫作<strong>赋权路径长</strong>。而<strong>无权路径长</strong>只是路径上的边数，即 n-1。</li><li><strong>单源最短路径问题</strong>：给定一个有向附权图 G 和一个特定的顶点 s 作为输入，找出从 s 到 G 中每一个其他顶点的最短赋权路径。</li><li>单源最短路径问题的解可能不唯一。</li><li><strong>负值圈</strong>：如果存在圈，且圈上存在某个边的权值为负数，则称这个圈为负值圈。</li><li>求解单源最短路径问题时，需要分情况进行讨论，分别是： 1. 无权或者权值均为非负。 2. 无负值圈但有负权。 3. 存在负值圈。这种情况下，在求解最短路径过程中会陷入无限循环，即不存在最短路径。</li></ul>
          </div>
<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>在这里，我们介绍 Dijkstra 算法，用它来求解情况 1 下的最短路径。首先，用一张我在网上发现的图片展示 Dijkstra 算法的原理。图片来源<a href="https://zhuanlan.zhihu.com/p/34624812" target="_blank" rel="noopener">轻松搞懂 dijkstra 算法+堆优化 || 原理+实战</a></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86gif%E5%9B%BE.gif" alt="Dijkstra算法原理gif图"></p>
<div class="note info">
            <p>Dijkstra 算法实现步骤：</p><ol><li>对于每一个顶点，有 3 条必要信息：<ul><li><code>distance</code>：代表从开始顶点 s 到当前顶点的最短距离。s 的<code>distance = 0</code>，其他顶点在初始时<code>distance</code>为无穷大。</li><li><code>path</code>：与<code>distance</code>对应的路径上的前一个顶点。</li><li><code>known</code>：该值为<code>true</code>时表示当前顶点的<code>distance</code>值已经是最小的，后续不会再进行更新。<strong>初始时，包括 s 在内的所有顶点<code>known = false</code>。</strong></li></ul></li><li>从 s 开始遍历每个<code>known = false</code>的顶点，将当前顶点的<code>known</code>标识为<code>true</code>。找出当前顶点可以邻接到的其他顶点，然后依次根据情况决定是否更新这些被邻接到的顶点的<code>distance</code>和<code>path</code>。最后在所有<code>known = false</code>的顶点中找出<code>distance</code>最小的一个，让它成为下一个当前顶点。</li><li>当所有顶点的<code>known</code>均为<code>true</code>时，算法运行结束。</li></ol><hr><p><strong>如果有向图是无圈的，则可以改进 Dijkstra 算法原有的顶点选择方式，按照拓扑排序的顺序选择顶点。</strong></p>
          </div>
<div class="note warning">
            <p><strong>如果想要 Dijkstra 算法可以正常工作，必须保证有向图中没有负的权值，否则<code>known</code>将失去存在的意义。</strong></p>
          </div>
<h2 id="无负值圈但有负权"><a href="#无负值圈但有负权" class="headerlink" title="无负值圈但有负权"></a>无负值圈但有负权</h2><div class="note warning">
            <p><strong>有的人想到在这种情况下给每个边上的权值都加上一个相同的常数，从而消除负权值，再使用 Dijkstra 算法进行计算。这样做是行不通的，因为这样做会导致边数多的路径相对于边数少的路径，权重更重了。</strong></p>
          </div>
<div class="note info">
            <p>这种情况的新算法步骤如下所示：</p><ol><li>每个顶点都有<code>distance</code>和<code>path</code>属性。同时算法还需要维护一个队列，它里面保存的是需要被遍历的顶点。</li><li>将开始顶点 s 加入队列中。</li><li>取出队列中的第一个顶点，找到所有可以被它邻接到的其他顶点，然后依次根据情况决定是否更新这些被邻接到的顶点的<code>distance</code>和<code>path</code>。</li><li>在进行步骤 3 时，如果决定更新某个顶点的<code>distance</code>和<code>path</code>，并且这个被更新的顶点不在队列之中，那么就在更新的同时，将它加入到队列中。</li><li>重复步骤 3 和步骤 4，直到队列为空。</li></ol><p><strong>这个算法的重点在于加顶点加入队列的判断机制。</strong></p>
          </div>
<h1 id="网络流问题"><a href="#网络流问题" class="headerlink" title="网络流问题"></a>网络流问题</h1><p>设给定有向图 G，其任意边$(v<em>i, v_j)$上的容量为$c</em>{i,j}$。这里有两个顶点，一个是<strong>发点 s</strong>，一个是<strong>收点 t</strong>。在既不是发点 s 又不是收点 t 的任意顶点 v，总的进入流必须等于总的发出流。<strong>最大流问题</strong>就是确定从 s 到 t 可以通过的最大流量。例如，下图展示了一个有向图和它的最大流。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%92%8C%E5%AE%83%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81.png" alt="一个图和它的最大流"></p>
<p>从图中看到，顶点 s 有容量为 4 和 2 的两条边流出，而顶点 t 有容量为 3 和 3 的两条边进入。因此，最大流也许可能是 6 而不是 5。然而，下图指出如何证明最大流就是 5。我们把图切割成两部分：一部分包含顶点 s，而另一部分包含顶点 t。既然流必须通过切口，于是切口上所有的边的总容量就是最大流的一个界。从图中恰好可以看到，5 就是最大流的一个界。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%88%87%E5%89%B2%E5%9B%BE.png" alt="切割图"></p>
<p>求解最大流问题的首要想法是分阶段进行。我们从图 G 开始并构造一个<strong>流图（flow graph）</strong>$G_f$。$G_f$表示在求解的任意阶段已经达到的流。开始时$G_f$的所有的边都是没有流的，我们希望当算法终止时$G_f$包含最大流。另外，我们还构造一个图$G_r$，称为<strong>残余图（residual graph）</strong>，它表示对于每条边还能再添加上多少流。对于每一条边，可以从容量中减去当前的流而计算除残余的流。$G_r$的边叫作<strong>残余边（residual edge）</strong>。在每个阶段，我们寻找图$G_r$中从 s 到 t 的一条路径，这条路径叫作<strong>增长通路（augmenting path）</strong>。这条路径上的最小容量就是可以添加到路径每一边上的流的量。下面用一个图展示这些概念。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E3%80%81%E6%B5%81%E5%9B%BE%E4%BB%A5%E5%8F%8A%E6%AE%8B%E4%BD%99%E5%9B%BE.png" alt="图、流图以及残余图"></p>
<p>下面给出求解最大流问题的具体步骤：</p>
<div class="note info">
            <ol><li>在$G_r$中找到任意一条增长通路，根据该增长通路，更新$G_f$中的的流信息，然后在$G_r$将该增长路径调整为相反方向。</li><li>重复步骤 1，直到在$G_r$中找不到增长通路位置。</li></ol><p>其实步骤 1 中的增长通路的选择上可以做一些文章从而减少时间复杂度，这里暂时不进行详细分析了。</p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E3%80%81%E6%B5%81%E5%9B%BE%E4%BB%A5%E5%8F%8A%E6%AE%8B%E4%BD%99%E5%9B%BE.png" alt="图、流图以及残余图"></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.png" alt="求解过程"></p>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>堆</title>
    <url>/posts/f2cac40a/</url>
    <content><![CDATA[<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>只要满足下面的结构性质和堆序性质的，就是二叉堆</p>
<h3 id="结构性质"><a href="#结构性质" class="headerlink" title="结构性质"></a>结构性质</h3><p>二叉堆是一颗被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入。这样的树称为完全二叉树。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p>
<p>容易证明，一颗高为 h 的完全二叉树有$2^h$到$2^{h+1} - 1$个节点。这意味着，完全二叉树的高是$\lfloor logN \rfloor$，显然它是$O(logN)$</p>
<p>一个重要的观察发现，因为完全二叉树这么有规律，所以它可以用一个数组表示</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0.png" alt="完全二叉树的数组实现"></p>
<p>该数组索引为 0 的位置是空的，元素是从索引为 1 的位置开始放入的。这样的话，对于数组中的任意位置$i$上的元素，其左儿子在位置$2i$上，右儿子在左儿子后的单元$2i+1$中，它的父亲则在位置$\lfloor i/2 \rfloor$上。</p>
<h3 id="堆序性质"><a href="#堆序性质" class="headerlink" title="堆序性质"></a>堆序性质</h3><p>使操作被快速执行的性质是<strong>堆序性质</strong>。由于我们想要能够快速地找出最小/大元，因此最小/大元应该在根上。如果我们考虑任意子树也应该是一个堆，那么任意节点就应该小/大于它的所有后裔。</p>
<h2 id="最小-大堆"><a href="#最小-大堆" class="headerlink" title="最小/大堆"></a>最小/大堆</h2><div class="note info">
            <p>二叉堆分为最小堆和最大堆</p><ul><li><strong>最小堆</strong>：在最小堆中，对于每一个节点 X，X 的父亲中的关键字小于（或等于）X 中的关键字，根节点除外（它没有父亲）</li><li><strong>最大堆</strong>：在最大堆中，对于每一个节点 X，X 的父亲中的关键字大于（或等于）X 中的关键字，根节点除外（它没有父亲）</li></ul>
          </div>
<h2 id="二叉堆的操作"><a href="#二叉堆的操作" class="headerlink" title="二叉堆的操作"></a>二叉堆的操作</h2><p>下面的操作，均以最小堆为例</p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>为了将一个元素 X 插入到堆中，我们必须在下一个可用位置创建一个<strong>空穴</strong>，否则该堆将不是完全二叉树了。如果 X 可以放在该空穴中而并不破坏堆的序，那么插入完成。否则，我们把空穴的父节点上的元素移入该空穴中，这样，空穴就朝着根的方向上冒一步。继续该过程直到 X 能被放入空穴中位置。这种一般的策略叫作<strong>上滤</strong>。</p>
<div class="note info">
            <p><strong>时间复杂度（最坏）</strong>：$O(logN)$</p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/insert1.png" alt="insert1"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/insert2.png" alt="insert2"></p>
<h3 id="deleteMin"><a href="#deleteMin" class="headerlink" title="deleteMin"></a>deleteMin</h3><p>当删除一个最小元时，要在根节点建立一个空穴。由于现在的堆少了一个元素，因此堆中最后一个元素 X 必须移动到该堆的某个地方。如果 X 可以被放到空穴中，那么 <code>deleteMin</code> 就完成。否则我们将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层。重复该步骤直到 X 可以被放入空穴中。因此，我们的做法是将 X 置入沿着从根节点开始包含最小儿子的一条路径上的一个正确的位置。这种一般的策略叫作<strong>下滤</strong>。</p>
<div class="note info">
            <p><strong>时间复杂度（最坏）</strong>：$O(logN)$</p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/deleteMin.png" alt="deleteMin"></p>
<h3 id="decreaseKey"><a href="#decreaseKey" class="headerlink" title="decreaseKey"></a>decreaseKey</h3><p><code>decreaseKey(p, △)</code> 操作降低在位置 <code>p</code> 处的项的值，降值的幅度为正的量 <code>△</code>。由于这可能破坏堆序性质，因此必须通过上滤堆堆进行调整。</p>
<h3 id="increaseKey"><a href="#increaseKey" class="headerlink" title="increaseKey"></a>increaseKey</h3><p><code>increaseKey(p, △)</code> 操作增加在位置 <code>p</code> 处的项的值，增值的幅度为正的量 <code>△</code>。这可以用下滤来完成。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove(p)</code> 操作删除堆中位置 <code>p</code> 上的节点。该操作通过首先执行 <code>decreaseKey(p, ∞)</code> 然后再执行 <code>deleteMin</code> 来完成。</p>
<h3 id="buildHeap"><a href="#buildHeap" class="headerlink" title="buildHeap"></a>buildHeap</h3><p>有时二叉堆是由一些项的一个初始集合构造而得的，当然可以使用连续的 <code>insert</code> 操作来完成堆的构建，但是这样的话最坏情况下的时间复杂度为 $O(NlogN)$，这并不是最优的方案。</p>
<div class="note info">
            <p>最优方案步骤：</p><ol><li>将这些项构成的集合直接转换为一个无序的完全二叉树</li><li>从完全二叉树的最后一个非叶子节点开始往前遍历，依次进行下滤策略</li></ol><p><strong>时间复杂度（最坏）</strong>：$O(N)$</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">90</span>, <span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildHeap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> heap = [];</span><br><span class="line">  heap.size = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    heap[i + <span class="number">1</span>] = array[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentIndex = <span class="built_in">Math</span>.floor(heap.size / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    percolateDown(heap, currentIndex);</span><br><span class="line">    currentIndex--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">percolateDown</span>(<span class="params">heap, currentIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> leftSonIndex = <span class="number">2</span> * currentIndex,</span><br><span class="line">    rightSonIndex = <span class="number">2</span> * currentIndex + <span class="number">1</span>,</span><br><span class="line">    minValueIndex = currentIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (leftSonIndex &lt;= heap.size &amp;&amp; heap[leftSonIndex] &lt; heap[currentIndex]) &#123;</span><br><span class="line">    minValueIndex = leftSonIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rightSonIndex &lt;= heap.size &amp;&amp; heap[rightSonIndex] &lt; heap[minValueIndex]) &#123;</span><br><span class="line">    minValueIndex = rightSonIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentIndex !== minValueIndex) &#123;</span><br><span class="line">    [heap[currentIndex], heap[minValueIndex]] = [</span><br><span class="line">      heap[minValueIndex],</span><br><span class="line">      heap[currentIndex],</span><br><span class="line">    ];</span><br><span class="line">    percolateDown(heap, minValueIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buildHeap(list));</span><br></pre></td></tr></table></figure>
<h1 id="d-堆"><a href="#d-堆" class="headerlink" title="$d$堆"></a>$d$堆</h1><p>$d$ 堆是二叉堆的简单推广，它恰像一个二叉树，只是所有的节点都有 $d$ 个儿子（因此，二叉堆是 2 堆）。</p>
<p>$d$ 堆要比二叉堆浅得多，它将 <code>insert</code> 操作的运行时间改进为 $O(log_dN)$。然而，对于大的 $d$，<code>deleteMin</code> 操作费时得多，因为虽然树是浅了，但是 $d$ 个儿子中的最小者是必须要找出的，如果使用标准的算法，这会花费 $d-1$ 次比较，于是将操作的用时提高到 $O(dlog_dN)$。如果 $d$ 是常数，那么当然两者的运行时间都是 $O(logN)$。最后，有证据显示，在实践中 4 堆可以胜过二叉堆。</p>
<h1 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h1><p><strong>左式堆</strong>像二叉堆那样也具有结构性和有序性。事实上，和所有使用的堆一样，左式堆具有相同的堆序性质。左式堆与二叉堆的区别主要体现在结构性上。</p>
<h2 id="结构性质-1"><a href="#结构性质-1" class="headerlink" title="结构性质"></a>结构性质</h2><p>我们把任意节点 X 的<strong>零路径长</strong><code>npl(X)</code>定义为从 X 到一个不具有两个儿子的节点的最短路径长。因此，具有 0 或 1 个儿子的节点的<code>npl = 0</code>，而空节点的<code>npl = -1</code>。</p>
<p>任意节点的零路径长比它的诸儿子节点的零路径长的最小值多 1。这个结论也适用少于两个儿子的节点。</p>
<div class="note info">
            <ul><li><strong>左式堆的结构性质是</strong>：对于每一个节点 X，左儿子的零路径长至少与右儿子的零路径长一样。对于堆中的每一个节点 X，左儿子的零路径长大于等于右儿子的零路径长</li><li>《数据结构与算法分析》中有证明，在右路径上有$r$个节点的左式堆必然至少有$2^r-1$个节点</li></ul>
          </div>
<h2 id="左式堆操作"><a href="#左式堆操作" class="headerlink" title="左式堆操作"></a>左式堆操作</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>这里我要介绍的是递归进行合并的方法。当要合并两个堆时，如果有一个是空的，则直接返回另一个堆。否则，为了合并这两个堆，可比较它们的根。首先，递归地将具有较大的根植的堆与具有较小的根植的堆的右子堆合并，然后判断左子堆和新的右子堆的零路径长，如果不满足左式堆的结构性，那么交换左子堆与右子堆的位置。</p>
<h3 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h3><p>insert 可以看作是 merge 的一种特殊情况，就是把插入看作是单节点堆与一个更大的堆的 merge。</p>
<h3 id="deleteMin-1"><a href="#deleteMin-1" class="headerlink" title="deleteMin"></a>deleteMin</h3><p>deleteMin 也可以看作是 merge 的一种特殊情况，首先将根节点移除，然后对两个儿子进行 merge 操作。</p>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/posts/cd65786b/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><div class="note info">
            <p>排序算法可以分为以下两种类型：</p><ul><li><strong>比较类非线性时间排序</strong>：通过比较来决定元素间的相对次序，其时间复杂度不能突破$O(nlogn)$</li><li><strong>非比较类线性时间排序</strong>：不通过比较来决定元素间的相对次序，其时间复杂度最低可以为$O(n)$</li></ul><hr><ul><li><strong>稳定性</strong>：如果排序前后两个相等元素的相对次序不变，则算法稳定；反之算法不稳定</li></ul>
          </div>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>从最前面的两个元素开始，不断对相邻元素进行比较，根据情况决定是否交换相邻元素的位置，直到最后。这会将最大的元素“冒泡”到元素列的末尾位置。</li><li>步骤 1 需要被重复执行 n-1 次。但是每一趟排序时，不是全部元素都需要进行比较的。例如，对于第 m 趟排序，此时元素列最后面的 m 个元素是已经完成排序了的，所以不需要对它们进行重复的比较。</li></ol></li><li><strong>最坏时间复杂度</strong>：$O(n^2)$</li><li><strong>平均时间复杂度</strong>：$O(n^2)$</li><li><strong>最好时间复杂度</strong>：$O(n)$</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>稳定性</strong>：稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array.join(<span class="string">'   '</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [array[j], array[j + <span class="number">1</span>]] = [array[j + <span class="number">1</span>], array[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(array.join(<span class="string">'   '</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleSort(list);</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>共需要进行 n-1 次循环。每次循环都会选定一个起点元素，例如，第一次循环是以第一个元素为起点。第 m 次循环是以第 m 个元素为起点。</li><li>在每次循环中，找出本次循环中从起点元素开始到最后一个元素为止最小的元素，如果这个元素正是起点元素则什么都不做，否则交换起点元素与该最小元素的位置。</li></ol></li><li><strong>最坏时间复杂度</strong>：$O(n^2)$</li><li><strong>平均时间复杂度</strong>：$O(n^2)$</li><li><strong>最好时间复杂度</strong>：$O(n^2)$</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>稳定性</strong>：不稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array.join(<span class="string">'   '</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line">  <span class="keyword">let</span> mixIndex;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    mixIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &lt; array[mixIndex]) &#123;</span><br><span class="line">        mixIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [array[mixIndex], array[i]] = [array[i], array[mixIndex]];</span><br><span class="line">    <span class="built_in">console</span>.log(array.join(<span class="string">'   '</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectionSort(list);</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>共需要进行 n-1 次循环。每次循环都会选定一个待插入元素，例如，第一次循环是以第二个元素为待插入元素。第 m 次循环是以第 m+1 个元素为待插入元素。</li><li>在每次循环中，不断将待插入元素与处于它前方的元素进行比较，找出适合它的位置并插入。</li></ol></li><li><strong>最坏时间复杂度</strong>：$O(n^2)$</li><li><strong>平均时间复杂度</strong>：$O(n^2)$</li><li><strong>最好时间复杂度</strong>：$O(n)$</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>稳定性</strong>：稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array.join(<span class="string">'   '</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> unsortValue = array[i];</span><br><span class="line">    <span class="keyword">let</span> currentIndex = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (currentIndex &gt;= <span class="number">0</span> &amp;&amp; array[currentIndex] &gt; unsortValue) &#123;</span><br><span class="line">      array[currentIndex + <span class="number">1</span>] = array[currentIndex];</span><br><span class="line">      currentIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    array[currentIndex + <span class="number">1</span>] = unsortValue;</span><br><span class="line">    <span class="built_in">console</span>.log(array.join(<span class="string">'   '</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insertionSort(list);</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt="插入排序"></p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>按照步长<code>n/2 =&gt; n/4 =&gt; ··· =&gt; 1</code>进行循环。每次循环中根据步长对元素列进行分组，然后对这些分组执行插入排序。</li></ol></li><li><strong>最坏时间复杂度</strong>：$O(n^2)$</li><li><strong>平均时间复杂度</strong>：$O(n^{1.3})$</li><li><strong>最好时间复杂度</strong>：$O(n)$</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>稳定性</strong>：不稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array.join(<span class="string">'   '</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="comment">// 内部为插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> unsortValue = array[i];</span><br><span class="line">      <span class="keyword">let</span> currentIndex = i - gap;</span><br><span class="line">      <span class="keyword">while</span> (currentIndex &gt;= <span class="number">0</span> &amp;&amp; array[currentIndex] &gt; unsortValue) &#123;</span><br><span class="line">        array[currentIndex + gap] = array[currentIndex];</span><br><span class="line">        currentIndex = currentIndex - gap;</span><br><span class="line">      &#125;</span><br><span class="line">      array[currentIndex + gap] = unsortValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(array.join(<span class="string">'   '</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shellSort(list);</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="希尔排序"></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>不断地将元素列分成两个部分，然后对这两个部分递归执行归并排序。</li><li>当元素列只有 1 个元素时，停止递归。</li><li>对于被划分的两个部分，需要按照顺序将它们合并为一个整体。</li></ol></li><li><strong>最坏时间复杂度</strong>：$O(nlogn)$</li><li><strong>平均时间复杂度</strong>：$O(nlogn)$</li><li><strong>最好时间复杂度</strong>：$O(nlogn)$</li><li><strong>空间复杂度</strong>：$O(n)$</li><li><strong>稳定性</strong>：稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">      left = array.slice(<span class="number">0</span>, middle),</span><br><span class="line">      right = array.slice(middle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">    result.push(left.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">    result.push(right.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergeSort(list);</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>通过<strong>三数中值分割法</strong>，从元素列中选出最左侧，中间和最右侧的三个元素，并排序。</li><li>从步骤 1 中排序后的三个元素中选择中间元素作为枢纽元素，并交换枢纽元素和元素列倒数第二个元素的位置。</li><li>选择<code>i = left + 1, j = right - 2</code>。</li><li>不断执行<code>i++</code>操作，直到<code>i</code>所处元素大于等于枢纽元素为止。</li><li>不断执行<code>j--</code>操作，直到<code>j</code>所处元素小于等于枢纽元素为止。</li><li>如果<code>i &lt; j</code>，那么交换这两个位置上的元素，然后重复执行步骤 4、5。</li><li>如果<code>i &gt;= j</code>，那么此刻位置<code>i</code>上的元素一定是大于等于枢纽元素的，此时交换位置<code>i</code>上的元素和枢纽元素的位置。交换之后，枢纽元素左侧的元素均小于等于它，而它右侧的元素均大于等于它。</li><li>不断对被枢纽元素分割开来的两个子元素列执行步骤 1 至步骤 7，直到排序完成。</li></ol></li><li><strong>最坏时间复杂度</strong>：$O(n^2)$</li><li><strong>平均时间复杂度</strong>：$O(nlgn)$</li><li><strong>最好时间复杂度</strong>：$O(nlgn)$</li><li><strong>空间复杂度</strong>：$O(lgn)$ 至 $O(n)$ 之间</li><li><strong>稳定性</strong>：不稳定</li></ul>
          </div>
<div class="note warning">
            <ul><li>需要注意<code>array[i]=array[j]=pivot</code>的情况，不要陷入死循环。</li><li>为什么当所遇元素与枢纽元素相等时，也要让<code>i</code>和<code>j</code>停下来，并交换位置？<br>这样可以确保被枢纽元素分割开来的两部分尽量均衡，减少插入排序算法总的时间复杂度。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> left = <span class="keyword">typeof</span> left !== <span class="string">'number'</span> ? <span class="number">0</span> : left,</span><br><span class="line">    right = <span class="keyword">typeof</span> right !== <span class="string">'number'</span> ? array.length - <span class="number">1</span> : right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left + <span class="number">1</span> === right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[left] &lt;= array[right]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [array[left], array[right]] = [array[right], array[left]];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pivot = median3(array, left, right),</span><br><span class="line">    i = left + <span class="number">1</span>,</span><br><span class="line">    j = right - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pivot &lt; array[j]) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] === array[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [array[i], array[j]] = [array[j], array[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [array[i], array[right - <span class="number">1</span>]] = [array[right - <span class="number">1</span>], array[i]];</span><br><span class="line"></span><br><span class="line">  quickSort(array, left, i - <span class="number">1</span>);</span><br><span class="line">  quickSort(array, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">median3</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> center = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array[center] &lt; array[left]) &#123;</span><br><span class="line">    [array[left], array[center]] = [array[center], array[left]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[right] &lt; array[left]) &#123;</span><br><span class="line">    [array[left], array[right]] = [array[right], array[left]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[right] &lt; array[center]) &#123;</span><br><span class="line">    [array[center], array[right]] = [array[right], array[center]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [array[center], array[right - <span class="number">1</span>]] = [array[right - <span class="number">1</span>], array[center]];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array[right - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">quickSort(list);</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>首先将元素列转换为最大堆形式的数组。</li><li>数组中的最大元素总在 A[1] 中，把它与 A[heap.size] 进行互换，同时从堆中去掉最后一个结点（这一操作可以通过减少 heap.size 来实现）。</li><li>步骤 2 之后，最大堆的剩余结点中，原来根的孩子结点仍然是最大堆，而新的根节点可能会违背最大堆的性质。为了维护最大堆的性质，我们要做的就是通过下滤操作使其符合最大堆的性质。</li><li>重复步骤 2、3，直到 heap.size = 1。</li></ol></li><li><strong>最坏时间复杂度</strong>：$O(nlgn)$</li><li><strong>平均时间复杂度</strong>：$O(nlgn)$</li><li><strong>最好时间复杂度</strong>：$O(nlgn)$</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>稳定性</strong>：不稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">90</span>, <span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> heap = buildHeap(array);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = heap.size; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">    [heap[i], heap[<span class="number">1</span>]] = [heap[<span class="number">1</span>], heap[i]];</span><br><span class="line">    heap.size--;</span><br><span class="line">    percolateDown(heap, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> heap.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildHeap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> heap = [];</span><br><span class="line">  heap.size = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    heap[i + <span class="number">1</span>] = array[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentIndex = <span class="built_in">Math</span>.floor(heap.size / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    percolateDown(heap, currentIndex);</span><br><span class="line">    currentIndex--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">percolateDown</span>(<span class="params">heap, currentIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> leftSonIndex = <span class="number">2</span> * currentIndex,</span><br><span class="line">    rightSonIndex = <span class="number">2</span> * currentIndex + <span class="number">1</span>,</span><br><span class="line">    maxValueIndex = currentIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (leftSonIndex &lt;= heap.size &amp;&amp; heap[leftSonIndex] &gt; heap[currentIndex]) &#123;</span><br><span class="line">    maxValueIndex = leftSonIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rightSonIndex &lt;= heap.size &amp;&amp; heap[rightSonIndex] &gt; heap[maxValueIndex]) &#123;</span><br><span class="line">    maxValueIndex = rightSonIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentIndex !== maxValueIndex) &#123;</span><br><span class="line">    [heap[currentIndex], heap[maxValueIndex]] = [</span><br><span class="line">      heap[maxValueIndex],</span><br><span class="line">      heap[currentIndex],</span><br><span class="line">    ];</span><br><span class="line">    percolateDown(heap, maxValueIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(heapSort(list)); <span class="comment">// [ 50, 60, 61, 70, 80, 83, 84, 87, 88, 90 ]</span></span><br></pre></td></tr></table></figure>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>假设元素列中的元素均处于 $[0, k]$ 区间内，$k$ 为某个整数。</li><li>准备一个长度为 $k+1$ 的数组 temp，索引为 $i$ 处记录着元素列中值为 $i$ 的元素的个数。</li><li>调整数组 temp，使得索引为 $i$ 处记录着元素列中值小于等于 $i$ 的元素的个数。</li><li>准备一个长度为 $n$ 的数组 res 用于存储排序后的元素列，然后从后至前的迭代待排序的元素列，根据 temp 确定每次迭代的元素应该处于哪个位置，同时对 temp 进行适当的修改。</li></ol></li><li><strong>时间复杂度</strong>：$\Theta(n+k)$</li><li><strong>空间复杂度</strong>：$O(n+k)$</li><li><strong>稳定性</strong>：稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = [];</span><br><span class="line"></span><br><span class="line">  array.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp[item] === <span class="string">'number'</span>) &#123;</span><br><span class="line">      temp[item] = temp[item] + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      temp[item] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">typeof</span> temp[i] === <span class="string">'number'</span> ? temp[i] : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">      temp[i] = cur;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      temp[i] = cur + temp[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = array[i];</span><br><span class="line">    res[temp[value] - <span class="number">1</span>] = value;</span><br><span class="line">    temp[value] = temp[value] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(countingSort(list)); <span class="comment">// [ 0, 0, 2, 2, 3, 3, 3, 5 ]</span></span><br></pre></td></tr></table></figure>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>假设元素列中的元素均处于 $[0, 1）$ 区间内。</li><li>准备一个长度为 10 的数组 temp。</li><li>假设元素的值为 $x$，则将它放入 temp 数组索引为 $\lfloor 10x \rfloor$ 的位置。</li><li>对数组 temp 下的每个“桶”进行排序，然后将排序后的“桶”拼接在一起。</li></ol></li><li><strong>时间复杂度</strong>：需要考虑每个桶内排序所消耗的时间</li><li><strong>空间复杂度</strong>：$O(n+k)$</li><li><strong>稳定性</strong>：稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">0.78</span>, <span class="number">0.17</span>, <span class="number">0.39</span>, <span class="number">0.26</span>, <span class="number">0.72</span>, <span class="number">0.94</span>, <span class="number">0.21</span>, <span class="number">0.12</span>, <span class="number">0.23</span>, <span class="number">0.68</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>), () =&gt; []);</span><br><span class="line"></span><br><span class="line">  array.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(item * <span class="number">10</span>);</span><br><span class="line">    temp[index].push(item);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  temp = temp.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      insertionSort(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [].concat(...temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> unsortValue = array[i];</span><br><span class="line">    <span class="keyword">let</span> currentIndex = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (currentIndex &gt;= <span class="number">0</span> &amp;&amp; array[currentIndex] &gt; unsortValue) &#123;</span><br><span class="line">      array[currentIndex + <span class="number">1</span>] = array[currentIndex];</span><br><span class="line">      currentIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    array[currentIndex + <span class="number">1</span>] = unsortValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bucketSort(list)); <span class="comment">// [ 0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94 ]</span></span><br></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><div class="note info">
            <ul><li><strong>实现步骤（从小到大排序）</strong>：<ol><li>从最低有效位开始，依次根据当前位的关键字对元素列使用<strong>稳定排序算法</strong>进行排序。</li></ol></li><li><strong>时间复杂度</strong>：<ol><li>给定 $n$ 个 $d$ 位数，其中每一个数位有 $k$ 个可能的取值。如果使用的稳定排序方法耗时 $\Theta(n+k)$，那么它就可以在 $\Theta(d(n+k))$ 时间内将这些数排好序。</li><li>给定一个 $b$ 位数和任何正整数 $r \leq b$，如果使用稳定排序算法对数据取值区间为 $[0, k]$ 的输入进行排序耗时 $\Theta(n+k)$，那么它就可以在 $\Theta((b/r)(n+2^r))$ 时间内将这些数排好序。</li></ol></li><li><strong>空间复杂度</strong>：由过程中使用的稳定排序算法决定</li><li><strong>稳定性</strong>：稳定</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">329</span>, <span class="number">457</span>, <span class="number">657</span>, <span class="number">839</span>, <span class="number">436</span>, <span class="number">720</span>, <span class="number">355</span>, <span class="number">11</span>, <span class="number">20</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">array, d</span>) </span>&#123;</span><br><span class="line">  array = array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="built_in">String</span>(item),</span><br><span class="line">      len = str.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0'</span>.repeat(d - len) + str;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = d - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = [];</span><br><span class="line"></span><br><span class="line">    array.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> temp[item[i]] === <span class="string">'number'</span>) &#123;</span><br><span class="line">        temp[item[i]] = temp[item[i]] + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp[item[i]] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; temp.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = <span class="keyword">typeof</span> temp[j] === <span class="string">'number'</span> ? temp[j] : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (j === <span class="number">0</span>) &#123;</span><br><span class="line">        temp[j] = cur;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp[j] = cur + temp[j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = array.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = array[j],</span><br><span class="line">        singleValue = array[j][i];</span><br><span class="line">      res[temp[singleValue] - <span class="number">1</span>] = value;</span><br><span class="line">      temp[singleValue] = temp[singleValue] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array = res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">parseInt</span>(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(radixSort(list, <span class="number">3</span>)); <span class="comment">// [ 4, 11, 20, 329, 355, 436, 457, 657, 720, 839 ]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>散列（哈希）表</title>
    <url>/posts/5ff4158/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>散列表是一种用于以常数平均时间执行插入、删除和查找的技术。但是，那些需要元素间任何序信息的树操作在这里将不会得到有效的支持（如<code>findMin</code>、<code>findMax</code>）。理想的散列表只不过是一个具有固定大小的数组。假定散列表长度为<code>n</code>，当向散列表中插入数据时，将该数据的<strong>关键字（key）</strong>作为输入传递给一个称作<strong>散列函数（hash function）</strong>的映射函数，然后得到一个 <code>0 ~ n-1</code> 的数值，这个数值代表的是该数据插入散列表的位置。给定两个不同的关键字，如果散列函数的输出结果相同，这种情况叫作<strong>冲突（collision）</strong>。</p>
<p>如果输入的关键字是整数，则一般合理的方法是直接返回 Key mod TableSize，除非 Key 碰巧具有某些不理想的性质。例如，若表的大小是 10 而关键字都以 0 为个位，则此时上述标准的散列函数就是一个坏的选择。为了避免这样的情况，通常保证表的大小是素数，当输入的关键字是随机整数时，散列函数不仅计算起来非常简单，而且关键字的分配也很均匀，减少了冲突的发生。</p>
<h1 id="分离链表法"><a href="#分离链表法" class="headerlink" title="分离链表法"></a>分离链表法</h1><p>解决冲突的第一种方法叫作<strong>分离链表法</strong>，其做法是将散列到同一个值的所有元素保留到一个链表中。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%E8%A1%A8/%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95.png" alt="分离链表法"></p>
<p>为了执行一次 search，需要使用散列函数来确定究竟遍历哪个链表，然后在适当的链表中执行一次查找。为执行 insert，需要检查相应的链表看看该元素是否已经处在相应的位置。如果这个元素是个新的元素，那么它将被插入到链表的前端，这不仅是因为方便，而且还因为常常发生这样的事实：新近插入的元素最有可能不久又被访问。</p>
<p>除链表外，任何合理的方案也都可以解决冲突现象，一颗二叉查找树或甚至另一个散列表都将胜任这个工作，但是我们期望，如果散列表是大的并且散列函数是好的，那么所有的链表都应该是短的，从而基本的分离链表法就没有必要再尝试任何复杂的手段了。</p>
<p>我们定义散列表的<strong>装填因子 λ</strong> 为散列表中的元素个数对该表大小的比。在上面的例子中，<code>λ = 1.0</code>。链表的平均长度为 λ。执行一次查找所需的代价，是计算散列函数值所需要的常数时间加上遍历所用的时间。在一次不成功的查找中，要遍历的节点数平均为 <code>λ</code>。一次成功的查找则需要遍历大约 <code>1+(λ/2)</code> 个链。</p>
<h1 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h1><p>分离链表法的缺点是使用一些链表，由于给新单元分配地址需要时间，因此这就导致算法的速度有些减慢，同时算法实际上还要求对第二种数据结构的实现。而开放定址法解决冲突的思路是尝试另外一些单元，直到找出空的单元为止。一般来说，对于使用开放定址法的散列表，其装填因子应该满足<code>λ &lt; 0.5</code>。</p>
<h2 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h2><div class="note info">
            <p><strong>当发生冲突时，从当前位置开始，依次往后进行探测，当探测到空闲位置时，插入元素。</strong></p>
          </div>
<p>下面例子中，$hash(x) = x mod n, n = 10$，插入项：{89, 18, 49, 58, 69}。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%E8%A1%A8/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png" alt="线性探测法"></p>
<p>只要表足够大，使用线性探测法总能够找到一个空闲为止，但是如此花费的时间是相当多的。更糟的是，即使表相对较空，这样占据的为止也会开始形成一些区块，其结果称为<strong>一次聚焦</strong>，就是说，散列到区块中的任何数据都需要多次试选单元才能够解决冲突，然后该数据被添加到相应的区块中。</p>
<h2 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h2><div class="note info">
            <p><strong>当发生冲突时，从当前位置开始，依次探测当前位置之后的第 $1, 2^2, 3^2, 4^2, …$ 个位置，当探测到空闲位置时，插入元素。</strong></p>
          </div>
<p>下面例子中，$hash(x) = x mod n, n = 10$，插入项：{89, 18, 49, 58, 69}。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%E8%A1%A8/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95.png" alt="平方探测法"></p>
<div class="note info">
            <p>使用平方探测时，如果表的大小是素数，同时表至少还有一半的空余位置，那么新的元素一定可以探测到空余位置。</p>
          </div>
<p>对于线性探测，让散列表几乎填满元素并不是个好主意，因为此时表的性能会降低。对于平方探测情况甚至更糟，一旦表被填满超过一半，或者表的长度不是素数，就不能保证可以探测到空余位置了。这是因为可以用作解决冲突的备选位置最多只有表长度的一半。</p>
<p>虽然平方探测排除了一次聚焦，但是散列到同一位置上的那些元素将探测相同的备选单元。这叫作<strong>二次聚焦</strong>。二次聚焦是理论上的一个小缺憾。</p>
<h2 id="双散列"><a href="#双散列" class="headerlink" title="双散列"></a>双散列</h2><div class="note info">
            <p><strong>当发生冲突时，使用第二个散列函数计算 $d=hash_2(x)$，然后依次探测当前位置之后的第 $d, 2d, 3d, …$ 个位置，当探测到空闲位置时，插入元素。</strong></p>
          </div>
<p>下面例子中，$hash_1(x) = x mod n, hash_2(x) = 7 - (x mod 7), n = 10$，插入项：{89, 18, 49, 58, 69}。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%E8%A1%A8/%E5%8F%8C%E6%95%A3%E5%88%97.png" alt="双散列"></p>
<h1 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h1><div class="note warning">
            <p><strong>再散列是为了解决插入操作运行时间过长的问题，而不是为了解决冲突。</strong></p>
          </div>
<p>对于使用平方探测的开放定址散列法，如果散列填的太满，那么操作的运行时间将消耗过长，且插入操作可能失败。这可能发生在有太多的删除和插入混杂的场合。此时，一种解决方法是建立另外一个大约两倍大的表（而且使用一个相关的新散列函数），扫描整个原始散列表，计算每个（未删除的）元素的新散列值并将其插入到新表中。</p>
<p>下面用一个例子演示再散列的过程。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%E8%A1%A8/%E5%86%8D%E6%95%A3%E5%88%97.png" alt="再散列"></p>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法的分析</title>
    <url>/posts/cb7b8910/</url>
    <content><![CDATA[<h1 id="渐近记号"><a href="#渐近记号" class="headerlink" title="渐近记号"></a>渐近记号</h1><div class="note info">
            <ul><li>如果存在正常数 $c$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq f(n) \leq cg(n)$， 则记为 $f(n) = O(g(n))$。</li><li>如果存在正常数 $c$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq cg(n) \leq f(n)$， 则记为 $f(n) = \Omega(g(n))$。</li><li>如果存在正常数 $c_1$、$c_2$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq c_1g(n) \leq f(n) \leq c_2g(n)$，则记为 $f(n) = \Theta(g(n))$。</li><li>$f(n) = O(g(n)) 且 f(n) = \Omega(g(n))$ $\iff$ $f(n) = \Theta(g(n))$。</li></ul><hr><ul><li>如果存在正常数 $c$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq f(n) &lt; cg(n)$， 则记为 $f(n) = o(g(n))$。</li><li>如果存在正常数 $c$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq cg(n) &lt; f(n)$， 则记为 $f(n) = \omega(g(n))$。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90/%E6%B8%90%E8%BF%91%E8%AE%B0%E5%8F%B7.png" alt="渐近记号"></p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><div class="note info">
            <ul><li>对任意实数 $x$，$x-1 &lt; \lfloor x \rfloor \leq x \leq \lceil x \rceil &lt; x+1$</li><li>对任意整数 $n$，$\lceil n/2 \rceil + \lfloor n/2 \rfloor = n$</li><li>对任意实数 $x \geq 0$ 和整数 $a,b &gt; 0$有 - $\lceil \frac{\lceil x/a \rceil}{b} \rceil = \lceil \frac{x}{ab} \rceil$ - $\lfloor \frac{\lfloor x/a \rfloor}{b} \rfloor = \lfloor \frac{x}{ab} \rfloor$ - $\lceil \frac{a}{b} \rceil \leq \frac{a+(b-1)}{b}$ - $\lfloor \frac{a}{b} \rfloor \geq \frac{a-(b-1)}{b}$</li></ul>
          </div>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><div class="note info">
            <ul><li>$a \pmod n = a - n\lfloor a/n \rfloor$</li><li>$0 \leq a \pmod n &lt; n$</li></ul>
          </div>
<h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><div class="note warning">
            <p>在计算机科学中，认为$lgn = logn = log_2n$</p>
          </div>
<div class="note info">
            <ul><li>$a = b^{log_ba}$</li><li>$log_c(ab) = log_ca + log_cb$</li><li>$log_ba^n = n log_ba$</li><li>$log_ba = \frac{log_ca}{log_cb}$</li><li>$log_b(1/a) = -log_ba$</li><li>$log_ba = \frac{1}{log_ab}$</li><li>$a^{log_bc} = c^{log_ba}$</li></ul>
          </div>
<h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><div class="note info">
            <p>详情查看<strong>斯特林近似公式</strong></p><ul><li>$n! = o(n^n)$</li><li>$n! = \omega(2^n)$</li></ul>
          </div>
<h1 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h1><div class="note warning">
            <p><strong>主定理的证明请看《算法导论》第三版的 4.6 节。</strong></p>
          </div>
<div class="note info">
            <p>令 $a \geq 1$ 和 $b &gt; 1$是常数，$f(n)$ 是一个函数，$T(n)$ 是定义在非负整数上的递归式：</p><p><center>$T(n) = aT(n/b) + f(n)$</center><br>其中我们将 $n/b$ 解释为 $\lfloor n/b \rfloor$ 或 $\lceil n/b \rceil$。那么 $T(n)$ 有如下渐近界：</p><ol><li>若对某个常数 $\epsilon &gt; 0$ 有 $f(n) = O(n^{log_ba-\epsilon})$，则 $T(n)=\Theta(n^{log_ba})$</li><li>若 $f(n) = \Theta(n^{log_ba})$，则 $T(n) = \Theta(n^{log_ba}lgn)$</li><li>若对某个常数 $\epsilon &gt; 0$ 有 $f(n) = \Omega(n^{log_ba+\epsilon})$，且对某个常数 $c &lt; 1$ 和所有足够大的 $n$ 有 $af(n/b) \leq cf(n)$，则 $T(n) = \Theta(f(n))$</li></ol>
          </div>
<div class="note warning">
            <p>对于三种情况的每一种，我们将函数 $f(n)$ 与函数 $n^{log_ba}$ 进行比较。直觉上，两个函数较大者决定了递归式的解。</p><ul><li>若函数 $n^{log_ba}$ 更大，如情况 1，则解为 $T(n)=\Theta(n^{log_ba})$。</li><li>若两个函数大小相当，如情况 2，则乘上一个对数因子，解为 $T(n) = \Theta(n^{log_ba}lgn) = \Theta(f(n)lgn) $</li><li>若函数 $f(n)$ 更大，如情况 3，则解为 $T(n) = \Theta(f(n))$。</li></ul><p>在此直觉之外，我们需要了解一些技术细节。在第一种情况中，不是 $f(n)$ 小于 $n^{log_ba}$ 就够了，而是要多项式意义上的小于。也就是说，$f(n)$ 必须渐近小于 $n^{log_ba}$，要相差一个因子 $n^{\epsilon}$。在第三种情况中，不是 $f(n)$ 大于 $n^{log_ba}$ 就够了，而是要多项式意义上的大于，而且还要满足条件 $af(n/b) \leq cf(n)$。</p><p><strong>注意，这三种情况并未覆盖 $f(n)$ 的所有可能性。情况 1 和情况 2 之间有一定的间隙，情况 2 和情况 3 之间也有一定间隙。这样的情况下就不能使用主定理来求解递归式了。</strong></p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90/%E4%B8%BB%E5%AE%9A%E7%90%86%E4%B8%BE%E4%BE%8B.png" alt="主定理举例]"></p>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>树</title>
    <url>/posts/7b216a3b/</url>
    <content><![CDATA[<h1 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h1><p>一棵树是一些节点的集合，这个集合可以是空集；若不是空集，则树由称做<strong>根（root）</strong>的节点$r$及 0 或多个非空的（子）树$T_1,T_2, ···,T_k$组成，这些子树中每一颗的根都被来自根$r$的一条有向的边所连接。每一颗子树的根叫作根$r$的<strong>儿子</strong>，而$r$是每一颗子树的根的<strong>父亲</strong></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%B8%80%E8%88%AC%E7%9A%84%E6%A0%91.png" alt="一般的树"></p>
<p>下图中，节点 A 是根。节点 F 有一个父亲 A 并且有儿子 K、L 和 M。每一个节点可以有任意多个儿子，也可能是零个儿子。没有儿子的节点称为<strong>树叶</strong>，下图中的树叶是 B、C、H、I、P、Q、K、L、M 和 N。具有相同父亲的节点为<strong>兄弟</strong>。因此，K、L 和 M 都是兄弟。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%B8%80%E6%A3%B5%E6%A0%91.png" alt="一颗树"></p>
<p>从节点$n_1$到$n_k$的<strong>路径</strong>定义为节点$n_1, n_2, ···, n_k$的一个序列，使得对于$1 \leq i \leq k$的节点$n_i$是$n$<sub>$i+1$</sub>的父亲。这条路径的长是该路径上边的条数，即$k - 1$。从每一个节点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个节点恰好存在一条路径</p>
<p>对任意节点$n_i$，$n_i$的<strong>深度</strong>为从根到$n_i$的唯一路径的长。因此，根的深度为 0。节点$n_i$的<strong>高</strong>是从$n_i$到一片树叶的最长路径的长。因此所有树叶的高都是 0。<strong>一棵树的高等于它的根的高</strong>。上图中的树，E 的深度为 1 而高为 2；F 的深度为 1 而高也是 1；该树的高为 3。<strong>一棵树的深度等于其最深的树叶的深度，该深度总是等于这棵树的高</strong></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><div class="note info">
            <ul><li><strong>二叉树</strong>：是一种特殊的树，它每个节点最多只能有两个儿子</li><li><strong>完美二叉树</strong>：高为 h，且节点数为$2^{h+1} - 1$的二叉树。也就是说除了最后一层无任何子节点之外，每一层上的所有节点都有两个儿子</li><li><strong>完全二叉树</strong>：从根节点到倒数第二层满足完美二叉树，最后一层没有完全填满，其叶子节点都靠左对齐。一颗高为 h 的完全二叉树有$2^h$到$2^{h+1} - 1$个节点。这意味着，完全二叉树的高是$\lfloor logN \rfloor$，显然它是$O(logN)$</li><li><strong>完满二叉树</strong>：对于任意节点，要不就是拥有两个儿子，要不就是一个儿子都没有</li><li><strong>堆</strong>：特殊的完全二叉树，后续文章会详细介绍</li><li><strong>二叉查找树</strong>：使二叉树成为二叉查找树的性质是，对于树中的每个节点 X，它的左子树中所有项的值均小于 X 中的项，而它的右子树中所有项的值均大于 X 中的项</li><li><strong>AVL 树</strong>：带有平衡条件的二叉查找树</li></ul>
          </div>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><div class="note info">
            <ul><li><strong>先序遍历</strong>：首先处理根节点，然后再处理它的左儿子和右儿子</li><li><strong>中序遍历</strong>：首先处理左儿子，然后处理根节点，最后处理右儿子</li><li><strong>后序遍历</strong>：首先处理左儿子，然后处理右儿子，最后处理根节点</li><li><strong>层序遍历</strong>：按照从上到下、从左到右的顺序处理节点</li></ul>
          </div>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrderTraverse</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.val);</span><br><span class="line"></span><br><span class="line">    preOrderTraverse(node.left);</span><br><span class="line">    preOrderTraverse(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrderTraverse</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> cur = node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur || stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(cur.val);</span><br><span class="line"></span><br><span class="line">      stack.push(cur);</span><br><span class="line">      cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      cur = stack.pop().right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleOrderTraverse</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    middleOrderTraverse(node.left);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(node.val);</span><br><span class="line"></span><br><span class="line">    middleOrderTraverse(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleOrderTraverse</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> cur = node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur || stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      stack.push(cur);</span><br><span class="line">      cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> topNode = stack.pop();</span><br><span class="line">      <span class="built_in">console</span>.log(topNode.val);</span><br><span class="line">      cur = topNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrderTraverse</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    postOrderTraverse(node.left);</span><br><span class="line">    postOrderTraverse(node.right);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(node.val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrderTraverse</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cur = node;</span><br><span class="line">  <span class="keyword">let</span> lastHandled = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur || stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      stack.push(cur);</span><br><span class="line">      cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> topNode = stack[stack.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (topNode.right &amp;&amp; topNode.right !== lastHandled) &#123;</span><br><span class="line">        cur = topNode.right;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(topNode.val);</span><br><span class="line">        lastHandled = topNode;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrderTraverse</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = [node];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevLevelNode = queue.shift();</span><br><span class="line">    <span class="built_in">console</span>.log(prevLevelNode.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevLevelNode.left) &#123;</span><br><span class="line">      queue.push(prevLevelNode.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevLevelNode.right) &#123;</span><br><span class="line">      queue.push(prevLevelNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><div class="note info">
            <p>二叉查找树与普通的二叉树相比，有如下特点：</p><ul><li>所有节点彼此互异，即不存在相同的节点</li><li>对于树中的任意节点 X，它的左子树中所有项的值均小于 X 中的项，而它的右子树中所有项的值均大于 X 中的项</li></ul>
          </div>
<p>下面是实现一个二叉查找树的代码：</p>
<div class="note warning">
            <p>从二叉查找树中移除元素是这部分的难点，首先定位到要移除元素所在节点，然后进行如下 3 种操作：</p><ol><li>如果当前节点为树叶，那么直接删除该树叶</li><li>如果当前节点拥有一个子树，那么用该子树的根节点替换当前节点</li><li>如果当前节点拥有两个子树，那么找出右子树中的最小节点并递归的删除该最小节点，然后将这个最小节点的值赋给当前节点的值（也可以采用相反的方式，去寻找左子树中的最大节点）</li></ol>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(newValue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = newValue;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.isNode = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> makeTree(array) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree = <span class="keyword">new</span> BinarySearchTree(array[<span class="number">0</span>]);</span><br><span class="line">    array.slice(<span class="number">1</span>).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      tree.insert(item);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert(newNode, currentNode = <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newNode.isNode) &#123;</span><br><span class="line">      newNode = <span class="keyword">new</span> BinarySearchTree(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newNode.value &lt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left) &#123;</span><br><span class="line">        currentNode.insert(newNode, currentNode.left);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode.left = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newNode.value &gt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right) &#123;</span><br><span class="line">        currentNode.insert(newNode, currentNode.right);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode.right = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newNode.value === currentNode.value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;newNode.value&#125;</span> already exists`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  contains(inputValue, currentNode = <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputValue &lt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode.contains(inputValue, currentNode.left);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputValue &gt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode.contains(inputValue, currentNode.right);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputValue === currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findMin(currentNode = <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.left) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentNode.findMin(currentNode.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> currentNode.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findMax(currentNode = <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.right) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentNode.findMin(currentNode.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> currentNode.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// preNode和where参数完全是为了删除树叶准备的</span></span><br><span class="line">  remove(inputValue, currentNode = <span class="keyword">this</span>, preNode = <span class="literal">null</span>, where = <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputValue &lt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left) &#123;</span><br><span class="line">        currentNode.remove(inputValue, currentNode.left, currentNode, <span class="string">'left'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;inputValue&#125;</span> does not exist`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputValue &gt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right) &#123;</span><br><span class="line">        currentNode.remove(inputValue, currentNode.right, currentNode, <span class="string">'right'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;inputValue&#125;</span> does not exist`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputValue === currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!currentNode.left &amp;&amp; !currentNode.right) &#123;</span><br><span class="line">        preNode[where] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!currentNode.left) &#123;</span><br><span class="line">        currentNode = currentNode.right;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!currentNode.right) &#123;</span><br><span class="line">        currentNode = currentNode.left;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currentNode.left &amp;&amp; currentNode.right) &#123;</span><br><span class="line">        <span class="keyword">let</span> minValue = currentNode.right.findMin();</span><br><span class="line">        currentNode.remove(minValue, currentNode.right, currentNode, <span class="string">'right'</span>);</span><br><span class="line">        currentNode.value = minValue;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">  tree = BinarySearchTree.makeTree(array);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrderTraverse</span>(<span class="params">node, result = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  result += node.value + <span class="string">'  '</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">    result = preOrderTraverse(node.left, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">    result = preOrderTraverse(node.right, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(preOrderTraverse(tree)); <span class="comment">// 6  2  1  4  3  5  8  7</span></span><br><span class="line"></span><br><span class="line">tree.remove(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(preOrderTraverse(tree)); <span class="comment">// 6  2  1  5  3  8  7</span></span><br><span class="line"></span><br><span class="line">tree.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(preOrderTraverse(tree)); <span class="comment">// 6  2  1  5  3  4  8  7</span></span><br><span class="line"></span><br><span class="line">tree.remove(<span class="number">41</span>); <span class="comment">// 41 does not exist</span></span><br><span class="line"><span class="built_in">console</span>.log(preOrderTraverse(tree)); <span class="comment">// 6  2  1  5  3  4  8  7</span></span><br></pre></td></tr></table></figure>
<h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><div class="note info">
            <ul><li>AVL 树是带有平衡条件的二叉查找树</li><li>平衡条件为每个节点的左子树和右子树的高度最多差 1（空树的高度定义为-1）</li></ul>
          </div>
<p>如果要对一个 AVL 树进行插入操作，需要更新通向根节点路径上那些节点的所有平衡信息，而插入操作隐含着困难的原因在于，插入一个节点可能破坏 AVL 树的平衡特性。如果发生这种情况，那么可以通过<strong>旋转</strong>来恢复 AVL 树的平衡</p>
<div class="note info">
            <p>在一次插入之后，从插入点到根节点的路径上寻找其中深度最深（或高度最小）的不平衡节点，称该节点为 A，造成不平衡的插入分为下面四种情况：</p><ol><li>对 A 的左儿子的左子树进行一次插入</li><li>对 A 的左儿子的右子树进行一次插入</li><li>对 A 的右儿子的左子树进行一次插入</li><li>对 A 的右儿子的右子树进行一次插入</li></ol><p><strong>删除操作会出现的情况与插入类似，不单独介绍了。</strong></p>
          </div>
<p>情况 1 和情况 4 是关于 A 点的镜像对称，使用<strong>单旋转</strong>来处理，原理如下图所示</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL1.png" alt="AVL1"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL4.png" alt="AVL4"></p>
<p>情况 2 和情况 3 也是关于点的镜像对称，使用<strong>双旋转</strong>来处理，原理如下图所示，<strong>因为子树 B 和 C 中有一颗比 D 深两层，但是我们不能肯定是哪一颗，所以图中 B 和 C 都被画成比 D 低 1.5 层</strong></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL2.png" alt="AVL2"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/AVL3.png" alt="AVL3"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><div class="note warning">
            <p><strong>我实现二叉查找树和 AVL 树的代码书写思路不同，最主要的区别是插入和删除操作是否有返回值。普通二叉树没有利用返回值，而 AVL 树的插入和删除操作都会返回新的 AVL 树 🌲！</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(newValue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = newValue;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.isNode = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> makeTree(array) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree = <span class="keyword">new</span> AVLTree(array[<span class="number">0</span>]);</span><br><span class="line">    array.slice(<span class="number">1</span>).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      tree = tree.insert(item);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert(newNode, currentNode = <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newNode.isNode) &#123;</span><br><span class="line">      newNode = <span class="keyword">new</span> AVLTree(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newNode.value &lt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left) &#123;</span><br><span class="line">        currentNode.left = currentNode.insert(newNode, currentNode.left);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode.left = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newNode.value &gt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right) &#123;</span><br><span class="line">        currentNode.right = currentNode.insert(newNode, currentNode.right);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode.right = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newNode.value === currentNode.value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;newNode.value&#125;</span> already exists`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentNode = currentNode.balanceTree(currentNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只要树的结构发生改变就要触发这个函数</span></span><br><span class="line">  <span class="comment">// 负责保持树的平衡和更新节点的高度信息</span></span><br><span class="line">  balanceTree(currentNode) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTreeHeight</span>(<span class="params">currentNode</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!currentNode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode.height;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rotateWithLeftChild</span>(<span class="params">currentNode</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> nextNode = currentNode.left;</span><br><span class="line"></span><br><span class="line">      currentNode.left = nextNode.right;</span><br><span class="line">      nextNode.right = currentNode;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rotateWithRightChild</span>(<span class="params">currentNode</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> nextNode = currentNode.right;</span><br><span class="line"></span><br><span class="line">      currentNode.right = nextNode.left;</span><br><span class="line">      nextNode.left = currentNode;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doubleWithLeftChild</span>(<span class="params">currentNode</span>) </span>&#123;</span><br><span class="line">      currentNode.left = rotateWithRightChild(currentNode.left);</span><br><span class="line">      currentNode = rotateWithLeftChild(currentNode);</span><br><span class="line">      <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doubleWithRightChild</span>(<span class="params">currentNode</span>) </span>&#123;</span><br><span class="line">      currentNode.right = rotateWithLeftChild(currentNode.right);</span><br><span class="line">      currentNode = rotateWithRightChild(currentNode);</span><br><span class="line">      <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      getTreeHeight(currentNode.left) - getTreeHeight(currentNode.right) &gt;</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        getTreeHeight(currentNode.left.left) &gt;=</span><br><span class="line">        getTreeHeight(currentNode.left.right)</span><br><span class="line">      ) &#123;</span><br><span class="line">        currentNode = rotateWithLeftChild(currentNode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = doubleWithLeftChild(currentNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      getTreeHeight(currentNode.right) - getTreeHeight(currentNode.left) &gt;</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        getTreeHeight(currentNode.right.right) &gt;=</span><br><span class="line">        getTreeHeight(currentNode.right.left)</span><br><span class="line">      ) &#123;</span><br><span class="line">        currentNode = rotateWithRightChild(currentNode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = doubleWithRightChild(currentNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateHeight</span>(<span class="params">currentNode</span>) </span>&#123;</span><br><span class="line">      currentNode.height =</span><br><span class="line">        <span class="built_in">Math</span>.max(</span><br><span class="line">          getTreeHeight(currentNode.left),</span><br><span class="line">          getTreeHeight(currentNode.right)</span><br><span class="line">        ) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode.left) &#123;</span><br><span class="line">      updateHeight(currentNode.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode.right) &#123;</span><br><span class="line">      updateHeight(currentNode.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateHeight(currentNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove(inputValue, currentNode = <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputValue &lt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.left) &#123;</span><br><span class="line">        currentNode.left = currentNode.remove(</span><br><span class="line">          inputValue,</span><br><span class="line">          currentNode.left,</span><br><span class="line">          currentNode,</span><br><span class="line">          <span class="string">'left'</span></span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;inputValue&#125;</span> does not exist`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputValue &gt; currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.right) &#123;</span><br><span class="line">        currentNode.right = currentNode.remove(</span><br><span class="line">          inputValue,</span><br><span class="line">          currentNode.right,</span><br><span class="line">          currentNode,</span><br><span class="line">          <span class="string">'right'</span></span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;inputValue&#125;</span> does not exist`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputValue === currentNode.value) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> !currentNode.left &amp;&amp; !currentNode.right:</span><br><span class="line">          currentNode = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> !currentNode.left:</span><br><span class="line">          currentNode = currentNode.right;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> !currentNode.right:</span><br><span class="line">          currentNode = currentNode.left;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> currentNode.left &amp;&amp; currentNode.right:</span><br><span class="line">          <span class="keyword">let</span> minValue = currentNode.right.findMin();</span><br><span class="line">          currentNode = currentNode.remove(</span><br><span class="line">            minValue,</span><br><span class="line">            currentNode.right,</span><br><span class="line">            currentNode,</span><br><span class="line">            <span class="string">'right'</span></span><br><span class="line">          );</span><br><span class="line">          currentNode.value = minValue;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode) &#123;</span><br><span class="line">      currentNode = currentNode.balanceTree(currentNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrderTraverse</span>(<span class="params">node, result = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  result += node.value + <span class="string">'  '</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">    result = preOrderTraverse(node.left, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">    result = preOrderTraverse(node.right, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">15</span>],</span><br><span class="line">  tree = AVLTree.makeTree(array);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(preOrderTraverse(tree)); <span class="comment">// 4  2  1  3  6  5  15  7  16</span></span><br><span class="line"></span><br><span class="line">tree = tree.insert(<span class="number">14</span>);</span><br><span class="line"><span class="built_in">console</span>.log(preOrderTraverse(tree)); <span class="comment">// 4  2  1  3  7  6  5  15  14  16</span></span><br><span class="line"></span><br><span class="line">tree = tree.remove(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(preOrderTraverse(tree)); <span class="comment">// 4  2  1  3  7  5  15  14  16</span></span><br><span class="line"></span><br><span class="line">tree = tree.remove(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(preOrderTraverse(tree)); <span class="comment">// 4  2  1  3  15  7  14  16</span></span><br></pre></td></tr></table></figure>
<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseTree</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> cur = root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur || stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="comment">// preOrderTraverse</span></span><br><span class="line"></span><br><span class="line">      stack.push(cur);</span><br><span class="line"></span><br><span class="line">      cur.visitedIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.visitedIndex += <span class="number">1</span>;</span><br><span class="line">        cur = cur.children[cur.visitedIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> topNode = stack[stack.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (topNode.children.length - <span class="number">1</span> &gt; topNode.visitedIndex!) &#123;</span><br><span class="line">        topNode.visitedIndex! += <span class="number">1</span>;</span><br><span class="line">        cur = topNode.children[topNode.visitedIndex!];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// postOrderTraverse</span></span><br><span class="line"></span><br><span class="line">        stack.pop();</span><br><span class="line">        <span class="keyword">delete</span> topNode.visitedIndex;</span><br><span class="line">        cur = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h1><div class="note info">
            <p>阶为 $M$ 的 B 树是一颗具有下列特性的 $M$ 叉树：</p><ol><li>数据全部存储在叶节点上；</li><li>非叶节点最多可以存储 $M-1$ 个关键字，以指示搜索的方向。关键字 $i$ 代表子树 $i+1$ 中最小的关键字；</li><li>树的根如果有子节点，则子节点个数一定在 2 和 $M$ 之间；</li><li>除根外，所有非叶节点的子节点个数在 $\lceil M/2 \rceil$ 和 $M$ 之间；</li><li>所有树叶的深度相同，并且每片树叶上存储的数据个数在 $\lceil L/2 \rceil$ 和 $L$ 之间。$L = 节点可容纳数据个数 = 节点容量/数据大小$</li></ol>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/B%20Tree%20Demo.png" alt="B-Tree Demo"></p>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>volume的备份及还原</title>
    <url>/posts/e113cc4a/</url>
    <content><![CDATA[<p>现在Docker中有一个名为<code>registry-data</code>的volume，我想备份它。</p>
<div class="note info">
            <p>思路如下：</p><ol><li>创建一个文件夹，路径如下<code>/d/Docker/backup</code>，<code>backup</code>就是我保存备份的文件夹；</li><li>运行一个临时的容器，它需要做以下工作：<ul><li>将想要备份的<code>registry-data</code>挂载到容器上；</li><li>将第一步创建的文件夹，挂载到容器上；</li><li>通过命令压缩<code>registry-data</code>，而后保存到第一步创建的文件夹中。</li></ul></li></ol>
          </div>
<p>运行如下命令，将会生成<code>registry-data20190509.tar</code>压缩文件，并将其保存在<code>backup</code>文件夹中。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">docker run --rm -v registry-data:/source -v /d/Docker/backup:/backup alpine sh -c "cd /source &amp;&amp; tar cvf /backup/registry-data20190509.tar ."</span><br></pre></td></tr></table></figure>
<p>如果想将备份还原成volume，只需运行下面的命令即可：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">docker run --rm -v another-registry-data:/source -v /d/Docker/backup:/backup alpine sh -c "cd /source &amp;&amp; tar xvf /backup/registry-data20190509.tar ."</span><br></pre></td></tr></table></figure>
<p>这样就会利用备份的压缩文件，为我们生成一个名为<code>another-registry-data</code>的volume。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>vue+node+python+docker实战</title>
    <url>/posts/96fb2f92/</url>
    <content><![CDATA[<h1 id="Docker基础概念"><a href="#Docker基础概念" class="headerlink" title="Docker基础概念"></a>Docker基础概念</h1><p><a href="https://yeasy.gitbooks.io/docker_practice/introduction/what.html" target="_blank" rel="noopener">Docker中文文档</a><br><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker英文文档</a></p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><div class="note info">
            <p>系统中各组成部分介绍：</p><ul><li><strong>vue-client</strong>：使用vue开发的前端界面；</li><li><strong>node-serve</strong>：使用hapi开发的基础服务器，主要负责系统内数据的增删改查；</li><li><strong>node-worker</strong>：基于node的消息队列消费者；</li><li><strong>python-serve</strong>：使用flask开发的算法服务端，主要负责系统内算法的运行；</li><li><strong>mysql</strong>：数据库；</li><li><strong>phpmyadmin</strong>：数据库UI；</li><li><strong>rabbitmq</strong>：消息队列服务器。</li></ul><hr><p>上面介绍的组成部分，除了<code>mysql</code>和<code>phpmyadmin</code>不需要利用<code>Dockerfile</code>构建镜像外，其余全需要。</p><p>马上就会讲解它们的<code>Dockerfile</code>，不过需要注意的是，<strong>请将所有镜像全部构建完成后，再利用<code>docker-compose</code>来启动所有容器。否则只单独启动像<code>node-worker</code>这样的容器，是不会成功的，因为它依赖于<code>rabbitmq</code>。</strong></p>
          </div>
<h2 id="vue-client"><a href="#vue-client" class="headerlink" title="vue-client"></a>vue-client</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile文件</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> ./dist /app</span><br><span class="line"><span class="keyword">COPY</span> ./nginx.conf /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx.conf文件</span></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                        <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                        <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /app;</span><br><span class="line">            index  index.html;</span><br><span class="line">            try_files $uri $uri/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /api &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://node-serve:<span class="number">8000</span>;</span><br><span class="line">            proxy_connect_timeout <span class="number">600</span>s;</span><br><span class="line">            proxy_send_timeout <span class="number">600</span>s;</span><br><span class="line">            proxy_read_timeout <span class="number">600</span>s;</span><br><span class="line">            send_timeout <span class="number">600</span>s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">        location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>在项目根目录下依次运行如下命令：</p><ol><li><code>npm run build</code>：这会将项目打包到根目录下的<code>dist</code>文件夹；</li><li><code>docker build -t vue-client:20190509_1 .</code>：构建一个名称为<code>vue-client:20190509_1</code>的镜像。</li></ol>
          </div>
<h2 id="node-serve"><a href="#node-serve" class="headerlink" title="node-serve"></a>node-serve</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile文件</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">10.15</span>.<span class="number">1</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> . .</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> npm install --registry=https://registry.npm.taobao.org &amp;&amp; \</span><br><span class="line">    apk add --no-cache tzdata &amp;&amp; \</span><br><span class="line">	cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="line">	echo "Asia/Shanghai" &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">	apk del tzdata</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span> ["npm", "start", "-s"]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .dockerignore文件</span></span><br><span class="line">npm-debug.log</span><br><span class="line">node_modules</span><br><span class="line"></span><br><span class="line">.vscode</span><br><span class="line">typings</span><br><span class="line">package-lock.json</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>在项目根目录下运行<code>docker build -t node-serve:20190509_1 .</code>构建一个名称为<code>node-serve:20190509_1</code>的镜像。</p>
          </div>
<h2 id="node-worker"><a href="#node-worker" class="headerlink" title="node-worker"></a>node-worker</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile文件</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">10.15</span>.<span class="number">1</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> . .</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> npm install --registry=https://registry.npm.taobao.org &amp;&amp; \</span><br><span class="line">	npm install -g pm2 --registry=https://registry.npm.taobao.org &amp;&amp; \</span><br><span class="line">    apk add --no-cache tzdata &amp;&amp; \</span><br><span class="line">	cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="line">	echo "Asia/Shanghai" &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">	apk del tzdata</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span> ["pm2", "start", "ecosystem.config.js", "--no-daemon"]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .dockerignore文件</span></span><br><span class="line">.vscode/</span><br><span class="line">node_modules/</span><br><span class="line">.git/</span><br><span class="line">.gitignore</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>在项目根目录下运行<code>docker build -t node-worker:20190509_1 .</code>构建一个名称为<code>node-worker:20190509_1</code>的镜像。</p>
          </div>
<h2 id="python-serve"><a href="#python-serve" class="headerlink" title="python-serve"></a>python-serve</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile文件</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /usr/src/app</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> . .</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> pip install -U pip &amp;&amp; \</span><br><span class="line">    pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span> ["gunicorn", "-c", "gunicorn.conf", "run:app"]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .dockerignore文件</span></span><br><span class="line">__pycache__</span><br><span class="line">.vscode/</span><br><span class="line">.git/</span><br><span class="line">.gitignore</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>在项目根目录下运行<code>docker build -t python-serve:20190509_1 .</code>构建一个名称为<code>python-serve:20190509_1</code>的镜像。</p>
          </div>
<h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h2><p><code>rabbitmq</code>的根目录下只有一个文件，就是<code>Dockerfile</code>文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile文件</span></span><br><span class="line"><span class="keyword">FROM</span> rabbitmq:<span class="number">3</span>-management-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> rabbitmq-plugins enable rabbitmq_stomp &amp;&amp; \</span><br><span class="line">    rabbitmq-plugins enable rabbitmq_web_stomp &amp;&amp; \</span><br><span class="line">    rabbitmq-plugins enable --offline rabbitmq_management</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">15672</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">15674</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>在项目根目录下运行<code>docker build -t rabbitmq:stomp .</code>构建一个名称为<code>rabbitmq:stomp</code>的镜像。</p>
          </div>
<h1 id="docker-compose实例"><a href="#docker-compose实例" class="headerlink" title="docker-compose实例"></a>docker-compose实例</h1><p>创建一个文件夹用于存放<code>docker-compose.yml</code>文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">vue-client:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">vue-client:20190509_1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"8888:80"</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">node-serve</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">node-worker</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">python-serve</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">node-serve:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">node-serve:20190509_1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"8000:8000"</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">node-worker:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">node-worker:20190509_1</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">python-serve</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">python-serve:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">python-serve:20190509_1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">rabbitmq</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql:5.6</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"3306:3306"</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">yourpassword</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">mysqld</span> <span class="string">--character-set-server=utf8mb4</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">phpmyadmin:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">phpmyadmin/phpmyadmin:latest</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"8001:80"</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">yourpassword</span></span><br><span class="line">            <span class="attr">PMA_HOST:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">rabbitmq:stomp</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"15672:15672"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"15674:15674"</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">RABBITMQ_DEFAULT_USER:</span> <span class="string">yourname</span></span><br><span class="line">            <span class="attr">RABBITMQ_DEFAULT_PASS:</span> <span class="string">yourpassword</span></span><br><span class="line">            <span class="attr">RABBITMQ_ERLANG_COOKIE:</span> <span class="string">yourpassword</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">app-net:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="attr">mysql-data:</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>命令介绍：</p><ul><li><code>docker-compose build</code>：构建（重新构建）服务容器；</li><li><code>docker-compose up -d</code>：后台自动（重新）创建服务和关联服务相关容器；</li><li><code>docker-compose down</code>：停止容器、移除容器和网络。</li></ul><hr><p>遇到的坑：</p><ul><li><strong>depends_on</strong>：解决容器的依赖、启动先后问题，<strong>但是不会等到所依赖的容器完全启动之后，再启动后续容器</strong>。所以如果在<code>docker-compose up -d</code>后，发现<code>node-worker</code>部分没有正常工作的话，你在保证<code>rabbitmq</code>完全启动后，重启下<code>node-worker</code>就可以了。这里有其他的解决办法，比如利用<code>wait-for-it</code>脚本等，我简单的试了一下，有些小问题，为了项目进度，暂时搁置，<a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">相关资料戳这里</a>。</li></ul>
          </div>
<h1 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h1><p>运行如下命令就可以启动一个docker的可视化管理工具。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer-data:/data portainer/portainer</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>对docker数据持久化的理解</title>
    <url>/posts/9d0d99dd/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目需要读取本地的一个文件，采用的方式是挂载本地目录作为<code>volume</code>。但是在将这个项目部署到远端服务器时，项目<code>image</code>可以直接拉取，而项目所需文件的迁移就成了问题</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><div class="note info">
            <ol><li>创建一个专门用于<code>COPY</code>数据的<code>image</code>，起名为<code>data-image:1.0</code></li><li>接着就可以远程访问服务器，创建<code>docker-compose.yml</code>文件，通过挂载<code>volume</code>的方式实现数据共享</li><li>到此为止就可以拉取镜像、启动服务了</li></ol>
          </div>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> ./data /usr/src/data</span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">project:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">project-image</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">project-data:/usr/src/data</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">data-container:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">data-image:1.0</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">project-data:/usr/src/data</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="attr">project-data:</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note info">
            <ul><li>只有<code>volume</code>可以做到数据持久化，<code>image</code>内的数据是无法被更改的</li><li>当项目启动后对依赖文件的改动会被记录在<code>project-data</code>中，而两个<code>image</code>中<code>/usr/src/data</code>目录下的内容会一直保持它们最开始的状态</li><li>启动服务后，<code>project-data</code>会被挂载到两个<code>container</code>上，实现数据的共享，这个时候两个<code>container</code>中<code>/usr/src/data</code>目录下的内容与<code>project-data</code>同步</li><li>如果删除了<code>project-data</code>，则对依赖文件的改动会丢失</li></ul>
          </div>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax 与 Comet</title>
    <url>/posts/5ffed448/</url>
    <content><![CDATA[<p>Ajax 是 Asynchronous JavaScript + XML 的简写，这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。</p>
<p>Ajax 技术的核心是 <code>XMLHttpRequest</code> 对象（简称 XHR），XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口。</p>
<h1 id="XHR-对象"><a href="#XHR-对象" class="headerlink" title="XHR 对象"></a>XHR 对象</h1><h2 id="XHR-属性"><a href="#XHR-属性" class="headerlink" title="XHR 属性"></a>XHR 属性</h2><div class="note info">
            <ul><li><code>readyState</code>（只读）：代表XHR对象的当前状态。<ul><li><code>0</code>：未初始化。尚未调用 <code>open()</code> 方法。</li><li><code>1</code>：启动。已经调用 <code>open()</code> 方法，但尚未调用 <code>send()</code> 方法。</li><li><code>2</code>：发送。已经调用 <code>send()</code>方法，但尚未接收到响应。</li><li><code>3</code>：接收。已经接收到部分响应数据。</li><li><code>4</code>：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul></li><li><code>onreadystatechange</code>：它是 XHR 对象的一个方法，只要 <code>readyState</code> 属性值发生变化，就会调用该方法。<strong>必须在调用 <code>open()</code> 方法之前为 <code>onreadystatechange</code> 赋值才能确保跨浏览器兼容性。并且在这个事件处理程序中最好不要使用 <code>this</code> 对象，否则可能会出问题。</strong></li><li><code>response</code>（只读）：返回响应的主体部分。主体部分内容的格式由 <code>responseType</code> 属性决定。</li><li><code>responseText</code>（只读）：返回响应的主体内容的字符串形式。</li><li><code>responseType</code>：通过这个属性指定期望的 <code>response</code> 的类型。该属性的默认值为 <code>text</code>。</li><li><code>responseURL</code>（只读）：返回响应的序列化URL，如果 URL 为空则返回空字符串。如果URL有锚点，则位于 <code>#</code> 后面的内容会被删除。如果 URL 有重定向， <code>responseURL</code> 的值会是经过多次重定向后的最终URL。</li><li><code>responseXML</code>（只读）：如果响应的内容类型是 <code>&quot;text/xml&quot;</code> 或 <code>&quot;application/xml&quot;</code>，这个属性中将保存包含着响应数据的 XML DOM 文档。</li><li><code>status</code>（只读）：HTTP 状态码。</li><li><code>statusText</code>（只读）：HTTP 状态码对应的描述信息。</li><li><code>timeout</code>：设置请求超时的毫秒数。超时后会触发 <code>ontimeout</code> 事件处理程序。</li><li><code>upload</code>（只读）：该属性专门用于上传文件，可用于显示上传进度。它返回的是一个 <code>XMLHttpRequestUpload</code> 对象，该对象也拥有 loadstart、progress、error、abort、load、loadend 和 timeout 事件。</li><li><code>withCredentials</code>：该属性为布尔值，它指示了是否该使用类似 cookies，authorization headers 或者 TLS 客户端证书这一类资格证书来创建一个跨站点访问控制请求。在同一个站点下使用 withCredentials 属性是无效的。默认值为 <code>false</code>。</li></ul>
          </div>
<h2 id="XHR方法"><a href="#XHR方法" class="headerlink" title="XHR方法"></a>XHR方法</h2><div class="note info">
            <ul><li><code>open(method, url, async, user, password)</code>：初始化一个 XHR 对象。<ul><li><code>method</code>：一个字符串，用于表示要发送的请求类型，比如：<code>&quot;get&quot;</code>、<code>&quot;post&quot;</code>。</li><li><code>url</code>：请求的 URL。</li><li><code>async</code>（可选）：一个布尔值，用于表示是否发送是异步请求，默认为 <code>true</code>。</li><li><code>user</code>（可选）：用户名，默认为 <code>null</code>。</li><li><code>password</code>（可选）：密码，默认为 <code>null</code>。</li></ul></li><li><code>send(body)</code>：在 <code>send()</code> 之后，通过调用该发送请求。<code>body</code> 参数是请求主体要发送的数据，如果不需要通过请求主体发送数据，则传入 <code>null</code>。</li><li><code>abort()</code>：终止已经发送的请求。当调用该方法时，被终止的 XHR 对象的 <code>readyState</code> 值变为 <code>0</code>，<code>status</code> 值也变为 <code>0</code>。</li><li><code>getResponseHeader(headerName)</code>：用于获取对应首部字段的值。</li><li><code>getAllResponseHeaders()</code>：用于获取所有的首部字段内容。各个首部字段被 <code>CRLF</code> 分隔，如果无首部字段，则返回 <code>null</code>。</li><li><code>setRequestHeader(header，value)</code>：设置首部字段。<strong>必须在调用 <code>open()</code> 之后，调用 <code>send()</code> 之前使用该方法才有效。</strong></li><li><code>overrideMimeType(mimeType)</code>：重写响应的MIME类型。<strong>必须在调用 <code>send()</code> 之前使用该方法才有效。</strong></li></ul>
          </div>
<h2 id="XHR事件"><a href="#XHR事件" class="headerlink" title="XHR事件"></a>XHR事件</h2><div class="note info">
            <p>需要在调用 <code>open()</code> 之前注册事件处理程序的事件：</p><ul><li><code>loadstart</code>：在接收到响应数据的第一个字节时触发。</li><li><code>progress</code>：在接收响应期间持续不断地触发。</li><li><code>error</code>：在请求发生错误时触发。</li><li><code>abort</code>：在因为调用 <code>abort()</code> 方法而终止连接时触发。</li><li><code>load</code>：在接收到完整的响应数据时触发。</li><li><code>loadend</code>：在通信完成或者触发 error、abort 或 load 事件后触发。</li></ul><hr><p>需要在调用 <code>open()</code> 之后，调用 <code>send()</code> 之前注册事件处理程序的事件：</p><ul><li><strong>timeout</strong>：在请求超时时触发。</li></ul>
          </div>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>demo 用于展示如何利用 XHR 发送请求，并没有进行什么特殊配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.txt'</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>通过 XHR 实现 Ajax 通信的一个主要限制，来源于跨域安全策略（同源策略）。默认情况下，使用 XHR 对象发送请求的 URL 域名必须和当前页面完全一致。完全一致的意思是，域名要相同（<code>www.example.com</code> 和 <code>example.com</code> 不同），协议要相同（<code>http</code> 和 <code>https</code>不同），端口号也要相同。有的浏览器比较宽松，允许端口不同，大多数浏览器都会严格遵守这个限制。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。</p>
<div class="note warning">
            <p><strong>就算是域名和域名对应的 IP 之间发起请求，也算作跨域。</strong></p>
          </div>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS（Cross-Origin Resource Sharing，跨域资源共享）是 W3C 的一个工作草案，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>比如一个简单的使用 GET 或 POST 发送的请求，它没有自定义的头部，而主体内容是 <code>text/plain</code>。在发送该请求时，需要给它附加一个额外的 <code>Origin</code> 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是 <code>Origin</code> 头部的一个示例：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure>
<p>如果服务器认为这个请求可以接收，就在响应的 <code>Access-Control-Allow-Origin</code> 头部中回发相同的源信息（如果是公共资源，可以回发 <code>&quot;*&quot;</code>）。例如：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure>
<p>如果响应没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。<strong>注意，请求和响应都不包含 <code>cookie</code> 信息。</strong></p>
<p>现代浏览器都通过 <code>XMLHttpRequest</code> 对象对象实现了对CORS的源生支持，在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。</p>
<div class="note warning">
            <p>跨域 XHR 对象也有一些限制，但为了安全这些限制是必需的。以下就是这些限制：</p><ul><li>不能使用 <code>setRequestHeader()</code> 设置自定义头部。</li><li>默认不能发送和接收 <code>cookie</code>，但是可以通过 XHR 对象的 <code>withCredentials</code> 来发送带凭据的跨域请求。</li><li>调用 <code>getAllResponseHeaders()</code> 方法总会返回空字符串。</li></ul><p>由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对 URL，在访问远程资源时再使用绝对 URL。这样做能消除歧义，避免出现限制访问头部或本地 <code>cookie</code> 信息等问题。</p>
          </div>
<h2 id="Preflight-request"><a href="#Preflight-request" class="headerlink" title="Preflight request"></a>Preflight request</h2><p>参考资料：<a href="https://www.jianshu.com/p/b55086cbd9af" target="_blank" rel="noopener">前端 | 浅谈preflight request</a></p>
<p>想象一个场景，我们发送一个 POST 跨域请求，服务器收到请求后对数据库进行了相应的操作并返回响应，但是由于浏览器的跨域限制，导致我们收到的是请求失败的结果。这种情况就是明明用户请求的操作成功了，但是用户不知道他成功了。</p>
<p>预检请求（Preflight request）就是为了解决上述问题的。某些情况下浏览器在发送跨域请求之前会先发送一个相应的预检请求，从而获知服务器是否允许该跨域请求。如果允许，就发送跨域请求。如果不允许，则阻止发送跨域请求。</p>
<div class="note info">
            <p>触发预检请求的条件：</p><ul><li>如果请求方法不是 GET、HEAD 或 POST，那么将发送预检请求。</li><li>如果人为设置了对 CORS 安全的首部字段集合之外的首部字段，那么将发送预检请求。对 CORS 安全的首部字段集合包含：<ol><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code></li><li><code>DPR</code></li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ol></li><li>如果请求头的 <code>Content-Type</code> 的值不是 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code> 之一的话，那么将发送预检请求。</li></ul><hr><p>预检请求使用的是 OPTIONS 方法，发送下列头部：</p><ul><li><code>Origin</code>：源信息。</li><li><code>Access-Control-Allow-Method</code>：跨域请求使用的方法。</li><li><code>Access-Control-Allow-Headers</code>（可选）：跨域请求会额外发送的头部字段，这些头部字段用逗号分隔。</li></ul><hr><p>预检请求的响应会包含如下头部字段：</p><ul><li><code>Access-Control-Allow-Origin</code>：源信息。</li><li><code>Access-Control-Allow-Methods</code>：允许的方法，多个方法以逗号分隔。</li><li><code>Access-Control-Allow-Headers</code>：允许的头部，多个头部以逗号分隔。</li><li><code>Access-Control-Max-Age</code>（可选）：应该将这个预检请求缓存多长时间（以秒表示），也就是说在这个时间范围内，不会再发送相同的预检请求。</li></ul>
          </div>
<h2 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h2><p>默认情况下，跨域请求不提供凭据（<code>cookie</code>、HTTP 认证及客户端 SSL 证明等）。通过将 <code>withCredentials</code> 属性设置为 <code>true</code>，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的 HTTP 头部来响应：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript（于是，<code>responseText</code> 中将是空字符串，<code>status</code> 的值为 <code>0</code>，而且会调用 <code>onerror()</code> 事件处理程序）。另外，服务器还可以在预检请求的响应中发送这个 HTTP 头部，表示允许源发送带凭据的请求。</p>
<h1 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h1><h2 id="图像-Ping"><a href="#图像-Ping" class="headerlink" title="图像 Ping"></a>图像 Ping</h2><p>图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。通过图像 Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时候接收到的。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'http://www.example.com/test?name=Nicholas'</span></span><br></pre></td></tr></table></figure>
<p>图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数。图像 Ping 有两个主要缺点，一是只能发送 GET 请求，二是无法访问服务器的响应文本。因此，图像 Ping 只能用于浏览器与服务器的单向通信。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写，是应用 JSON 的一种方法。JSONP 看起来与 JSON 差不多，只不过是被包含在函数调用中的 JSON，就像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleResponse(&#123; <span class="string">"name"</span>: <span class="string">"Nicholas"</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，回调函数一般是在请求中通过 <code>callback</code> 查询字段指定的。而数据就是传入回调函数中的 JSON 数据。下面是一个典型的 JSONP 请求：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">http://aadonkeyz.com/example.js?callback=handleResponse</span><br></pre></td></tr></table></figure>
<p>JSONP 的原理很简单，它是通过动态 <code>&lt;script&gt;</code> 元素来发送请求的，然后将收到的响应内容（JSONP 格式）当作是 JavaScript 代码处理。</p>
<p>请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.src = <span class="string">'http://aadonkeyz.com/example.js?callback=handleResponse'</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到 JSONP 为 'handleResponse(&#123; "name": "Nicholas" &#125;)' 时，则等价于下面</span></span><br><span class="line"><span class="comment">// &lt;script&gt;</span></span><br><span class="line"><span class="comment">//     handleResponse(&#123; "name": "Nicholas" &#125;)</span></span><br><span class="line"><span class="comment">// &lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>这个例子的执行顺序为：</p><ol><li>浏览器通过 <code>&lt;script&gt;</code> 标签发送请求。</li><li>服务器收到请求后，发现这个是 JSONP 的请求，根据请求的 <code>callback</code> 查询字段获取回调函数的名称，然后准备要返回的 JSON 数据，最后以 JSONP 的格式结合回调函数名称和 JSON 数据。</li><li>浏览器接收到 JSONP 格式的响应，开始执行代码，即 <code>handleResponse({ &quot;name&quot;: &quot;Nicholas&quot; })</code>。</li></ol>
          </div>
<p>与图像 Ping相比，JSONP 非常简单易用并且能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过它也有自己的缺点：</p>
<p>首先，JSONP 是从其他域中加载代码执行，如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃 JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的 Web 服务时，一定要保证它安全可靠。</p>
<p>其次，要确定 JSONP 请求是否失败并不容易。但是 HTML5 给 <code>&lt;script&gt;</code> 标签新增了一个 <code>onerror</code> 事件处理程序，现在来说这个应该不算缺点了吧……</p>
<h1 id="服务器推送技术"><a href="#服务器推送技术" class="headerlink" title="服务器推送技术"></a>服务器推送技术</h1><h2 id="Comte"><a href="#Comte" class="headerlink" title="Comte"></a>Comte</h2><p>Comte 是 Alex Russell 发明的一个词儿，指的是一种更高级的 Ajax 技术（经常也有人称为“服务器推送”）。<strong>Ajax 是一种从页面向服务器请求数据的技术，而 Comte 则是一种服务器向页面推送数据的技术。Comte 能够让信息近乎实时地被推送到页面上。</strong></p>
<p>有两种实现 Comte 的方式：<strong>长轮询</strong>和<strong>流</strong>。</p>
<div class="note info">
            <p>短轮询是浏览器定时向服务器发送请求，查看是否有更新的数据。</p><p>长轮询是在页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。</p><p>无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的链接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。</p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E9%95%BF%E7%9F%AD%E8%BD%AE%E8%AF%A2%E6%97%B6%E9%97%B4%E7%BA%BF.png" alt="长短轮询时间线"></p>
<div class="note info">
            <p>第二种流行的 Comet 实现是 HTTP 流。流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个 HTTP 连接。具体来说，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。</p><p>在浏览器中，通过注册 <code>onreadystatechange</code> 事件处理程序及检测 <code>readyState</code> 的值，就可以利用 XHR 对象实现 HTTP 流。随着不断从服务器接收数据，<code>readyState</code> 的值会周期性地变为 <code>3</code>，而浏览器将接收的所有数据均保存在 <code>responseText</code> 属性中。</p>
          </div>
<p>使用 XHR 对象实现 HTTP 流的典型代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStreamingClient</span>(<span class="params">url, progress, finished</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  <span class="keyword">var</span> received = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">3</span>) &#123;</span><br><span class="line">      result = xhr.responseText.substring(received)</span><br><span class="line">      received += result.length</span><br><span class="line"></span><br><span class="line">      progress(result)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      finished(xhr.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">'get'</span>, url)</span><br><span class="line">  xhr.send(<span class="literal">null</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> xhr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = createStreamingClient(</span><br><span class="line">  <span class="string">'http://demo.com'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Received: '</span> + data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Done!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h2><div class="note warning">
            <p><strong>使用 SSE 可以跨域。</strong></p>
          </div>
<p>SSE（Server-Sent Events，服务器发送事件）是围绕只读 Comet 交互推出的 API。SSE API 用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME 类型必须是 <code>text/event-stream</code>，而且是浏览器中的 JavaScript API 能解析格式输出。SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。</p>
<p>SSE 的 JavaScript API与其他传递消息的JavaScript API很相似。要预订新的事件流，首先要创建一个新的<code>EventSource</code>对象实例，并传进一个入口点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(url)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(url, &#123; <span class="attr">withCredentials</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>上面的 <code>url</code> 可以与当前网页同域，也可以跨域。跨域时，可以指定第二个参数。<code>withCredentials</code> 是一个布尔值，表示是否一起发送 <code>cookie</code>。</p>
<p>默认情况下，<code>EventSource</code> 对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着 SSE 适合长轮询和 HTTP 流。如果想强制立即断开连接并且不再重新连接，可以调用 <code>close()</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">source.close()</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><code>EventSource</code> 的实例有一个 <code>readyState</code> 属性</p><ul><li>值为 <code>0</code> 表示正连接到服务器。</li><li>值为 <code>1</code> 表示打开了连接。</li><li>值为 <code>2</code> 表示关闭了连接。</li></ul><hr><p>另外，还有以下三个事件：</p><ul><li><code>open</code>：在建立连接时触发。</li><li><code>message</code>：在从服务器接收到新事件时触发。</li><li><code>error</code>：在无法建立连接时触发。</li></ul><p>服务器发回的数据已字符串形式保存在 <code>event.data</code> 中。</p>
          </div>
<p>所谓的服务器事件会通过一个持久的 HTTP 响应发送，这个响应的 MIME 类型为 <code>text/event-stream</code>。响应数据的格式是纯文本，最简单的情况是每个数据项都带有前缀 <code>data:</code>，例如：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">data: foo</span><br><span class="line"></span><br><span class="line">data: bar</span><br><span class="line"></span><br><span class="line">data: foo</span><br><span class="line">data bar</span><br></pre></td></tr></table></figure>
<p>对以上响应而言，事件流中的第一个 message 事件返回的 <code>event.data</code> 值为 <code>&quot;foo&quot;</code>，第二个 message 事件返回的 <code>event.data</code> 值为 <code>&quot;bar&quot;</code>，第三个 message 事件返回的 <code>event.data</code> 值为 <code>&quot;foo\nbar&quot;</code>（注意中间的换行符）。对于多个连续的以 <code>data:</code> 开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。<strong>只有在包含 <code>data:</code> 的数据行后面有空格时，才会触发 message 事件，因此在服务器上生成事件流时不能忘了多添加这一行。</strong></p>
<p>通过 <code>id:</code> 前缀可以给特定的事件指定一个关联的 ID，这个 ID 行位于 <code>data:</code> 行前面或后面皆可：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">data: foo</span><br><span class="line">id: 1</span><br></pre></td></tr></table></figure>
<p>设置了 ID 后，<code>EventSource</code> 对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为 <code>Last-Event-ID</code> 的特殊 HTTP 头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。</p>
<h2 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h2><p>Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 Web Sockets 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 Web Sockets 协议。也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持 Web Sockets 协议的专门服务器才能正常工作。</p>
<p>由于 Web Sockets 使用了自定义的协议，所以 URL 模式也略有不同。<strong>未加密得到连接不再是 <code>http://</code> 而是 <code>ws://</code>。加密的连接也不是 <code>https://</code> 而是 <code>wss://</code>。</strong>在使用 Web Sockets URL 时，必须带着这个模式，因为将来还有可能支持其他模式。</p>
<p>要创建 Web Sockets，先实例一个 <code>WebSocket</code> 对象并传入要连接的URL：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.example.com/server.php'</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <ul><li>必须给 <code>WebSocket</code> 构造函数传入绝对 URL。</li><li>同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接（不存在跨域问题）。</li><li>实例化了 <code>WebSocket</code> 对象后，浏览器就会马上尝试创建连接。</li></ul>
          </div>
<div class="note info">
            <p>与 XHR 类似，<code>WebSocket</code> 也有一个表示当前状态的 <code>readyState</code> 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示：</p><ul><li><code>WebSocket.OPENING(0)</code>：正在建立连接。</li><li><code>WebSocket.OPEN(1)</code>：已经建立连接。</li><li><code>WebSocket.CLOSING(2)</code>：正在关闭连接。</li><li><code>WebSocket.CLOSE(3)</code>：已经关闭连接。</li></ul><p><strong><code>WebSocket</code> 没有 readystatechange 事件。</strong></p>
          </div>
<p>要关闭 Web Sockets 连接，可以在任何时候调用 <code>close()</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">socket.close()</span><br></pre></td></tr></table></figure>
<p>调用了 <code>close()</code> 方法之后，<code>readyState</code> 属性的值立即变为 <code>2</code>，而在关闭连接后就会变成 <code>3</code>。</p>
<p>Web Sockets 打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用 <code>send()</code> 方法并传入任意字符串，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.example.com/server.php'</span>)</span><br><span class="line">socket.send(<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>当服务器向客户端发来消息时，<code>WebSocket</code> 对象就会触发 message 事件。这个 message 事件与其他传递消息的协议类似，也是把返回的数据保存在 <code>event.data</code> 属性中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <ul><li>在使用 Web Sockets 连接发送和接收数据时，需要注意传递的数据只能是纯文本数据。</li><li><code>WebSocket</code> 对象还有其他三个事件，在连接生命周期的不同阶段触发，分别是 <code>open</code>、<code>error</code> 和 <code>close</code>。<code>WebSocket</code> 对象不支持 DOM2 级事件侦听器，因此必须使用 DOM0 级语法分别注册每个事件处理程序。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.example.com/server.php'</span>)</span><br><span class="line"></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Connection established.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Connection error.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Connection closed.'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这三个事件中，只要 close 事件的 <code>event</code> 对象有额外的信息。这个事件的事件对象有三个额外属性：<code>wasClean</code>、<code>code</code> 和 <code>reason</code>。其中，<code>wasClean</code> 是一个布尔值，表示连接是否已经明确地关闭。<code>code</code> 是服务器返回的数值状态码。而 <code>reason</code> 是一个字符串，包含服务器发回的消息。</p>
<h2 id="SSE-与-Web-Sockets"><a href="#SSE-与-Web-Sockets" class="headerlink" title="SSE 与 Web Sockets"></a>SSE 与 Web Sockets</h2><p>面对某个具体的用例，在考虑是使用 SSE 还是使用 Web Sockets 时，可以考虑如下几个因素。首先，你是否有自由度建立和维护 Web Sockets 服务器？因为 Web Sockets 协议不同于 HTTP，所以现有服务器不能用于 Web Sockets 通信。SSE 倒是通过常规 HTTP 通信，因此现有服务器就可以满足需求。</p>
<p>第二个要考虑的问题是到底需不需要双向通信。如果用例只需读取服务器数据，那么 SSE 比较容易实现。如果用例必须双向通信，那么 Web Sockets 显然更好。别忘了，在不能选择 Web Sockets 的情况下，组合 XHR 和 SSE 也是能实现双向通信的。</p>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>CSS解析原理</title>
    <url>/posts/df6afb91/</url>
    <content><![CDATA[<h1 id="CSS选择器的解析顺序"><a href="#CSS选择器的解析顺序" class="headerlink" title="CSS选择器的解析顺序"></a>CSS选择器的解析顺序</h1><p>在利用 DOM 和 CSSOM 合成 render tree 的时候，需要将样式表中的每一条 CSS 样式规则与对应的 DOM 元素关联起来。然而实际中，样式规则可能数量很大，但是绝大多数不会匹配到任何 DOM 元素上，所以有一个快速的方法来判断 CSS 选择器是否具有匹配的 DOM 元素是极其重要的。</p>
<p>以下面的例子讲解CSS 选择器的解析规则：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 111 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 222 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 333 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'yellow'</span>&gt;</span> 444 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div &gt; div.jartto p span.yellow&#123;</span><br><span class="line">   color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>如果采用<strong>从左至右</strong>的规则，过程如下所示：</p><ol><li>首先找到所有 <code>&lt;div&gt;</code>。</li><li>在每个 <code>&lt;div&gt;</code> 内寻找所有 <code>class=jartto</code> 的子 <code>&lt;div&gt;</code>。</li><li>在步骤二中找到的每个子 <code>&lt;div&gt;</code> 内接着按 CSS 选择器进行寻找，直到最后。</li></ol><p><strong>这样的搜索过程对于一个只是匹配很少节点的选择器来说，效率是极低的，因为我们花费了大量的时间在回溯匹配不符合规则的节点。</strong></p>
          </div>
<div class="note info">
            <p>如果采用<strong>从右至左</strong>的规则，过程如下所示：</p><ol><li>首先找到所有 <code>class=yellow</code> 的 <code>&lt;span&gt;</code>。</li><li>然后判断这些 <code>&lt;span&gt;</code> 的父元素是否为 <code>&lt;p&gt;</code></li><li>接着判断这些 <code>&lt;p&gt;</code> 的父元素是否为 <code>class=jartto</code> 的 <code>&lt;div&gt;</code>。</li><li>最后判断这些 <code>&lt;div&gt;</code> 的父元素是否也是 <code>&lt;div&gt;</code>。</li></ol><p><strong>因为每一个元素都只拥有一个父元素，所以从右至左的解析 CSS 选择器可以有效减少无效匹配的次数，从而使匹配更快、性能更优。</strong></p>
          </div>
<h1 id="computedStyle的计算"><a href="#computedStyle的计算" class="headerlink" title="computedStyle的计算"></a>computedStyle的计算</h1><p>render tree 生成时，元素的 computedStyle 是经过层叠计算后得到的。在某些特定的情况下，浏览器会让不同元素之间共享它们的 computedStyle。也就是说，如果多个元素的 computedStyle 不通过计算就可以确认它们相等，那么这个 computedStyle 只会被计算一次，从而提高了性能。</p>
<p>只要元素之间满足以下条件，它们之间就可以共享 computedStyle。</p>
<div class="note info">
            <ul><li>元素不能有 <code>id</code> 属性。</li><li>元素的标签名必须相同，即必须是同类型的元素。</li><li>元素的 <code>class</code> 属性必须相同。</li><li>元素之间的 mappedAttribute（一些可以影响 CSS ComputedStyle 的 HTML 属性） 必须相等。</li><li>元素不能有 <code>style</code> 属性，哪怕是这些元素的 <code>style</code> 属性值相同也不可以。</li><li>不能使用 sibling selector。例如，<code>first-child</code>、<code>:last-selector</code>、<code>+ selector</code>。</li></ul>
          </div>
<h1 id="选择器书写建议"><a href="#选择器书写建议" class="headerlink" title="选择器书写建议"></a>选择器书写建议</h1><div class="note info">
            <ul><li>ID 选择器是非常高效的，且 ID 是唯一的，所以在使用的时候应该单独使用，不需要再指定标签名等。</li><li>避免深层次的选择器。</li><li>慎用子代选择器。</li><li>属性选择的的解析速度非常慢，慎用。</li></ul>
          </div>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://juejin.im/entry/5a123c55f265da432240cc90" target="_blank" rel="noopener">探究 CSS 解析原理</a></li>
</ul>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>Web Worker</title>
    <url>/posts/da19b401/</url>
    <content><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>Web Worker 是让 Web 内容在后台线程中运行脚本的一种简单方法。Worker 线程在执行任务期间不会受到用户交互的干扰，除此之外，还可以使用 XMLHttpRequest 执行 I/O 操作。</p>
<div class="note info">
            <ul><li>Worker 线程运行环境不同于主线程，所以在 Worker 线程中无法使用 <code>document</code>、<code>window</code> 和 <code>parent</code> 这些对象，但是可以使用 <code>navigator</code> 对象和 <code>location</code> 对象。</li><li>Worker 线程中，<code>this</code> 对象和 <code>self</code> 对象是相同的。</li><li>Worker 线程不允许读取本地文件，即不能打开本机的文件系统 <code>file://</code>。这样说来，在使用 <code>new Worker()</code> 创建 Worker 线程时也不允许使用本机文件，在学习过程中为了方便，可以使用 <code>window.URL.createObjectURL(new Blob())</code> 来绕过这一限制。</li><li>Web Worker 分为专用 Worker 和共享 Worker。</li><li>在主线程和 Worker 线程之间，通过 <code>postMessage()</code> 来发送数据，通过 message 事件来接收数据。这个过程中数据是被深拷贝的，所以不会彼此干扰。</li><li>在主线程中，使用 <code>terminate()</code> 中止 Worker 线程。</li><li>在 Worker 线程中，可以使用 <code>importScript()</code> 加载脚本。</li><li>Worker 线程运行出错时，会触发 error 事件。该事件不会冒泡并且可以被取消。</li></ul>
          </div>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">  if (Worker) &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">worker_function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="javascript">        postMessage(<span class="string">'from work thread'</span>);</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> myWorker = <span class="keyword">new</span> Worker(</span></span><br><span class="line">      URL.createObjectURL(</span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Blob(</span></span><br><span class="line"><span class="javascript">          [<span class="string">'('</span>+worker_function.toString()+<span class="string">')()'</span>],</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">type</span>: <span class="string">'text/javascript'</span>&#125;</span></span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="javascript">    myWorker.postMessage(<span class="string">'from main thread'</span>);</span></span><br><span class="line"><span class="javascript">    myWorker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"></span><br><span class="line">      myWorker.terminate();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>Broswer Event Loop</title>
    <url>/posts/cf159629/</url>
    <content><![CDATA[<div class="note info">
            <p>不是我懒惰，是我怕翻译错<br>so</p><ul><li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">HTML Standard - Event Loop</a></li><li><a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers" target="_blank" rel="noopener">HTML Standard - Timers</a></li><li><a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#microtask-queuing" target="_blank" rel="noopener">HTML Standard - Microtask Queuing</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">Concurrency model and the event loop</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth" target="_blank" rel="noopener">In depth: Microtasks and the JavaScript runtime environment</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" rel="noopener">Using microtasks in JavaScript with queueMicrotask()</a></li><li><a href="https://javascript.info/event-loop#event-loop" target="_blank" rel="noopener">Event loop: microtasks and macrotasks</a></li></ul>
          </div>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>DOM</title>
    <url>/posts/ee93c80b/</url>
    <content><![CDATA[<p>DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API。DOM 描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p>
<h1 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h1><p>DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的 HTML 为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以将这个简单的 HTML 文档表示为如下层次结构：</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/DOM%20%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="DOM 层次结构"></p>
<p>文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即 <code>&lt;html&gt;</code> 元素，我们称之为文档元素。<strong>文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。</strong>在 HTML 页面中，文档元素始终都是 <code>&lt;html&gt;</code> 元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。</p>
<p>每一段标记都可以通过树中的一个节点来表示。HTML 元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型有继承自一个基类型。</p>
<h1 id="NodeList-与-HTMLCollection"><a href="#NodeList-与-HTMLCollection" class="headerlink" title="NodeList 与 HTMLCollection"></a>NodeList 与 HTMLCollection</h1><div class="note info">
            <ul><li><code>NodeList</code> 是节点集合，是一个类数组对象。有两种类型的 <code>NodeList</code>：<ul><li><code>Live NodeList</code>：它会随着 DOM 的变化而自动更新。</li><li><code>Static NodeList</code>：无论 DOM 如何变化，它的值都不变。可以理解为当生成 <code>Static NodeList</code> 时，对那一时刻的 <code>NodeList</code> 作了一次浅拷贝。</li></ul></li><li><code>HTMLCollection</code> 是元素集合，是一个类数组对象。<code>HTMLCollection</code> 是动态的，会随着 DOM 的变化而变化。</li></ul>
          </div>
<h1 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h1><p>DOM1 级定义了一个 <code>Node</code> 接口，该接口将由 DOM 中的所有节点类型实现。这个 <code>Node</code> 接口在 JavaScript 中是作为 <code>Node</code> 类型实现的。除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。JavaScript 中的所有节点类型都继承自 <code>Node</code> 类型，因此所有节点类型都共享着相同的基本属性和方法。</p>
<div class="note info">
            <p>每个节点都有一个 <code>nodeType</code> 属性，用于表明节点的类型。节点类型有 <code>Node</code> 类型中定义的下列 12 个数值常量来表示，任何节点类型必居其一：</p><ul><li><code>Node.ELEMENT_NODE</code>: 1。</li><li><code>Node.ATTRIBUTE_NODE</code>: 2。</li><li><code>Node.TEXT_NODE</code>: 3。</li><li><code>Node.CDATA_SECTION_NODE</code>: 4。</li><li><code>Node.ENTITY_REFERENCE_NODE</code>: 5。</li><li><code>Node.ENTITY_NODE</code>: 6。</li><li><code>Node.PROCESSING_INSTRUCTION_NODE</code>: 7。</li><li><code>Node.COMMENT_NODE</code>: 8。</li><li><code>Node.DOCUMENT_NODE</code>: 9。</li><li><code>Node.DOCUMENT_TYPE_NODE</code>: 10。</li><li><code>Node.DOCUMENT_FRAGMENT_NODE</code>: 11。</li><li><code>Node.NOTATION_NODE</code>: 12。</li></ul>
          </div>
<p>通过比较上面这些常量，可以很容易地确定节点的类型，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在IE中无效</span></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Node is an element'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了确保跨浏览器兼容，最好还是将 <code>nodeType</code> 属性与数字值进行比较，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 适用于所有浏览器</span></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Node is an element'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Node-的属性"><a href="#Node-的属性" class="headerlink" title="Node 的属性"></a>Node 的属性</h2><div class="note info">
            <p>文档中所有的节点之间都存在这样或那样的关系，节点间的各种关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。每个节点都有如下属性，用于记录彼此之间的关系：</p><ul><li><code>childNodes</code>：该属性可以看作一个保存着所有子节点的有序列表，它是一个 <code>Live NodeList</code> 对象。</li><li><code>firstChild</code>：指向 <code>childNodes</code> 列表的第一个节点，如果不存在，则为 <code>null</code>。</li><li><code>lastChild</code>：指向 <code>childNodes</code> 列表的最后一个节点，如果不存在，则为 <code>null</code>。</li><li><code>parentNode</code>：该属性指向文档中的父节点。</li><li><code>previousSibling</code>：指向上一个同胞节点，如果不存在，则为 <code>null</code>。</li><li><code>nextSibling</code>：指向下一个同胞节点，如果不存在，则为 <code>null</code>。</li><li><code>ownerDocument</code>：指向表示整个文档的文档节点。</li><li><code>children</code>：该属性可以看作一个保存着所有子元素的有序列表，它是一个 <code>HTMLCollection</code> 对象。</li><li><code>childElementCount</code>：返回子元素的个数。</li><li><code>firstElementChild</code>：指向第一个子元素。</li><li><code>lastElementChild</code>：指向最后一个子元素。</li><li><code>previousElementSibling</code>：指向前一个同辈元素。</li><li><code>nextElementSibling</code>：指向后一个同辈元素。</li></ul>
          </div>
<h2 id="Node-的方法"><a href="#Node-的方法" class="headerlink" title="Node 的方法"></a>Node 的方法</h2><div class="note info">
            <p>因为节点的关系属性都是只读的，所以 DOM 提供了一些操作子节点的方法，：</p><ul><li><code>appendChild()</code>：该方法接受单个参数：要新增的节点。操作成功后返回新增的节点。该操作会将新增的节点添加到 <code>childNodes</code> 列表的末尾。添加节点后，<code>childNodes</code> 中相关节点的关系会自动更新。</li><li><code>insertBefore()</code>：该方法接受两个参数：要插入的节点和作为参照的节点。操作成功后返回插入的节点。如果第二个参数是 <code>null</code>，则会将要插入的节点添加到 <code>childNodes</code> 列表的末尾。<strong>如果省略第二个参数，会抛出错误</strong>。</li><li><code>replaceChild()</code>：该方法接受两个参数：要插入的节点和要替换的节点。操作成功后返回被替换的节点。</li><li><code>removeChild()</code>：该方法接受单个参数：要移除的节点。操作成功后返回被移除的节点。</li><li><code>cloneNode()</code>：该方法接受一个布尔值参数，表示是否执行深复制。在参数为 <code>true</code> 时，执行深复制，也就是复制节点及其整个子节点树。在参数为 <code>false</code> 时，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。<strong>需要注意的是，该方法不会复制添加到 DOM 节点中的 JavaScript 属性，例如事件处理程序等</strong>。</li><li><code>importNode()</code>：该方法接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。</li><li><code>normalize()</code>：该方法唯一的作用是处理文档树中的文本节点。由于解析器的实现或 DOM 操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它。如果找到相邻的文本节点，则将它们合并为一个文本节点。</li></ul><hr><p>注意事项：</p><ul><li>任何一个 DOM 节点不能同时出现在文档中的多个位置上，所以当使用 <code>appendChild()</code>、<code>insertBefore()</code> 或 <code>replaceChild()</code> 方法并且传入的第一个参数为文档树中已经存在的节点时，该节点会从原位置转移到对应的新位置。</li><li>如果调用 <code>appendChild()</code> 时传入的节点属于不同的文档，则会抛出错误。</li><li>每个节点都有一个 <code>ownerDocument</code> 属性，表示所属的文档。</li></ul>
          </div>
<h1 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h1><p>JavaScript 通过 <code>Document</code> 类型表示文档。在浏览器中，<code>document</code> 对象是 <code>HTMLDocument</code>（继承自 <code>Document</code> 类型）的一个实例，表示整个 HTML 页面。而且，<code>document</code> 对象是 <code>window</code> 对象的一个属性，因此可以将其作为全局对象来访问。<code>Document</code> 节点具有下列特征：</p>
<div class="note info">
            <ul><li><code>nodeType</code> 的值为 <code>9</code>。</li><li><code>nodeName</code> 的值为 <code>&quot;#document&quot;</code>。</li><li><code>nodeValue</code> 的值为 <code>null</code>。</li><li><code>parentNode</code> 的值为 <code>null</code>。</li><li><code>ownerDocument</code> 的值为 <code>null</code>。</li><li>其子节点可能是一个 <code>DocumentType</code>（最多一个）、<code>Element</code>（最多一个）、<code>ProcessingInstruction</code> 或 <code>Comment</code>。</li></ul>
          </div>
<h2 id="document-的属性"><a href="#document-的属性" class="headerlink" title="document 的属性"></a>document 的属性</h2><div class="note info">
            <ul><li><code>documentElement</code>：该属性指向 HTML 页面中的 <code>&lt;html&gt;</code> 元素。</li><li><code>body</code>：该属性指向 HTML 页面中的 <code>&lt;body&gt;</code> 元素。</li><li><code>doctype</code>：该属性指向 <code>&lt;!DOCTYPE&gt;</code> 标签，但是不同浏览器对该属性的支持差别很大。</li><li><code>title</code>：通过该属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。</li><li><code>URL</code>：该属性保存着页面完整的URL。</li><li><code>domain</code>：该属性保存着页面的域名。</li><li><code>referrer</code>：该属性保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下，该属性值可能会包含空字符串。</li><li><code>anchors</code>：该属性保存着文档中所有带 <code>name</code> 特性的 <code>&lt;a&gt;</code> 元素，是一个 <code>HTMLCollection</code> 对象。</li><li><code>applets</code>：该属性保存着文档中所有的 <code>&lt;applet&gt;</code> 元素，是一个 <code>HTMLCollection</code> 对象，因为不再推荐使用 <code>&lt;applet&gt;</code> 元素，所以这个集合已经不建议使用了。</li><li><code>forms</code>：该属性保存着文档中所有的 <code>&lt;form&gt;</code> 元素，是一个 <code>HTMLCollection</code> 对象，与 <code>document.getElementsByTagName(&#39;form&#39;)</code> 得到的结果相同。</li><li><code>images</code>：该属性保存着文档中所有的 <code>&lt;img&gt;</code> 元素，是一个 <code>HTMLCollection</code> 对象，与 <code>document.getElementsByTagName(&#39;img&#39;)</code> 得到的结果相同。</li><li><code>links</code>：该属性保存着文档中所有带 <code>href</code> 特性的 <code>&lt;a&gt;</code> 元素，是一个 <code>HTMLCollection</code> 对象。</li></ul><hr><p><strong>关于 <code>domain</code> 属性，可以将低级域改为高级域，但是不能将高级域改为低级域。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'wrox.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误！</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'p2p.wrox.com'</span></span><br></pre></td></tr></table></figure>
<h1 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h1><p>除了 <code>Document</code> <code>类型之外，Element</code> 类型就要算是 Web 编程中最常用的类型了。<code>Element</code> 类型用于表现 XML 或 HTML 元素，提供了对元素签名、子节点及特性的访问。<code>Element</code> 节点具有以下特征：</p>
<div class="note info">
            <ul><li><code>nodeType</code> 的值为 <code>1</code>。</li><li><code>nodeName</code> 的值为元素的标签名。</li><li><code>nodeValue</code> 的值为 <code>null</code>。</li><li><code>parentNode</code> 可能是 <code>Document</code> 或 <code>Element</code>。</li><li>其子节点可能是 <code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code> 或 <code>EntityReference</code>。</li></ul>
          </div>
<p>要访问元素的标签名，可以使用 <code>nodeName</code> 属性，也可以使用 <code>tagName</code> 属性。这两个属性会返回相同的值。以下面的元素为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以像下面这样获得这个元素及其标签名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DIV</span></span><br><span class="line"><span class="built_in">console</span>.log(div.tagName)                    </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(div.tagName === div.nodeName)</span><br></pre></td></tr></table></figure>
<p>这里的元素标签名是 <code>div</code>，它拥有一个值为 <code>myDiv</code> 的 ID。可是，<code>div.tagName</code> 实际上输出的是 <code>&quot;DIV&quot;</code> 而非 <code>&quot;div&quot;</code>。<strong>在 HTML 中，标签名始终都是以全部大写表示。而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。</strong>假如你不确定自己的脚本将会在 HTML 还是 XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.tagName.toLowerCase === <span class="string">'div'</span>) &#123;</span><br><span class="line">  <span class="comment">// 在此执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HTML-元素的属性"><a href="#HTML-元素的属性" class="headerlink" title="HTML 元素的属性"></a>HTML 元素的属性</h2><p>所有 HTML 元素都是由 <code>HTMLElement</code> 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。<code>HTMLElement</code> 类型直接继承自 <code>Element</code> 并添加了一些属性。添加的这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。</p>
<div class="note info">
            <ul><li><code>id</code>：元素在文档中的唯一标识符。</li><li><code>title</code>：有关元素的附加说明信息，一般通过工具提示条显示出来。</li><li><code>lang</code>：元素内容的语言代码，很少使用。</li><li><code>dir</code>：语言的方向，值为 <code>ltr</code> 或 <code>rtl</code>，也很少使用。</li><li><code>className</code>：与元素的 <code>class</code> 特性对应，即为元素指定的 CSS 类。没有将这个属性命名为 <code>class</code>，是因为 <code>class</code> 是 ECMAScript 的保留字。</li></ul>
          </div>
<p>上述这些属性都可以用来取得或修改相应的特性值。以下面的HTML元素为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">class</span>=<span class="string">"bd"</span> <span class="attr">title</span>=<span class="string">"Body text"</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>元素中指定的所有信息，都可以通过下列 JavaScript 代码取得：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// myDiv</span></span><br><span class="line"><span class="built_in">console</span>.log(div.id)         </span><br><span class="line"></span><br><span class="line"><span class="comment">// bd</span></span><br><span class="line"><span class="built_in">console</span>.log(div.className)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Body text</span></span><br><span class="line"><span class="built_in">console</span>.log(div.title)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// en</span></span><br><span class="line"><span class="built_in">console</span>.log(div.lang)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// ltr</span></span><br><span class="line"><span class="built_in">console</span>.log(div.dir)</span><br></pre></td></tr></table></figure>
<p>当然，像下面这样通过为每个属性赋予新的值，也可以修改对应的每个特性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.id = <span class="string">"someOtherId"</span></span><br><span class="line">div.className = <span class="string">'ft'</span></span><br><span class="line">div.title = <span class="string">'Some other text'</span></span><br><span class="line">div.lang = <span class="string">'fr'</span></span><br><span class="line">div.dir = <span class="string">'rtl'</span></span><br></pre></td></tr></table></figure>
<h2 id="操作特性"><a href="#操作特性" class="headerlink" title="操作特性"></a>操作特性</h2><p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或内容的附加信息。操作特性的 DOM 方法主要有三个：<code>getAttribute()</code>、<code>setAttribute()</code> 和 <code>removeAttribute()</code>。关于这三个方法的用法就不详细介绍了，下面介绍下使用它们时的注意事项：</p>
<div class="note warning">
            <ul><li><strong>传递给三个方法的特性名必须与实际的特性名相同，但是不区分大小写</strong>。例如，如果想要得到 <code>class</code> 特性值，应传入 <code>class</code> 而不是 <code>className</code>，后者只有在通过对象属性访问特性时才用。</li><li>根据 HTML5 规范，自定义特性应该加上 <code>data-</code> 前缀以便验证。</li><li>用户自定义特性，只能通过这三个方法来操作，无法通过对象属性形式来操作。</li><li>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过 <code>getAttribute()</code> 方法返回的值并不相同。它们分别是：<code>style</code> 特性和像 <code>onclick</code> 这样的事件处理程序。它们的属性值分别为对象和函数，但是通过 <code>getAttribute()</code> 方法返回的都是是字符串。</li><li>在使用 <code>setAttribute()</code> 为元素设置属性时，无论你传递的是什么类型的值，它都会将该值转换为字符串在设置到元素的属性上。所以对于一些特殊的属性，比如 <code>&lt;input&gt;</code> 标签上的 <code>check</code> 属性，只要出现了，无论你给它传递任何属性值（哪怕是空字符串也不行），它的属性值就是 <code>true</code>。只有使用 <code>removeAttribute()</code> 移除 <code>check</code> 属性，才会让该属性值变为 <code>false</code>。所以有的属性最好不要使用 <code>setAttribute()</code> 来设置。</li></ul>
          </div>
<p>下面的例子展示了公认特性与自定义特性的区别：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-special</span>=<span class="string">"aadonkeyz"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"myInput"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// myDiv</span></span><br><span class="line"><span class="built_in">console</span>.log(div.id)                         </span><br><span class="line"><span class="comment">// myDiv</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'id'</span>))             </span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(div[<span class="string">'data-special'</span>])                </span><br><span class="line"><span class="comment">// aadonkeyz</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'data-special'</span>))   </span><br><span class="line"></span><br><span class="line">div.setAttribute(<span class="string">'class'</span>, <span class="string">'myClass'</span>)</span><br><span class="line"><span class="comment">// myClass</span></span><br><span class="line"><span class="built_in">console</span>.log(div.className)         </span><br><span class="line"></span><br><span class="line">div[<span class="string">'data-other'</span>] = <span class="string">'other'</span></span><br><span class="line"><span class="comment">// other</span></span><br><span class="line"><span class="built_in">console</span>.log(div[<span class="string">'data-other'</span>])</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'data-other'</span>))</span><br><span class="line">div.setAttribute(<span class="string">'data-other'</span>, <span class="string">'other'</span>)</span><br><span class="line"><span class="comment">// other </span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'data-other'</span>))     </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'myInput'</span>)</span><br><span class="line"></span><br><span class="line">input.setAttribute(<span class="string">'checked'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(input.checked)</span><br><span class="line"></span><br><span class="line">input.setAttribute(<span class="string">'checked'</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(input.checked)</span><br><span class="line"></span><br><span class="line">input.removeAttribute(<span class="string">'checked'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(input.checked)</span><br></pre></td></tr></table></figure>
<h2 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h2><p><code>Element</code> 类型是使用 <code>attributes</code> 属性的唯一一个 DOM 节点类型。<code>attributes</code> 属性中包含一个 <code>NamedNodeMap</code> 类数组对象，它是一个“动态”的集合。</p>
<div class="note info">
            <p><code>attributes</code> 属性中包含一系列 Attr 节点，每个节点的 <code>nodeName</code> 就是特性的名称，而节点的 <code>nodeValue</code> 就是特性值。</p><ul><li><code>getNamedItem(name)</code>：返回 <code>nodeName</code> 属性等于 <code>name</code> 的节点。</li><li><code>removeNamedItem(name)</code>：从列表中移除 <code>nodeName</code> 属性等于 <code>name</code> 的节点。</li><li><code>setNamedItem(node)</code>：向列表中添加节点，以节点的 <code>nodeName</code> 属性为索引。</li><li><code>item(pos)</code>：返回位于数字 <code>pos</code> 位置处的节点。</li></ul>
          </div>
<p>下面简单的演示一下 <code>getNamedItem()</code> 方法的几种使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接使用</span></span><br><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">'id'</span>).nodeValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台自动调用 getNamedItem() 方法</span></span><br><span class="line"><span class="keyword">var</span> id = element.attributes[<span class="string">'id'</span>].nodeValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先取得特性节点，然后修改它的 nodeValue</span></span><br><span class="line">element.attributes[<span class="string">'id'</span>].nodeValue = <span class="string">'someOtherId'</span></span><br></pre></td></tr></table></figure>
<p>一般来说，由于 <code>attributes</code> 属性上的方法不够方便，开发人员更多的会使用 <code>getAttribute()</code>、<code>setAttribute()</code> 和 <code>removeAttribute()</code> 方法。不过当你想要遍历元素的特性时，<code>attributes</code> 属性倒是可以派上用场。在需要将 DOM 结构序列化为 XML 或 HTML 字符串时，多数都会涉及遍历元素特性。以下代码展示了如何迭代元素的每一个特性，然后将它们构造成 <code>name=&#39;value&#39; name=&#39;value&#39;</code> 这样的字符串格式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttributes</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pairs = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">var</span> attrName;</span><br><span class="line">  <span class="keyword">var</span> attrValue;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">var</span> len;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, len = element.attributes.length; i &lt; len; i++) &#123;</span><br><span class="line">    attrName = element.attributes[i].nodeName;</span><br><span class="line">    attrValue = element.attributes[i].nodeValue;</span><br><span class="line">    pairs.push(attrName + <span class="string">'="'</span> + attrValue + <span class="string">'"'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pairs.join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>关于以上代码的运行结果，以下是两点必要的说明：</p><ul><li>针对 <code>attributes</code> 中包含的特性，不同浏览器返回的顺序不同。这些特性在 XML 或 HTML 代码中出现的先后顺序，不一定与它们出现在 <code>attributes</code> 中的顺序一致。</li><li>IE7 及更早的版本会返回 HTML 元素中所有可能的特性，包括没有指定的特性。换句话说，返回 100 多个特性的情况会很常见。</li></ul>
          </div>
<p>针对 IE7 及更早版本中存在的问题，可以对上面的函数加以改进，让它只返回指定的特性。每个特性节点都有一个名为 <code>specified</code> 的属性，这个属性的值如果为 <code>true</code>，则意味着要么是在 HTML 中指定了相应特性，要么是通过 <code>setAttribute()</code> 方法设置了该特性。在 IE 中，所有未设置过的特性的该属性值都为 <code>false</code>，而在其他浏览器中根本不会为这类特性生成对应的特性节点（因此，在这些浏览器中，任何特性节点的 <code>specified</code> 值始终为 <code>true</code>）。改进后的代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttributes</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pairs = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">var</span> attrName;</span><br><span class="line">  <span class="keyword">var</span> attrValue;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">var</span> len;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, len = element.attributes.length; i &lt; len; i++) &#123;</span><br><span class="line">    attrName = element.attributes[i].nodeName;</span><br><span class="line">    attrValue = element.attributes[i].nodeValue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (element.attributes[i].specified) &#123;</span><br><span class="line">      pairs.push(attrName + <span class="string">'="'</span> + attrValue + <span class="string">'"'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pairs.join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h2><p>使用 <code>document.createElement()</code> 方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在 HTML 文档中不区分大小写，而在 XML（包括 XHTML）文档中，则是区分大小写的。在使用该方法创建新元素的同时，也为新元素设置了 <code>ownerDocument</code> 属性。例如，使用以下代码可以创建一个 <code>&lt;div&gt;</code> 元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure>
<p>在 IE 中，可以以另一种方式使用 <code>document.createElement()</code>，即为这个方法传入完整的元素标签，也可以包含属性，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'&lt;div id="myNewDiv" class="box"&gt;&lt;/div&gt;'</span>)</span><br></pre></td></tr></table></figure>
<p>这种方式有助于避开在 IE7 及更早版本中动态创建元素的某些问题。<strong>建议只在需要避开 IE7 及更早版本中存在的问题时，才使用这种方式！</strong></p>
<h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><div class="note info">
            <p>只能在 <code>document</code> 上调用的方法：</p><ul><li><code>getElementById()</code>：输入要取得的元素 ID。如果没找到，返回 <code>null</code>。如果有多个则返回第一个。<strong>注意，这里的 ID 必须与页面中元素的 <code>id</code> 特性严格匹配，包括大小写。</strong></li><li><code>getElementsByName()</code>：输入取得元素的 <code>name</code> 特性值。返回一个 <code>Live NodeList</code> 对象。</li></ul><hr><p>既能在 <code>document</code> 上调用，也能在 <code>HTMLElement</code> 上调用的方法：</p><ul><li><code>getElementsByTagName()</code>：输入要取得元素的标签名。返回一个 <code>HTMLCollection</code> 对象。如果想要取得文档中的所有元素，可以向该方法传入 <code>&quot;*&quot;</code>。</li><li><code>getElementsByClassName()</code>：输入要取得元素的类。返回一个 <code>HTMLCollection</code> 对象。</li><li><code>querySelector()</code>：输入要取得元素的 css selector。如果没找到，返回 <code>null</code>。如果有多个则返回第一个。<strong>如果输入的 css selector 不合法，会抛出错误。</strong></li><li><code>querySelectorAll()</code>：输入要取得元素的 css selector。返回一个 <code>Static NodeList</code> 对象。<strong>如果输入的 css selector 不合法，会抛出错误。</strong></li></ul>
          </div>
<h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><h2 id="CSSStyleDeclaration"><a href="#CSSStyleDeclaration" class="headerlink" title="CSSStyleDeclaration"></a>CSSStyleDeclaration</h2><div class="note info">
            <p><code>CSSStyleDeclaration</code> 对象代表一个 CSS 声明块。通过以下三种方式都能够访问到各自的 <code>CSSStyleDeclaration</code> 对象：</p><ul><li><code>HTMLElement.style</code>：行内样式。</li><li><code>CSSStyleSheet</code>：样式表。</li><li><code>window.getComputedStyle</code>：只读的计算样式。</li></ul><hr><p><code>CSSStyleDeclaration</code> 对象上有如下属性和方法：</p><ul><li><code>cssText</code></li><li><code>length</code></li><li><code>parentRule</code></li><li><code>getPropertyPriority()</code></li><li><code>getPropertyValue()</code></li><li><code>removeProperty()</code></li><li><code>setProperty()</code></li></ul>
          </div>
<h2 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h2><p>任何支持 <code>style</code> 特性的 HTML 元素在 JavaScript 中都有一个对应的 <code>style</code> 属性，其中保存着一个 <code>CSSStyleDeclaration</code> 对象。该对象包含通过 HTML 的 <code>style</code> 特性指定的所有样式信息，但不包含外部样式表或嵌入样式表层叠而来的样式。对于使用短划线的 CSS 属性名，必须将其转换成驼峰大小写形式，才能通过 JavaScript 来访问。</p>
<div class="note warning">
            <ul><li>由于 <code>float</code> 是 JavaScript 的保留字，因此不能用于属性名。DOM2 级规范规定样式对象上相应的属性名应该是 <code>cssFloat</code>.Firefox、Safari、Opera 和 Chrome 都支持这个属性，而 IE 支持的则是 <code>styleFloat</code>。</li><li>在标准模式下，所有度量值都必须指定一个度量单位。在混杂模式下，可以将 <code>style.width</code> 设置为 <code>&quot;20&quot;</code>，浏览器会假设它是 <code>&quot;20px&quot;</code>。但在标准模式下，将 <code>style.width</code> 设置为 <code>&quot;20&quot;</code> 会导致被忽略。在实践中，最好始终都指定度量单位。</li><li>如果没有为元素设置 style 特性，那么 <code>style</code> 对象中可能会包含一些默认的值，但这些值并不能准确地反映该元素的样式信息。例如，在 style 特性中没有定义 <code>width</code>，而通过样式表来定义了 <code>width</code> 的话，默认值就不能准确地反映样式信息了。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"width: 10px; font-size: 1px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10px</span></span><br><span class="line"><span class="built_in">console</span>.log(div.style.width)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1px</span></span><br><span class="line"><span class="built_in">console</span>.log(div.style.fontSize) </span><br><span class="line"></span><br><span class="line">div.style.height = <span class="string">'20px'</span></span><br></pre></td></tr></table></figure>
<h2 id="计算样式"><a href="#计算样式" class="headerlink" title="计算样式"></a>计算样式</h2><p><code>window.getComputedStyle(element [, pseudoElt])</code> 方法会解析一个元素的样式，然后返回一个包含元素所有 CSS 属性值的对象。<strong>所有计算样式都是只读的，试图修改会抛出错误。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"width: 10px; font-size: 1px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> computedStyle = <span class="built_in">window</span>.getComputedStyle(div)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10px</span></span><br><span class="line"><span class="built_in">console</span>.log(computedStyle.width)</span><br></pre></td></tr></table></figure>
<h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><div class="note warning">
            <p><strong>如果样式已经通过行内样式的方式定义了，那么怎么操作样式表也修改不了对应的样式！</strong></p>
          </div>
<h3 id="CSSRule"><a href="#CSSRule" class="headerlink" title="CSSRule"></a>CSSRule</h3><p><code>CSSRule</code> 对象表示样式表中的每一条规则。实际上，<code>CSSRule</code> 是一个供其他多种类型继承的基类型，其中最常见的就是 <code>CSSStyleRule</code> 类型，表示样式信息。<code>CSSStyleRule</code> 对象包含下列属性：</p>
<div class="note info">
            <ul><li><code>cssText</code>：返回整条规则对应的文本。</li><li><code>parentRule</code>：如果当前规则是导入的规则，这个属性引用就是导入的规则，否则这个值为 <code>null</code>。</li><li><code>parentStyleSheet</code>：当前规则所属的样式表。</li><li><code>selectorText</code>：返回当前规则的选择符文本。</li><li><code>style</code>：一个 CSSStyleDeclaration 对象，可以通过它设置和取得规则中特定的样式值。</li><li><code>type</code>：表示规则类型的常量值。</li></ul>
          </div>
<h3 id="样式表的属性和方法"><a href="#样式表的属性和方法" class="headerlink" title="样式表的属性和方法"></a>样式表的属性和方法</h3><p><code>CSSStyleSheet</code> 类型表示的是样式表，包括通过 <code>&lt;link&gt;</code> 元素包含的样式表和在 <code>&lt;style&gt;</code> 元素中定义的样式表。<code>CSSStyleSheet</code> 继承自 <code>StyleSheet</code>，后者可以作为一个基础接口来定义非 CSS 样式表。</p>
<div class="note info">
            <p>从 <code>StyleSheet</code> 接口继承而来的属性如下，<strong>其中除了 <code>disable</code> 属性，其他属性均为只读属性</strong>：</p><ul><li><code>disabled</code>：表示样式是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为 <code>true</code> 可以禁用样式表。</li><li><code>href</code>：如果样式表是通过 <code>&lt;link&gt;</code> 包含的，则是样式表的 URL，否则为 <code>null</code>。</li><li><code>media</code>：当前样式表支持的所有媒体类型的集合。与所有 DOM 集合一样，这个集合也有一个 <code>length</code> 属性和一个 <code>item()</code> 方法，也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。</li><li><code>ownerNode</code>：指向拥有当前样式表的节点的指针，样式表可能是在 HTML 中通过 <code>&lt;link&gt;</code> 或 <code>&lt;style&gt;</code> 引入的（在 XML 中可能是通过指令引入的）。如果当前样式表是其他样式表通过 <code>@import</code> 导入的，则这个属性值为 <code>null</code>。</li><li><code>parentStyleSheet</code>：在当前样式表是通过 <code>@import</code> 导入的情况下，这个属性是一个指向导入它的样式表的指针。</li><li><code>title</code>：<code>ownerNode</code> 中 <code>title</code> 属性的值。</li><li><code>type</code>：表示样式表类型的字符串。对 CSS 样式表而言，这个字符串是 <code>&quot;type/css&quot;</code>。</li></ul><hr><p><code>CSSStyleSheet</code> 类型还支持下列属性和方法：</p><ul><li><code>cssRules</code>：样式表中包含的样式规则的集合，集合中的每一项都是一个 <code>CSSRule</code> 对象。IE 不支持这个属性，但有一个类似的 <code>rules</code> 属性。</li><li><code>ownerRules</code>：如果样式表是通过 <code>@import</code> 导入的，这个属性就是一个指针，指向表示导入的规则，否则为 <code>null</code>。</li><li><code>deleteRule(index)</code>：删除 <code>cssRules</code> 集合中指定位置的规则。</li><li><code>insertRule(rule, index)</code>：向 <code>cssRules</code> 集合中指定的位置插入 <code>rule</code> 字符串。</li></ul>
          </div>
<h3 id="获取样式表"><a href="#获取样式表" class="headerlink" title="获取样式表"></a>获取样式表</h3><p>应用于文档的所有样式表是通过 <code>document.styleSheets</code> 集合来表示的。通过这个集合的 <code>length</code> 属性可以获知文档中样式表的数量，而通过方括号语法或 <code>item()</code> 方法可以访问每一个样式表。来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="literal">null</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">document</span>.styleSheets.length; i &lt; len; i++) &#123;</span><br><span class="line">  sheet = <span class="built_in">document</span>.styleSheets[i]</span><br><span class="line">  <span class="built_in">console</span>.log(sheet)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DOM 为 <code>&lt;link&gt;</code> 或 <code>&lt;style&gt;</code> 元素定义了一个 <code>sheet</code> 属性，通过它可以直接取得对应的样式表。除了 IE，其他浏览器都支持这个属性，IE 支持的是 <code>styleSheet</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyleSheet</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element.sheet || element.styleSheet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得第一个&lt;link&gt;元素引入的样式表</span></span><br><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementByTagName(<span class="string">'link'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> sheet = getStyleSheet(link)</span><br></pre></td></tr></table></figure>
<h3 id="使用样式表"><a href="#使用样式表" class="headerlink" title="使用样式表"></a>使用样式表</h3><p>前面已经介绍足够多的准备知识了，现在直接举一个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">id</span>=<span class="string">"mySheet"</span>&gt;</span></span><br><span class="line">      #myDiv &#123;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> sheet = <span class="built_in">document</span>.getElementById(<span class="string">'mySheet'</span>).sheet</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 取得规则列表</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> rules = sheet.cssRules || sheet.rules</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 取得第一条规则</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> rule = rules[<span class="number">0</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// #myDiv &#123; border: 1px solid red; &#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(rule.cssText)           </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// null</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(rule.parentRule)        </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// #myDiv</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(rule.selectorText)    </span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">// 1</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(rule.type)           </span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">// 1px solid red</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(rule.style.border)      </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 改变第一条规则中的内容</span></span></span><br><span class="line"><span class="javascript">      rule.style.border = <span class="string">'1px solid black'</span></span></span><br><span class="line"><span class="javascript">      rule.style.width = <span class="string">'20%'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 创建第二条规则，并放到样式表最前面</span></span></span><br><span class="line"><span class="javascript">      sheet.insertRule(<span class="string">'body &#123;background: silver&#125;'</span>, <span class="number">0</span>)</span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">// 删除旧的规则</span></span></span><br><span class="line">      sheet.deleteRule(1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h1><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><div class="note info">
            <p>首先要介绍的属性涉及偏移量，包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。通过下列属性可以取得元素的偏移量：</p><ul><li><code>offsetParent</code>：该属性指向最近的包含该元素的定位元素。如果外层没有定位元素，则返回最近的 <code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;table&gt;</code> 或者 <code>&lt;body&gt;</code>。如果元素的 <code>style.display</code> 为 <code>none</code>，则 <code>offsetParent</code> 返回 <code>null</code>。</li><li><code>offsetLeft</code>：元素的左外边框至 <code>offsetParent</code> 的左内边框之间的像素距离。</li><li><code>offsetTop</code>：元素的上外边距至 <code>offsetParent</code> 的上内边框之间的像素距离。</li><li><code>offsetHeight</code>：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。</li><li><code>offsetWidth</code>：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。</li></ul>
          </div>
<div class="note warning">
            <ul><li><code>offsetLeft</code> 和 <code>offsetTop</code> 的值都是相对于最近的<strong>定位元素</strong>，也就是 <code>offsetParent</code>。</li><li>所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性。如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F-%E5%81%8F%E7%A7%BB%E9%87%8F.png" alt="元素大小-偏移量"></p>
<p>要想知道某个元素在页面上的偏移量，将这个元素的 <code>offsetLeft</code> 和 <code>offsetTop</code> 与其 <code>offsetParent</code> 的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。以下两个函数就可以用于分别取得元素的左和上偏移量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    actualLeft += current.offsetLeft</span><br><span class="line">    current = current.offsetParent</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actualLeft</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actualTop = element.offsetTop</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    actualTop += current.offsetTop</span><br><span class="line">    current = current.offsetParent</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actualTop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户区"><a href="#客户区" class="headerlink" title="客户区"></a>客户区</h2><div class="note info">
            <p>元素的客户区大小，指的是元素内容及其内边距所占据的空间大小。有关客户区大小的属性有两个：</p><ul><li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度。</li><li><code>clientHeight</code>：元素内容区高度加上上下内边距高度。</li><li><code>clientLeft</code>：元素左边框的厚度。</li><li><code>clientTop</code>：元素上边框的厚度。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F-%E5%AE%A2%E6%88%B7%E5%8C%BA.png" alt="元素大小-客户区"></p>
<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><div class="note info">
            <p>滚动大小指的是包含滚动内容的元素的大小。有些元素（例如 <code>&lt;html&gt;</code> 元素），即使没有执行任何代码也能自动添加滚动条。但另外一些元素，则需要通过 CSS 的 <code>overflow</code> 属性进行设置才能滚动。以下是与滚动大小相关的属性：</p><ul><li><code>scrollHeight</code>：在没有滚动条的情况下，元素内容区高度加上上下内边距高度。</li><li><code>scrollWidth</code>：在没有滚动条的情况下，元素内容区宽度加上左右内边距宽度。</li><li><code>scrollLeft</code>：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</li><li><code>scrollTop</code>：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F-%E6%BB%9A%E5%8A%A8.png" alt="元素大小-滚动"></p>
<h2 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h2><p>通过 <code>Element.getBoundingClientRect()</code> 的形式调用该方法，会返回一个对象，用于指示目标元素在页面中相对于视口的位置信息和目标元素的大小信息，该对象包含 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>、<code>width</code>、<code>height</code>、<code>x</code> 和 <code>y</code>。其中不同浏览器对 <code>width</code>、<code>height</code>、<code>x</code> 和 <code>y</code>属性的支持程度不一样。</p>
<div class="note warning">
            <ul><li><code>bottom</code> 和 <code>right</code> 的含义与绝对定位中的不同，请看下图。</li><li>当计算边界矩形时，会考虑视口区域（或其他可滚动元素）内的滚动操作，也就是说，当滚动位置发生了改变，<code>top</code>、 <code>right</code>、 <code>bottom</code> 和 <code>left</code> 属性值就会立即随之发生改变。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F-getBoundingClientRect.png" alt="元素大小-getBoundingClientRect"></p>
<p>对于不支持 <code>Element.getBoundingClientRect()</code> 方法的浏览器，可以通过其他手段取得相同的信息。一般来说，<code>right</code> 和 <code>left</code> 的差值与 <code>offsetWidth</code> 的值相等，而 <code>bottom</code> 和 <code>top</code> 的差值与 <code>offsetHeight</code> 的值相等。polyfill 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    actualLeft += current.offsetLeft</span><br><span class="line">    current = current.offsetParent</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actualLeft</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actualTop = element.offsetTop</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    actualTop += current.offsetTop</span><br><span class="line">    current = current.offsetParent</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actualTop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.getBoundingClientRect) &#123;</span><br><span class="line">    <span class="keyword">return</span> element.getBoundingClientRect()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">    <span class="keyword">var</span> scrollLeft = <span class="built_in">document</span>.documentElement.scrollLeft</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> actualTop = getElementTop(element)</span><br><span class="line">    <span class="keyword">var</span> actualLeft = getElementLeft(element)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      top: actualTop - scrollTop,</span><br><span class="line">      bottom: actualTop - scrollTop + element.offsetHeight,</span><br><span class="line">      left: actualLeft - scrollLeft,</span><br><span class="line">      right: actualLeft - scrollLeft + element.offsetWidth</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>事件</title>
    <url>/posts/9c2b83ad/</url>
    <content><![CDATA[<p>JavaScript 与 HTML 之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间，比如：点击按钮、拖动鼠标等。</p>
<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>事件冒泡是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的 HTML 页面为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你单击了页面中的 <code>&lt;div&gt;</code> 元素，那么这个 click 事件会按照如下顺序传播</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1.png" alt="事件冒泡"></p>
<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>事件捕获的顺序与事件冒泡的顺序正好相反，以前面的HTML页面为例，它的顺序为：</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7.png" alt="事件捕获"></p>
<h2 id="事件流-1"><a href="#事件流-1" class="headerlink" title="事件流"></a>事件流</h2><p>DOM2 级事件规定的事件流包括三个阶段：<strong>事件捕获阶段</strong>、<strong>处于目标阶段</strong>和<strong>事件冒泡阶段</strong>。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。还是以前面的HTML页面为例，它的顺序如下所示：</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E4%BA%8B%E4%BB%B6%E6%B5%81.png" alt="事件流"></p>
<p>在 DOM 事件流中，实际的目标在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从 <code>document</code> 到 <code>&lt;html&gt;</code> 再到 <code>&lt;body&gt;</code> 后就停止了。下一个阶段是“处于目标”阶段，于是事件在 <code>&lt;div&gt;</code> 上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。</p>
<p>多数支持 DOM 事件流的浏览器都实现了一种特定的行为：即使DOM2 级事件规范明确要求捕获阶段不会涉及事件目标，但 IE9、Safari、Chrome、Firefox 和 Opera9.5 及更高版本都会在捕获阶段触发事件对象上的事件。结果就是有两个机会在目标对象上面操作事件。</p>
<h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><p>事件就是用户或浏览器自身执行的某种动作。诸如 click、load 和 mouseover，都是事件的名字。而响应某个事件的函数就叫做<strong>事件处理程序</strong>（或<strong>事件侦听器</strong>）。事件处理程序的名字就是在事件名前面加上 <code>&quot;on&quot;</code>，因此 click 事件的事件处理程序就是 <code>onclick</code>，load 事件的事件处理程序就是 <code>onload</code>。为事件注册处理程序的方式有好几种，下面一一进行介绍。</p>
<h2 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h2><p>某个元素支持的每种事件，都拥有一个与相应事件处理程序同名的 HTML 特性，可以通过这个特性来注册事件处理程序。下面以 <code>onclick</code> 事件为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAnother</span> (<span class="params">that</span>) </span>&#123;</span><br><span class="line">  alert(that.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 直接在HTML中指定具体动作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">onclick</span>=<span class="string">"alert(this.value)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 调用在&lt;script&gt;标签内定义的函数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"2"</span> <span class="attr">onclick</span>=<span class="string">"showMessage(this, event)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 调用外部js文件中定义的函数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">onclick</span>=<span class="string">"showAnother(this)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./test.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span> (<span class="params">that, event</span>) </span>&#123;</span></span><br><span class="line">        alert(that.value)</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(that)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event)</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 HTML 中注册事件处理程序，会创建一个封装着元素属性值的函数。这个函数中有一个局部变量 <code>event</code>，也就是事件对象（后面将会讨论这个概念），通过 <code>event</code> 变量可以直接访问事件对象。并且在这个函数内部，<code>this</code> 值等于事件的目标元素。所以你可以将 <code>event</code> 和 <code>this</code> 当做参数，传递给要调用的函数。关于这一点，你可以查看上面例子中 <code>showMessage()</code> 函数打印的内容来验证。</p>
<div class="note info">
            <p>HTML 事件处理程序的缺点：</p><ul><li>如果用户在页面解析 <code>showMessage()</code> 和 <code>showAnother()</code> 之前就点击了对应的按钮，会抛出错误。可以使用 <code>onclick=&quot;try {showMessage()} catch(ex) {}&quot;</code> 的形式来解决这个问题。</li><li>事件处理程序的作用域链在不同的浏览器中会有不同的结果。</li><li>HTML 和 JS 代码紧密耦合。</li></ul>
          </div>
<h2 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h2><div class="note warning">
            <ul><li>使用 DOM0 级方法只能在元素上注册一个事件处理程序。</li><li>对于相同的事件，DOM0 级事件处理程序与 HTML 事件处理程序事件处理程序无法共存。</li><li>使用 DOM0 级方法注册的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行，所以此时函数中的 <code>this</code> 指向元素自身。</li><li>在注册事件处理程序时，不推荐使用 <a href="https://aadonkeyz.com/posts/9595c646/#箭头函数">箭头函数</a>，因为它会造成 <code>this</code> 的丢失。</li></ul>
          </div>
<p>在添加的事件处理程序函数内部，可以直接通过 <code>event</code> 变量访问事件对象。也可以通过给程序处理函数定义参数或者使用 <code>arguments</code> 来访问事件对象，在下面有例子。</p>
<p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。你可以通过将事件处理程序属性的值设置为 <code>null</code> 来删除添加的事件处理程序。</p>
<p>来看一个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"myButton"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>)</span></span><br><span class="line"><span class="javascript">      button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event)</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event === e)    </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event === <span class="built_in">arguments</span>[<span class="number">0</span>]) </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 删除添加的事件处理程序</span></span></span><br><span class="line"><span class="javascript">        button.onclick = <span class="literal">null</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的按钮，只有第一次点击时会打印内容，之后就没有任何反应，因为事件处理程序在第一次触发之后，就被删除了。</p>
<h2 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h2><p>DOM2 级事件定义了两个方法，<code>addEventListener()</code> 和 <code>removeEventListener()</code>，分别用于注册和删除事件处理程序，所有 DOM 节点都包含这两个方法。</p>
<div class="note warning">
            <ul><li>使用 <code>addEventListener()</code> 可以在同一个元素上注册多个事件处理程序，触发的顺序为添加顺序。</li><li>关于 <code>this</code> 和 <code>event</code> 的使用规则，与 DOM0 级事件处理程序一致。</li></ul>
          </div>
<div class="note info">
            <p>首先介绍 <code>addEventListener()</code> 方法，它的参数如下：</p><ul><li><code>type</code>：表示监听事件类型的字符串，<strong>需要注意的是没有 <code>on</code> 前缀</strong>。</li><li><code>listener</code>：作为事件处理程序的函数。</li><li><code>options（可选）</code>：一个对象。其属性如下：<ul><li><code>capture</code>：一个布尔值，默认为 <code>false</code>。当值为 <code>true</code> 时，<code>listener</code> 会在事件捕获阶段时被调用。</li><li><code>once</code>：一个布尔值，默认为 <code>false</code>。当值为 <code>true</code> 时，<code>listener</code> 会在其被调用之后自动移除。</li><li><code>passive</code>：一个布尔值，默认为 <code>false</code>。当值为 <code>true</code> 时，<code>listener</code> 内部不允许调用 <code>event.preventDefault()</code>，否则会抛出错误。</li></ul></li><li><code>useCapture（可选）</code>：一个布尔值，默认为 <code>false</code>。当值为 <code>true</code> 时，<code>listener</code> 会在事件捕获阶段时被调用。</li></ul><p><strong>对于 <code>options</code> 和 <code>useCapture</code> 参数，它们都是该方法的第三个参数，<code>options</code> 是新标准，而 <code>useCapture</code> 是老标准。</strong></p><hr><p>接着介绍 <code>removeEventListener()</code> 方法，它的参数如下：</p><ul><li><code>type</code>：表示监听事件类型的字符串，<strong>需要注意的是没有 <code>on</code> 前缀</strong>。</li><li><code>listener</code>：作为事件处理程序的函数。</li><li><code>options（可选）</code>：一个对象。其属性如下：<ul><li><code>capture</code>：一个布尔值，默认为 <code>false</code>。当值为 <code>true</code> 时，表示要移除的 <code>listener</code> 是注册在事件捕获阶段的。</li></ul></li><li><code>useCapture（可选）</code>：一个布尔值，默认为 <code>false</code>。当值为 <code>true</code> 时，表示要移除的 <code>listener</code> 是注册在事件捕获阶段的。</li></ul><p><strong>如果一个事件处理程序一共注册了两次，一次在事件捕获阶段，一次在事件冒泡阶段，那么这两次注册需要分别移除，两者不会互相干扰。</strong></p>
          </div>
<p>下面的例子用于观察 <code>options.capture</code> 和 <code>useCapture</code> 的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      #outer, #inner &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        text-decoration: none;</span><br><span class="line">      &#125;</span><br><span class="line">      #outer&#123;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        color: red;</span><br><span class="line">      &#125;</span><br><span class="line">      #inner&#123;</span><br><span class="line">        border: 1px solid green;</span><br><span class="line">        color: green;</span><br><span class="line">        width: 250px;</span><br><span class="line">        height: 250px;</span><br><span class="line">        margin: 125px auto;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">      outer, capture &amp; none-capture</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">        inner</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> outer = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> inner = <span class="built_in">document</span>.getElementById(<span class="string">'inner'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">captureListener1</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'outer, capture1'</span>)</span></span><br><span class="line"><span class="javascript">        outer.removeEventListener(<span class="string">'click'</span>, captureListener1, <span class="literal">true</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">captureListener2</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'outer, capture2'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">noneCaptureListener</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'outer, none-capture'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">innerListener</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'inner'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      outer.addEventListener(<span class="string">'click'</span>, captureListener1, &#123; <span class="attr">capture</span>: <span class="literal">true</span> &#125;)</span></span><br><span class="line"><span class="javascript">      outer.addEventListener(<span class="string">'click'</span>, captureListener2, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">      outer.addEventListener(<span class="string">'click'</span>, noneCaptureListener)</span></span><br><span class="line"><span class="javascript">      inner.addEventListener(<span class="string">'click'</span>, innerListener)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上例中 <code>captureListener1</code> 和 <code>captureListener2</code> 都是注册在 <code>outer</code> 的捕获阶段，而 <code>noneCaptureListener</code> 和 <code>innerListener</code> 分别注册在 <code>outer</code> 和 <code>inner</code> 的冒泡阶段。并且 <code>captureListener1</code> 会在第一次调用后被移除。请多点击几次 inner 框，查看打印的结果。</p>
<h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><p>在触发 DOM 上的某个事件时，会产生一个事件对象 <code>event</code>，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。这里只介绍 DOM 中的事件对象，忽略 IE 的。</p>
<p>无论注册事件处理程序时使用的是 DOM0 级还是 DOM2 级方法，兼容 DOM 的浏览器都会将一个 <code>event</code> 对象传入到事件处理程序中，这样就可以直接在函数内部访问到 <code>event</code> 对象了。</p>
<p><code>event</code> 对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。下面简单的对事件对象的属性和方法进行了介绍，如果想查看详细信息，去移步 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">MDN</a>。</p>
<div class="note info">
            <p>属性：</p><ul><li><code>bubbles</code>（只读）：表明事件是否会冒泡。</li><li><code>cancelBubble</code>：通过将该属性设置为 <code>true</code> 可阻止事件继续冒泡。</li><li><code>cancelable</code>（只读）：表明是否可以取消事件的默认行为。</li><li><code>currentTarget</code>（只读）：事件处理程序注册在哪个元素上，<code>currentTarget</code> 就指向哪个元素。</li><li><code>defaultPrevented</code>（只读）：表明是否已经调用了 <code>preventDefault()</code> 方法。</li><li><code>eventPhase</code>（只读）：表明处于事件流的哪个阶段。<code>1</code> 表示捕获阶段，<code>2</code> 表示处于目标，<code>3</code> 表示冒泡阶段。</li><li><code>target</code>（只读）：触发事件的那个元素，也就是事件流在“处于目标”阶段时的那个目标元素。</li><li><code>timeStamp</code>（只读）：表明事件对象的创建时间。</li><li><code>type</code>（只读）：表明事件对象的类型。</li><li><code>isTrusted</code>（只读）：当事件是由用户触发的时（比如点击鼠标），该属性值为 <code>true</code>。当事件是由脚本触发时，该属性值为 <code>false</code>。</li></ul><hr><p>方法：</p><ul><li><code>preventDefault()</code>：取消事件的默认行为。该方法只有在 <code>cancelable</code> 属性为 <code>true</code> 时才会起作用。</li><li><code>stopImmediatePropagation()</code>：取消事件的进一步捕获或冒泡，同时阻止其后的所有事件处理程序被调用。</li><li><code>stopPropagation()</code>：取消事件的进一步捕获或冒泡，但是不会阻止注册在当前 <code>currentTarget</code> 上的事件处理程序被调用。</li></ul>
          </div>
<h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><div class="note info">
            <p>下面我只简单的介绍一下我认为比较常用的事件，如果你想比较全面的了解这里，点击下面的链接！</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">MDN，只有你想不到，没有找不到</a></p>
          </div>
<h1 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h1><p>在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>对“事件处理程序过多”问题的解决方案就是<strong>事件委托</strong>。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 <code>document</code> 。也就是说，我们可以为整个页面指定一个 <code>onclick</code> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>
<h2 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h2><p>每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。如前所述，可以采用事件委托技术，限制建立的连接数量。另外，在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的“空事件处理程序”，也是造成 Web 应用程序内存与性能问题的主要原因。</p>
<p>在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的 DOM 操作，例如使用 <code>removeChild()</code> 方法，但更多地是发生在使用 <code>innerHTML</code> 替换页面中某一部分的时候。如果带有事件处理程序的元素被 <code>innerHTML</code> 删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。<strong>所以如果你知道某个元素即将被移除，那么最好在此之前手工移除事件处理程序。</strong></p>
<p>另一种情况，就是卸载页面的时候。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。每次加载完页面在卸载页面时（可能是在两个页面间来回切换，也可能是单击了“刷新”按钮），内存中滞留的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。<strong>因此最好的做法就是在页面卸载之前，先通过 <code>onunload</code> 事件处理程序移除所有事件处理程序。</strong></p>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>前端路由的实现</title>
    <url>/posts/eb815672/</url>
    <content><![CDATA[<p>前端路由的实现有两种方式：hash 和 history。</p>
<h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><div class="note info">
            <ol><li>此时浏览器显示的 URL 为 <code>https://aadonkeyz.com/posts/eb815672/</code>。</li><li>执行 <code>location.hash = &#39;#hash&#39;</code> 后，生成一条新的浏览记录，其 URL 为 <code>https://aadonkeyz.com/posts/eb815672/#hash</code>，并将这条新的记录加入到浏览器历史记录的栈顶。与此同时浏览器的浏览状态会跳转到这个最新的记录上。</li><li><code>location.hash</code> 改变时，触发了 <code>window</code> 对象上注册的 <code>onhashchange</code> 事件处理程序。</li><li>页面内容进行对应的更新。</li><li>当使用前进或者后退时，会再次触发 <code>onhashchange</code> 事件处理程序，页面内容会再次进行相应的更新。</li><li>前端路由实现。</li></ol>
          </div>
<div class="note warning">
            <p><strong>在 URL 中，<code>#</code> 以及它之后的内容是用于在页面内定位的锚点，它们的改变不会引起浏览器发送网络请求</strong>。</p>
          </div>
<h1 id="history"><a href="#history" class="headerlink" title="history"></a>history</h1><div class="note info">
            <ol><li>此时浏览器显示的 URL 为 <code>https://aadonkeyz.com</code>。</li><li>更新页面内容，同时通过 <code>history.pushState()</code> 或者 <code>history.replaceState()</code> 新增/替换浏览器历史记录的栈顶记录，浏览器的浏览状态跳转到栈顶记录上，此时 URL 为 <code>https://aadonkeyz.com/posts/eb815672</code>。<strong>通过这两个方法，不会触发任何事件，也不会引起浏览器的加载行为。</strong></li><li>当浏览器前进或后退到某条由 <code>history.pushState()</code> 或者 <code>history.replaceState()</code> 生成的浏览记录时，会触发 <code>window</code> 对象上注册的 <code>onpopstate</code> 事件处理程序，并且在事件处理程序的内部，<code>event.state</code> 中保存着该浏览记录的状态对象的拷贝。因此可以根据这个 <code>event.state</code> 更新页面。</li><li>前端路由实现。</li></ol>
          </div>
<div class="note warning">
            <p><strong>采用这种方式时，为了防止浏览器真的去加载对应的 URL，从而返回 <code>404 Not Found</code> 的尴尬局面，需要服务器的支持，如果 URL 匹配不到任何静态资源，则应该返回根页面 HTML</strong>。</p>
          </div>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p><a href="https://juejin.cn/post/6844903890278694919#heading-10" target="_blank" rel="noopener">「前端进阶」彻底弄懂前端路由</a> 中对前端路由进行了简单的实现，感兴趣的可以阅读一下。如果想更细致的了解前端路由的实现方式，可以阅读 react-router 或者 vue-router 的源码。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://juejin.cn/post/6844903890278694919#heading-10" target="_blank" rel="noopener">「前端进阶」彻底弄懂前端路由</a> </li>
</ul>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>原生拖放</title>
    <url>/posts/2317527/</url>
    <content><![CDATA[<h1 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h1><div class="note info">
            <p>拖放事件分为两类：被拖拽元素上的事件和放置目标上的事件</p><ol><li>被拖拽元素上的事件：<ul><li><code>dragstart</code>：在被拖拽元素处按下鼠标并开始移动鼠标时触发。</li><li><code>drag</code>：紧随<code>dragstart</code>之后被触发，在元素被拖拽期间该事件会持续被触发（每 350 毫秒一次）。</li><li><code>dragend</code>：当拖拽停止（无论是把元素放到了有效的放置目标上，还是放到了无效的放置目标上）时触发。</li></ul></li><li>放置目标上的事件：<ul><li><code>dragenter</code>：当元素被拖拽到放置目标上空时触发。</li><li><code>dragover</code>：紧随 <code>dragenter</code> 之后被触发，而且只要被拖拽元素还在放置目标的范围内移动，就会持续触发该事件（每 350 毫秒一次）。</li><li><code>dragleave</code>：当被拖拽元素离开放置目标时触发。</li><li><code>drop</code>：当元素被放置到放置目标上时触发（前提是阻止了 <code>drogover</code> 事件的默认行为）。</li></ul></li></ol>
          </div>
<h1 id="可拖拽元素"><a href="#可拖拽元素" class="headerlink" title="可拖拽元素"></a>可拖拽元素</h1><p>通过元素的 <code>draggable</code> 属性可以设置元素是否可拖拽，<code>true</code> 表示可拖拽，<code>false</code> 表示不可拖拽。</p>
<p>默认情况下 <code>draggable = auto</code>，此时元素是否可拖拽取决于浏览器的默认行为。通常<strong>被选中的文本</strong>、<strong>图片</strong>和<strong>链接</strong>都是默认可拖拽的，并且它们拥有自己的默认 <code>ondragstart</code> 事件处理程序。</p>
<h1 id="可放置目标"><a href="#可放置目标" class="headerlink" title="可放置目标"></a>可放置目标</h1><p>虽然所有元素都支持放置目标事件（<code>drop</code> 事件），但这些元素默认是不允许放置的。如果想将元素设置为可放置，方法是重写 <code>dragover</code> 事件的默认行为。</p>
<p>假设有一个 ID 为 <code>drop-target</code> 的 <code>&lt;div&gt;</code> 元素，可以用下面的代码将它变成一个放置目标。这样就可以触发放置目标的 <code>drop</code> 事件了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">'drop-target'</span>)</span><br><span class="line"></span><br><span class="line">droptarget.ondragover = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  event.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>为了让 Firefox 支持正常的拖放，还需要取消 <code>drop</code> 事件的默认行为。</strong></p>
          </div>
<h1 id="dataTransfer"><a href="#dataTransfer" class="headerlink" title="dataTransfer"></a>dataTransfer</h1><p>只有简单的拖放而没有数据的变化是没有什么用的，而通过事件的 <code>dataTransfer</code> 对象可以进行数据的传递。<strong><code>dataTransfer</code> 对象是事件对象的属性，所以只能在拖拽事件处理程序中访问</strong>。下面介绍它的属性和方法</p>
<div class="note info">
            <p>属性：</p><ol><li><code>dropEffect</code>：该属性用于设置当被拖拽元素处于放置目标上方时鼠标的显示效果。需要注意的是，该属性必须配合 <code>effectAllowed</code> 属性才会生效。该属性有四个可选值：<code>none</code>、<code>move</code>、<code>copy</code> 和 <code>link</code>。</li><li><code>effectAllowed</code>：表示允许哪种 <code>dropEffect</code>。需要注意的是，该属性必须在 <code>ondragstart</code> 事件处理程序中设置才会生效。可选值有：<ul><li><code>uninitialized</code>：没有设置时的默认值，等同于设置为 <code>all</code>。</li><li><code>none</code>：相当于禁止了 <code>dropEffect</code> 的效果。</li><li><code>copy</code>：只允许值为 <code>copy</code> 的 <code>dropEffect</code>。</li><li><code>link</code>：只允许值为 <code>link</code> 的 <code>dropEffect</code>。</li><li><code>move</code>：只允许值为 <code>move</code> 的 <code>dropEffect</code>。</li><li><code>copyLink</code>：允许值为 <code>copy</code> 和 <code>link</code> 的 <code>dropEffect</code>。</li><li><code>copyMove</code>：允许值为 <code>copy</code> 和 <code>move</code> 的 <code>dropEffect</code>。</li><li><code>linkMove</code>：允许值为 <code>link</code> 和 <code>move</code> 的 <code>dropEffect</code>。</li><li><code>all</code>：允许任意的 <code>dropEffect</code>。</li></ul></li><li><code>files</code>：被用户拖拽到放置目标中的文件所组成的数组。</li><li><code>types</code>（只读）：被拖拽元素所携带数据的类型组成的数组。另外，在 <code>drag</code> 和 <code>dragend</code> 中该属性一直为空数组，我也不知道为什么。</li></ol><hr><p>方法：</p><ol><li><code>setData(format, data)</code>：该方法只有在 <code>ondragstart</code> 事件处理程序中调用才有效，它用于设置拖拽元素要携带的数据，为 <strong>format-data对</strong> 形式（类似于键值对，这个名字是我自己为了理解自己起的）。一次拖拽可以同时设置多个 <strong>format-data对</strong>。<ul><li><code>format</code>：数据的类型，允许指定各种 MIME 类型，通常使用的是 <code>text/plain</code> 和 <code>text/uri-list</code>。我自己尝试着将类型设置为 <code>id</code>、<code>custom-type</code> 之类的，也可以正常工作。</li><li><code>data</code>：设置的数据如果不是字符串，会自动被调用 <code>toString()</code> 方法。</li></ul></li><li><code>getData(format)</code>：在放置目标的 4 个事件上均可以使用该方法，它用于根据 <code>format</code> 获取对应的数据，获取的数据一定是字符串。</li><li><code>clearData(format)</code>：该方法只有在 <code>ondragstart</code> 事件处理程序中调用才有效，它用于根据 <code>format</code> 清除对应的数据。</li><li><code>setDragImage(img, xOffset, yOffset)</code>：默认情况下拖拽元素的时候会自动根据被拖拽的元素生成一个半透明的图片。而通过这个方法可以设置这个半透明的图片。<ul><li><code>img</code>：可以是一个 <code>&lt;img&gt;</code> 元素或者 <code>&lt;canvas&gt;</code> 元素。</li><li><code>xOffset</code>：鼠标指针相对于图片左边界的水平偏移量。</li><li><code>yOffset</code>：鼠标指针相对于图片上边界的垂直偏移量。</li></ul></li></ol>
          </div>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>这里偷个懒，不自己想例子了。引用 <a href="https://segmentfault.com/a/1190000012427787" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012427787</a> 中的例子。</p>
<p>说句题外话，这段代码里还涉及了事件流的相关知识点，如果感兴趣可以将 <code>ev.target.classList.add(&#39;over&#39;)</code> 中的 <code>ev.target</code> 换为 <code>this</code>，然后观察一下效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖动<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    h2 &#123;</span><br><span class="line">      font-size: 20px;</span><br><span class="line">      color: #0d88c1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    div#left,</span><br><span class="line">    div#right &#123;</span><br><span class="line">      width: 120px;</span><br><span class="line">      float: left;</span><br><span class="line">      margin: 10px 100px 10px 0px;</span><br><span class="line">      height: 240px;</span><br><span class="line">      background-color: #dddddd;</span><br><span class="line">      overflow-y: auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    div label &#123;</span><br><span class="line">      font-size: 22px;</span><br><span class="line">      font-weight: bold;</span><br><span class="line">      width: 100%;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      padding: 4px 0;</span><br><span class="line">      text-align: center;</span><br><span class="line">      margin: 0px 0 2px 0;</span><br><span class="line">      color: #fff;</span><br><span class="line">      background-color: #0d88c1;</span><br><span class="line">    &#125;</span><br><span class="line">    .over &#123;</span><br><span class="line">      border: 1px dashed red;</span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>拖放（Drag 和 drop）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 左边元素框 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>index1<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>index2<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>index3<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>index4<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>index5<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>index6<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>index7<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 右边元素框 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> moveItem = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'label'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; moveItem.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//动态设置label元素id</span></span></span><br><span class="line"><span class="javascript">      moveItem[i].setAttribute(<span class="string">'id'</span>, <span class="string">'label'</span> + i);</span></span><br><span class="line"><span class="javascript">      moveItem[i].ondragstart = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//dataTransfer.setData() 方法设置被拖数据的数据类型和值</span></span></span><br><span class="line"><span class="javascript">        ev.dataTransfer.setData(<span class="string">"id"</span>, <span class="keyword">this</span>.id);</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'right'</span>).ondragover = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      ev.preventDefault(); <span class="comment">//阻止向上冒泡</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'right'</span>).ondragenter = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      ev.target.classList.add(<span class="string">'over'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'right'</span>).ondragleave = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      ev.target.classList.remove(<span class="string">'over'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'right'</span>).ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line">      ev.preventDefault();</span><br><span class="line"><span class="javascript">      ev.target.classList.remove(<span class="string">'over'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> id = ev.dataTransfer.getData(<span class="string">'id'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(id); <span class="comment">//当前拖动的元素</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> toElem = ev.toElement.id; <span class="comment">//放置位置</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (toElem == <span class="string">'right'</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//如果为container,元素放置在末尾</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.appendChild(elem);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//如果为container里的元素，则插入该元素之前</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.insertBefore(elem, <span class="built_in">document</span>.getElementById(toElem));</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'left'</span>).ondragover = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      ev.preventDefault(); <span class="comment">//阻止向上冒泡</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'left'</span>).ondragenter = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      ev.target.classList.add(<span class="string">'over'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'left'</span>).ondragleave = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      ev.target.classList.remove(<span class="string">'over'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'left'</span>).ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line">      ev.preventDefault();</span><br><span class="line"><span class="javascript">      ev.target.classList.remove(<span class="string">'over'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> id = ev.dataTransfer.getData(<span class="string">'id'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> toElem = ev.toElement.id;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (toElem == <span class="string">'left'</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//如果为container,元素放置在末尾</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.appendChild(elem);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//如果为container里的元素，则插入该元素之前</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.insertBefore(elem, <span class="built_in">document</span>.getElementById(toElem));</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器是如何渲染一个页面的？</title>
    <url>/posts/b5fc6f17/</url>
    <content><![CDATA[<h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.jpg" alt="浏览器渲染流程"></p>
<div class="note info">
            <ul><li>JavaScript： 构建 DOM + CSSOM</li><li>Style： 构建 Render Tree</li></ul>
          </div>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p><strong>Document Object Model</strong> 通过在内存中表示文档结构，将网页连接到脚本或编程语言。 DOM 使用逻辑树来表示一个文档结构。树的每一个分之都以一个节点结尾，并且每个节点都包含对象。 DOM 方法允许以编程方式访问树，使用这些方法可以更改文档的结构、样式或内容。DOM 上的节点并不一定总是 HTML 元素，当浏览器创建 DOM 树时，它还将诸如注释、属性、文本之类的内容另存为树中的单独节点。</p>
<div class="note warning">
            <ul><li>构建 DOM 的过程中遇到不携带 <code>async</code> 或 <code>defer</code> 的 <code>&lt;script&gt;</code> 标签，浏览器会停止 DOM 的构建，等待 JS 的下载和执行。</li><li>构建 DOM 的过程中携带 <code>async</code> 的 <code>&lt;script&gt;</code> 标签下载完毕后，浏览器会停止 DOM 的构建，等待 JS 的执行。</li></ul>
          </div>
<h2 id="CSSOM"><a href="#CSSOM" class="headerlink" title="CSSOM"></a>CSSOM</h2><p><strong>CSS Object Model</strong> 允许通过 JavaScript 操纵 CSS，它非常类似于 DOM。CSSOM 和 DOM 是相互独立的。CSSOM 的构建过程类似于 DOM 的构建，不过它依赖的是样式结构，而不是文档结构。</p>
<div class="note warning">
            <p>CSSOM 的构建会阻塞浏览器下载&amp;执行 JS。</p>
          </div>
<h2 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h2><p>Render Tree 是将 DOM 和 CSSOM 结合在一起而生成的树状结构。通过 Render Tree 可以知道在每个节点上应用哪些样式规则，但是无法知道这些节点的确切位置及大小信息。在 Render Tree 被构建出来之前，页面上不会呈现任何内容。</p>
<div class="note warning">
            <ul><li><code>display: none</code> 的元素不会出现在 Render Tree 中。</li><li>伪元素会出现在 Render Tree 中。</li></ul>
          </div>
<h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p>Layout Tree 是在 Render Tree 的基础上，为每个节点计算其布局信息，从而构建出的树状结构。</p>
<div class="note warning">
            <p>避免在通过 CSSOM 设置完样式后立刻对其进行访问，因为这样要求浏览器在你访问样式时返回最新的样式信息，相当于要求浏览器立刻进入 layout 阶段，从而造成不必要的性能损耗（本来可以在下一帧再更新样式的）。</p>
          </div>
<h2 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h2><p>在这一阶段需要了解两个概念：layer 和 rasterization。Layer 让浏览器知道以何种顺序去渲染相互层叠的元素，同时帮助浏览器在网页的整个生命周期中更有效执行的 paint 操作。Rasterization 是对每一个 layer 进行栅格化，使得浏览器以更高效的方式进行 paint 操作。</p>
<h2 id="Compositing"><a href="#Compositing" class="headerlink" title="Compositing"></a>Compositing</h2><p>利用计算好的 layer 和每一层 layer 内的栅格，组合出 viewpoint 内应该展示的页面。</p>
<h1 id="first-paint"><a href="#first-paint" class="headerlink" title="first paint"></a>first paint</h1><p>为了更好的用户体验，浏览器不一定非要等到 DOM 和 CSSOM 构建完，才开始页面的渲染。可以参考 <a href="http://eux.baidu.com/blog/fe/Chrome%E7%9A%84First%20Paint" target="_blank" rel="noopener">Chrome的First Paint</a> 的思路自己在浏览器的 performance 面板中观察下实际的效果。</p>
<p>最佳实践是将 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 标签放在 <code>&lt;head&gt;</code> 中，将 <code>&lt;script&gt;</code> 标签放在 <code>&lt;/body&gt;</code> 前。当然如果你为 <code>&lt;script&gt;</code> 标签添加 <code>async</code> 或 <code>defer</code> 属性的话，将它们放在 <code>&lt;head&gt;</code> 中也是可以的。</p>
<p>详细的原理可以参考 <a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969" target="_blank" rel="noopener">How the browser renders a web page? — DOM, CSSOM, and Rendering</a>。</p>
<h1 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h1><div class="note info">
            <ul><li>使用 <code>requestAnimationFrame()</code> 代替 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li><li>避免 long task 的出现。</li><li>使用 Web Worker。</li><li>减少样式选择器的复杂度。</li><li>避免 <a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid_forced_synchronous_layouts" target="_blank" rel="noopener"><strong>强制同步布局</strong></a></li></ul>
          </div>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path" target="_blank" rel="noopener">Critical rendering path</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work" target="_blank" rel="noopener">Populating the page: how browsers work</a></li>
<li><a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969" target="_blank" rel="noopener">How the browser renders a web page? — DOM, CSSOM, and Rendering</a></li>
<li><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3" target="_blank" rel="noopener">Inside look at modern web browser (part 3)</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Rendering Performance</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path" target="_blank" rel="noopener">Critical Rendering Path</a></li>
<li><a href="https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/" target="_blank" rel="noopener">How CSS works: Parsing &amp; painting CSS in the critical rendering path</a></li>
<li><a href="https://glenelkins.medium.com/the-secrets-of-the-cssom-why-you-should-care-943a1d50307b" target="_blank" rel="noopener">The Secrets of the CSSOM &amp; Why You Should Care</a></li>
<li><a href="https://software.intel.com/content/www/us/en/develop/articles/software-vs-gpu-rasterization-in-chromium.html" target="_blank" rel="noopener">Software vs. GPU Rasterization in Chromium</a></li>
<li><a href="https://www.html5rocks.com/en/tutorials/speed/layers/" target="_blank" rel="noopener">Accelerated Rendering in Chrome</a></li>
<li><a href="http://eux.baidu.com/blog/fe/Chrome%E7%9A%84First%20Paint" target="_blank" rel="noopener">Chrome的First Paint</a></li>
</ul>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>跨域问题常见解决方案</title>
    <url>/posts/713a5759/</url>
    <content><![CDATA[<p>我个人将跨域问题分类为两种：<strong>网络请求跨域</strong>和<strong>非网络请求跨域</strong>。</p>
<h1 id="网络请求跨域"><a href="#网络请求跨域" class="headerlink" title="网络请求跨域"></a>网络请求跨域</h1><div class="note info">
            <p>网络请求跨域的解决方案有：</p><ul><li>图像img</li><li>JSONP</li><li>CORS</li><li>Nginx反向代理、Nodejs中间件</li><li>SSE、Web Socket（它们是服务器推送技术，无跨域问题）</li></ul><p><a href="https://aadonkeyz.com/posts/5ffed448/">详细信息在这里</a></p>
          </div>
<h1 id="非网络请求跨域"><a href="#非网络请求跨域" class="headerlink" title="非网络请求跨域"></a>非网络请求跨域</h1><h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><div class="note info">
            <p>如果要进行通信的窗口之间主域相同，子域不同，则可以直接将它们的 <code>document.domain</code> 修改为主域，这样就不存在跨域问题了。</p>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"a"</span> <span class="attr">src</span>=<span class="string">"http://a.domain.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"b"</span> <span class="attr">src</span>=<span class="string">"http://b.domain.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- domain 初始值为 a.domain.com --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> user = <span class="string">'a'</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- domain 初始值为 b.domain.com --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span></span><br><span class="line"><span class="javascript">  alert(<span class="string">'get js data from a ---&gt; '</span> + <span class="built_in">window</span>.parent.frames.a.user);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h2><div class="note info">
            <p>父窗口 A 修改子窗口 B 的 <code>location.hash</code> 值，会触发对应子窗口 B <code>window</code> 对象的 <code>onhashchange</code> 事件处理程序。这个过程是单向的，但是你可以通过在子窗口 B 中添加一个 <code>iframe</code> 标签，这个 <code>iframe</code> 的 <code>src</code> 域名与父窗口域名相同的，然后在这个 <code>iframe</code> 页面内调用父窗口 A 的函数，此时是不存在跨域的。</p>
          </div>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><div class="note info">
            <p><code>window</code> 对象的 <code>name</code> 属性有一个独特之处，一个窗口只要一直存在并且没有被主动的更改 <code>name</code> 属性，那么它的 <code>name</code> 属性会一直保持不变。即窗口的 URL（或 <code>iframe</code> 的 <code>src</code>）随意变化，<code>name</code> 属性也不会变。<code>name</code> 属性内存最大可以支持 2MB，所以可以通过它来传递数据。</p>
          </div>
<h2 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h2><p>通过 <code>window.postMessage</code> 方法和 message 事件完成数据的传递。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a></li>
</ul>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟渲染列表简单介绍</title>
    <url>/posts/2b565654/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/FE/%E8%99%9A%E6%8B%9F%E6%B8%B2%E6%9F%93%E5%88%97%E8%A1%A8.png" alt="虚拟渲染列表"></p>
<p>容器的高度是给定的，且通过设置 <code>overflow: auto</code> 让它的子元素可以滚动。</p>
<p>列表只设置一个 <code>height</code> 属性即可，它的高度由列表项高度和列表项个数决定，它存在的意义是使得滚动条可以正确显示。</p>
<p>列表项分为真实渲染和虚拟渲染两种，真实渲染的列表项需要被包裹起来，然后对包裹层设置 <code>transform: translateY(container&#39;s scrollTop)</code>。如果不这么做，以第二个图为例，会导致第三个真实渲染列表项出现在第一个虚拟渲染列表项的位置。</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><div class="note info">
            <ul><li>buffer：不单单真实渲染出现在容器可视范围内的列表项，对超出的前后 n 个也进行真实渲染。</li><li>动态高度：每一个列表项的高度可能不同。</li><li>具有头部元素：比如 h5 场景下，虚拟列表上方还有一块信息展示区。为了避免处理两层滚动的麻烦和用户体验问题，可以将上方的信息展示区放入虚拟渲染列表的“列表”上方，这样全局就只有一个滚动条了。</li></ul>
          </div>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/posts/45b9746d/</url>
    <content><![CDATA[<p>在某些场景下（scroll、resize 事件等），函数有可能被非常频繁地调用，这样会消耗不必要的性能。为了解决这个问题，引出了防抖（debounce）和节流（throttle）的概念。</p>
<h1 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h1><div class="note info">
            <p>在事件被触发时，设定 n 秒后执行对应的回调函数。如果在 n 秒之内事件被重复触发，则重新计时。如果连续触发事件，对应的回调函数可能永远不会被调用。</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, timeRange</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="keyword">this</span>, ...args)</span><br><span class="line">    &#125;, timeRange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h1><div class="note info">
            <p>一段时间周期内，最多只执行一次回调函数。</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, timeRange</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">        fn.call(<span class="keyword">this</span>, ...args)</span><br><span class="line">      &#125;, timeRange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h1><p>在实际工作中给你，往往都是直接引用 <a href="https://github.com/lodash/lodash" target="_blank" rel="noopener">lodash</a>，而 lodash 的 debounce 和 throttle 的规则是可以在进行适当配置的。</p>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title>Git Basics</title>
    <url>/posts/22d36175/</url>
    <content><![CDATA[<h1 id="What-is-Git"><a href="#What-is-Git" class="headerlink" title="What is Git"></a>What is Git</h1><p>The major difference between Git and other VCS (Version Control System) is the way Git thinks about its data. Conceptually, most other systems store information as a list of file-based changes. These other systems think of the information they store as a set of files and the changes made to each file over time. Git dosen’t think of or store its data this way, instead, Git thinks of its data more like a series of snapshots of a miniature filesystem. With Git, every time you commit, or save the state of your project, Git basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot. To be efficient, if files have not changed, Git dosen’t store the file again, just a link to the previous identical file it has already stored. Git thinks about its data more like a stream of snapshots. Because you have the entire history of the project tight there on your local disk, most operations seem almost instantaneous, and most operations in Git need only local files and resources to operate — generally no information is needed from another computer on your network. </p>
<div class="note info">
            <p>Git has three main states that your files can reside in:</p><ul><li><strong>modified</strong>: you have changed the file but have not commited it to your database yet.</li><li><strong>staged</strong>: you have marked a modified file in its current version to go into your next commit snapshot.</li><li><strong>committed</strong>: the data is safely stored in your local database.</li></ul><p>This leads us to the three main sections of a Git project:</p><ul><li><strong>the working directory</strong>: a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.</li><li><strong>the staging area</strong>: a file, generally contained in your Git directory, that stores information about what will go into your next commit. Its technical name in Git parlance is the “index”, but the phrase “staging area” works just so well.</li><li><strong>the Git directory</strong>: stores the metadata and project database for your project. This is the most important part of Git, and it is what is copied when you <code>clone</code> a repository from another computer.</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Tutorial%20of%20Git/main%20sections%20of%20Git.png" alt="main sections of Git"></p>
<p>Git comes with a tool called <code>git config</code> that lets you get and set configuration variables that control all aspects of how Git looks and operates. These variables can be stored in three different places:</p>
<div class="note info">
            <ul><li><code>/etc/gitconfig</code> file: Contains value applied to every user on the system and all their repositories. If you pass the option <code>--system</code> to <code>git config</code>, it reads and writes from this file specifically.</li><li><code>~/.gitconfig</code> or <code>~/.config/git/config</code> file: Values specific personally to you, the user. You can make Git read and write to this file specifically by passing the <code>--global</code> option, and this affects all of the repositories you work with on your system.</li><li><code>config</code> file in the Git directory of whatever repository you’re currently using: Specific to that single repository. You can force Git to read from and write to this file with the <code>--local</code> option, but that is in fact the default</li></ul>
          </div>
<h1 id="Getting-a-Git-Repository"><a href="#Getting-a-Git-Repository" class="headerlink" title="Getting a Git Repository"></a>Getting a Git Repository</h1><p>You can take a local directory that is currently not under version control, and turn it into a Git repository.</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Users/user/my_project</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>Or, you can <code>clone</code> an existing Git repository from elsewhere.</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;url&gt; [target-directory]</span><br></pre></td></tr></table></figure>
<h1 id="Recording-Changes-to-the-Repository"><a href="#Recording-Changes-to-the-Repository" class="headerlink" title="Recording Changes to the Repository"></a>Recording Changes to the Repository</h1><div class="note info">
            <p>Each file in your working directory can be in one of two states:</p><ul><li><strong>tracked</strong>: Tracked files are files that were in the last snapshot or in the Staging Area. In short, tracked files are files that Git knows about.</li><li><strong>untracked</strong>: Any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven’t edited anything.</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Tutorial%20of%20Git/lifecycle%20of%20the%20status%20of%20files.png" alt="lifecycle of status of files"></p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># determine which files are in which state</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># move a file from the working directory to the staging area</span></span><br><span class="line"><span class="comment"># "git add ." means move all files in current directory</span></span><br><span class="line">$ git add &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># discard changes in working directory</span></span><br><span class="line"><span class="comment"># you can only use this command on tracked files</span></span><br><span class="line">$ git checkout -- &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># move a file from the staging area to the working directory</span></span><br><span class="line">$ git reset HEAD &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># see what you've changed but not yet staged</span></span><br><span class="line">$ git diff</span><br><span class="line"><span class="comment"># see what you've staged that will go into your next commit</span></span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove a file from Git, and also removes the file from the working directory (which means delete the file)</span></span><br><span class="line">$ git rm &lt;filename&gt;</span><br><span class="line"><span class="comment"># keep the file in the working directory but remove it from the staging area</span></span><br><span class="line"><span class="comment"># this is particulary useful if you forgot to add something to your .gitignore file and accidentally staged it</span></span><br><span class="line">$ git rm --cached &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit your changes that are in the staging area</span></span><br><span class="line">$ git commit [-m &lt;msg&gt;]</span><br></pre></td></tr></table></figure>
<p>Often, you’ll have a class of files that you don’t want Git to automatically add or even show you as being untracked. In such cases, you can create a file listing patterns to match them named <code>.gitignore</code></p>
<div class="note info">
            <p>The rules for the patterns you can put in the <code>gitignore</code> file are as follows:</p><ul><li>Blank lines or lines starting with <code>#</code> are ignored.</li><li>Standard glob patterns work, and will be applied recursively throughout the entire working directory.</li><li>You can start patterns with a forward slash (<code>/</code>) to avoid recursivity.</li><li>You can end patterns with a forward slash (<code>/</code>) to specify a directory.</li><li>you can negate a pattern by starting it with an exclamation point (<code>!</code>).</li></ul>
          </div>
<p>Here is an example <code>.gitignore</code> file:</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ignore all .a files</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># but do track lib.a, even though you're ignoring .a files above</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all files in any directory named build</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory and any of its subdirectories</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>
<h1 id="Working-with-Remotes"><a href="#Working-with-Remotes" class="headerlink" title="Working with Remotes"></a>Working with Remotes</h1><p>Remote repositories are versions of your project that are hosted on the Internet or network somewhere.</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># show the list of the shortnames of each remote handle you've specified</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># show the URLs that Git has stored for the shortname</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># add a new remote Git repository</span></span><br><span class="line">$ git remote add &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># get data from remote repository</span></span><br><span class="line"><span class="comment"># this command only downloads the data to your local repository</span></span><br><span class="line"><span class="comment"># it doesn't automatically merge it with any of your work of modify what you're currently working on</span></span><br><span class="line"><span class="comment"># if you don't type remote, it will use origin as default</span></span><br><span class="line">$ git fetch [&lt;remotename&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># push any commits you've done back up to the server</span></span><br><span class="line">$ git push &lt;remotename&gt; &lt;branchname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># inspect a remote</span></span><br><span class="line">$ git remote show &lt;remotename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># change a remote's shortname</span></span><br><span class="line">$ git remote rename &lt;oldname&gt; &lt;newname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove a remote</span></span><br><span class="line">$ git remote remove &lt;remotename&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Tagging"><a href="#Tagging" class="headerlink" title="Tagging"></a>Tagging</h1><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list the existing tags</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># create an tag</span></span><br><span class="line">$ git tag &lt;tagname&gt; [&lt;commit&gt;] [-a] [-m &lt;msg&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># the `git push` command doesn't transfer tags to remote servers</span></span><br><span class="line"><span class="comment"># you will have to explicitly push tags to a shared server after you have created them</span></span><br><span class="line">$ git push &lt;remotename&gt; &lt;tagname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># transfer all of your tags to the remote server that are not already there</span></span><br><span class="line">$ git push &lt;remotename&gt; --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete local tag</span></span><br><span class="line">$ git tag -d &lt;tagname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete remote tag</span></span><br><span class="line">$ git push &lt;remotename&gt; :refs/tags/&lt;tagname&gt;</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ git push &lt;remotename&gt; --delete &lt;tagname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># switch your working directory</span></span><br><span class="line">$ git checkout [&lt;branchname&gt; | &lt;tagname&gt; | &lt;commitsha1&gt;]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git Branching</title>
    <url>/posts/3557a152/</url>
    <content><![CDATA[<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create a branch</span></span><br><span class="line"><span class="comment"># only create, don't switch</span></span><br><span class="line"><span class="comment"># if you don't type existbranch, use current branch</span></span><br><span class="line">$ git branch &lt;newbranch&gt; [&lt;existbranch&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># switch your working directory</span></span><br><span class="line">$ git checkout [&lt;branchname&gt; | &lt;tagname&gt; | &lt;commitsha1&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># rename a branch</span></span><br><span class="line"><span class="comment"># if the newbranch is already existed</span></span><br><span class="line"><span class="comment"># -m =&gt; rename fail</span></span><br><span class="line"><span class="comment"># -M =&gt; delete the existed one, and then rename</span></span><br><span class="line">$ git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a branch and switch to it</span></span><br><span class="line"><span class="comment"># if you don't type existbranch, use current branch</span></span><br><span class="line">$ git checkout -b &lt;newbranch&gt; [&lt;existbranch&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># move the branch pointer</span></span><br><span class="line">$ git branch -f [&lt;branchname&gt; | &lt;tagname&gt; | &lt;commitsha1&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge the target branch into your current branch</span></span><br><span class="line">$ git merge &lt;targetbranch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge the target branch into your current branch</span></span><br><span class="line"><span class="comment"># create a merge commit in all cases</span></span><br><span class="line"><span class="comment"># even when the merge could instead be resolved as a fast-forward</span></span><br><span class="line">$ git merge &lt;targetbranch&gt; --no-ff</span><br><span class="line"></span><br><span class="line"><span class="comment"># no options =&gt; local branches list</span></span><br><span class="line"><span class="comment"># -r =&gt; remote branches list</span></span><br><span class="line"><span class="comment"># -a =&gt; both remote and local branches list</span></span><br><span class="line">$ git branch [-r | -a]</span><br><span class="line"></span><br><span class="line"><span class="comment"># see the last commit on each branch</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter the list to branches that you have or haven't merged into your current branch</span></span><br><span class="line">$ git branch [--merged | --no-merged]</span><br><span class="line"></span><br><span class="line"><span class="comment"># fetch any data from the given remote that you don't yet have</span></span><br><span class="line"><span class="comment"># update your local database</span></span><br><span class="line"><span class="comment"># move your remote/branch pointer to its new, more up-to-data position.</span></span><br><span class="line"><span class="comment"># if you don't type remote, it will use origin as default</span></span><br><span class="line">$ git fetch [&lt;remotename&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># push the local branch to the remote branch</span></span><br><span class="line">$ git push &lt;remotename&gt; &lt;localbranch:remotebranch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># fetch the upstream branch and merge into the tracking branch</span></span><br><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the current branch to track remotebranch</span></span><br><span class="line"><span class="comment"># you can use this command to change the relationship between a tracking branch and a upstream branch</span></span><br><span class="line">$ git branch &lt;-u | --<span class="built_in">set</span>-upstream-to&gt; &lt;[[remotes/]origin/]remotebranch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># if current branch is not a tracking branch, and you want to push it</span></span><br><span class="line"><span class="comment"># if remotebranch isn't exist, Git will automatically create it</span></span><br><span class="line">$ git push --<span class="built_in">set</span>-upstream &lt;remotename&gt; &lt;remotebranch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># see what tracking branches you have set up</span></span><br><span class="line">$ git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete a local branch</span></span><br><span class="line">$ git branch -d &lt;branchname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete a remote branch</span></span><br><span class="line">$ git push &lt;remotename&gt; --delete &lt;branchname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># take the patch(s) and replay it/them on top of somewhere else</span></span><br><span class="line"><span class="comment"># if there is no argument, it will rebase on the upstream of current local branch</span></span><br><span class="line">$ git rebase [&lt;branchname&gt; | &lt;tagname&gt; | &lt;commitsha1&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># if there is any conflict while rebasing, use this command</span></span><br><span class="line">$ git rebase &lt;--<span class="built_in">continue</span> | --abort | --skip&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Branches-in-a-Nutshell"><a href="#Branches-in-a-Nutshell" class="headerlink" title="Branches in a Nutshell"></a>Branches in a Nutshell</h1><p>To really understand the way Git does branching, we need to take a back and examine how Git stores its data. Git doesn’t store data as a series of changesets or differents, but instead as a series of <strong>snapshots</strong>. When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged. This object also contains the author’s name and email address, the message that you typed, and the pointer to the commit or commits that directly came before this commit (its parent or parents): zero parents for the inital commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two of more branches.</p>
<div class="note info">
            <p><strong>A branch in Git is simply a lightweight movable pointer to one of these commits.</strong></p>
          </div>
<p>When you create a new branch, Git creates a new pointer for you to move around. And How does Git know what branch you’re currently on? Git keeps a special pointer called <code>HEAD</code>, it is the symbolic name for the currently checkout out commit — it’s essentially what commit you’re working on top of. Normally <code>HEAD</code> attaches to a branch, when you commit, the status of that branch is altered. When <code>HEAD</code> attaches to a commit instead of a branch, this phenomenon is called <strong>detach</strong>.</p>
<h1 id="Basic-Branching-and-Merging"><a href="#Basic-Branching-and-Merging" class="headerlink" title="Basic Branching and Merging"></a>Basic Branching and Merging</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Git%20Branching/before-merge.png" alt="before-merge"></p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ git checkout -b bugFix</span><br><span class="line">$ git commit</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git commit</span><br><span class="line">$ git merge bugFix</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Git%20Branching/after-merge.png" alt="after-merge"></p>
<h1 id="Remote-Branches"><a href="#Remote-Branches" class="headerlink" title="Remote Branches"></a>Remote Branches</h1><p>Look at an example, let’s say you have a Git server on your network at <code>git.ourcompany.com</code>. If you clone from this, Git’s <code>clone</code> command automatically names it <code>origin</code> for you, pulls down all its data, creates some pointers to correspond to remote branches, the name of remote branchs in local will has a prefix like <code>remotes/</code> or <code>remotes/origin/</code>. Git also gives you your own local <code>master</code> branch starting at the same places as origin’s <code>master</code> branch, so you have something to work from.</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Git%20Branching/Server%20and%20local%20repositories%20after%20cloning.png" alt="Server and local repositories after cloning"></p>
<p>If you do some work on your local <code>master</code> branch, and, in the meantime, someone else pushes to <code>git.ourcompany.com</code> and updates its <code>master</code> branch, then your histories move forward differently. Also, as long as you stay out of contact with your <code>origin</code> server, your <code>origin/master</code> pointer doesn’t move.</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Git%20Branching/Local%20and%20remote%20work%20can%20diverge.png" alt="Local and remote work can diverge"></p>
<p>To synchronize your work with a given remote, you run a <code>git fetch &lt;remote&gt;</code> command. This command fetches any data from the given remote that you don’t yet have, and updates your local database, moving your <code>origin/master</code> pointer to its new, more up-to-data position.</p>
<div class="note warning">
            <p><strong>It’s important to note that when you do a fetch that brings down new remote-tracking branches, you don’t automatically have local, editable copies of them. In other words, in this case, you don’t have a new branch — you have only an <code>origin/master</code> pointer that you can’t modify.</strong></p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Git%20Branching/git%20fetch%20updates%20your%20remote-tracking%20branches.png" alt="git fetch updates your remote-tracking branches"></p>
<p>When you want to share a branch with the world, you need to push it up to a remote to which you have write access. Your local branches aren’t automatically synchronized to the remotes you write to — you have to explicitly push the branches you want to share. That way, you can use private branches for work you don’t want to share, and push up only the topic branches you want to collaborate on.</p>
<p>If you have a branch named <code>serverfix</code> that you want to work on with others, you can push it up the same way you pushed your first branch. Run <code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 24, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>
<p>This is a bit of a shortcut. Git automatically expands the <code>serverfix</code> branchname out to <code>refs/heads/serverfix:refs/heads/serverfix</code>, which means, “Take my <code>serverfix</code> local branch and push it to update the remote’s <code>serverfix</code> branch.” You can also do <code>git push origin serverfix:serverfix</code>, which does the same thing — it says, “Take my serverfix and make it the remote’s serverfix.” You can use this format to push a local branch into a remote branch that is named differently. If you didn’t want it to be called <code>serverfix</code> on the remote, you could instead run <code>git push origin serverfix:awesomebranch</code> to push your local <code>serverfix</code> branch to the <code>awesomebranch</code> branch on the remote project.</p>
<p>Checking out a local branch from a remote-tracking branch automatically creates what is called a “tracking branch”, and the branch it tracks is called an “upstream branch”. Tracking branches are local branches that have a direct relationship to a remote branch. If you’re on a tracking branch and type <code>git pull</code>, Git automatically know which server to fetch from and which branch to merge in. If you want to change the upstream branch you’re tracking, you can use the <code>-u</code> or <code>--set-upstream-to</code> option to <code>git branch</code> to explicitly set it at any time.</p>
<h1 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h1><div class="note warning">
            <p><strong>It turns out that in addition to the commit SHA-1 checksum, Git also calculates a checksum that is based just on the patch introduced with the commit, this is called a “patch-id”.</strong></p>
          </div>
<p>In addition to <code>merge</code>, if you want to integrate changes from <code>experiment</code> into <code>master</code>, there is another way.</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Git%20Branching/Simple%20divergent%20history.png" alt="Simple divergent history"></p>
<p>You can take the patch of the change that was introduce in <code>C4</code> and reapply it on top of <code>C3</code>. In Git, this is called <strong>rebasing</strong>. With the <code>rebase</code> command, you can take all the changes that were committed on one branch and replay them on a different branch.</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Git%20Branching/Rebasing%20the%20change%20introduced%20in%20C4%20onto%20C3.png" alt="Rebasing the change introduced in C4 onto C3"></p>
<p>At this point, you can go back to the <code>master</code> branch and do a fast-forward merge.</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Git%20Branching/Fast-forwarding%20the%20master%20branch.png" alt="Fast-forwarding the master branch"></p>
<div class="note info">
            <p><strong>Rebasing replays changes from one line of work onto another in the order they were introduced, whereas merging takes the endpoints and merges them together. There is no difference in the end product of the integration, but rebasing makes for a cleaner history. In addition, when you rebase stuff, you’re abanding existing commits and creating new ones that are similar but different.</strong></p>
          </div>
<div class="note warning">
            <p><strong>If there is any conflict while you are rebasing, you should fix the conflict, and then use <code>git add</code> to stage the files, use <code>git rebase --continue</code> to finish the rebasing process. In this process, do not use <code>git commit</code>, it will create a commit and detach the HEAD!</strong></p>
          </div>]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git的安装及配置</title>
    <url>/posts/6749cdaf/</url>
    <content><![CDATA[<h1 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h1><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">首先附上Git的下载链接</a></p>
<p>在Git下载完成之后，除了对安装位置进行更改之外，其他的按照默认选项来就可以。当安装完成之后，打开命令行，输入<code>git</code>,如果看到有关Git的相关信息就说明安装成功了！</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGit%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/git%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="Git安装成功"></p>
<h1 id="Git的配置"><a href="#Git的配置" class="headerlink" title="Git的配置"></a>Git的配置</h1><p>安装成功后要配置Git的用户名与邮箱，相当于自报家门，在进行这一配置时可以通过参数指定配置的作用域。<br>作用域：<code>--system &gt; --global &gt; --local</code>。<br>优先级：<code>--local &gt; --global &gt; --system</code>。</p>
<p>以github和gitlab为例，由于我在两个网站的注册用户名与邮箱均为为aadonkeyz和aadonkeyz@gmail.com，所以我选择进行一次全局配置即可。</p>
<p>全局配置指令：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">git config --global user.name "aadonkeyz"</span><br><span class="line">git config --global user.email "aadonkeyz@gmail.com"</span><br></pre></td></tr></table></figure>
<h1 id="SSH-配置"><a href="#SSH-配置" class="headerlink" title="SSH 配置"></a>SSH 配置</h1><p>因为我们需要在同一台电脑中同时使用github和gitlab，为了保证两个网站在使用SSH时不产生冲突，需要为两个网站生成两对不同的秘钥，并在SSH的config文件中指定Git在访问不同的网站时要使用相对应的秘钥。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C aadonkeyz@github</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>-t = The type of the key to generate<br>-C = comment to identify the key</p>
          </div>
<p>注释内容一般填写注册邮箱，不过我在两个网站的注册邮箱相同，所以我的注释分为了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">aadonkeyz@github</span><br><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">aadonkeyz@gitlab</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGit%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/%E4%B8%BAgithub%E7%94%9F%E6%88%90%E7%A7%98%E9%92%A5%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C.png" alt="为github生成秘钥的命令行"></p>
<p>上面是我为github生成秘钥的过程，在过程中我没有修改秘钥的默认保存位置，但是为了对秘钥进行区分修改了秘钥的名称，并设定了密码（passphrase），一旦为秘钥设置了密码，那么以后每次使用SSH时都会要求输入秘钥。请读者自行将生成的秘钥添加到github中去，并在gitlab上进行相同的操作。</p>
<p>接下来开始自定义config文件，首先在保存秘钥的文件夹下创建一个名为config的文件，注意不要任何后缀（可以先创建名为config的文本文档，之后删除“.txt”后缀），然后填写如下内容：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line"><span class="code">    User git</span></span><br><span class="line"><span class="code">    IdentityFile ~/.ssh/github_rsa</span></span><br><span class="line"></span><br><span class="line">Host gitlab.com</span><br><span class="line"><span class="code">    User git</span></span><br><span class="line"><span class="code">    IdentityFile ~/.ssh/gitlab_rsa</span></span><br></pre></td></tr></table></figure>
<p>保存并退出，最后我们来通过指令，<code>ssh -T github.com</code>和<code>ssh -T gitlab.com</code>测试一下是否成功。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/Windows%E4%B8%8BGit%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/ssh%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95.png" alt="ssh连接测试"></p>
<p>大功告成！</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>HTML标签</title>
    <url>/posts/500cdacf/</url>
    <content><![CDATA[<h1 id="HTML标签大全"><a href="#HTML标签大全" class="headerlink" title="HTML标签大全"></a>HTML标签大全</h1><p>太多了，整理一会之后果断放弃，<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element" target="_blank" rel="noopener">MDN上的介绍</a></p>
<h1 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a>HTML模板</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"简介"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"关键字"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"作者"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>题目<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">href</span>=<span class="string">"/apple-touch-icon.png"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"/favicon.ico"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">            /* CSS内部样式表 */</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里放内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h1><div class="note info">
            <p><code>&lt;a&gt;</code>标签代表一个超链接，它有如下属性：</p><ul><li><code>download</code>：这个属性用于指示浏览器去下载<code>href</code>所指向的资源而不是进行页面跳转。如果给<code>download</code>属性设置一个值，这个值将是对应资源被保存成本地文件过程中的默认名称。</li><li><code>href</code>：URL。</li><li><code>hreflang</code>：用于指定链接资源的人类语言</li><li><code>ping</code>：包含一个以空格分隔的 URL 列表，当跟随超链接时，将由浏览器发送带有正文的 PING 的 POST 请求，通常用于跟踪。</li><li><code>rel</code>：该属性执行了目标对象到链接对象的关系。该值是空格分隔的列表类型值。</li><li><code>target</code>：该属性指定在何处显示链接的资源。它的值包括：<code>_self</code>、<code>_blank</code>、<code>_parent</code>和<code>_top</code>。</li><li><code>type</code>：该属性指定在一个 MIME type 链接目标的形式的媒体查询。其仅提供建议，并没有内置的功能。</li></ul><hr><p><code>&lt;a&gt;</code>标签还有四个伪类：</p><ul><li><code>link</code>：具有<code>href</code>属性。</li><li><code>visited</code>：被访问过。</li><li><code>hover</code>：鼠标悬浮。</li><li><code>active</code>：鼠标点击瞬间。</li></ul>
          </div>
<p>下面展示一个使用<code>download</code>属性的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">download</span>=<span class="string">"国旗"</span> <span class="attr">href</span>=<span class="string">"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALYAAAB5CAMAAACjkCtXAAAAe1BMVEX/AAD////XsbH0RETe2dnToqLi7e3wVVX80Rb80xb81Rb82Bf/MQX/JQT8xhX/FwL8yxX+VQn/Ogb83Rf8whT9nBD+TAj9jw/9lQ/9rhL9uBP8uxT+bgv9ohDGv7/SuLj9hA3+XQj9eAn+fw39qBL+Qwf+ZQv2OzvmbW2v1N+9AAACiklEQVR4nO3ZCW+bMByHYdjpg8PcEMhKUpL2+3/CORs9osUGofFzUP6vlKpqFfTINTZOPd//9WVTPf3wfd/z/e/epvpJbGDERkZsZMRGRmxkxEb2YOxkFc3slrLzVTSzW8QOgpIlQbCWaUaL2D0XnMsqXAs13bJJEkZSOZ3dy9ixGMRhJdGslrH73uuKlUSzmmbHN36Wji9nTbKT9pb7UxO/XqdJdp+drBeIq/9umtEku8mO1guEuYv1e4qtl7q95e1VUbCi6OETZYp9YDy3bCtpoTeeAX93TrGfBVel7QIqixzsllPsvWDCNrnPUZLbJ/8qGdjp+HePW82ux+/TG8N6TL3gbtipEoypdqgqxvTk7usmV4zJAe8zZBjtQ5RxLoSU7OKWUug7L2ucboxXGed2zwT7nIgcH2iuMt+S5S7jH+isdnkq+CfbSnKM3txiZ10E8VkXwHJ0i8HhQeZmdvY4vXlkvkDsZHmxsmu9kPDLgGfm2/H+HqUCxZlQjdBfTUNaNQ1vmuquHqWOeofkZz3mnCvDQ3dYSS4cHOEt7HgnRH7hdkzTTBdQKnIwSyzskxTt30Hu9GZjeH/Xlrvn9XimLOwiG97m7CnPzrff340vcGZ2HNUfd9qptZ1x8FlG+/pGc3JAN/Zgn297idNHq8XsYYMfXSaHkvXJ2d0D1jL2KWec8Xol04yWTpJGSpezZCE7zAflYHN8byG7q7xgv7l/gvzZikKHO9CjbTduIzYyYiMjNjJiIyM2MmIjIzYyYiMjNjJiIyM2MmIjIzYyYiMjNjJiIyM2MmIjIzYyYiMjNjJiIyM2MmIjIzYyYiMjNjJiIyM2MmIje2e/fN1SryP728Ya2Vtso+zffNMqoOoYARcAAAAASUVORK5CYII="</span>&gt;</span>下载图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h1><div class="note info">
            <p><code>&lt;input&gt;</code>标签用于接受来自用户的数据。它有如下属性：</p><ul><li><code>autocomplete</code>：一个字符串，描述输入应提供的任何类型的自动完成功能。自动完成的典型实现只是回忆在同一输入字段中输入的先前值，但可以存在更复杂的自动完成形式。例如，浏览器可以与设备的联系人列表集成，以在电子邮件输入字段中自动完成电子邮件地址。不过当<code>type</code>属性值为<code>button</code>、<code>file</code>等时，<code>&lt;input&gt;</code>不会返回文本或数值数据，此时<code>autocomplete</code>属性将被忽略。</li><li><code>autofocus</code></li><li><code>disabled</code></li><li><code>form</code>：该属性值为一个<code>&lt;form&gt;</code>的<code>id</code>，用于指示该<code>&lt;input&gt;</code>是属于它的。如果缺失，则该<code>&lt;input&gt;</code>属于最近的<code>&lt;form&gt;</code>或者不属于任何<code>&lt;form&gt;</code>。</li><li><code>list</code>：该属性值为一个<code>&lt;datalist&gt;</code>的<code>id</code>，<code>&lt;datalist&gt;</code>用于为该<code>&lt;input&gt;</code>提供建议列表。</li><li><code>name</code>：该<code>&lt;input&gt;</code>的名称，与表单数据一起提交。</li><li><code>readonly</code></li><li><code>required</code></li><li><code>tabindex</code>：该<code>&lt;input&gt;</code>在当前文档的 Tab 导航顺序中的位置。</li><li><code>type</code>：该<code>&lt;input&gt;</code>的类型。包括：<code>button</code>、<code>checkbox</code>、<code>color</code>、<code>date</code>、<code>datetime-local</code>、<code>email</code>、<code>file</code>、<code>hidden</code>、<code>image</code>、<code>month</code>、<code>number</code>、<code>password</code>、<code>radio</code>、<code>range</code>、<code>reset</code>、<code>search</code>、<code>submit</code>、<code>tel</code>、<code>text</code>、<code>time</code>、<code>url</code>、<code>week</code>。</li><li><code>value</code>：该<code>&lt;input&gt;</code>的当前值。</li></ul>
          </div>
<h1 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h1><p><code>&lt;meta&gt;</code>标签中包含那些不能被<code>&lt;base&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>和<code>&lt;title&gt;</code>标签所表示的内容。并且<code>&lt;meta&gt;</code>标签一次只干一件事，如果想利用<code>&lt;meta&gt;</code>标签设置多个内容，那就多写几个<code>&lt;meta&gt;</code>标签。它有如下属性：</p>
<div class="note info">
            <ul><li><code>charset</code>：该属性表明了页面的编码方式，通常为<code>UTF-8</code>。</li><li><code>content</code>：该属性值对应于<code>http-equiv</code>属性或<code>name</code>属性的值。</li><li><code>http-equiv</code>：该属性定义 HTTP 的一些首部字段，对应的首部字段值在<code>content</code>属性中。<ul><li><code>content-security-policy</code>：定义页面的内容安全策略，内容策略主要指定允许的服务器源和脚本端点，这有助于防止 XSS 攻击。</li><li><code>refresh</code>：<ul><li>如果<code>content</code>属性值是一个正整数，则该正数代表页面重载的时间间隔（秒）。</li><li>如果<code>content</code>属性值是一个正整数，并且后面跟着<code>;url=</code>和一个合法的 URL，则页面将在指定秒数后进行跳转。</li></ul></li></ul></li><li><code>name</code>：该属性定义能定义如下内容，同样的，这些内容的值在<code>content</code>属性中。<ul><li><code>author</code>：定义作者。</li><li><code>description</code>：定义页面的描述信息。在你收藏一个页面时，描述信息就是来自于这里的。</li><li><code>generator</code>：生成页面的软件的标识符。</li><li><code>keywords</code>：用<code>,</code>分隔的关键词。</li><li><code>referrer</code>：控制所有从页面发出的 HTTP 请求的<code>Referer</code>首部字段。下面所述的<strong>页面的源包含协议、域名和端口</strong>。<ul><li><code>no-referrer</code>：不发送<code>Referer</code>首部字段。</li><li><code>origin</code>：发送页面的源。</li><li><code>no-referrer-when-downgrade</code></li><li><code>origin-when-cross-origin</code>：对于与页面同源的请求发送页面完整的 URL，与页面不同源的请求只发送页面的源。</li><li><code>same-origin</code>：对于与页面同源的请求发送页面的源，与页面不同源的请求不发送<code>Referer</code>首部字段。</li><li><code>strict-origin</code></li><li><code>strict-origin-when-cross-origin</code></li><li><code>unsafe-URL</code>：发送页面完整的 URL。</li></ul></li><li><code>theme-color</code>：建议客户端应该用来使用的主题颜色。</li><li><code>color-scheme</code>：指定一个或多个主题颜色。<ul><li><code>normal</code></li><li><code>[light | dark]+</code></li><li><code>only light</code></li></ul></li><li><code>creator</code>：定义网页作者，即一个组织或者机构的名称。</li><li><code>googlebot</code></li><li><code>publisher</code>：定义网页发布者。</li><li><code>robots</code></li><li><code>slurp</code></li><li><code>viewport</code>：专门用于为移动端设备定义视口的大小。<ul><li><code>width</code></li><li><code>height</code></li><li><code>initial-scale</code></li><li><code>maximum-scale</code></li><li><code>minimum-scale</code></li><li><code>user-scalable</code></li></ul></li></ul></li></ul>
          </div>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>Git Stash</title>
    <url>/posts/1955d066/</url>
    <content><![CDATA[<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># save your local modifications to a new stash entry</span></span><br><span class="line"><span class="comment"># and roll them back to HEAD</span></span><br><span class="line">$ git stash push [-m &lt;message&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># list the stash entries that you currently have</span></span><br><span class="line"><span class="comment"># stash@&#123;0&#125; is the latest entry, stash@&#123;1&#125; is the one before</span></span><br><span class="line">$ git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># show the changes recorded in the stash entry as a diff </span></span><br><span class="line"><span class="comment"># between the stashed contents and </span></span><br><span class="line"><span class="comment"># the commit back when the stash entry was first created</span></span><br><span class="line">$ git stash show [&lt;stash&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove a single stashed state from the stash list</span></span><br><span class="line"><span class="comment"># and apply it on top of the current working tree state</span></span><br><span class="line">$ git stash pop [&lt;stash&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># like pop, but do not remove the state from the stash list</span></span><br><span class="line">$ git stash apply [&lt;stash&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all the stash entries</span></span><br><span class="line">$ git stash clear</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove a single stash entry from the list of entries</span></span><br><span class="line">$ git stash drop [&lt;stash&gt;]</span><br></pre></td></tr></table></figure>
<p>When you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command <code>git stash</code> saves your local modifications away and reverts the working directory to match the <code>HEAD</code> commit.</p>
<p>The modifications stashed away by this command can be listed with <code>git stash list</code>, inspected with <code>git stash show</code>, and restored with <code>git stash apply</code>. Calling <code>git stash</code> without any arguments is equivalent to <code>git stash push</code>. A stash is by default listed as “WIP on <strong>branchname</strong>…”, but you can give a more descriptive message on the command line when you create one.</p>
<p>The latest stash you created is stored in <code>refs/stash</code>; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. <code>stash@{0}</code> is the most recently created stash, <code>stash@{1}</code> is the one before it, <code>stash@{2.hours.ago}</code> is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer <code>n</code> is equivalent to <code>stash@{n}</code>).</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>min-*、max-*、*的优先级</title>
    <url>/posts/df94ca98/</url>
    <content><![CDATA[<p>本文参考链接<a href="http://www.fly63.com/article/detial/561" target="_blank" rel="noopener">理解css中min-width和max-width，width与它们之间的区别联系</a></p>
<div class="note warning">
            <p><code>width</code>与<code>height</code>的情况是一致的，下面以<code>width</code>为例进行说明。</p>
          </div>
<h1 id="min-width比width大时"><a href="#min-width比width大时" class="headerlink" title="min-width比width大时"></a>min-width比width大时</h1><div class="note info">
            <p><code>min-width</code>的优先级高于<code>width</code>，即使有<code>!important</code>也是如此。</p>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div &#123;</span><br><span class="line">        height: 200px;</span><br><span class="line">        min-width: 400px;</span><br><span class="line">        width: 200px !important;</span><br><span class="line">        background: black;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="min-width比max-width大时"><a href="#min-width比max-width大时" class="headerlink" title="min-width比max-width大时"></a>min-width比max-width大时</h1><div class="note info">
            <p><code>min-width</code>的优先级高于<code>max-width</code>，即使有<code>!important</code>也是如此。</p>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div &#123;</span><br><span class="line">        height: 200px;</span><br><span class="line">        min-width: 400px;</span><br><span class="line">        max-width: 200px !important;</span><br><span class="line">        background: black;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="max-width比width小时"><a href="#max-width比width小时" class="headerlink" title="max-width比width小时"></a>max-width比width小时</h1><div class="note info">
            <p><code>max-width</code>的优先级高于<code>width</code>，即使有<code>!important</code>也是如此。</p>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div &#123;</span><br><span class="line">        height: 200px;</span><br><span class="line">        max-width: 200px;</span><br><span class="line">        width: 400px !important;</span><br><span class="line">        background: black;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>元素居中的几种方法</title>
    <url>/posts/fc526f38/</url>
    <content><![CDATA[<div class="note warning">
            <p><strong>本文只讨论元素宽高未知的情况。元素宽高未知指的是在居中的过程中，不依赖于元素的宽高。</strong></p>
          </div>
<h1 id="通过position和margin"><a href="#通过position和margin" class="headerlink" title="通过position和margin"></a>通过position和margin</h1><div class="note info">
            <ul><li>通过<code>margin</code>就可以做到令元素水平居中。</li><li>再通过<code>position</code>令元素<strong>脱离文档流（不脱离无法做到垂直居中）</strong>，并设置<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>均为0，就可以使得元素在垂直方向上也居中。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    #outer &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">    &#125;</span><br><span class="line">    #inner &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        margin: auto;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="通过position和transform"><a href="#通过position和transform" class="headerlink" title="通过position和transform"></a>通过position和transform</h1><div class="note info">
            <ul><li>通过<code>position</code>将元素的左上角放到包含元素的中心。</li><li>再通过<code>transform</code>将元素的中心移动到包含元素的中心。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    #outer &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">    &#125;</span><br><span class="line">    #inner &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        position: relative;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%, -50%);</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="通过flex"><a href="#通过flex" class="headerlink" title="通过flex"></a>通过flex</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    #outer &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">    &#125;</span><br><span class="line">    #inner &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>可编程的CSS</title>
    <url>/posts/6abf3348/</url>
    <content><![CDATA[<h1 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h1><div class="note info">
            <ul><li>CSS的自定义属性（也叫做变量）是通过前缀<code>--</code>定义的</li><li>区分大小写</li><li>同一个变量可以在多个选择器内声明。读取的时候，优先级最高的声明生效，这与CSS的“层叠”规则是一致的</li><li><code>var(&lt;custom-property-name&gt;, &lt;declaration-value&gt;?)</code>用于读取变量。<code>&lt;custom-property-name&gt;</code>为变量名称，<code>&lt;declaration-value&gt;</code>为默认值</li><li>声明变量的时候可以使用<code>var()</code></li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS自定义属性<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">            :root &#123;</span><br><span class="line">                --first-color: red;</span><br><span class="line">                --temporary-color: white;</span><br><span class="line">                --second-color: var(--temporary-color);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            #firstParagraph &#123;</span><br><span class="line">                background-color: var(--first-color);</span><br><span class="line">                color: var(--second-color)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            #secondParagraph &#123;</span><br><span class="line">                background-color: var(--second-color);</span><br><span class="line">                color: var(--first-color)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            #container &#123;</span><br><span class="line">                --first-color: green;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            #thirdParagraph &#123;</span><br><span class="line">                background-color: var(--first-color);</span><br><span class="line">                color: var(--second-color)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"firstParagraph"</span>&gt;</span>This paragraph should have a red background and white text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"secondParagraph"</span>&gt;</span>This paragraph should have a white background and red text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"thirdParagraph"</span>&gt;</span>This paragraph should have a green background and white text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/%E5%8F%AF%E7%BC%96%E7%A8%8B%E7%9A%84CSS/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7.png" alt="自定义属性"></p>
<h1 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h1><p>在CSS中使用<code>calc()</code>可是实现加、减、乘、除。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 20<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">--custom-height</span>: <span class="selector-tag">calc</span>(60% + 20<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">height</span>: <span class="selector-tag">calc</span>(<span class="selector-tag">var</span>(<span class="selector-tag">--custom-height</span>) * 1<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure>
<h1 id="通过JavaScript访问自定义属性"><a href="#通过JavaScript访问自定义属性" class="headerlink" title="通过JavaScript访问自定义属性"></a>通过JavaScript访问自定义属性</h1><div class="note info">
            <ul><li>可以通过<code>getComputedStyle().getPropertyValue()</code>来访问在CSS中定义的变量</li><li>变量是可继承的</li><li>不允许修改变量值，否则会抛出错误</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS自定义属性<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-pseudo">:root</span> &#123;</span></span><br><span class="line">                --first-color: red;</span><br><span class="line">                --second-color: white;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#myDiv</span> &#123;</span></span><br><span class="line">                --first-color: green;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"width: 10px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(div, <span class="literal">null</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(computedStyle[<span class="string">'--first-color'</span>])                     <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(computedStyle.getPropertyValue(<span class="string">'--first-color'</span>))    <span class="comment">// green</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(computedStyle.getPropertyValue(<span class="string">'--second-color'</span>))   <span class="comment">// white</span></span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>媒体查询</title>
    <url>/posts/d62e352c/</url>
    <content><![CDATA[<h1 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h1><div class="note info">
            <ul><li><code>all</code>：所有媒体</li><li><code>braile</code>：盲文触觉设备</li><li><code>embossed</code>：盲文打印机</li><li><code>handheld</code>：手持设备</li><li><code>print</code>：打印预览或打印机</li><li><code>projection</code>：项目演示</li><li><code>screen</code>：彩屏设备</li><li><code>speech</code>：听觉类似的媒体</li><li><code>tty</code>：不适用像素的设备，如电传打字机</li><li><code>tv</code>：电视</li></ul>
          </div>
<h1 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h1><div class="note info">
            <p>以下特性，除<code>scan</code>和<code>grid</code>外，都可以加上<code>min</code>或<code>max</code>前缀以指定范围</p><ul><li><code>width</code>：视口宽度</li><li><code>height</code>：视口高度</li><li><code>device-width</code>：渲染表面的宽度（可以认为是设备屏幕的宽度）</li><li><code>device-height</code>：渲染表面的高度（可以认为是设备屏幕的高度）</li><li><code>orientation</code>：设备方向是水平还是垂直</li><li><code>aspect-ratio</code>：视口的宽高比。如<code>16:9</code>的宽屏显示器可以写成<code>aspect-ratio: 16/9</code></li><li><code>color</code>：颜色组分的位深。如<code>min-color: 16</code>表示设备至少支持16位深</li><li><code>color-index</code>：设备颜色查找表中的条目数，值必须是数值，且不能为负</li><li><code>monochrome</code>：单色帧缓冲中表示每个像素的位数，值必须是数值（整数），且不能为负</li><li><code>resolution</code>：屏幕或打印分辨率。如<code>min-resolution: 300dpi</code>，也可以接受每厘米多少点，如<code>min-resolution: 118dpcm</code></li><li><code>scan</code>：针对电视的逐行扫描（<code>progressive</code>）和隔行扫描（<code>interlace</code>）</li><li><code>grid</code>：设备基于栅格还是位图</li></ul>
          </div>
<h1 id="媒体查询方式"><a href="#媒体查询方式" class="headerlink" title="媒体查询方式"></a>媒体查询方式</h1><h2 id="link标签的media属性"><a href="#link标签的media属性" class="headerlink" title="link标签的media属性"></a>link标签的media属性</h2><p>在<code>&lt;link&gt;</code>标签的<code>media</code>属性中指定媒体查询是CSS2的方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen"</span> <span class="attr">href</span>=<span class="string">"screenstyles.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h2><p><code>@media</code>是在样式表中使用的媒体查询方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h2><p><code>@import</code>可以根据媒体查询将其他样式表加载到当前样式表中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">"phone.css"</span>) screen</span><br></pre></td></tr></table></figure>
<h1 id="媒体查询语法"><a href="#媒体查询语法" class="headerlink" title="媒体查询语法"></a>媒体查询语法</h1><div class="note info">
            <ul><li><code>and</code>：类似于逻辑与</li><li><code>,</code>：类似于逻辑或</li><li><code>not</code>：用于对整个媒体查询取反</li><li><code>only</code>：指定某种特定的媒体类型，用来对那些不支持媒体特性但支持媒体类型的设备隐藏样式表</li></ul>
          </div>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 当设备是彩屏设备并且视口最小宽度大于等于400px时生效 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当设备垂直或者视口最小宽度大于等于400px时生效 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">orientation:</span> portrait), (<span class="attribute">min-width:</span> <span class="number">400px</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当视口最小宽度小于400px时生效 */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>) &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> (all <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>)) &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 而不是 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="keyword">not</span> all) <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>圣杯布局和双飞翼布局的原理</title>
    <url>/posts/ee7ae9c6/</url>
    <content><![CDATA[<h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><div class="note info">
            <ol><li>三个部分必须都设置向左浮动。</li><li>先写 middle，让页面先渲染中间的重要区域。</li><li>content 设置左右内边距是为了给 left 和 right 留出空间。</li><li>middle 设置<code>width: 100%</code>，而 left 和 right 的<code>width</code>属性值分别为 content 的左右内边距。</li><li>为 left 和 right 分别设置<code>margin-left</code>，由于 middle 也是浮动元素，所以这样会使 left 和 right 向上层浮动。</li><li>通过<code>position: relative</code>，分别将 left 和 right 向左右两侧拉扯。</li></ol>
          </div>
<div class="note warning">
            <p><strong>由于 left 设置了<code>margin-left: -100%</code>，当 content 内容区的宽度小于 left 的宽度时，此时 left 左移的距离小于 left 自身的宽度，导致 left 并不会向上移动到与 middle 同层。简言之，布局乱了。</strong></p>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    padding: 0 200px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 80px;</span><br><span class="line">    float: left;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.left</span> &#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 80px;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">    position: relative;</span><br><span class="line">    left: -200px;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.right</span> &#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 80px;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    position: relative;</span><br><span class="line">    right: -200px;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h1><div class="note info">
            <p><strong>圣杯布局的升级版，修改 DOM 结构，然后使用<code>margin</code>代替<code>padding</code>。</strong></p>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 80px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.inner-middle</span> &#123;</span></span><br><span class="line">    margin: 0 200px;</span><br><span class="line">    height: 80px;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.left</span> &#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 80px;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.right</span> &#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 80px;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>布局</title>
    <url>/posts/ee1ff2c0/</url>
    <content><![CDATA[<h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><h2 id="float的初衷"><a href="#float的初衷" class="headerlink" title="float的初衷"></a>float的初衷</h2><p>首先介绍引入<code>float</code>属性的初衷：为了实现文字环绕图片的效果，就像下面的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/13340/butterfly.jpg"</span> <span class="attr">alt</span>=<span class="string">"A pretty butterfly with red, white, and brown coloring, sitting on a large leaf"</span> <span class="attr">style</span>=<span class="string">"float: left"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/float%E7%9A%84%E5%88%9D%E8%A1%B7.png" alt="float的初衷"></p>
<h2 id="利用float布局"><a href="#利用float布局" class="headerlink" title="利用float布局"></a>利用float布局</h2><div class="note info">
            <p>在此之后，人们开始利用<code>float</code>属性进行布局，不过需要了解如下内容：</p><ul><li>一定要为浮动元素设置宽度。</li><li>当前一个元素非浮动，后一个元素浮动时，浮动元素在原水平位置向左或向右浮动。</li><li>当前一个元素浮动，后一个元素也浮动时，后一个元素会在宽度允许的条件下与前一个元素挤在同一行。<strong>如果两个元素都是向左浮动，且前一个元素宽度过大导致两个元素无法放置在同一行，这个时候如果给后一个浮动元素设置适当的负的左边距，那么它会浮动上去与前一个元素发生重叠（默认后一个元素在上方）。</strong></li><li>当前一个元素浮动，后一个元素非浮动时，如果后一个元素不是BFC，则会发生重叠。如果后一个元素是BFC，则不会发生重叠。</li></ul>
          </div>
<h2 id="围住浮动元素"><a href="#围住浮动元素" class="headerlink" title="围住浮动元素"></a>围住浮动元素</h2><p>浮动元素脱离了文档流，其父元素也看不到它了，因而也不会包围它。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/13340/butterfly.jpg"</span> <span class="attr">alt</span>=<span class="string">"A pretty butterfly with red, white, and brown coloring, sitting on a large leaf"</span> <span class="attr">style</span>=<span class="string">"float: left"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>It is fun to float.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black;"</span>&gt;</span>Here is the footer element runs across the bottom of the page.<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E7%88%B6%E5%85%83%E7%B4%A0%E5%9B%B4%E4%B8%8D%E4%BD%8Ffloat%E5%AD%90%E5%85%83%E7%B4%A0.png" alt="父元素围不住float子元素"></p>
<p>这个效果明显不是我们实际想要的，为了解决这个问题，介绍下面几种让父元素围住子元素的方法。</p>
<p>下面几种方案的效果都是一致的，如下所示：</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E7%88%B6%E5%85%83%E7%B4%A0%E5%9B%B4%E4%BD%8Ffloat%E5%AD%90%E5%85%83%E7%B4%A0.png" alt="父元素围住float子元素"></p>
<h3 id="利用overflow"><a href="#利用overflow" class="headerlink" title="利用overflow"></a>利用overflow</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black; overflow: hidden;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/13340/butterfly.jpg"</span> <span class="attr">alt</span>=<span class="string">"A pretty butterfly with red, white, and brown coloring, sitting on a large leaf"</span> <span class="attr">style</span>=<span class="string">"float: left"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>It is fun to float.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black;"</span>&gt;</span>Here is the footer element runs across the bottom of the page.<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="同时浮动父元素"><a href="#同时浮动父元素" class="headerlink" title="同时浮动父元素"></a>同时浮动父元素</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black; float: left;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/13340/butterfly.jpg"</span> <span class="attr">alt</span>=<span class="string">"A pretty butterfly with red, white, and brown coloring, sitting on a large leaf"</span> <span class="attr">style</span>=<span class="string">"float: left"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>It is fun to float.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black;"</span>&gt;</span>Here is the footer element runs across the bottom of the page.<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="利用clear"><a href="#利用clear" class="headerlink" title="利用clear"></a>利用clear</h3><div class="note info">
            <ul><li><code>clear</code>属性的值分别为：<code>left</code>、<code>right</code>和<code>both</code>；</li><li><code>clear</code>属性指定一个元素是否必须移动（清除浮动后）到它之前的浮动元素下方。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/13340/butterfly.jpg"</span> <span class="attr">alt</span>=<span class="string">"A pretty butterfly with red, white, and brown coloring, sitting on a large leaf"</span> <span class="attr">style</span>=<span class="string">"float: left"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>It is fun to float.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">style</span>=<span class="string">"width: 500px; border: 1px solid black;"</span>&gt;</span>Here is the footer element runs across the bottom of the page.<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">    content: '.';</span><br><span class="line">    display: block;</span><br><span class="line">    height: 0;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><div class="note info">
            <ul><li><code>position</code>属性有四个可选值：<code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>和<code>sticky</code>，默认值为<code>static</code></li><li>只有当<code>position</code>属性为<code>relative</code>、<code>absolute</code>、<code>fixed</code>或<code>sticky</code>时，<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>才会其作用。</li><li><code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>是根据盒模型进行设置的。</li><li>如果使用百分比值设置<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>，则是相对于最近的块级祖先元素的宽高来计算的。</li></ul>
          </div>
<h2 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>First Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Second Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"specialpara"</span>&gt;</span>Third Paragraph (with ID)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Fourth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">p &#123;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-id">#specialpara</span> &#123;</span></span><br><span class="line">    position: static</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E9%9D%99%E6%80%81%E5%AE%9A%E4%BD%8D.png" alt="静态定位"></p>
<h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><div class="note info">
            <ul><li>相对定位是元素相对于它原来在文档流中的位置定位；</li><li>可以使用<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>来调整元素的位置；</li><li>相对定位的元素仍然处于文档流中，它原来的位置会被保留。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>First Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Second Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"specialpara"</span>&gt;</span>Third Paragraph (with ID)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Fourth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">p &#123;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-id">#specialpara</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    top: 25px;</span><br><span class="line">    left: 30px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D.png" alt="相对定位"></p>
<h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><div class="note info">
            <ul><li>绝对定位会将元素从文档流中拿出来，它是相对于定位上下文进行定位的；</li><li>可以使用<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>来调整元素的位置；</li><li>绝对定位默认的定位上下文是<code>&lt;body&gt;</code>元素；</li><li>如果绝对定位的祖先元素中有<code>position</code>属性值不为<code>static</code>的元素，那么绝对定位就以其为定位上下文。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>First Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Second Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"specialpara"</span>&gt;</span>Third Paragraph (with ID)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Fourth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">p &#123;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-id">#specialpara</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 25px;</span><br><span class="line">    left: 30px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D.png" alt="绝对定位"></p>
<h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><div class="note info">
            <ul><li>固定定位会将元素从文档流中拿出来，它是根据视口（浏览器窗口或手持设备的屏幕）进行定位的，所以在页面滚动时，它的位置也不会改变；</li><li>可以使用<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>来调整元素的位置。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>First Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Second Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"specialpara"</span>&gt;</span>Third Paragraph (with ID)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Fourth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Fifth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Sixth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Seven Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Eighth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Ninth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Tenth Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">p &#123;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-id">#specialpara</span> &#123;</span></span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 25px;</span><br><span class="line">    left: 30px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D1.png" alt="固定定位1"></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D2.png" alt="固定定位2"></p>
<h2 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h2><div class="note info">
            <ul><li>粘性定位没有脱离正常的文档流。它可以看作是相对定位和固定定位的结合。</li><li>必须使用<code>top</code>、<code>right</code>、<code>bottom</code>或<code>left</code>来设定一个<strong>阀值</strong>。</li><li>当距离没有达到阀值时显示效果与相对定位相同。当距离在阀值范围之内时，显示效果与固定定位相同。</li><li>粘性元素被最近的块级祖先元素限制着，即当块级祖先元素消失在BFC范围时，粘性元素也会随之消失。</li></ul>
          </div>
<p>这里我理解的还不够透彻，就不写demo了，想看效果可以去<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener">MDN</a></p>
<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><p>Flexbox是一种布局方式，我们称之为弹性布局。设置了<code>display: flex</code>的元素被称为容器（flex container），而它的子元素则称之为项目（flex item）。对于容器和项目，它们各自有着不同的CSS属性。</p>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>Flexbox中有两根轴：主轴和交叉轴。这两个轴代表什么取决容器上的<code>flex-direction</code>属性，它共有四个可供选择的值：<code>row</code>（默认）、<code>row-reverse</code>、<code>column</code>和<code>column-reverse</code>。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/flex-direction.png" alt="flex-direction"></p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>属性用于定义项目在主轴上的对齐方式。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/justify-content.png" alt="justify-content"></p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>属性用于定义项目在交叉轴上的对齐方式。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/align-items1.png" alt="align-items1"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/align-items2.png" alt="align-items2"></p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><code>align-content</code>属性用于定义多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/align-content1.png" alt="align-content1"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/align-content2.png" alt="align-content2"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/align-content3.png" alt="align-content3"></p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code>属性用于定义当主轴上项目过多时，是否允许折行。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/flex-wrap.png" alt="flex-wrap"></p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>的简写形式。</p>
<h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p><code>order</code>属性用于定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/order.png" alt="order"></p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code>属性用于定义项目的放大比例，默认为0，即就算存在剩余空间，也不放大。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/flex-grow.png" alt="flex-grow"></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><code>flex-shrink</code>属性用于定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/flex-shrink.png" alt="flex-shrink"></p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code>属性用于定义项目在未放大或缩小前，占据的主轴空间大小，默认为<code>auto</code>，即项目本来的大小。</p>
<div class="note warning">
            <p><strong><code>flex-basis</code>设置的是元素的<code>border-box</code>，而不是<code>content-box</code>。</strong></p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/flex-basis.png" alt="flex-basis"></p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code>属性是<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code>的简写形式。</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对其方式。可覆盖容器的<code>align-items</code>属性。</p>
<h1 id="column布局"><a href="#column布局" class="headerlink" title="column布局"></a>column布局</h1><p>CSS多列布局扩展块布局模式，以便更容易地定义多列文本</p>
<div class="note warning">
            <p>根据定义来看多列布局是为了定义文本的布局方式的，但实际上多列布局也可以应用于其他类型的元素上。看下面的例子，多列布局竟然能将元素以这种方式截断！</p>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80%E5%BA%94%E7%94%A8%E4%BA%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%85%83%E7%B4%A0.png" alt="多列布局应用于其他类型元素"></p>
<div class="note info">
            <p>术业有专攻，还是将多列布局用于文本布局吧</p><ul><li><code>column-count</code>：设置列数</li><li><code>column-width</code>：设置期望最小列宽</li><li><code>column-gap</code>：设置列之间的缝隙大小</li></ul><hr><p>CSS3多列规范需要列高平衡：即浏览器自动设置最大列高，因此每列中的内容高度大致相同。除此之外，也允许通过<code>height</code>或<code>max-height</code>属性来限制列高，在生成新的一列之前每一列都会仅允许增加到这个高度</p>
          </div>
<h1 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h1><div class="note info">
            <ul><li><code>none</code>：完全移除元素；</li><li><code>inline</code>：将元素变为行内元素，它的<code>height</code>和<code>weight</code>将不会起作用；</li><li><code>block</code>：将元素变为块级元素；</li><li><code>inline-block</code>：将元素变成具有<code>height</code>和<code>weight</code>的行内元素；</li><li><code>list-item</code>：元素表现得像是<code>&lt;li&gt;</code>一样；</li><li><code>table</code>：元素表现得像是<code>&lt;table&gt;</code>一样；</li><li><code>flex</code>：将元素变为flex container，其子元素变为flex item；</li><li><code>inline-flex</code>：将元素变为行内flex container；</li><li><code>grid</code>：将元素变为grid container。</li></ul>
          </div>
<h1 id="元素层叠"><a href="#元素层叠" class="headerlink" title="元素层叠"></a>元素层叠</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E5%85%83%E7%B4%A0%E5%B1%82%E5%8F%A0%E7%AD%89%E7%BA%A7.jpg" alt="元素层叠等级"></p>
<div class="note info">
            <ul><li>元素层叠是相对的；</li><li><code>z-index</code>属性只有当对应元素的<code>postion</code>属性不为<code>static</code>时才有效。</li></ul>
          </div>
<p>下面的例子有助于理解元素层叠是相对的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#outer</span> &#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: black;</span><br><span class="line">    position: relative;</span><br><span class="line">    z-index: -100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#a</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: red;</span><br><span class="line">    position: relative;</span><br><span class="line">    z-index: -1000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#b</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E5%85%83%E7%B4%A0%E5%B1%82%E5%8F%A0%E4%BE%8B%E5%AD%90.png" alt="元素层叠例子"></p>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>格式化上下文</title>
    <url>/posts/451e216f/</url>
    <content><![CDATA[<p>格式化上下文（Formatting context）是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用</p>
<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="BFC形成条件"><a href="#BFC形成条件" class="headerlink" title="BFC形成条件"></a>BFC形成条件</h2><div class="note info">
            <p>块级格式化上下文（Block formatting context，简称BFC）是一个独立的渲染区域，它规定了内部block-level box如何布局，并且内部block-level box的布局丝毫不受BFC外部区域的影响。下面是形成BFC的条件，<strong>满足任意一条即可</strong></p><ul><li>根元素，即<code>&lt;html&gt;</code>。</li><li><code>float</code>的值不为<code>none</code>。</li><li><code>overflow</code>的不值为<code>visible</code>。</li><li><code>display</code>的值为<code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>、<code>inline-flex</code>之一。</li><li><code>position</code>的值为<code>absolute</code>或<code>fixed</code>。</li></ul>
          </div>
<h2 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h2><div class="note info">
            <ul><li>内部block-level box会在垂直方向，一个接一个地放置。</li><li>属于同一个BFC的两个相邻block-level box会发生垂直外边距重叠，而属于不同BFC的相邻block-level box则不会发生垂直外边距重叠。</li><li>每个盒模型的<code>margin-box</code>的左边，与包含块的<code>border-box</code>的左边相接触（对于从左往右的格式化，否则相反）。</li><li>BFC的区域不会与浮动元素重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，外面的元素也影响不到容器里面的子元素。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><hr><p>关于垂直外边距重叠，如果两个外边距都是正数，那么取最大值。如果两个外边距都是负数，那么取两者中绝对值大的那个。如果两个外边距一正一负，那么取两者的和。</p>
          </div>
<h2 id="BFC作用"><a href="#BFC作用" class="headerlink" title="BFC作用"></a>BFC作用</h2><div class="note info">
            <ol><li>通过触发block-level box形成BFC，阻止它与在它之前的浮动元素发生重叠，此时如果宽度允许，它们会并排显示在同一行。</li><li>如果一个父元素内部拥有浮动子元素，通过将父元素设置成BFC，可以让父元素包含浮动子元素。</li><li>两个相邻的block-level box之间会发生垂直外边距重叠，通过将其中一个用BFC包裹，则可以避免垂直外边距重叠的发生（<strong>有歧义，请看后面的解释</strong>）。</li></ol>
          </div>
<p>关于第3点作用，是有歧义的，请看下方图片。通过图片可以看出，就算不用BFC包裹，而用普通的block-level box包裹，也会有同样的效果</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/%E5%9E%82%E7%9B%B4%E5%A4%96%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0.png" alt="垂直外边距重叠"></p>
<h1 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h1><h2 id="IFC形成条件"><a href="#IFC形成条件" class="headerlink" title="IFC形成条件"></a>IFC形成条件</h2><p>行级格式化上下文（Inline formatting context，简称IFC）用来规定了内部inline-level box如何布局。与BFC的形成条件不同，只要一个block-level box内仅包含inline-level box时，这个外部的block-level box就会变成一个IFC</p>
<h2 id="IFC布局规则"><a href="#IFC布局规则" class="headerlink" title="IFC布局规则"></a>IFC布局规则</h2><div class="note info">
            <ul><li>子元素水平方向横向排列，并且垂直方向起点为元素顶部。</li><li>子元素只会计算横向样式空间，垂直方向样式空间不会被计算。</li><li>在垂直方向上，子元素的对齐规则由<code>vertical-align</code>决定。</li><li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。行框的高度是由内部的元素决定的。</li><li>行框一般左右边紧贴IFC，但浮动元素会优点排列。</li><li>行框的高度由行高计算规则来决定，同一个IFC下不同行框的高度可能会不同。</li><li>当一个行框内包含的多个子元素的总宽度不够时，它们的水平渲染规则由<code>text-align</code>决定。</li><li>当一个子元素的宽度超过行框时，该子元素会被分割成多分，分布在多个行框内。如果该子元素设置了不允许折行，那么超出的部分会溢出行框。</li></ul>
          </div>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>字体和文本</title>
    <url>/posts/9e9287fd/</url>
    <content><![CDATA[<p><strong>字体</strong>是“文字的不同体式”或者“字的形体结构”。对于英文而言，每种字体都是由一组具有独特样式的字母、数字和符号组成的。</p>
<p><strong>文本</strong>就是一组字或字符，比如章标题、段落正文等等，跟使用什么字体无关。</p>
<h1 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h1><div class="note info">
            <p>网页中的字体有三个来源：</p><ul><li>用户机器中安装的字体；</li><li>保存在第三方网站上的字体；</li><li>保存在你的Web服务器上的字体。</li></ul>
          </div>
<h2 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h2><p><code>font-family</code>用于设定元素中的文本使用什么字体，它是可以继承的属性，因此它的值会遗传给所有后代元素。一般来说，应该给整个页面设定一种主字体，然后只对那些需要使用不同字体的元素再应用<code>font-family</code>。要为整个页面指定字体，可以设定<code>&lt;body&gt;</code>元素的<code>font-family</code>属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: verdana, sans-serif; &#125;</span><br></pre></td></tr></table></figure>
<p>用户机器上的字体是随操作系统一起安装的，可以由本地应用共享。每种操作系统自带的字体不多，而且用户随时会安装或删除字体，因此我们永远也不敢保证一定能使用某种字体来显示网页。为此，在指定文本的字体时，需要多列出几种后背字体，以防第一种字体无效。这个字体的列表也叫字体栈。</p>
<h2 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h2><div class="note info">
            <ol><li><code>font-size</code>属性是可继承的</li><li>设定字体大小时可以使用：<ul><li>绝对单位：<code>px</code></li><li>相对单位：百分比、<code>em</code>、<code>rem</code></li><li>关键字：<code>x-small</code>、<code>medium</code>、<code>x-large</code>等</li></ul></li><li>如果你给某个元素设定了相对字体大小，则该元素的字体大小要相对于最近的“被设定过字体大小”的祖先元素来确定。<code>rem</code>单位比较特殊，它只是相对于<code>&lt;html&gt;</code>根元素</li></ol>
          </div>
<h2 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h2><div class="note info">
            <p><code>font-style</code>设定字体是斜体还是正体，它的值有：<code>italic</code>（斜体）、<code>oblique</code>（正体）和<code>normal</code></p>
          </div>
<h2 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h2><div class="note info">
            <p><code>font-weight</code>设定字体粗细，它的值可以是：<code>100</code>、<code>200</code>…<code>900</code>，或者<code>lighter</code>、<code>normal</code>、<code>bold</code>或<code>bolder</code></p>
          </div>
<h2 id="font-variant"><a href="#font-variant" class="headerlink" title="font-variant"></a>font-variant</h2><div class="note info">
            <p><code>font-variant</code>的值只能是：<code>small-caps</code>和<code>normal</code>。<code>small-caps</code>会让小写英文字母变为小型大写字母</p>
          </div>
<h2 id="font"><a href="#font" class="headerlink" title="font"></a>font</h2><div class="note info">
            <ul><li><code>font</code>是字体的简写属性</li><li>使用<code>font</code>时必须声明<code>font-size</code>和<code>font-family</code>的值</li><li>使用<code>font</code>时必须按照如下顺序：<ol><li><code>font-weight</code>、<code>font-style</code>、<code>font-variant</code>不分先后</li><li>然后是<code>font-size</code></li><li>最后是<code>font-family</code></li></ol></li><li>实际上，在设定<code>font-size</code>属性的同时，可以顺便设定<code>line-height</code>的值，如<code>12px/1.5</code></li></ul>
          </div>
<h1 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h1><h2 id="text-indent"><a href="#text-indent" class="headerlink" title="text-indent"></a>text-indent</h2><div class="note info">
            <ul><li><code>text-indent</code>属性设定行内盒子相对于包含元素的起点。默认情况下，这个起点就是包含元素的左上角</li><li><code>text-indent</code>的值可正、可负</li><li><code>text-indent</code>属性是可以被继承的，它继承的是经过计算之后的绝对值</li></ul>
          </div>
<h2 id="letter-spacing"><a href="#letter-spacing" class="headerlink" title="letter-spacing"></a>letter-spacing</h2><div class="note info">
            <p><code>letter-spacing</code>属性用于调整字符间距，为负值时缩小间距。无论设定字体大小时使用的是什么单位，设定字符间距一定要用相对单位，以便字符间距跟随字体大小同比例变化</p>
          </div>
<h2 id="word-spacing"><a href="#word-spacing" class="headerlink" title="word-spacing"></a>word-spacing</h2><div class="note info">
            <p><code>word-spacing</code>属性用于调整单词间距</p>
          </div>
<h2 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h2><div class="note info">
            <p><code>text-decoration</code>属性的值：<code>underline</code>、<code>overline</code>、<code>line-through</code>、<code>blink</code>、<code>none</code></p>
          </div>
<h2 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h2><div class="note info">
            <ul><li><code>text-align</code>属性的值：<code>left</code>、<code>right</code>、<code>center</code>、<code>justify</code></li><li><code>center</code>值也可以用来在较大的元素中居中较小的固定宽度的元素或图片</li></ul>
          </div>
<h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h2><div class="note info">
            <ul><li><code>line-height</code>属性用于指定文本的行高</li><li>如果<code>line-height</code>的值是不包含单位的数值，那么行高就是<code>数值 * 字体大小</code></li></ul>
          </div>
<h2 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h2><div class="note info">
            <p><code>text-transform</code>属性的值：<code>none</code>、<code>uppercase</code>、<code>lowercase</code>、<code>capitalize</code></p>
          </div>
<h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><div class="note info">
            <p><code>vertical-align</code>属性的值：<code>sub</code>、<code>super</code>、<code>top</code>、<code>middle</code>、<code>bottom</code>或任意长度值</p>
          </div>
<h2 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h2><div class="note info">
            <p><code>word-break</code>属性的值：<code>normal</code>、<code>break-all</code>、<code>keep-all</code>、<code>break-word</code></p>
          </div>
<h2 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h2><div class="note info">
            <ul><li><code>text-overflow</code>属性的值：<code>clip</code>、<code>ellipsis</code>、<code>&lt;string&gt;</code></li><li><code>text-overflow</code>属性只对那些在块级元素溢出的内容有效</li></ul>
          </div>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overflow behavior at line end</span></span><br><span class="line"><span class="comment">   Right end if ltr, left end if rtl */</span></span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">clip</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: "…";</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">fade</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">fade</span>(10<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">fade</span>(5%);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Overflow behavior at left end | at right end</span></span><br><span class="line"><span class="comment">   Directionality has no influence */</span></span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">clip</span> <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: "…" "…";</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">fade</span> <span class="selector-tag">clip</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">fade</span>(10<span class="selector-tag">px</span>) <span class="selector-tag">fade</span>(10<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">fade</span>(5%) <span class="selector-tag">fade</span>(5%);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>
<h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><div class="note info">
            <ul><li><code>white-space</code>属性的值：<code>normal</code>、<code>nowrap</code>、<code>pre</code>、<code>pre-wrap</code>、<code>pre-line</code></li><li><code>white-space</code>属性只对那些在块级元素溢出的内容有效</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/%E5%AD%97%E4%BD%93%E5%92%8C%E6%96%87%E6%9C%AC/white-space.png" alt="white-space"></p>
<h2 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h2><div class="note info">
            <ol><li><code>text-shadow: &lt;offset-x&gt; &lt;offset-y&gt; &lt;blue-radius&gt; &lt;color&gt;</code>：<ul><li><code>&lt;offset-x&gt;</code>（必选）：阴影水平偏移量</li><li><code>&lt;offset-y&gt;</code>（必选））：阴影垂直偏移量</li><li><code>&lt;blue-radius&gt;</code>（可选）：该值越大，阴影面积越大，阴影就越大越淡。不能为负值。默认为<code>0</code>，此时阴影边缘锐利</li><li><code>&lt;color&gt;</code>（可选）：颜色。默认颜色由浏览器决定</li></ul></li><li>如果想设置多个阴影，则不同阴影规则之间需要使用逗号分隔</li></ol>
          </div>
<h1 id="文字版式"><a href="#文字版式" class="headerlink" title="文字版式"></a>文字版式</h1><p>具体的文字版式设计可以看《CSS权威指南》的4.4节</p>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>过渡、变形和动画</title>
    <url>/posts/540576d8/</url>
    <content><![CDATA[<h1 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h1><h2 id="过渡相关属性"><a href="#过渡相关属性" class="headerlink" title="过渡相关属性"></a>过渡相关属性</h2><div class="note info">
            <ul><li><code>transition-property</code>：要过渡的CSS属性的名字（如<code>background-color</code>、<code>text-shadow</code>或者<code>all</code>，<code>all</code>会过渡所有可以过渡的属性）</li><li><code>transition-duration</code>：定义过渡效果持续的时间（用秒进行定义，例如<code>.3s</code>、<code>2s</code>或<code>1.5s</code>）</li><li><code>transition-timing-function</code>：定义过渡期间的速度变化（例如<code>ease</code>、<code>linear</code>、<code>ease-in</code>、<code>ease-out</code>、<code>ease-in-out</code>或者<code>cubic-bezier</code>，默认为<code>ease</code>）</li><li><code>transition-delay</code>：可选，用于定义过渡开始前的延迟时间。相反，将值设置为一个负数，可以让过渡效果立即开始，但过渡旅程会在半路结束（同样是用秒进行定义，例如<code>.3s</code>、<code>2s</code>或<code>1.5s</code>）</li></ul>
          </div>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.style</span> &#123;</span><br><span class="line">    <span class="attribute">transition-property</span>: all;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: ease;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过渡的简写语法"><a href="#过渡的简写语法" class="headerlink" title="过渡的简写语法"></a>过渡的简写语法</h2><p>我们可以把这些独自的属性组合成一个简写版：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.style</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当使用简写语法的时候，第一个和时间相关的值会被应用给<code>transition-duration</code>，而第二个则会被应用到<code>transition-delay</code>上。</p>
<p>尽量只定义那些你真的需要过渡的属性。定义成<code>all</code>是十分方便，但是如果你只需要过渡透明度，那么就把<code>transition-property</code>设成<code>opacity</code>，否则你会加重浏览器的负担</p>
<h2 id="在不同时间段内过渡不同属性"><a href="#在不同时间段内过渡不同属性" class="headerlink" title="在不同时间段内过渡不同属性"></a>在不同时间段内过渡不同属性</h2><p>当一条规则要实现多个属性过渡时，这些属性不必步调一致</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.style</span> &#123;</span><br><span class="line">    <span class="attribute">transition-property</span>: border, color, text-shadow;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">2s</span>, <span class="number">3s</span>, <span class="number">8s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们首先指定要过渡的属性，然后在分别为它们指定不同的过渡时间，不同过渡之间用逗号分隔</p>
<h1 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h1><p>虽然两个英文单词发音相似，但变形和过渡完全不同。可以这么理解：<strong>过渡是从一种状态平滑转换到另一种状态，而变形则定义了元素将会变成什么样子</strong>。</p>
<h2 id="变形原点"><a href="#变形原点" class="headerlink" title="变形原点"></a>变形原点</h2><p>元素的默认变形原点为正中心，即元素X轴的50%和Y轴的50%处。</p>
<p>你可以使用<code>transform-origin</code>来改变变形原点的位置。如果给它传递数值，则代表需要相对于正中心的偏移量。如果给它传递百分值，则表示要将变形原点移动到对应轴的对应百分比处。</p>
<h2 id="如何变形"><a href="#如何变形" class="headerlink" title="如何变形"></a>如何变形</h2><div class="note info">
            <p>CSS的变形是通过<code>transform</code>属性实现的，下面列表中的内容具体的形变种类</p><ol><li><code>scale()</code>：用来对元素进行缩放。如果给定一个值，则X轴和Y轴同时按照这个值进行缩放。如果给定两个值，则分别对应X轴和Y轴的缩放系数。如果还有第三个值，那这个值对应Z轴的缩放系数。<strong>当值为负数时，首先在对应方向上将元素镜像，然后在进行缩放</strong>。</li><li><code>translate()</code>：用来移动元素。用法与<code>scale()</code>相同，如果使用百分值，那么是相对于元素自身的百分比。</li><li><code>rotate()</code>：使元素围绕变形原点进行旋转。如果角度为正，那么顺时针方向旋转。反之则逆时针方向。</li><li><code>skew()</code>：沿X轴和Y轴对元素进行斜切。对X轴进行斜切时，以变形原点为中心让X轴顺时针旋转。对Y轴进行斜切时，以变形原点为中心让Y轴逆时针旋转。</li><li><code>matrix()</code>：允许你以像素精度来控制变形效果。以后理解更深刻的时候再回来整理。</li></ol>
          </div>
<h2 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h2><p><code>perspective</code>属性指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三位元素比正常大，反之则小。</p>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>首先，我们创建一个关键帧规则</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> pulse &#123;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">#bbb</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">4px</span> <span class="number">#bbb</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，在<code>@keyframes</code>关键词后我们定义了一个新的关键帧规则，并且给这个动画命了名。</p>
<p>我们这里只定义了一个简单的关键帧选择器：<code>100%</code>。然而，你也可以设置多个关键帧选择器（用百分比定义）。你可以把它们想像成时间轴上的点。例如，<code>10%</code>的时候背景变成蓝色，<code>30%</code>的时候背景变成紫色，<code>60%</code>的时候让元素变得透明，等等。</p>
<p>在支持的浏览器中，<code>from</code>代表<code>0%</code>，<code>to</code>代表<code>100%</code>。</p>
<div class="note warning">
            <p>如果定义了负值或者大于<code>100%</code>的关键帧，它会被忽略。</p>
          </div>
<p>与过渡的<code>transition</code>相对应，动画使用<code>animation</code>属性。它也是一个缩写属性，当然你也可以不采用缩写形式而使用下面例子中的形式，可选值已用<code>|</code>分隔表示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation-properties</span> &#123;</span><br><span class="line">    <span class="attribute">animation-name</span>: pulse;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">1.5s</span>;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease | ease-in | ease-out | ease-in-out | linear | step-start | step-end;</span><br><span class="line">    <span class="attribute">animation-iteration-count</span>: infinite | n;</span><br><span class="line">    <span class="attribute">animation-play-state</span>: running | paused;</span><br><span class="line">    <span class="attribute">animation-delay</span>: <span class="number">0s</span>;</span><br><span class="line">    <span class="attribute">animation-fill-mode</span>: none | forwards | backwards | both;</span><br><span class="line">    <span class="attribute">animation-direction</span>: normal | reverse | alternate | alternaterverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            position: relative;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#item</span> &#123;</span></span><br><span class="line">            width: 20px;</span><br><span class="line">            height: 20px;</span><br><span class="line">            border-radius: 10px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            margin: auto;</span><br><span class="line">            background: red;</span><br><span class="line">            animation-name: bounce;</span><br><span class="line"><span class="css">            <span class="selector-tag">animation-duration</span>: 1<span class="selector-class">.5s</span>;</span></span><br><span class="line">            animation-timing-function: linear;</span><br><span class="line">            animation-iteration-count: infinite;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> bounce &#123;</span></span><br><span class="line">            0% &#123;</span><br><span class="line">                top: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            50% &#123;</span><br><span class="line">                top: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            100% &#123;</span><br><span class="line">                top: 180px;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>背景</title>
    <url>/posts/28d95575/</url>
    <content><![CDATA[<h1 id="背景结构图"><a href="#背景结构图" class="headerlink" title="背景结构图"></a>背景结构图</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/%E8%83%8C%E6%99%AF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="背景结构图"></p>
<h1 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h1><p>通过这个属性可以指定盒模型的背景颜色。</p>
<h1 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h1><p>格式为：<code>background-image: url(图片路径/图片文件名)</code>。</p>
<h1 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h1><p>该属性用于定义背景图片的重复方式。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/background-repeat.png" alt="background-repeat"></p>
<h1 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h1><p>该属性用于定义背景图片的位置，该属性的值可以是：关键字、百分比、绝对或相对单位的数值，也可以将关键字与百分比或数值配合使用。</p>
<p>关键字包括：<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>和<code>center</code>。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/background-position.png" alt="background-position"></p>
<h1 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h1><p>该属性用于定义背景图片的大小。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/background-size.png" alt="background-size"></p>
<h1 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h1><p>该属性用于定义背景图片是否随元素滚动而移动。这个属性的默认值是<code>scroll</code>，即背景图片随元素移动。如果把它的值改为<code>fixed</code>，那么背景图片不会随元素滚动而移动。</p>
<h1 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h1><p>该属性用于定义背景图片的覆盖范围。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/background-clip.png" alt="background-clip"></p>
<h1 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h1><p>该属性用于定义背景图片的起点位置。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/background-origin.png" alt="background-origin"></p>
<h1 id="background"><a href="#background" class="headerlink" title="background"></a>background</h1><div class="note info">
            <p><code>background</code>属性是有关背景的简写属性，这里需要注意的是，当<code>background-position</code>和<code>background-size</code>同时出现时，应写为<code>background-position/background-size</code>。且如果想指定<code>background-size</code>，则必须指定<code>background-position</code>，否则背景图片不会呈现。</p>
          </div>
<h1 id="多背景图片"><a href="#多背景图片" class="headerlink" title="多背景图片"></a>多背景图片</h1><p>直接上例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#background-demo</span> &#123;</span><br><span class="line"><span class="attribute">background</span>:</span><br><span class="line">    <span class="built_in">url</span>(images/demo1.png) <span class="number">20px</span> -<span class="number">10px</span> no-repeat,</span><br><span class="line">    <span class="built_in">url</span>(images/demo2.png) <span class="number">145px</span> <span class="number">0px</span> no-repeat,</span><br><span class="line">    <span class="built_in">url</span>(images/demo3.png) <span class="number">14px</span> -<span class="number">30px</span> no-repeat, <span class="number">#ffbd75</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><strong>在<code>background</code>中先定义的背景图片显示在上方，或者说更接近前景</strong>。所以demo1.png显示在最上方，demo3.png在最下方。</p>
          </div>
<h1 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h1><p><code>background-image</code>属性除了可以指定背景图片外，还可以定义背景的渐变效果。</p>
<h2 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h2><div class="note info">
            <p><code>linear-gradient</code>使用步骤：</p><ol><li><strong>确定渐变方向</strong>：渐变方向有两种定义方式：关键字和角度。当未指定渐变方向时，默认为<code>to bottom</code>，也叫作<code>180deg</code>；</li><li><strong>在渐变方向的不同位置处，定义渐变点</strong>：渐变点的个数不能少于两个。如果为同一个渐变点设定两种颜色，会得到突变效果。</li></ol>
          </div>
<p>首先通过下图理解渐变方向。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/%E6%B8%90%E5%8F%98%E6%96%B9%E5%90%91.png" alt="渐变方向"></p>
<p>然后就可以上例子了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d"</span>&gt;</span>d<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"e"</span>&gt;</span>e<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"f"</span>&gt;</span>f<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#outer</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">    width: 700px;</span><br><span class="line">    align-items: center;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    color: white;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    margin-top: 40px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#a</span> &#123;</span></span><br><span class="line">    background-image: linear-gradient(red, blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#b</span> &#123;</span></span><br><span class="line">    background-image: linear-gradient(to bottom right, red, blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#c</span> &#123;</span></span><br><span class="line">    background-image: linear-gradient(90deg, red, blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#d</span> &#123;</span></span><br><span class="line">    background-image: linear-gradient(red 20%, yellow 50%, blue 80%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#e</span> &#123;</span></span><br><span class="line">    background-image: linear-gradient(red 30%, blue 30%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#f</span> &#123;</span></span><br><span class="line">    background-image: linear-gradient(45deg, red 30%, blue 30%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/linear-gradient.png" alt="linear-gradient"></p>
<h2 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial-gradient"></a>radial-gradient</h2><div class="note info">
            <p><code>linear-gradient</code>时需要设置渐变方向。而使用<code>radial-gradient</code>时则需要设置渐变的形状、大小和位置：</p><ol><li><strong>形状</strong>：<code>circle</code>或<code>ellipse</code>（默认）；</li><li><strong>大小</strong>：<ul><li><code>closest-side</code>：渐变从圆形（或椭圆形）中心开始，到距离中心最近的边终止；</li><li><code>closest-corner</code>：渐变从圆形（或椭圆形）中心开始，到距离中心最近的角终止；</li><li><code>farthest-side</code>：渐变从圆形（或椭圆形）中心开始，到距离中心最远的边终止；</li><li><code>farthest-corner</code>：渐变从圆形（或椭圆形）中心开始，到距离中心最远的角终止；</li><li><code>12rem</code>：会生成一个直径为<code>12rem</code>的圆；</li><li><code>40px 30px</code>：会生成一个X方向宽40像素、Y方向高30像素的椭圆形。</li></ul></li><li><strong>位置</strong>：使用<code>at</code>定义渐变中心的位置，例如<code>at center</code>或<code>at top 100px right</code>。</li></ol>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d"</span>&gt;</span>d<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"e"</span>&gt;</span>e<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"f"</span>&gt;</span>f<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#outer</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">    width: 700px;</span><br><span class="line">    align-items: center;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    color: white;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    margin-top: 40px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#a</span> &#123;</span></span><br><span class="line">    background-image: radial-gradient(red, blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#b</span> &#123;</span></span><br><span class="line">    background-image: radial-gradient(closest-side, red 50%, blue 50%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#c</span> &#123;</span></span><br><span class="line">    background-image: radial-gradient(closest-corner, red 50%, blue 50%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#d</span> &#123;</span></span><br><span class="line">    background-image: radial-gradient(circle closest-side at top 45px left 45px, red 20%, yellow 20%, blue 50%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#e</span> &#123;</span></span><br><span class="line">    background-image: radial-gradient(ellipse 200px 100px at bottom left , red 20%, yellow 50%, blue 80%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-id">#f</span> &#123;</span></span><br><span class="line">    background-image: radial-gradient(circle closest-corner at 100%, red, red 50%, yellow 75%, blue 75%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E8%83%8C%E6%99%AF/radial-gradient.png" alt="radial-gradient"></p>
<h2 id="重复渐变"><a href="#重复渐变" class="headerlink" title="重复渐变"></a>重复渐变</h2><p>规则相同，就是在前面加上<code>repeating-</code>前缀</p>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>盒模型</title>
    <url>/posts/165da8b7/</url>
    <content><![CDATA[<h1 id="理解盒模型"><a href="#理解盒模型" class="headerlink" title="理解盒模型"></a>理解盒模型</h1><div class="note info">
            <ul><li>盒模型由四个部分组成：<strong>内容区</strong>、<strong>内边距</strong>、<strong>边框</strong>、<strong>外边距</strong></li><li>盒模型中有四种盒子：<code>content-box</code>、<code>padding-box</code>、<code>border-box</code>、<code>margin-box</code></li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="理解盒模型"></p>
<h1 id="盒模型和元素的大小"><a href="#盒模型和元素的大小" class="headerlink" title="盒模型和元素的大小"></a>盒模型和元素的大小</h1><div class="note info">
            <ol><li>盒模型的大小和元素的大小不是一回事</li><li>盒模型的大小是<code>外边距+边框+内边距+内容区</code></li><li>元素的大小取决于<code>box-sizing</code>属性，它有两个值：<ul><li><code>content-box</code>（默认）：此时元素的<code>width</code>和<code>height</code>属性设置的是<code>内容区</code>的宽度和高度</li><li><code>border-box</code>：此时元素的<code>width</code>和<code>height</code>属性设置的是<code>边框+内边距+内容区</code>的宽度和高度</li></ul></li><li>块级元素在没有设置<code>width</code>时，它的盒模型会始终填满其父元素的宽度。</li></ol>
          </div>
<h1 id="盒模型种类"><a href="#盒模型种类" class="headerlink" title="盒模型种类"></a>盒模型种类</h1><div class="note info">
            <p>根据盒模型的不同，它们参与不同的<a href="https://aadonkeyz.com/posts/451e216f/">格式化上下文</a></p><ul><li><strong>block-level box</strong>：<code>display</code>属性为<code>block</code>、<code>list-item</code>、<code>table</code></li><li><strong>inline-level box</strong>：<code>display</code>属性为<code>inline</code>、<code>inline-block</code>、<code>inline-table</code></li><li><strong>run-in box</strong>：<code>display</code>属性为<code>run-in</code></li></ul>
          </div>
<h1 id="margin和padding的注意事项"><a href="#margin和padding的注意事项" class="headerlink" title="margin和padding的注意事项"></a>margin和padding的注意事项</h1><div class="note warning">
            <ul><li><code>margin</code>的<code>top</code>和<code>bottom</code>对非替换内联元素无效，例如：<code>&lt;span&gt;</code>和<code>&lt;code&gt;</code></li><li><code>margin</code>和<code>padding</code>的属性值如果用百分比设置，那么都是相对于该元素包含块的<strong>宽度</strong></li><li><code>margin</code>的属性值如果是<code>auto</code>，那么对应的外边距会自动占据包含块空间的所有可用空间</li></ul>
          </div>
<h1 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h1><p><code>border-radius</code>允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/border-radius.png" alt="border-radius"></p>
<p>该属性是一个简写属性，是为了将<code>border-top-left-radius</code>、<code>border-top-right-radius</code>、<code>border-bottom-right-radius</code>和<code>border-bottom-left-radius</code>简写为一个属性</p>
<p><code>border-radius</code>在设置椭圆形时，使用（<code>/</code>）分隔水平半轴和垂直半轴</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">border-radius: 1em / 5em;</span><br><span class="line"><span class="comment">/* 等价于： */</span></span><br><span class="line"><span class="selector-tag">border-top-left-radius</span>:     1<span class="selector-tag">em</span> 5<span class="selector-tag">em</span>;</span><br><span class="line"><span class="selector-tag">border-top-right-radius</span>:    1<span class="selector-tag">em</span> 5<span class="selector-tag">em</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-right-radius</span>: 1<span class="selector-tag">em</span> 5<span class="selector-tag">em</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-left-radius</span>:  1<span class="selector-tag">em</span> 5<span class="selector-tag">em</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ================================ */</span></span><br><span class="line"></span><br><span class="line">border-radius: 4px 3px 6px / 2px 4px;</span><br><span class="line"><span class="comment">/* 等价于： */</span></span><br><span class="line"><span class="selector-tag">border-top-left-radius</span>:     4<span class="selector-tag">px</span> 2<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-top-right-radius</span>:    3<span class="selector-tag">px</span> 4<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-right-radius</span>: 6<span class="selector-tag">px</span> 2<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-left-radius</span>:  3<span class="selector-tag">px</span> 4<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/border-radius1.png" alt="border-radius1"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/border-radius2.png" alt="border-radius2"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/border-radius3.png" alt="border-radius3"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/border-radius4.png" alt="border-radius4"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/border-radius5.png" alt="border-radius5"><br><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E5%B8%83%E5%B1%80/border-radius6.png" alt="border-radius6"></p>
<h1 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h1><div class="note info">
            <ol><li><code>box-shadow: inset &lt;offset-x&gt; &lt;offset-y&gt; &lt;blur-radius&gt; &lt;spread-radius&gt; &lt;color&gt;</code>，需要特别注意的是，<strong>这些长度值需要指明单位！！！</strong><ul><li><code>inset</code>（可选）：不使用<code>inset</code>则阴影在边框外，使用<code>inset</code>则阴影在边框内</li><li><code>&lt;offset-x&gt;</code>（必选）：水平偏移量</li><li><code>&lt;offset-y&gt;</code>（必选）：垂直偏移量</li><li><code>&lt;blur-radius&gt;</code>（可选）：该值越大，阴影面积越大，阴影就越大越淡。不能为负值。默认为<code>0</code>，此时阴影边缘锐利</li><li><code>&lt;spread-radius&gt;</code>（可选）：取正值时，阴影扩大。取负值时，阴影缩小。默认为<code>0</code>，此时阴影与元素同样大</li><li><code>&lt;color&gt;</code>（可选）：颜色。默认颜色由浏览器决定</li></ul></li><li>如果给出了第三个长度值，则它被解释为<code>&lt;blur-radius&gt;</code>。如果给出了第四个长度值，则它被解释为<code>&lt;spread-radius&gt;</code></li><li>如果想设置多个阴影，则不同阴影规则之间需要使用逗号分隔。越靠前的阴影规则，对应的阴影越接近显示的表层</li><li>如果元素同时设置了<code>border-radius</code>，那么阴影也会有圆角效果</li></ol>
          </div>]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP基础</title>
    <url>/posts/22f97770/</url>
    <content><![CDATA[<h1 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h1><div class="note warning">
            <ul><li>实体是要进行传输的数据。</li><li>实体首部字段存在于报文首部字段之中。</li><li>实体主体和报文主体在起始时是相同的。</li><li>如果实体主体过大，需要进行分块传输，会导致报文主体中包含多个实体主体。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.png" alt="请求报文格式"></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.png" alt="响应报文格式"></p>
<h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>GET是最常用的方法。通常用于向服务器请求某个资源。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/GET.png" alt="GET"></p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取是集资源的情况下，对资源的首部进行检查。服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。</p>
<div class="note info">
            <p>使用HEAD，可以：</p><ul><li>在不获取资源的情况下了解资源的情况。比如，判断其类型。</li><li>通过查看响应中的状态码，看看某个对象是否存在。</li><li>通过查看首部，测试资源是否被修改了。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/HEAD.png" alt="HEAD"></p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>与GET从服务器读取文档相反，PUT方法会向服务器写入文档。服务器应使用PUT请求的主体来创建/替换文档。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/PUT.png" alt="PUT"></p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>POST方法用于向服务器传输数据，由服务器根据情况判断如何使用这些数据。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/POST.png" alt="POST"></p>
<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。</p>
<p>TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一个TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否以及如何被毁坏或修改的。</p>
<p>尽管TRACE可以很方便地用于诊断，但它确实也有缺点，它假定中间应用程序对各种不同类型请求的处理是相同的。很多HTTP应用程序会根据方法的不同做出不同的事情——比如，代理可能会将POST请求直接发送给服务器，而将GET请求发送给另一个HTTP应用程序。TRACE并不提供区分这些方法的机制。通常，中间应用程序会自行决定对TRACE请求的处理方式。</p>
<p>TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/TRACE.png" alt="TRACE"></p>
<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>OPTIONS方法请求服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/OPTIONS.png" alt="OPTIONS"></p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>DELETE方法所做的事情就是请服务器删除请求URL所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/DELETE.png" alt="DELETE"></p>
<h2 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h2><div class="note info">
            <ul><li>GET 请求参数放在 URL 中，POST 请求参数放在请求的 body 中。</li><li>GET 请求会被浏览器主动缓存，而 POST 则需要手动设置。</li><li>浏览器对 GET 请求在 URL 中传送的参数是有长度限制的（通常为 2K），而对 POST 请求的限制为 80K - 100K。<strong>实际上 GET 和 POST 请求本身对大小是无限制的。</strong></li><li>GET 请求产生一个 TCP 数据包，而 POST 请求产生两个数据包（Firefox 除外）。POST 请求先发送 header ，服务器响应 100 Continue 后，再接着发送 data，最后服务器响应 200 OK。</li></ul>
          </div>
<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/%E7%8A%B6%E6%80%81%E7%A0%81%E7%B1%BB%E5%88%AB.png" alt="状态码类别"></p>
<div class="note info">
            <ul><li><strong>100 Continue</strong>：说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应。</li><li><strong>101 Switching Protocols</strong>：说明服务器正在根据客户端的指定，将协议切换成<code>Update</code>首部所列的协议。</li></ul><hr><ul><li><strong>200 OK</strong>：请求没问题，实体的主体部分包含了所请求的资源。</li><li><strong>204 No Content</strong>：响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不专为显示新文档的情况下，对其进行更新。</li><li><strong>206 Partial Content</strong>：客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由<code>Content-Range</code>指定范围的实体内容。</li></ul><hr><ul><li><strong>301 Moved Permanently</strong>：在请求的URL已被移除时使用。响应的<code>Location</code>首部中应包含资源现在所处的URL。</li><li><strong>302 Found</strong>：与301状态码类似，但是客户端应该使用<code>Location</code>首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</li><li><strong>303 See Other</strong>：与<code>302</code>类似，但是<code>303</code>明确表示客户端应当采用GET方法获取资源，这点与<code>302</code>有区别。</li><li><strong>304 Not Modified</strong>：告知客户端它的它所请求的资源不同重新缓存，使用以前的就好。它虽然被划分在<code>3XX</code>类别中，但是和重定向没有关系。</li><li><strong>307 Temporary Redirect</strong>：与<code>302</code>有着相同的含义。尽管<code>302</code>禁止POST变换为GET，但实际使用时大家并不遵守。<code>307</code>会遵照浏览器标准，不会从POST变换为GET。</li></ul><hr><ul><li><strong>400 Bad Request</strong>：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong>：发送的请求需要有通过HTTP认证的认证信息，若之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong>：对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</li><li><strong>404 Not Found</strong>：服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</li></ul><hr><ul><li><strong>500 Internal Server Error</strong>：服务器端在执行请求时发生了错误。</li><li><strong>502 Bad Gateway</strong>：服务器作为网关或代理，从上游服务器收到无效响应。</li><li><strong>503 Service Unavailable</strong>：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入<code>RetryAfter</code>首部字段再返回给客户端。</li></ul>
          </div>
<h1 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h1><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h2><p>历史上第一个有记载的 HTTP 版本是 0.9，它诞生在 1991 年。这个协议被设计用于从服务器获取 HTML 文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telent example.com 80</span><br><span class="line">GET /</span><br></pre></td></tr></table></figure>
<p>整个协议的请求只有 1 行，只支持 GET 请求，当从服务器返回文档内容后，关闭 TCP 连接。</p>
<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><div class="note info">
            <ul><li>支持请求/响应头</li><li>支持响应状态码</li><li>支持 HEAD、POST 方法</li></ul>
          </div>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><div class="note info">
            <ul><li>支持持久连接</li><li>支持并行连接</li><li>支持管道化连接</li><li>在 HTTP 1.0 的基础上，对 HTTP 缓存进行优化（加入<code>Etag</code>实体标签）</li><li>支持 OPTIONS、PUT、DELETE、TRACE、CONNECT 方法</li></ul>
          </div>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><div class="note info">
            <ul><li>所有数据以二进制格式传输</li><li>支持信道复用，一个 TCP 连接里可以发送多个请求，不再需要按着顺序来</li><li>头信息压缩、减少带宽</li><li>支持服务器推送</li></ul>
          </div>
<h1 id="HTTP连接方式"><a href="#HTTP连接方式" class="headerlink" title="HTTP连接方式"></a>HTTP连接方式</h1><div class="note info">
            <ul><li><strong>串行连接</strong>：一个 TCP 连接一次只能发送一次 HTTP 请求。</li><li><strong>并行连接</strong>：通过多条 TCP 连接发起并发的 HTTP 请求。</li><li><strong>持久连接</strong>：重用 TCP 连接，以消除连接及关闭时延。</li><li><strong>管道化连接</strong>：通过共享的 TCP 连接发起并发的 HTTP 请求。</li></ul>
          </div>
<h2 id="串行连接"><a href="#串行连接" class="headerlink" title="串行连接"></a>串行连接</h2><p>串行连接中 HTTP 请求只能一个一个发送，且每次发起 HTTP 请求都要进行 TCP 连接和断开操作，时延较长且耗费性能。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/%E4%B8%B2%E8%A1%8C%E8%BF%9E%E6%8E%A5.png" alt="串行连接"></p>
<h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><p>并行连接中 HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。相比于串行连接，每个 TCP 连接的时延会重叠，所以总的网络时延会较小。但是想象一个场景，如果一百个用户同时发出申请，每个用户打开 100 个连接，服务器就要负责处理 10000 个连接，这会造成服务器性能的严重下降。</p>
<div class="note warning">
            <p>总结起来，并行连接有如下缺点：</p><ul><li>每个事务都会打开/关闭一条新的 TCP 连接，会耗费时间和带宽。</li><li>由于 TCP 拥塞控制的存在，每条新连接的性能都会有所降低。</li><li>可打开的并行连接数量实际上是有限的。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/%E5%B9%B6%E8%A1%8C%E8%BF%9E%E6%8E%A5.png" alt="并行连接"></p>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png" alt="持久连接"></p>
<h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p>HTTP/1.1 允许在持久连接上可选地使用<strong>请求管道</strong>。在响应到达之前，可以将多条请求放入队列，当第一条请求通过网络 流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。</p>
<div class="note warning">
            <p>对管道化连接有几条限制：</p><ul><li>如果 HTTP 客户端无法确认连接是持久的，就不应该使用管道。</li><li>必须使用与请求相同的顺序回送 HTTP 响应。HTTP 报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li><li>HTTP 客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了 10 条请求，服务器可能在只处理了 5 条请求之后关闭连接，剩下的 5 条请求会失败，客户端必须能够应付这些过早关闭连接的情况，重新发出这些请求。</li><li>HTTP 客户端不应该使用管道化的方式发送会产生副作用的请求（比如 POST）。总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试 POST 这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险。</li></ul>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP%E5%9F%BA%E7%A1%80/%E7%AE%A1%E9%81%93%E5%8C%96%E8%BF%9E%E6%8E%A5.png" alt="管道化连接"></p>
<h1 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h1><h2 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h2><div class="note info">
            <ul><li><code>Connection</code>：允许客户端和服务器指定与请求/响应连接有关的选项。</li><li><code>Cache-Control</code>：强缓存使用的首部字段。</li><li><code>Date</code>：创建报文的日期。</li><li><code>MIME-Version</code>：给出了发送端使用的 MIME 版本。</li><li><code>Trailer</code>：如果报文采用了分块传输编码，就可以用这个首部列出位于报文拖挂部分的首部集合。</li><li><code>Transfer-Encoding</code>：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</li><li><code>Update</code>：给出了发送端可能想要“升级”使用的新版本或协议。</li><li><code>Via</code>：显示了报文经过的中间节点（代理、网关）。</li><li><code>Warning</code>：错误通知。</li></ul>
          </div>
<h2 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h2><div class="note info">
            <ul><li><code>Accept</code>：告诉服务器能够发送哪些媒体类型。</li><li><code>Accept-Charset</code>：告诉服务器能够发送哪些字符集。</li><li><code>Accept-Encoding</code>：告诉服务器能够发送哪些内容编码。</li><li><code>Accept-Language</code>：告诉服务器能够发送哪些自然语言。</li><li><code>Authorization</code>：Web 认证信息。</li><li><code>Except</code>：期待服务器的特定行为。</li><li><code>From</code>：用户的电子邮箱地址。</li><li><code>Host</code>：请求资源所在服务器。</li><li><code>If-Match</code>：协商缓存使用的首部字段。</li><li><code>If-Modified-Since</code>：协商缓存使用的首部字段。</li><li><code>If-Range</code>：允许对文档的某个范围进行条件请求。</li><li><code>If-Unmodified-Since</code>：协商缓存使用的首部字段。</li></ul>
          </div>
<h2 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h2><div class="note info">
            <ul><li><code>Accept-Ranges</code>：是否接受字节范围请求。</li><li><code>Age</code>：推算资源创建经过时间。</li><li><code>Etag</code>：协商缓存使用的首部字段。</li><li><code>Location</code>：令客户端重定向至指定 URI。</li><li><code>Proxy-Authenticate</code>：代理服务器对客户端的认证信息。</li><li><code>Retry-After</code>：对再次发起请求的时机要求。</li><li><code>Server</code>：HTTP 服务器的安装信息。</li><li><code>Vary</code>：代理服务器缓存的管理信息。</li><li><code>WWW-Authenticate</code>：服务器对客户端的认证信息。</li></ul>
          </div>
<h2 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h2><div class="note info">
            <ul><li><code>Allow</code>：资源可支持的 HTTP 方法。</li><li><code>Content-Encoding</code>：实体主体使用的编码方式。</li><li><code>Content-Language</code>：实体主体的自然语言。</li><li><code>Content-Length</code>：实体主体的大小</li><li><code>Content-Location</code>：替代对应资源的 URI。</li><li><code>Content-MD5</code>：实体主体的报文摘要。</li><li><code>Content-Range</code>：实体主题的位置范围。</li><li><code>Content-Type</code>：实体主题的媒体类型。</li><li><code>Expires</code>：实体主体的日期时间。</li><li><code>Last-Modified</code>：资源的最后修改日期时间。</li></ul>
          </div>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS</title>
    <url>/posts/c9a2a716/</url>
    <content><![CDATA[<h1 id="数字加密"><a href="#数字加密" class="headerlink" title="数字加密"></a>数字加密</h1><div class="note info">
            <ol><li><strong>密码</strong>：对文本进行编码，使偷窥者无法识别的<strong>算法</strong>。</li><li><strong>密钥</strong>：改变密码行为的数字化参数。</li><li><strong>对称密钥加密系统</strong>：编/解码使用相同的密钥。</li><li><strong>非对称密钥加密系统</strong>：编/解码使用不同的密钥。</li><li><strong>数字签名</strong>：用来验证报文未被伪造或篡改的校验和。</li><li><strong>数字证书</strong>：由一个可信的组织验证和签发的识别信息。</li></ol>
          </div>
<h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h2><p>很多数字加密算法都被称为对称密钥加密技术，这是因为它们在编码时使用的密钥和解码时使用的密钥是相同的。在对称密钥加密技术中，发送端和接收端要共享相同的密钥才能进行通信。发送端用共享的密钥来加密报文，并将得到的密文发送给接收端。接收端收到密文，并对其应用解密函数和相同的共享密钥，恢复出原始的明文。</p>
<div class="note info">
            <p>对称密钥加密技术的缺点：</p><ul><li>在通信的双方首次传输密钥的过程中，密钥可能会被窃取。</li><li>发送者和接收者在互相对话之前，一定要有一个共享的保密密钥。如果有$N$个节点，每个节点都要和其他所有$N-1$个节点进行安全对话，总共大概会有$N^2$个保密密钥。</li></ul>
          </div>
<h2 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h2><p>非对称密钥加密系统中有一个保密的<strong>私有密钥</strong>和一个众所周知的<strong>公开密钥</strong>。</p>
<div class="note info">
            <p>下面用一个例子来说明它们是如何工作的，现有一台Web服务器S，和众多客户端A、B、C等。</p><ol><li>服务器持有保密的私有密钥，它不会将它泄漏给任何人。</li><li>众多客户端A、B、C持有与私有密钥对应的公开密钥。</li><li>客户端向服务器发送信息时，通过公开密钥对信息进行加密，加密后的密文，只有持有私有密钥的服务器才能进行正确解密。</li><li>服务器向客户端发送信息的时候，通过私有密钥对特定信息进行加密从而生成数字签名，然后将明文报文和数字签名一起发送给客户端。</li></ol>
          </div>
<p>所有公开密钥非对称加密系统所面临的共同挑战是，要确保即便有人拥有了下面所有的线索，也无法算出保密的私有密钥。</p>
<div class="note info">
            <ul><li>公开密钥</li><li>一小片拦截下来的密文</li><li>一条报文及与之相关的密文</li></ul>
          </div>
<p>RSA算法就是一个满足了所有这些条件的流行的公开密钥加密系统，它的机密技术细节中包括很多繁琐的数学问题，这里就不进行详细介绍了（其实是我不懂）。</p>
<h2 id="混合加密系统和会话密钥"><a href="#混合加密系统和会话密钥" class="headerlink" title="混合加密系统和会话密钥"></a>混合加密系统和会话密钥</h2><p>任何人只要知道了其公开密钥，就可以向一台公共服务器发送安全报文，所以非对称密钥加密系统是很好用的。两个节点无须为了进行安全的通信而先交换私有密钥，但非对称密钥加密系统的计算可能会很慢。</p>
<p>比较常见的做法是在两节点间通过便捷的公开密钥加密技术建立起安全通信，然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><div class="note info">
            <p>数字签名是附加在报文上的特殊加密校验和。它有如下用处：</p><ul><li>签名可以证明是私有密钥拥有者编写了这条报文。</li><li>签名可以防止报文被篡改。如果有恶意攻击者在报文传输过程中对其进行了修改，校验和就不再匹配了。由于校验和用私有密钥才能产生，所以攻击者无法为篡改了的报文伪造出正确的校验和。</li></ul>
          </div>
<p>下面用两张图片分别展示数字签名是如何生成的，以及它是如何工作的。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTPS/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%9A%84%E7%94%9F%E6%88%90.png" alt="数字签名的生成过程"></p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTPS/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="数字签名的工作过程"></p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>通过HTTPS建立了一个安全Web事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。服务器证书中包含很多字段，其中包括：</p>
<div class="note info">
            <ul><li>Web站点的名称和主机名</li><li>Web站点的公开密钥</li><li>签名颁发机构的名称</li><li>来自签名颁发机构的签名</li></ul>
          </div>
<p>浏览器收到证书时，会对签名颁发机构进行检查。如果这个机构是个很有权威的公共签名机构，浏览器可能已经知道其公开密钥了（浏览器会预先安装很多签名颁发机构的证书），这样就可以通过验证这个机构的签名来判断这个证书是否真的是这个权威机构颁发的了。如果浏览器对签名颁发机构一无所知，就无法确定是否应该应该信任这个签名颁发机构，它通常会向用户显示一个对话框，看看它是否相信这个签名发布者。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTPS/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="数字证书工作过程"></p>
<h1 id="HTTPS概述"><a href="#HTTPS概述" class="headerlink" title="HTTPS概述"></a>HTTPS概述</h1><p>HTTPS就是在安全的传输层上发送的HTTP。HTTPS没有将未加密的HTTP报文发送给TCP，它在将报文发送给TCP之前，先将其发送给了一个安全层，对其进行加密。现在，HTTP安全层是通过SSL及其现代替代协议TLS来实现的。我们遵循常见的用法，用属于SSL来表示SSL或者TLS。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTPS/HTTPS%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="HTTPS协议栈"></p>
<p>现在，安全的HTTP是可选的。因此，对Web服务器发起请求时，我们需要有一种方式来告知Web服务器去执行HTTP的安全协议版本。这是在URL的方案中实现的。通常情况下，非安全的HTTP的URL方案前缀为<code>http</code>。在安全HTTPS协议中，URL的方案前缀为<code>https</code>。</p>
<div class="note info">
            <p>请求一个客户端对某Web资源执行某事务时，它会去检查URL的方案。</p><ul><li>如果URL的方案为<code>http</code>，客户端就会打开一条到服务器端口80（默认情况下）的连接，并向其发送老的HTTP命令。</li><li>如果URL的方案为<code>https</code>，客户端就会打开一条到服务器端口443（默认情况下）的连接，然后与服务器“握手”，以二进制格式与服务器交换一些SSL安全参数，附上加密的HTTP命令。</li></ul>
          </div>
<h1 id="建立安全传输"><a href="#建立安全传输" class="headerlink" title="建立安全传输"></a>建立安全传输</h1><p>由于SSL安全层的存在，在HTTPS中，客户端首先打开一条到Web服务器端口443（安全HTTP的默认端口）的连接。一旦建立了TCP连接，客户端和服务器就会初始化SSL层，对加密参数进行沟通，并交换密钥。握手完成之后，SSL初始化就完成了，客户端就可以将请求报文发送给安全层了。在将这些报文发送给TCP之前，要先对其进行加密。</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTPS/HTTP%E5%92%8CHTTPS%E4%BA%8B%E5%8A%A1.png" alt="HTTP和HTTPS事务"></p>
<h1 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h1><p>有关 SSL 握手的内容，参考自<a href="http://ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></p>
<div class="note info">
            <p>SSL 握手涉及四次通信，在每一次通信中需要传递的主要内容如下所示：</p><ol><li>客户端发出请求<ul><li>支持的协议版本，比如 TLS 1.0 版</li><li>一个客户端生成的随机数，稍后用于生成“对话密钥”</li><li>支持的加密算法</li><li>支持的压缩方法</li><li>想要请求的服务器域名（与虚拟主机有关）</li></ul></li><li>服务器回应<ul><li>确认使用的加密通信协议版本，比如 TLS 1.0 版。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信</li><li>一个服务器生成的随机数，稍后用于生成“对话密钥”</li><li>确认使用的加密算法</li><li>服务器证书</li></ul></li><li>客户端回应<ul><li>一个客户端生成的随机数，用于生成“对话密钥”。该随机数用服务器公钥加密，防止被窃听</li><li>编码改变通知，表示随后的信息都将用双方商定的加密算法和密钥发送</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验</li></ul></li><li>服务器的最后回应<ul><li>编码改变通知，表示随后的信息都将用双方商定的加密算法和密钥发送</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验</li></ul></li></ol>
          </div>
<div class="note warning">
            <p><strong>“对话密钥”是使用步骤 1、2 和 3 中的三个随机数生成的对称密钥。使用三个随机数是因为 SSL 协议不信任每个主机都能产生完全随机的随机数，而这样做可以增加随机性</strong></p>
          </div>
<h1 id="服务器证书"><a href="#服务器证书" class="headerlink" title="服务器证书"></a>服务器证书</h1><p>SSL支持双向认证，将服务器证书承载回客户端，再将客户端的证书会送给服务器。而现在，浏览器并不经常使用客户端证书。大部分用户甚至都没有自己的客户端证书。服务器可以要求使用客户端证书，但实际中很少出现这种情况。</p>
<p>另一方面，安全HTTPS事务总是要求使用服务器证书的。在一个Web服务器上执行安全事务，比如提交信用卡信息时，你总是希望是在与你所认为的那个组织对话。由知名权威机构颁发的服务器证书可以帮助你在发送信用卡或私人信息之前评估你对服务器的信任度。</p>
<h1 id="站点证书的有效性"><a href="#站点证书的有效性" class="headerlink" title="站点证书的有效性"></a>站点证书的有效性</h1><p>SSL自身不要求用户检查Web服务器证书，但大部分现代浏览器都会对证书进行简单的完整性检查，并为用户提供进一步彻查的手段。验证步骤如下所示：</p>
<div class="note info">
            <ol><li><strong>日期检测</strong><br>首先，浏览器检查证书的起始日期和结束日期，以确保证书仍然有效。如果证书过期了，或者还未被激活，则证书有效性验证失败，浏览器显示一条错误信息。</li><li><strong>签名颁发者可信度检测</strong><br>每个证书都是由某些证书颁发机构（CA）签发的，它们负责为服务器担保。证书有不同的等级，每种证书都要求不同级别的背景验证。</li><li><strong>签名检测</strong><br>一旦判定签名授权是可信的，浏览器就要对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性。</li><li><strong>站点身份检测</strong><br>为防止服务器复制其他人的证书，或拦截其他人的流量，大部分浏览器都会试着去验证证书中的域名与它们所对话的服务器的域名是否匹配。服务器证书中通常都包含一个域名，但有些CA会为一组或一群服务器创建一些包含了服务器名称列表或通配域名的证书。如果主机名与证书中的标识符不匹配，面向用户的客户端要么就去通知用户，要么就以表示证书不正确的差错报文来终止连接。</li></ol>
          </div>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title>Array</title>
    <url>/posts/6e01c1fe/</url>
    <content><![CDATA[<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><h2 id="ES5-及之前"><a href="#ES5-及之前" class="headerlink" title="ES5 及之前"></a>ES5 及之前</h2><p>数组的每一项都可以保存任何类型的数据，可以通过 <code>Array</code> 构造器和数组字面量语法两种方式创建数组，如果通过 <code>Array</code> 构造器创建数组，<code>new</code> 操作符可以省略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'red'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Array</span>(<span class="string">'red'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> c = [<span class="string">'red'</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 1 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 1 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 1 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <ul><li><strong>通过数组的 length 可以清空或截断数组。</strong></li><li><strong>数组会自动将字符串索引转换为对应数值索引，即<code>array[&#39;0&#39;] === array[0]</code>。</strong></li></ul>
          </div>
<h2 id="Array-构造器的怪异点"><a href="#Array-构造器的怪异点" class="headerlink" title="Array 构造器的怪异点"></a>Array 构造器的怪异点</h2><div class="note warning">
            <p><strong>通过 <code>Array</code> 构造器创建数组时，如果只传递一个数值，会创建一个有 <code>length</code> 属性的数组，但内部空空如也，无法进行如 <code>forEach</code> 等迭代操作。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> normal = <span class="built_in">Array</span>(<span class="string">'3'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ '3' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(normal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> empty = <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ &lt;3 empty items&gt; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(empty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(empty.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; empty.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 0 undefined</span></span><br><span class="line">  <span class="comment">// 1 undefined</span></span><br><span class="line">  <span class="comment">// 2 undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(i, empty[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">empty.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="用-Array-apply-创建数组"><a href="#用-Array-apply-创建数组" class="headerlink" title="用 Array.apply 创建数组"></a>用 Array.apply 创建数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 0 undefined</span></span><br><span class="line">  <span class="comment">// 1 undefined</span></span><br><span class="line">  <span class="comment">// 2 undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(index, item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="通过解构-amp-迭代器创建数组"><a href="#通过解构-amp-迭代器创建数组" class="headerlink" title="通过解构&amp;迭代器创建数组"></a>通过解构&amp;迭代器创建数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...Array(<span class="number">3</span>).entries()];</span><br><span class="line"><span class="keyword">var</span> b = [...Array(<span class="number">3</span>).keys()];</span><br><span class="line"><span class="keyword">var</span> c = [...Array(<span class="number">3</span>).values()];</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ [ 0, undefined ], [ 1, undefined ], [ 2, undefined ] ]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 0, 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>
<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h2><p>ES6 引入了 <code>Array.of()</code> 方法来解决 <code>Array</code> 构造器创建数组的怪异点。该方法的作用非常类似 <code>Array</code> 构造器，但在使用单个数值参数的时候并不会导致特殊结果。<code>Array.of()</code> 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。下面例子演示了 <code>Array.of()</code> 的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">0</span>])           </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>])           </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Array</span>.of(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.length)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b[<span class="number">0</span>])           </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Array</span>.of(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c.length)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// '2'</span></span><br><span class="line"><span class="built_in">console</span>.log(c[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><code>Array.of()</code> 方法并没有使用 <code>Symbol.species</code> 属性来决定返回值的类型，而是使用了当前的构造器（即 <code>of()</code> 方法内部的 <code>this</code>）来做决定。例如，<code>MyArray.of()</code> 返回 <code>MyArray</code> 类型的实例，<code>Array.of()</code> 返回 <code>Array</code> 类型的实例。</p>
          </div>
<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h2><p>将<strong>可迭代对象</strong>或者<strong>类数组对象</strong>作为第一个参数传入，<code>Array.from()</code> 就能返回一个数组。这里有个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 args</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处调用 <code>Array.from()</code> 方法，使用 <code>arguments</code> 对象创建了一个新数组 <code>args</code>，它是一个数组实例，并且包含了 <code>arguments</code> 对象的所有项，同时还保持了项的顺序。</p>
<div class="note warning">
            <p>与 <code>Array.of()</code> 一样，<code>Array.from()</code> 方法同样使用当前的构造器（即 <code>from()</code> 方法内部的 <code>this</code>）来决定要返回什么类型的数组。例如，<code>MyArray.from()</code> 返回 <code>MyArray</code> 类型的实例，<code>Array.from()</code> 返回 <code>Array</code> 类型的实例。</p>
          </div>
<p>如果你想实行进一步的数组转换，你可以向 <code>Array.from()</code> 方法传递一个映射用的函数作为第二个参数。此函数会将类数组对象的每一个值转换为目标形式，并将其存储在目标数组的对应位置上。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, value =&gt; value + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 2, 3, 4 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>
<p>如果映射函数需要在对象上工作，你可以手动传递第三个参数给 <code>Array.from()</code> 方法，从而指定映射函数内部的 <code>this</code> 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> helper = &#123;</span><br><span class="line">  diff: <span class="number">1</span>,</span><br><span class="line">  add (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="keyword">this</span>.diff</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 2, 3, 4 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>只要一个对象有 <code>length</code> 属性，<code>Array.from()</code> 就会可以通过它得到对应长度的数组</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(a))</span><br></pre></td></tr></table></figure>
<h1 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h1><p>ES5 提出了 <code>Array.isArray()</code> 方法来检测数组，不过并不是所有版本的浏览器都兼容这个方法。兼容各种情况的方法如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h1><p><code>join()</code>接收一个字符串作为参数，然后以该字符串为分隔符将数组（或类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组中只有一个元素，那么将返回该元素的字符串形式而不使用分隔符。如果没有给<code>join()</code>传递参数，则默认使用<code>,</code>作为分隔符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// "Fire,Air,Water"</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'Fire'</span>, <span class="string">'Air'</span>, <span class="string">'Water'</span>].join())</span><br><span class="line"></span><br><span class="line"><span class="comment">// "FireAirWater"</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'Fire'</span>, <span class="string">'Air'</span>, <span class="string">'Water'</span>].join(<span class="string">''</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// "Fire-Air-Water"</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'Fire'</span>, <span class="string">'Air'</span>, <span class="string">'Water'</span>].join(<span class="string">'-'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// "[object Object],[object Object]"</span></span><br><span class="line"><span class="built_in">console</span>.log([&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;].join())</span><br></pre></td></tr></table></figure>
<h1 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h1><p>栈是一种后进先出的数据结构，ECMAScript 为数组提供了 <code>push()</code> 和 <code>pop()</code> 方法来实现类似栈的行为。</p>
<div class="note info">
            <ul><li><code>push()</code> 方法接收任意数量的参数，把他们逐个添加到数组末尾，然后返回修改后数组的长度.</li><li><code>pop()</code> 方法从数组末尾移除最后一项，将数组长度减 1，然后返回移除的项。</li></ul>
          </div>
<h1 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h1><p>队列的访问规则是先见先出，可以通过 <code>unshift()</code> 和 <code>shift()</code> 配合实现。</p>
<div class="note info">
            <ul><li><code>unshift()</code> 方法在数组前端添加任意个项, 然后返回新数组的长度。</li><li><code>shift()</code> 方法移除数组中的第一项，将数组长度减 1，然后返回移除的项.</li></ul>
          </div>
<h1 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h1><p><code>reverse()</code> 方法会反转数组项的顺序。<code>sort()</code> 方法默认按升序排列数组项，并且可以接收一个比较函数作为参数。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">a.reverse()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [6, 2, 3, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line">a.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span> (<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line">values.sort(compare)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [15, 10, 5, 1, 0]</span></span><br><span class="line"><span class="built_in">console</span>.log(values)</span><br></pre></td></tr></table></figure>
<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p><code>concat()</code> 方法会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。<br>如果传递的参数是一个或多个数组，则会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单的添加到结果数组的末尾。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">'yellow'</span>, [<span class="string">'black'</span>, <span class="string">'brown'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ['red', 'green', 'blue']</span></span><br><span class="line"><span class="built_in">console</span>.log(colors)  </span><br><span class="line"><span class="comment">// ['red', 'green', 'blue', 'yellow', 'black', 'brown']   </span></span><br><span class="line"><span class="built_in">console</span>.log(colors2)</span><br></pre></td></tr></table></figure>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><code>slice(start, end)</code> 方法返回一个由原数组索引从 <code>start</code> 到 <code>end-1</code> 的项组成的新数组。</p>
<div class="note info">
            <ul><li>如果省略 <code>start</code>，则默认从 0 开始。</li><li>如果省略 <code>end</code> 或 <code>end</code> 大于数组长度，则 <code>slice</code> 方法会一直提取到数组末尾（包括最后一个元素）</li><li>如果 <code>start</code> 或 <code>end</code> 中有负数，则用数组长度加上该数来确定相应的索引。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// colors2 = [2, 3]</span></span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>, <span class="number">3</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// colors3 = [1, 2, 3]</span></span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="literal">undefined</span>, <span class="number">3</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// colors4 = [2, 3, 4]</span></span><br><span class="line"><span class="keyword">var</span> colors4 = colors.slice(<span class="number">1</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// colors5 = [2, 3, 4]    </span></span><br><span class="line"><span class="keyword">var</span> colors5 = colors.slice(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// colors6 = [2]        </span></span><br><span class="line"><span class="keyword">var</span> colors6 = colors.slice(<span class="number">1</span>, <span class="number">2</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// colors7 = [2]         </span></span><br><span class="line"><span class="keyword">var</span> colors7 = colors.slice(<span class="number">-3</span>, <span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p><code>splice(start, deleteNum, replaceItem, replaceItem, replaceItem, ...)</code> 方法返回一个数组，该数组包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。它是最灵活的一个数组操作方法，它可以实现对原始数组的删除、插入和替换操作。</p>
<div class="note info">
            <ul><li><code>start</code>：操作起始位置的索引。</li><li><code>deleteNum</code>：要删除的项数。</li><li><code>replaceItem</code>：要插入的项,一个或多个。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ['green', 'blue']</span></span><br><span class="line"><span class="built_in">console</span>.log(colors)        </span><br><span class="line"><span class="comment">// ['red']</span></span><br><span class="line"><span class="built_in">console</span>.log(removed)       </span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'yellow'</span>, <span class="string">'orange'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ['green', 'yellow', 'orange', 'blue']</span></span><br><span class="line"><span class="built_in">console</span>.log(colors)      </span><br><span class="line"><span class="comment">// []  </span></span><br><span class="line"><span class="built_in">console</span>.log(removed)       </span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">'red'</span>, <span class="string">'purple'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ['green', 'red', 'purple', 'orange', 'blue']</span></span><br><span class="line"><span class="built_in">console</span>.log(colors)    </span><br><span class="line"><span class="comment">// ['yellow']    </span></span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br></pre></td></tr></table></figure>
<h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><div class="note info">
            <p><code>fill(value, start, end + 1)</code> 方法使用参数 <code>value</code> 去替换数组索引从 <code>start</code> 至 <code>end</code> 的项。如果提供的起始位置（<code>start</code>）或结束位置（<code>end + 1</code>）为负数，则它们会被加上数组的长度来算出最终的位置。请观察下面的例子：</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">numbers.fill(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 1, 1, 1 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br><span class="line"></span><br><span class="line">numbers.fill(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 2, 2, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br><span class="line"></span><br><span class="line">numbers.fill(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 3, 3, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>需要注意的是，<code>fill()</code> 方法是使用浅复制来完成的。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">a.fill([]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ [], [] ]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>].push(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ [ 33 ], [ 33 ] ]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">0</span>] === a[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="copyWith"><a href="#copyWith" class="headerlink" title="copyWith"></a>copyWith</h2><p><code>copyWithin()</code> 方法与 <code>fill()</code> 类似，可以一次性修改数组的多个元素。不过，与 <code>fill()</code> 使用单个值来修改数组不同，<code>copyWithin()</code> 方法允许你在数组内部复制自身元素。为此你需要传递两个参数给 <code>copyWithin()</code> 方法：从什么位置开始进行修改，以及被用来复制的数据的起始位置索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 2 的位置开始粘贴</span></span><br><span class="line"><span class="comment">// 从索引 0 的位置开始复制数据</span></span><br><span class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 2, 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>copyWithin()</code> 方法总是会一直复制到数组末尾，不过你还可以提供一个可选参数来限制到底有多少元素会被修改。这第三个参数指定了复制停止的位置（不包括该位置自身），这里有个范例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 2 的位置开始粘贴</span></span><br><span class="line"><span class="comment">// 从索引 0 的位置开始复制数据</span></span><br><span class="line"><span class="comment">// 在索引 1 的位置停止复制</span></span><br><span class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 2, 1, 4 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>类似于 <code>fill()</code> 方法，如果你向 <code>copyWithin()</code> 方法传递负数参数，数组的长度会自动被加到该参数的值上，以便算出正确的索引位置。</p>
          </div>
<h1 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h1><p><code>indexOf(searchValue[, fromIndex])</code> 和 <code>lastIndexOf(searchValue[, fromIndex])</code> 都是找到就返回索引，找不到就返回 -1。</p>
<h1 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h1><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><div class="note info">
            <p><code>arr.every(callback[, thisArg])</code>：对每个数组元素调用 <code>callback()</code> 方法，如果所有 <code>callback()</code> 的返回值都等价于 <code>true</code>，返回 <code>true</code>。否则返回 <code>false</code>。</p><ul><li><code>callback(item, index, array)</code>：<ul><li><code>item</code>：元素。</li><li><code>index</code>：元素对应索引。</li><li><code>array</code>：<code>arr</code> 的引用。</li></ul></li><li><code>thisArg</code>：作用域对象。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.every(<span class="function">(<span class="params">item</span>) =&gt;</span> item));</span><br></pre></td></tr></table></figure>
<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><div class="note info">
            <p><code>arr.some(callback[, thisArg])</code>：对每个数组元素调用 <code>callback()</code> 方法，只要有一个 <code>callback()</code> 的返回值都等价于 <code>true</code>，返回 <code>true</code>。否则返回 <code>false</code>。</p><ul><li><code>callback(item, index, array)</code>：<ul><li><code>item</code>：元素。</li><li><code>index</code>：元素对应索引。</li><li><code>array</code>：<code>arr</code> 的引用。</li></ul></li><li><code>thisArg</code>：作用域对象。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> item));</span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><div class="note info">
            <p><code>arr.every(callback[, thisArg])</code>：对每个数组元素调用 <code>callback()</code> 方法，返回 <code>callback()</code> 返回值等价于 <code>true</code> 对应的元素所组成的新数组。</p><ul><li><code>callback(item, index, array)</code>：<ul><li><code>item</code>：元素。</li><li><code>index</code>：元素对应索引。</li><li><code>array</code>：<code>arr</code> 的引用。</li></ul></li><li><code>thisArg</code>：作用域对象。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><div class="note info">
            <ul><li><code>arr.forEach(callback[, thisArg])</code>：对每个数组元素调用 <code>callback()</code> 方法，该方法没有返回值。<ul><li><code>callback(item, index, array)</code>：<ul><li><code>item</code>：元素。</li><li><code>index</code>：元素对应索引。</li><li><code>array</code>：<code>arr</code> 的引用。</li></ul></li><li><code>thisArg</code>：作用域对象。</li></ul></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  item.index = index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, &#123; index: 1 &#125;, &#123; index: 2 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><div class="note info">
            <ul><li><code>arr.map(callback[, thisArg])</code>：对每个数组元素调用 <code>callback()</code> 方法，返回所有 <code>callback()</code> 返回值组成的新数组。<ul><li><code>callback(item, index, array)</code>：<ul><li><code>item</code>：元素。</li><li><code>index</code>：元素对应索引。</li><li><code>array</code>：<code>arr</code> 的引用。</li></ul></li><li><code>thisArg</code>：作用域对象。</li></ul></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !!item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [false, true, true]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><div class="note info">
            <ul><li><code>arr.reduce(callback[, initialValue])</code>：对每个数组元素调用 <code>callback()</code> 方法，返回最后一个 <code>callback()</code> 的返回值。<ul><li><code>callback(accumulator, currentValue[, index[, array]])</code>：该回调函数会在数组中进行迭代，它的返回值将传递给下一次迭代的 <code>accumulator</code> 参数，它的参数介绍如下：<ul><li><code>accumulator</code>：上一次迭代的返回值。</li><li><code>currentValue</code>：迭代的当前值。</li><li><code>index</code>：当前索引。</li><li><code>array</code>：数组对象。</li></ul></li><li><code>initialValue</code>：作为 <code>callback()</code> 进行第一次迭代时 <code>accumulator</code> 的值。如果没有传入这个参数，那么 <code>callback()</code> 在第一次迭代时会将数组的第一项作为 <code>accumulator</code> 的值。</li></ul></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> sum1 = values.reduce(<span class="function">(<span class="params">acc, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'acc: '</span> + acc, <span class="string">'cur: '</span> + cur, <span class="string">'index: '</span> + index)</span><br><span class="line">    <span class="keyword">return</span> acc + cur</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// acc: 1 cur: 2 index: 1</span></span><br><span class="line"><span class="comment">// acc: 3 cur: 3 index: 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum2 = values.reduce(<span class="function">(<span class="params">acc, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'acc: '</span> + acc, <span class="string">'cur: '</span> + cur, <span class="string">'index: '</span> + index)</span><br><span class="line">    <span class="keyword">return</span> acc + cur</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// acc: 10 cur: 1 index: 0</span></span><br><span class="line"><span class="comment">// acc: 11 cur: 2 index: 1</span></span><br><span class="line"><span class="comment">// acc: 13 cur: 3 index: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(sum1)    </span><br><span class="line"><span class="comment">// 16   </span></span><br><span class="line"><span class="built_in">console</span>.log(sum2)</span><br></pre></td></tr></table></figure>
<h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><div class="note info">
            <ul><li><code>arr.reduceRight(callback[, initialValue])</code>：按照<strong>倒序</strong>对每个数组元素调用 <code>callback()</code> 方法，返回最后一个 <code>callback()</code> 的返回值。<ul><li><code>callback(accumulator, currentValue[, index[, array]])</code>：该回调函数会在数组中进行迭代，它的返回值将传递给下一次迭代的 <code>accumulator</code> 参数，它的参数介绍如下：<ul><li><code>accumulator</code>：上一次迭代的返回值。</li><li><code>currentValue</code>：迭代的当前值。</li><li><code>index</code>：当前索引。</li><li><code>array</code>：数组对象。</li></ul></li><li><code>initialValue</code>：作为 <code>callback()</code> 进行第一次迭代时 <code>accumulator</code> 的值。如果没有传入这个参数，那么 <code>callback()</code> 在第一次迭代时会将数组的最后一项作为 <code>accumulator</code> 的值。</li></ul></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> sum1 = values.reduceRight(<span class="function">(<span class="params">acc, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'acc: '</span> + acc, <span class="string">'cur: '</span> + cur, <span class="string">'index: '</span> + index)</span><br><span class="line">    <span class="keyword">return</span> acc + cur</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// acc: 3 cur: 2 index: 1</span></span><br><span class="line"><span class="comment">// acc: 5 cur: 1 index: 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum2 = values.reduceRight(<span class="function">(<span class="params">acc, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'acc: '</span> + acc, <span class="string">'cur: '</span> + cur, <span class="string">'index: '</span> + index)</span><br><span class="line">    <span class="keyword">return</span> acc + cur</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// acc: 10 cur: 3 index: 2</span></span><br><span class="line"><span class="comment">// acc: 13 cur: 2 index: 1</span></span><br><span class="line"><span class="comment">// acc: 15 cur: 1 index: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(sum1)       </span><br><span class="line"><span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2)</span><br></pre></td></tr></table></figure>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><div class="note info">
            <ul><li><code>arr.find(callback[, thisArg])</code>：对每个数组元素调用 <code>callback()</code> 方法，如果某一个 <code>callback()</code> 返回值为 <code>true</code>，则返回其对应的数组元素。如果有多个 <code>callback()</code> 都返回 <code>true</code>，则只返回第一个。如果所有 <code>callback()</code> 都返回 <code>false</code>，则返回 <code>undefined</code>。<ul><li><code>callback(item, index, array)</code>：<ul><li><code>item</code>：元素。</li><li><code>index</code>：元素对应索引。</li><li><code>array</code>：<code>arr</code> 的引用。</li></ul></li><li><code>thisArg</code>：作用域对象。</li></ul></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.find(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item === <span class="number">2</span> || index === <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><div class="note info">
            <ul><li><code>arr.find(callback[, thisArg])</code>：对每个数组元素调用 <code>callback()</code> 方法，如果某一个 <code>callback()</code> 返回值为 <code>true</code>，则返回其对应的索引。如果有多个 <code>callback()</code> 都返回 <code>true</code>，则只返回第一个。如果所有 <code>callback()</code> 都返回 <code>false</code>，则返回 -1`。<ul><li><code>callback(item, index, array)</code>：<ul><li><code>item</code>：元素。</li><li><code>index</code>：元素对应索引。</li><li><code>array</code>：<code>arr</code> 的引用。</li></ul></li><li><code>thisArg</code>：作用域对象。</li></ul></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.findIndex(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item === <span class="number">2</span> || index === <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">4</span>));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>选择器</title>
    <url>/posts/7c8269b4/</url>
    <content><![CDATA[<h1 id="选择器种类"><a href="#选择器种类" class="headerlink" title="选择器种类"></a>选择器种类</h1><h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择器<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"my-span"</span>&gt;</span>选择器<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.my-span</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"my-span"</span>&gt;</span>选择器<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#my-span</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">* &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><div class="note info">
            <p>假设元素内设置了<code>data-attr=&quot;value1 value2 value3&quot;</code>，下面介绍对它使用属性选择器的几种方式：</p><ul><li><code>[data-attr]</code>：根据属性名称；</li><li><code>[data-attr=&quot;value1 value2 value3&quot;]</code>：根据属性名和属性值；</li><li><code>[data-attr^=&quot;val&quot;]</code>：以……开头；</li><li><code>[data-attr*=&quot;value2&quot;]</code>：包含……；</li><li><code>[data-attr$=&quot;3&quot;]</code>：以……结尾。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-attr</span>=<span class="string">"value1 value2 value3"</span>&gt;</span>选择器<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-attr">[data-attr]</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-attr">[data-attr=<span class="string">"value1 value2 value3"</span>]</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-attr">[data-attr^=<span class="string">"val"</span>]</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-attr">[data-attr*=<span class="string">"value2"</span>]</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-attr">[data-attr$=<span class="string">"3"</span>]</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="选择器使用规则"><a href="#选择器使用规则" class="headerlink" title="选择器使用规则"></a>选择器使用规则</h1><div class="note info">
            <p>选择器的组合使用：</p><ul><li><code>div, span</code>：同时选择<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>元素；</li><li><code>div.classValue</code>：选择<code>class</code>属性值包含<code>classValue</code>的<code>&lt;div&gt;</code>元素；</li><li><code>div#idValue</code>：选择<code>id</code>属性值为<code>idValue</code>的<code>&lt;div&gt;</code>元素；</li><li><code>div[data-attr]</code>：选择具有<code>data-attr</code>属性的<code>&lt;div&gt;</code>元素；</li><li><code>div.class1.class2</code>：选择<code>class</code>属性值同时包含<code>class1</code>和<code>class2</code>的<code>&lt;div&gt;</code>元素。</li></ul><hr><p>根据结构来使用选择器：</p><ul><li><code>selector1 selector2</code>：当<code>selector2</code>是<code>selector1</code>的后代元素时，选择<code>selector2</code>；</li><li><code>selector1 &gt; selector2</code>：当<code>selector2</code>是<code>selector1</code>的子元素时，选择<code>selector2</code>；</li><li><code>selector1 + selector2</code>：当<code>selector2</code>是<code>selector1</code>的同胞元素，且<code>selector2</code>紧跟着<code>selector1</code>时，选择<code>selector2</code>；</li><li><code>selector1 ~ selector2</code>：当<code>selector2</code>是<code>selector1</code>的同胞元素，且<code>selector2</code>位于<code>selector1</code>后面时，选择<code>selector2</code>；</li><li><code>selector1 * selector2</code>：当<code>selector2</code>是<code>selector1</code>的后代元素，且<code>selector2</code>不是<code>selector1</code>的子元素时，选择<code>selector2</code>。</li></ul>
          </div>
<h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Pseudo-classes_and_pseudo-elements" target="_blank" rel="noopener">MDN上伪类和伪元素的总结</a></p>
<div class="note info">
            <ul><li>伪类用于给已经存在于文档树中的元素添加不存在的类，并为其添加样式；</li><li>伪元素用于创建文档树中不存在的元素，并为其添加样式。</li></ul>
          </div>
<h1 id="样式层叠"><a href="#样式层叠" class="headerlink" title="样式层叠"></a>样式层叠</h1><h2 id="样式来源"><a href="#样式来源" class="headerlink" title="样式来源"></a>样式来源</h2><div class="note info">
            <p>以下就是浏览器层叠各个来源样式的顺序：</p><ul><li>浏览器默认样式表</li><li>用户样式表</li><li>作者链接样式表（按照它们链接到页面的先后顺序）</li><li>作者嵌入样式</li><li>作者行内样式</li></ul>
          </div>
<h2 id="特指度"><a href="#特指度" class="headerlink" title="特指度"></a>特指度</h2><div class="note info">
            <ol><li><code>100</code>：ID选择器。</li><li><code>10</code>：类选择器、伪类选择器和属性选择器。</li><li><code>1</code>：标签选择器和伪元素。</li></ol>
          </div>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/HTML%26CSS/CSS%E9%80%89%E6%8B%A9%E5%99%A8/%E7%89%B9%E6%8C%87%E5%BA%A6.png" alt="特指度"></p>
<h2 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a>层叠规则</h2><div class="note info">
            <ol><li>带有<code>!import</code>的优先级最高（开挂一样的存在）。</li><li>行内样式优先级仅次于<code>!import</code>。</li><li>抛开<code>!import</code>和行内样式，其他情况下，特指度大的优先级高。</li><li>当特指度相同时，嵌入样式表 &gt; 链接样式表 &gt; 用户样式表 &gt; 浏览器默认样式表。</li><li>当特指度相同时，则后出现的优先级高。</li></ol>
          </div>]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title>Class</title>
    <url>/posts/e1a12c4d/</url>
    <content><![CDATA[<h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><h2 id="基本的类声明"><a href="#基本的类声明" class="headerlink" title="基本的类声明"></a>基本的类声明</h2><p>类声明以 <code>class</code> 关键字开始，其后是类的名称。剩余部分的语法看起来就像对象字面量中的方法简写，并且在方法之间不需要使用逗号。作为范例，此处有个简单的类声明：</p>
<div class="note warning">
            <p><strong>类语法中，必须使用对象方法简写的形式来定义构造器、原型方法、访问器属性和静态方法等。不允许使用 <code>=</code>、<code>:</code> 和箭头函数来定义。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于 PersonType 构造器</span></span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">  sayName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'Nicholas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">person.sayName()                                    </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass)          </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)               </span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)                     </span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName)</span><br></pre></td></tr></table></figure>
<p>类声明允许你在其中使用特殊的 <code>constructor</code> 方法名称直接定义一个构造器，而不需要先定义一个函数再把它当做构造器使用。由于类的方法使用了简写语法，于是就不再需要使用 <code>function</code> 关键字。<code>constructor</code> 之外的方法名称则没有特别的含义，因此可以随你高兴自由添加方法。</p>
<p>自有属性：该属性出现在实例上而不是原型上，只能在类的构造器或方法内部进行创建。在本例中，<code>name</code> 就是一个自有属性。建议应在构造器函数内创建所有可能出现的自有属性，这样在类中声明变量就会被限制在单一位置（有助于代码检查）。</p>
<h2 id="为何要使用类的语法"><a href="#为何要使用类的语法" class="headerlink" title="为何要使用类的语法"></a>为何要使用类的语法</h2><div class="note info">
            <ul><li>类声明不会被提升，这与函数定义不同。类声明的行为与 <code>let</code> 相似，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。</li><li>类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。</li><li>类的所有方法都是不可枚举的。</li><li>类的所有方法内部都没有 <code>[[Construct]]</code>，因此使用 <code>new</code> 来调用它们会抛出错误。</li><li>调用类构造器时不使用 <code>new</code>，会抛出错误。</li><li>在类的内部不允许重写类名，在类的外部则可以。</li></ul>
          </div>
<p>这样看来，上例中的 <code>PersonClass</code> 声明实际上就直接等价于以下未使用类语法的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PersonClass = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 确认函数被调用时使用了 new</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Constructor must be called with new.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(PersonClass.prototype, <span class="string">'sayName'</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 确认函数被调用时没有使用 new</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Method cannot be called with new.'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> PersonClass</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>首先要注意这里有两个 <code>PersonClass</code> 声明：一个在外部作用域的 <code>let</code> 声明，一个在 IIFE 内部的 <code>const</code> 声明。这就是为何类的方法不能对类名进行重写、而类外部的代码则被允许。构造器函数检查了 <code>new.target</code>，以保证被调用时使用了 <code>new</code>，否则就抛出错误。接下来，<code>sayName()</code> 方法被定义为不可枚举，并且此方法也检查了 <code>new.target</code>，它则要保证在被调用时没有使用 <code>new</code>。最后一步是将构造器函数返回出去。</p>
<h1 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h1><p>类与函数有相似之处，即它们都有两种形式：声明与表达式。函数声明与类声明都以适当的关键字为起始（分别是 <code>function</code> 与 <code>class</code>），随后是标识符（即函数名或类名）。函数具有一种表达式形式，无须在 <code>function</code> 后面使用标识符。类似的，类也有不需要标识符的表达式形式。类表达式被设计用于变量声明，或可作为参数传递给函数。</p>
<h2 id="基本的类表达式"><a href="#基本的类表达式" class="headerlink" title="基本的类表达式"></a>基本的类表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'Nicholas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">person.sayName()                                    </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass)          </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)               </span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)                     </span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName)</span><br></pre></td></tr></table></figure>
<h2 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h2><p>上面的例子使用了一个匿名的类表达式，不过就像函数表达式那样，你也可以为类表达式命名。为此需要在 <code>class</code> 关键字后添加标识符，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)                 </span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2)</span><br></pre></td></tr></table></figure>
<p>与命名函数表达式相似，类表达式的标识符 <code>PersonClass2</code> 只在类定义内部存在，在外部则不存在。</p>
<h1 id="作为一级公民的类"><a href="#作为一级公民的类" class="headerlink" title="作为一级公民的类"></a>作为一级公民的类</h1><p>ES6 延续了传统，让类成为一级公民，这就使得类可以被多种方式所使用。例如，类可以作为参数传入函数，也可以立即调用类构造器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'Nicholas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">person.sayName()</span><br></pre></td></tr></table></figure>
<h1 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h1><p>自有属性需要在类构造器中创建，而类还允许你在原型上定义访问器属性。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> html () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> html (value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">'html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span> <span class="keyword">in</span> descriptor)           </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'set'</span> <span class="keyword">in</span> descriptor)           </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable)</span><br></pre></td></tr></table></figure>
<h1 id="需计算的成员名"><a href="#需计算的成员名" class="headerlink" title="需计算的成员名"></a>需计算的成员名</h1><p>类方法与类访问器属性也都能使用需计算的名称。语法相同于对象字面量中的需计算名称。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'sayName'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName] () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">'Nicholas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">me.sayName()                    </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> propertyName = <span class="string">'html'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> [propertyName] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> [propertyName] (value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h1><p>在类语法中，允许将任何方法变为一个生成器。因此可以使用 <code>Symbol.iterator</code> 来定义生成器方法，从而定义出类的默认迭代器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator] () &#123;</span><br><span class="line">    <span class="keyword">yield</span> *<span class="keyword">this</span>.items</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> Collection()</span><br><span class="line">collection.items.push(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">  <span class="comment">// 依次输出 1, 2, 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><p>直接在构造器上添加额外方法来模拟静态成员，这在 ES5 及更早版本中是另一个通用的模式。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonClass</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">PersonClass.create = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">PersonClass.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = PersonClass.create(<span class="string">'Nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p>在其他变成语言中，<code>PersonClass.create()</code> 会被认定为一个静态方法，它的数据不依赖 <code>PersonClass</code> 的任何实例。ES6 的类简化了静态成员的创建，只要在方法与访问器属性的名称前添加正式的 <code>static</code> 标注。作为一个例子，此处有个与上例等价的类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等价于 PersonType.create</span></span><br><span class="line">  <span class="keyword">static</span> create (name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = PersonClass.create(<span class="string">'Nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>类中的任何方法与访问器属性上都可以使用 <code>static</code> 关键字，唯一的限制是不能将它用于 <code>constructor</code> 方法。</strong></p>
<h1 id="使用派生类进行继承"><a href="#使用派生类进行继承" class="headerlink" title="使用派生类进行继承"></a>使用派生类进行继承</h1><p>ES6 之前，实现自定义类型的继承是个繁琐的过程。类的出现让继承工作变得更轻易，使用熟悉的 <code>extends</code> 关键字来指定当前类所需要继承的函数即可。生成的类的原型会被自动调整，而你还能调用 <code>super()</code> 方法来访问基类的构造器。此处有个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length) &#123;</span><br><span class="line">    <span class="comment">// 与 Rectangle.call(this, length, length) 相同</span></span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(square.getArea())               </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)</span><br></pre></td></tr></table></figure>
<p>此次 <code>Square</code> 类使用了 <code>extends</code> 关键字继承了 <code>Rectangle</code>。<code>Square</code> 构造器使用了 <code>super()</code> 配合指定参数调用了 <code>Rectangle</code> 的构造器。</p>
<p>继承了其他类的类被称为派生类。如果派生类指定了构造器，就需要使用 <code>super()</code>，否则会造成错误。若你选择不使用构造器，<code>super()</code> 方法会被自动调用，并会使用创建新实例时提供的所有参数。例如，下列两个类是完全相同的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例中的第二个类展示了与所有派生类默认构造器等价的写法，所有的参数都按顺序传递给了基类的构造器。在当前需求下，这种做法并不完全准确，因为 <code>Square</code> 构造器只需要单个参数，因此最好手动定义构造器。</p>
<div class="note info">
            <p>使用 <code>super()</code> 时需要牢记以下几点：</p><ul><li>你只能在派生类中使用 <code>super()</code>。若尝试在非派生的类或函数中使用它，就会抛出错误。</li><li>在构造器中，你必须在访问 <code>this</code> 之前调用 <code>super()</code>。由于 <code>super()</code> 负责初始化 <code>this</code>，因此试图先访问 <code>this</code> 自然就会造成错误（具体原因看本文的<a href="https://aadonkeyz.com/posts/e1a12c4d/#继承内置对象">继承内置对象</a>部分）。</li><li>唯一能避免调用 <code>super()</code> 的办法，是从派生类的构造器中返回一个对象。</li></ul>
          </div>
<h2 id="屏蔽类方法"><a href="#屏蔽类方法" class="headerlink" title="屏蔽类方法"></a>屏蔽类方法</h2><p>派生类中的方法总是会屏蔽基类的同名方法。例如，你可以将 <code>getArea()</code> 方法添加到 <code>Square</code> 类，以便重定义它的功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写并屏蔽 Rectangle.prototype.getArea()</span></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>getArea()</code> 已经被定义为 <code>Square</code> 的一部分，<code>Rectangle.prototype.getArea()</code> 方法就不能在 <code>Square</code> 的任何实例上被调用。当然，你总是可以使用 <code>super.getArea()</code> 方法来调用基类中的同名方法，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写、屏蔽并调用了 Rectangle.prototype.getArea()</span></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getArea()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用这种方式使用 <code>super</code>，其效果等同于在对象的简写方法中使用 <code>super</code>。</p>
<h2 id="继承静态成员"><a href="#继承静态成员" class="headerlink" title="继承静态成员"></a>继承静态成员</h2><p>如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> create (length, width) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Rectangle(length, width)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length) &#123;</span><br><span class="line">    <span class="comment">// 与 Rectangle.call(this, length, length) 相同</span></span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea())                 </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square)</span><br></pre></td></tr></table></figure>
<p>在此代码中，一个新的静态方法 <code>create()</code> 被添加到 <code>Rectangle</code> 类中。通过继承，该方法会以 <code>Square.create()</code> 的形式存在，并且其行为方式与 <code>Rectangle.create()</code> 一样。</p>
<h2 id="从表达式中派生类"><a href="#从表达式中派生类" class="headerlink" title="从表达式中派生类"></a>从表达式中派生类</h2><p>在 ES6 中派生类的最强大能力，或许就是能够从表达式中派生类。只要一个表达式能够返回一个具有 <code>[[Construct]]</code> 属性以及原型的函数，你就可以对其使用 <code>extends</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span> (<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.length = length</span><br><span class="line">  <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())                </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle)</span><br></pre></td></tr></table></figure>
<p><code>Rectangle</code> 被定义为 ES5 风格的构造器，而 <code>Square</code> 则是一个类。由于 <code>Rectangle</code> 具有 <code>[[Construct]]</code> 以及原型，<code>Square</code> 类就能直接继承它。</p>
<div class="note info">
            <p><strong><code>extends</code> 可以被用于继承 <code>null</code>，这好像违反了前面的说法，把这个当作特殊情况吧！</strong></p>
          </div>
<p><code>extends</code> 后面能接受任意类型的表达式，这带来了巨大可能性，例如动态地决定所要继承的类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span> (<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.length = length</span><br><span class="line">  <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Rectangle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())                </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle)</span><br></pre></td></tr></table></figure>
<h2 id="继承内置对象"><a href="#继承内置对象" class="headerlink" title="继承内置对象"></a>继承内置对象</h2><p>几乎从 JS 数组出现那天开始，开发者就想通过继承机制来创建他们自己的特殊数组类型。在 ES5 及早期版本中，这是不可能做到的。试图使用传统继承并不能产生功能正确的代码，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置数组的行为</span></span><br><span class="line"><span class="keyword">var</span> colors = []</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)      </span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])          </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ES5 中尝试继承数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)      </span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><code>MyArray</code> 实例上的 <code>length</code> 属性以及数值属性，其行为与内置数组并不一致，因为这些功能并未被涵盖在 <code>Array.apply()</code> 或数组原型中。</p>
<p>在 ES6 中的类，其设计目的之一就是允许从内置对象上进行继承。为了达成这个目的，类的继承模型与 ES5 或更早版本的传统继承模型有轻微差异：</p>
<div class="note warning">
            <p>在 ES5 的传统继承中，<code>this</code> 的值会先被派生类（例如 <code>MyArray</code>）创建，随后基类构造器（例如：<code>Array.apply()</code> 方法）才被调用。这意味着 <code>this</code> 一开始就是 <code>MyArray</code> 的实例，之后才使用了 <code>Array</code> 的附加属性对其进行了装饰。</p><p>在 ES6 基于类的继承中，<code>this</code> 的值会先被基类（<code>Array</code>）创建，随后才被派生类的构造器（<code>MyArray</code>）所修改。结果是 <code>this</code> 初始就拥有作为基类的内置对象的所有功能，并能正确接收与之关联的所有功能。</p>
          </div>
<p>以下范例实际展示了基于类的特殊数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)      </span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><code>MyArray</code> 直接继承了 <code>Array</code>，因此工作方式与正规数组一致。与数值索引属性的互动更新了 <code>length</code> 属性，而操纵 <code>length</code> 属性也能更新索引属性。这意味着你既能适当地继承 <code>Array</code> 来创建你自己的派生类数组，也同样能继承其他的内置对象。</p>
<h2 id="Symbol-species属性"><a href="#Symbol-species属性" class="headerlink" title="Symbol.species属性"></a>Symbol.species属性</h2><p>继承内置对象一个有趣的方面是：任意能返回内置对象实例的方法，在派生类上却会自动返回派生类的实例。因此，若你拥有一个继承了 <code>Array</code> 的派生类 <code>MyArray</code>，诸如 <code>slice()</code> 之类的方法都会返回 <code>MyArray</code> 的实例。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray)          </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray)</span><br></pre></td></tr></table></figure>
<p><code>Symbol.species</code> 知名符号被用于定义一个能返回函数的<strong>静态访问器属性</strong>。每当类实例的方法（<strong>构造器除外</strong>）必须创建一个实例时，<code>Symbol.species</code> 返回的函数就会被用为新实例的构造器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species] () &#123;</span><br><span class="line">    <span class="comment">// 静态成员为类构造器的方法，因此这个 this 指向 MyClass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  clone () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此例中，<code>Symbol.species</code> 知名符号被用于定义 <code>MyClass</code> 的一个静态访问器属性。注意此处只有个 <code>get</code> 函数而没有<code>set</code> 函数，这是因为修改类的 <code>species</code> 是不允许的。</p>
<p><code>Array</code> 使用了 <code>Symbol.species</code> 来指定方法所使用的的类，让其返回值为一个数组。在 <code>Array</code> 派生类中，你可以决定这些继承方法应返回何种类型的对象，正如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray)          </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> <span class="built_in">Array</span>)         </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray)</span><br></pre></td></tr></table></figure>
<h1 id="在类构造器中使用-new-target"><a href="#在类构造器中使用-new-target" class="headerlink" title="在类构造器中使用 new.target"></a>在类构造器中使用 new.target</h1><p>在类的构造器中可以使用 <code>new.target</code> 来判断类是被如何调用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle)</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new.target 就是 Square</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>Square</code> 调用了 <code>Rectangle</code>构造器，因此当 <code>Rectangle</code> 构造器被调用时，<code>new.target</code> 等于 <code>Square</code>。这很重要，因为构造器能根据如何被调用而有不同行为，并且这给了更改这种行为的能力。例如，你可以使用 <code>new.target</code> 来创建一个抽象基类（一个不能被实例化的类），如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This class cannot be instantiated directly.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length, width) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Shape)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: This class cannot be instantiated directly.</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Shape()</span><br></pre></td></tr></table></figure>
<p>此例中的 <code>Shape</code> 类构造器会在 <code>new.target</code> 为 <code>Shape</code> 的时候抛出错误，意味着 <code>new Shape()</code> 永远都会抛出错误。然而，你依然可以将 <code>Shape</code> 用作一个基类，正如 <code>Rectangle</code> 所做的那样。<code>super()</code> 的调用执行了 <code>Shape</code> 构造器，而且 <code>new.target</code> 的值等于 <code>Rectangle</code>，因此该构造器能够无错误地继续执行。</p>
<div class="note info">
            <p>由于调用类时不能缺少 <code>new</code>，于是 <code>new.target</code> 属性在类构造器内部就绝不会是 <code>undefined</code>。</p>
          </div>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>CommonJS</title>
    <url>/posts/b3fe2fad/</url>
    <content><![CDATA[<h1 id="CommonJS-模块规范"><a href="#CommonJS-模块规范" class="headerlink" title="CommonJS 模块规范"></a>CommonJS 模块规范</h1><p>CommonJS 是 Node 的规范，是一直沿用至今的一个模块规范,。虽然 ES6 提出了新的模块规范，但目前为止 Node 无法直接兼容 ES6，我们按照 ES6 的模块规范来书写代码，但是实际上它们最终会被编译为 CommonJS 规范对应的代码来执行。</p>
<p>需要记住，Node 对获取的 JavaScript 文件内容进行了头尾包装。在头部添加了<code>function (exports, require, module, __filename, __dirname) {\n</code>，而在尾部添加了<code>\n}</code>。所以一个正常的 JavaScript 文件会被包装成如下的样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// .js文件的内容</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>模块文件 5 个变量的含义：</p><ul><li><strong><code>exports</code></strong>：一个对象，用来挂载当前模块中要导出的内容；</li><li><strong><code>require</code></strong>：一个用来引入其他模块的函数；</li><li><strong><code>module</code></strong>：一个代表模块自身的对象；</li><li><strong><code>__filename</code></strong>：当前模块文件的绝对路径；</li><li><strong><code>__dirname</code></strong>：当前模块文件所在目录的绝对路径。</li></ul><p><strong>注意千万不要重写这些变量，否则会导致它们与模块文件之间的联系被切断。</strong></p>
          </div>
<p>下面的例子是我创建了一个名为 test.js 的文件并用 node 运行得到的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js文件</span></span><br><span class="line"><span class="built_in">console</span>.log(exports); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">require</span>); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(__filename); <span class="comment">// D:\Others\test.js</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname); <span class="comment">// D:\Others</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>); <span class="comment">// Module &#123;</span></span><br><span class="line"><span class="comment">//   id: '.',</span></span><br><span class="line"><span class="comment">//   exports: &#123;&#125;,</span></span><br><span class="line"><span class="comment">//   parent: null,</span></span><br><span class="line"><span class="comment">//   filename: 'D:\\Others\\test.js',</span></span><br><span class="line"><span class="comment">//   loaded: false,</span></span><br><span class="line"><span class="comment">//   children: [],</span></span><br><span class="line"><span class="comment">//   paths: [ 'D:\\Others\\node_modules', 'D:\\node_modules' ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>现在我创建了两个文件 a.js 和 b.js，在 a.js 中演示<code>exports</code>的使用，在 b.js 中演示<code>require</code>的使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'a.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.sayName = sayName;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"></span><br><span class="line">moduleA.sayName(); <span class="comment">// my name is a.js</span></span><br></pre></td></tr></table></figure>
<p>在 a.js 文件中，通过将函数<code>sayName()</code>挂载到<code>exports</code>对象上，来导出<code>sayName()</code>。而在 b.js 文件中，通过<code>require()</code>函数获取了 a.js 文件中要导出内容组成的对象。</p>
<p>我们已经知道了 Node 会将每个模块文件包装为一个函数，而<code>exports</code>对象实际上是通过形参的方式传入的，直接赋值形参会改变形参的引用。所以<strong>为了防止无意间重写<code>exports</code>，推荐使用<code>module.exports</code>来替代它</strong>。下面演示下初学者容易犯的错误，和推荐的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a1.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'a1.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误用法</span></span><br><span class="line">exports = &#123;</span><br><span class="line">  name,</span><br><span class="line">  sayName,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a2.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'a2.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 推荐用法</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  name,</span><br><span class="line">  sayName,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> moduleA1 = <span class="built_in">require</span>(<span class="string">'./a1.js'</span>);</span><br><span class="line"><span class="keyword">var</span> moduleA2 = <span class="built_in">require</span>(<span class="string">'./a2.js'</span>);</span><br><span class="line"></span><br><span class="line">moduleA1.sayName(); <span class="comment">// TypeError: moduleA.sayName is not a function</span></span><br><span class="line"></span><br><span class="line">moduleA2.sayName(); <span class="comment">// my name is a2.js</span></span><br></pre></td></tr></table></figure>
<h1 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h1><p>CommonJS 模块的重要特性是加载时执行，即模块文件内的代码会在被<code>require()</code>的时候，就会全部执行。当执行完成后，<code>module.exports</code>对象就代表着被加载的模块文件要导出的内容。</p>
<div class="note warning">
            <p>有两点需要注意：</p><ul><li><code>var moduleA = require(&#39;./a.js&#39;)</code>中的<code>moduleA</code>，是由 a.js 文件中的<code>module.exports</code>经过一次浅拷贝得到的；</li><li>同一个模块文件，也许会被多次加载，但是只会执行一次。</li></ul>
          </div>
<p>浅拷贝的操作类似于<code>clone</code>函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> ) &#123;</span><br><span class="line">        newObj[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在明白上面说述内容后，请观察一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  num: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`count is: <span class="subst">$&#123;count&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`obj.num is: <span class="subst">$&#123;obj.num&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  obj.num++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  count,</span><br><span class="line">  obj,</span><br><span class="line">  show,</span><br><span class="line">  change,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(moduleA.count); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(moduleA.obj.num); <span class="comment">// 0</span></span><br><span class="line">moduleA.show(); <span class="comment">// count is: 0</span></span><br><span class="line"><span class="comment">// obj.num is: 0</span></span><br><span class="line"></span><br><span class="line">moduleA.change();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(moduleA.count); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(moduleA.obj.num); <span class="comment">// 1</span></span><br><span class="line">moduleA.show(); <span class="comment">// count is: 1</span></span><br><span class="line"><span class="comment">// obj.num is: 1</span></span><br></pre></td></tr></table></figure>
<p>通过<code>change()</code>函数同时改变了<code>count</code>和<code>obj.num</code>的值。在 a.js 文件中，<code>count</code>和<code>obj.num</code>的值均变为<code>1</code>，而在 b.js 文件中<code>moduleA.count</code>的值还是为 0 没有变化，<code>moduleA.obj.num</code>的值则变为<code>1</code>。如果你没看懂，你可能需要<a href="https://aadonkeyz.com/posts/9b1cd8c7/#复制变量值">看这里</a>。</p>
<h1 id="模块循环-require"><a href="#模块循环-require" class="headerlink" title="模块循环 require()"></a>模块循环 require()</h1><p>在 CommonJS 中如果出现模块“循环<code>require()</code>”，只会输出已经执行的部分，还未执行的部分不会输出。下面贴出<a href="https://nodejs.org/api/modules.html#modules_cycles" target="_blank" rel="noopener">官方文档里面的例子</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a starting'</span>);</span><br><span class="line"></span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in a, b.done = %j'</span>, b.done);</span><br><span class="line"></span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a done'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b starting'</span>);</span><br><span class="line"></span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in b, a.done = %j'</span>, a.done);</span><br><span class="line"></span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b done'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'main starting'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in main, a.done = %j, b.done = %j'</span>, a.done, b.done);</span><br></pre></td></tr></table></figure>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">依次输出：</span><br><span class="line">main starting</span><br><span class="line">a starting</span><br><span class="line">b starting</span><br><span class="line">in b, a.done = false</span><br><span class="line">b done</span><br><span class="line">in a, b.done = true</span><br><span class="line">a done</span><br><span class="line">in main, a.done = true, b.done = true</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>. At that point, <code>b.js</code> tries to load <code>a.js</code>. In order to prevent an infinite loop, an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the <code>b.js</code> module. <code>b.js</code> then finishes loading, and its exports object is provided to the <code>a.js</code> module.</p>
          </div>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Executable Code and Execution Contexts</title>
    <url>/posts/33ac290/</url>
    <content><![CDATA[<h1 id="Types-of-Executable-Code"><a href="#Types-of-Executable-Code" class="headerlink" title="Types of Executable Code"></a>Types of Executable Code</h1><p>There are three types of ECMAScript executable code:</p>
<ul>
<li>Global code is source text that is treated as an ECMAScript Program. The global code of a particular Program does not include any source text that is parsed as part of a FunctionBody.</li>
<li>Eval code is the source text supplied to the built-in <code>eval</code> function. More precisely, if the parameter to the built-in eval function is a String, it is treated as an ECMAScript Program. The eval code for a particular invocation of <code>eval</code> is the global code portion of that Program.</li>
<li>Function code is source text that is parsed as part of a FunctionBody. The function code of a particular FunctionBody does not include any source text that is parsed as part of a nested FunctionBody. Function code also denotes the source text supplied when using the built-in Function object as a constructor. More precisely, the last parameter provided to the Function constructor is converted to a String and treated as the FunctionBody. If more than one parameter is provided to the Function constructor, all parameters except the last one are converted to Strings and concatenated together, separated by commas. The resulting String is interpreted as the FormalParameterList for the FunctionBody defined by the last parameter. The function code for a particular instantiation of a Function does not include any source text that is parsed as part of a nested FunctionBody.</li>
</ul>
<h1 id="Lexical-Environment"><a href="#Lexical-Environment" class="headerlink" title="Lexical Environment"></a>Lexical Environment</h1><p>A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a WithStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated.</p>
<p>An Environment Record records the identifier bindings that are created within the scope of its associated Lexical Environment.</p>
<p>The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment. An outer Lexical Environment may, of course, have its own outer Lexical Environment. A Lexical Environment may serve as the outer environment for multiple inner Lexical Environments. For example, if a FunctionDeclaration contains two nested FunctionDeclarations then the Lexical Environments of each of the nested functions will have as their outer Lexical Environment the Lexical Environment of the current execution of the surrounding function.</p>
<p>Lexical Environments and Environment Record values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>
<h1 id="Execution-Contexts"><a href="#Execution-Contexts" class="headerlink" title="Execution Contexts"></a>Execution Contexts</h1><p>When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the running execution context.</p>
<p>An execution context contains whatever state is necessary to track the execution progress of its associated code. In addition, each execution context has three state components:</p>
<ul>
<li>LexicalEnvironment: Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.</li>
<li>VariableEnvironment: Identifies the Lexical Environment whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this execution context.</li>
<li>ThisBinding: The value associated with the <code>this</code> keyword within ECMAScript code associated with this execution context.</li>
</ul>
<p>The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created, its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context.</p>
<p>An execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to access an execution context.</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://es5.github.io/#x10" target="_blank" rel="noopener">Annotated ES5</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/posts/fdc54b8c/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>关于 JSON，最重要的是理解它是一个数据格式，不是一种编程语言。虽然具有相同的语法形式，但 JSON 并不从属于 JavaScript。而且，并不是只有 JavaScript 才使用 JSON，毕竟 JSON 只是一种数据格式。</p>
<div class="note info">
            <p>JSON 的语法可以表示以下三种类型的值：</p><ul><li><strong>简单值</strong>：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 <code>null</code>。但 JSON 不支持 JavaScript 中的特殊值 <code>undefined</code>。</li><li><strong>对象</strong>：对象作为一种复杂数据类型，表示的是一组有序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。</li><li><strong>数组</strong>：数组也是一种复杂数据类型，表示一组有序的值的列表。可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。</li></ul><p><strong>JSON中的字符串必须使用双引号。</strong></p>
          </div>
<p>举个简单的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"json demo"</span>,</span><br><span class="line">  <span class="attr">"number"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"array"</span>: [</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"obj"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"obj"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"whatever"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h1><div class="note info">
            <p><code>JSON.stringify()</code> 接受三个参数：</p><ul><li><code>value</code>：需要被转换为JSON字符串的值。</li><li><code>replacer</code>（可选）：该参数可以是一个数组或者过滤器函数。<ul><li>当该参数为数组时，这个数组相当于是一个白名单，不在白名单中的属性将被过滤掉。</li><li>当该参数为函数时，这个函数接收两个参数：属性（键）名和属性值。这个函数的返回值就相当于对应的属性被序列化后的结果，但是如果函数返回了 <code>undefined</code>，那么对应属性将被过滤掉。</li></ul></li><li><code>space</code>（可选）：该参数可以是数值或字符串。当为数值时，这个数值表示序列化结果的缩进空格数。当为字符串时，这个字符串会替换空格，被用作缩进字符。</li></ul><hr><p>注意事项：</p><ul><li>如果 <code>value</code> 中出现循环引用会抛出错误。</li><li>如果 <code>value</code> 是对象，且没有传入 <code>replacer</code> 参数，那么如果它的某一个属性值是JSON所不支持的，比如 <code>undefined</code>，那么这个属性会被自动过滤掉。</li><li>如果 <code>value</code> 是对象，且 <code>replacer</code> 是数组，那么该数组相当于一个白名单，不在白名单中的属性将被过滤掉。</li><li>如果 <code>value</code> 是对象，且 <code>replacer</code> 是函数，那么这个函数接收两个参数：属性（键）名和属性值。这个函数的返回值就相当于对应的属性被序列化后的结果，如果函数返回了 <code>undefined</code>，那么对应属性将被过滤掉。</li><li>如果 <code>value</code> 是数组，且没有传入 <code>replacer</code> 参数，那么如果它的某一项是JSON所不支持的，比如 <code>undefined</code>，那么这个项会被转换为 <code>null</code>。</li><li>如果 <code>value</code> 是数组，且 <code>replacer</code> 也是数组，那么没有 <code>replacer</code> 没有什么作用，跟没传递 <code>replacer</code> 效果是一样的。</li><li>如果 <code>value</code> 是数组，且 <code>replacer</code> 是函数，那么这个函数接收两个参数：字符串形式的索引和每一项的值。这个函数的返回值就相当于对应的项被序列化后的结果，如果函数返回了 <code>undefined</code>，那么对应项会被转换为<code>null</code>。</li><li><code>replacer</code> 是个十分有意思的函数，它接收到的第一个键会是空字符串 <code>&#39;&#39;</code>，而接收到的第一个值会是 <code>value</code>。之后如果 <code>value</code> 是对象或者数组，它才开始在 <code>value</code>中进行迭代。</li></ul><hr><p>有时候 <code>JSON.stringify()</code> 还是不能满足对某些对象进行自定义序列化的需求，这种情况下，就可以在对象中定义 <code>toJson()</code> 方法。<strong>当 <code>JSON.stringify()</code> 接收的第一个参数包含 <code>toJson()</code> 方法时，会先调用其 <code>toJson()</code> 方法，然后再对该方法的返回值进行序列化，即实际上的操作是 <code>JSON.stringify(value.toJson())</code>。</strong>。</p>
          </div>
<p>下面的例子来自<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">MDN</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// '&#123;&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;&#125;)                    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 'true'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="literal">true</span>)                  </span><br><span class="line"></span><br><span class="line"><span class="comment">// '"foo"'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'foo'</span>)                 </span><br><span class="line"></span><br><span class="line"><span class="comment">// '[1,"false",false]'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="string">'false'</span>, <span class="literal">false</span>])   </span><br><span class="line"></span><br><span class="line"><span class="comment">// '[null,null,null]'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">NaN</span>, <span class="literal">null</span>, <span class="literal">Infinity</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment">// '&#123;"x":5&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: <span class="number">5</span> &#125;)              </span><br><span class="line"></span><br><span class="line"><span class="comment">// '"2006-01-02T15:04:05.000Z"'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2006</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">5</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// '&#123;"x":5,"y":6&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">y</span>: <span class="number">6</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// '[3,"false",false]'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>), <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'false'</span>), <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment">// String-keyed array elements are not enumerable and make no sense in JSON</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]</span></span><br><span class="line">a[<span class="string">'baz'</span>] = <span class="string">'quux'</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">// '["foo","bar"]'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(a) </span><br><span class="line"></span><br><span class="line"><span class="comment">// '&#123;"x":[10,null,null,null]&#125;' </span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: [<span class="number">10</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="built_in">Symbol</span>(<span class="string">''</span>)] &#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard data structures</span></span><br><span class="line"><span class="comment">// '[&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;]'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>]), <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">2</span>]]), <span class="keyword">new</span> <span class="built_in">WeakSet</span>([&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;]), <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="number">2</span>]])])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypedArray</span></span><br><span class="line"><span class="comment">// '[&#123;"0":1&#125;,&#123;"0":1&#125;,&#123;"0":1&#125;]'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="keyword">new</span> <span class="built_in">Int8Array</span>([<span class="number">1</span>]), <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>]), <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>])])</span><br><span class="line"></span><br><span class="line"><span class="comment">// '[&#123;"0":1&#125;,&#123;"0":1&#125;,&#123;"0":1&#125;,&#123;"0":1&#125;]'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">1</span>]), <span class="keyword">new</span> <span class="built_in">Uint8ClampedArray</span>([<span class="number">1</span>]), <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([<span class="number">1</span>]), <span class="keyword">new</span> <span class="built_in">Uint32Array</span>([<span class="number">1</span>])])</span><br><span class="line"></span><br><span class="line"><span class="comment">// '[&#123;"0":1&#125;,&#123;"0":1&#125;]'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="keyword">new</span> <span class="built_in">Float32Array</span>([<span class="number">1</span>]), <span class="keyword">new</span> <span class="built_in">Float64Array</span>([<span class="number">1</span>])])</span><br><span class="line"> </span><br><span class="line"><span class="comment">// toJSON()</span></span><br><span class="line"><span class="comment">// '11'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">y</span>: <span class="number">6</span>, toJSON()&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbols:</span></span><br><span class="line"><span class="comment">// '&#123;&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: <span class="literal">undefined</span>, <span class="attr">y</span>: <span class="built_in">Object</span>, <span class="attr">z</span>: <span class="built_in">Symbol</span>(<span class="string">''</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// '&#123;&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="string">'foo'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// '&#123;&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; [<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)]: <span class="string">'foo'</span> &#125;, [<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; [<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)]: <span class="string">'foo'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">k, v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> k === <span class="string">'symbol'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a symbol'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-enumerable properties:</span></span><br><span class="line"><span class="comment">// '&#123;"y":"y"&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123; <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="string">'x'</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;, <span class="attr">y</span>: &#123; <span class="attr">value</span>: <span class="string">'y'</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125; &#125;) )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是空字符串''</span></span><br><span class="line"><span class="comment">// &#123; '1': 1, '2': 2, '3': &#123; '4': 4, '5': &#123; '6': 6 &#125; &#125; &#125;</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// &#123; '4': 4, '5': &#123; '6': 6 &#125; &#125;</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// &#123; '6': 6 &#125;</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="string">"1"</span>: <span class="number">1</span>, <span class="string">"2"</span>: <span class="number">2</span>, <span class="string">"3"</span>: &#123;<span class="string">"4"</span>: <span class="number">4</span>, <span class="string">"5"</span>: &#123;<span class="string">"6"</span>: <span class="number">6</span>&#125;&#125;&#125;, (key, value) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'========'</span>)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, null, 3 ]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], (key, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (key !== <span class="string">'1'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h1><div class="note info">
            <p><code>JSON.parse()</code> 接受两个参数：</p><ul><li><code>text</code>：需要被转换为JSON字符串的值。</li><li><code>receiver</code>（可选）：该参数是一个函数，这个函数也接受键值对，并且返回一个值。如果返回值是 <code>undefined</code>，则表示要从对象中删除相应的属性，或者在数组中将对应的项变成 <code>&lt;empty&gt;</code>。关于这个函数是怎么迭代的，请看下面的例子。</li></ul>
          </div>
<p>例子来自 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener">MDN</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;&#125;'</span>)              </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>)            </span><br><span class="line"></span><br><span class="line"><span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'"foo"'</span>)           </span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 5, "false"]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1, 5, "false"]'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'null'</span>)            </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; p: 10 &#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"p": 5&#125;'</span>, (key, value) =&gt;</span><br><span class="line">  <span class="keyword">typeof</span> value === <span class="string">'number'</span></span><br><span class="line">    ? value * <span class="number">2</span>     <span class="comment">// return value * 2 for numbers</span></span><br><span class="line">    : value         <span class="comment">// return everything else unchanged</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// &#123; '6': 6 &#125;</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// &#123; '4': 4, '5': &#123; '6': 6 &#125; &#125;</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="comment">// 这里是空字符串''</span></span><br><span class="line"><span class="comment">// &#123; '1': 1, '2': 2, '3': &#123; '4': 4, '5': &#123; '6': 6 &#125; &#125; &#125;</span></span><br><span class="line"><span class="comment">// ========</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"1": 1, "2": 2, "3": &#123;"4": 4, "5": &#123;"6": 6&#125;&#125;&#125;'</span>, (key, value) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'========'</span>)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, &lt;1 empty item&gt;, 3, 4 ]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,4]'</span>, (key, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (key !== <span class="string">'1'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Node Event Loop</title>
    <url>/posts/1bc69df4/</url>
    <content><![CDATA[<p>下面两段代码，你能说出正确的打印顺序分别是什么吗？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法确定打印顺序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先 immediate</span></span><br><span class="line"><span class="comment">// 后 timeout</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>不是我懒惰，是我怕翻译错<br>so<br><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">Node 官方解读在这里</a></p>
          </div>
<p>下面是写的比较好的博客，它们是一个系列哦：</p>
<ul>
<li><a href="https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810" target="_blank" rel="noopener">Event Loop and the Big Picture — NodeJS Event Loop Part 1</a></li>
<li><a href="https://blog.insiderattack.net/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2-2c53fd511bb3" target="_blank" rel="noopener">Timers, Immediates and Process.nextTick — NodeJS Event Loop Part 2</a></li>
<li><a href="https://blog.insiderattack.net/promises-next-ticks-and-immediates-nodejs-event-loop-part-3-9226cbe7a6aa" target="_blank" rel="noopener">Promises, Next-Ticks, and Immediates — NodeJS Event Loop Part 3</a></li>
<li><a href="https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1" target="_blank" rel="noopener">Handling IO — NodeJS Event Loop Part 4</a></li>
<li><a href="https://blog.insiderattack.net/new-changes-to-timers-and-microtasks-from-node-v11-0-0-and-above-68d112743eb3" target="_blank" rel="noopener">New Changes to the Timers and Microtasks in Node v11.0.0 (and above)</a></li>
<li><a href="https://blog.insiderattack.net/event-loop-best-practices-nodejs-event-loop-part-5-e29b2b50bfe2" target="_blank" rel="noopener">Event Loop Best Practices — NodeJS Event Loop Part 5</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Object</title>
    <url>/posts/a7625ff7/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><strong>我们看到的大多数引用类型值都是 Object 类型的实例！对，连数组、函数等都是 Object 类型的实例！</strong></p>
<p>我所知道的例外有 <code>Object.create(null)</code> 返回的空对象。</p>
<div class="note info">
            <ul><li>创建 Object 实例方式有：<code>new Object()</code> 和<strong>对象字面量表示法</strong>。</li><li>对象属性名一定是<strong>字符串</strong>或<strong>符号</strong>，如果不是，会自动转换为字符串。</li><li>访问对象属性的方式：<strong>点表示法</strong>和<strong>方括号表示法</strong>。</li></ul>
          </div>
<h1 id="对象字面量语法"><a href="#对象字面量语法" class="headerlink" title="对象字面量语法"></a>对象字面量语法</h1><h2 id="属性初始化的速记法"><a href="#属性初始化的速记法" class="headerlink" title="属性初始化的速记法"></a>属性初始化的速记法</h2><p>在 ES6 中，你可以使用属性初始化的速记法来消除对象名称与本地变量的重复情况。当对象的一个属性名称与本地变量名相同时，你可以简单书写名称而省略冒号与值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当对象字面量中的属性只有名称时，引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。在本例中，局部变量 <code>name</code> 的值就被赋给了对象的 <code>name</code> 属性。</p>
<h2 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h2><p>ES6 允许在为对象字面量方法赋值时，省略冒号与 <code>function</code> 关键字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Nicholas'</span>,</span><br><span class="line">  sayName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="需计算属性名"><a href="#需计算属性名" class="headerlink" title="需计算属性名"></a>需计算属性名</h2><p>在 ES5 及更早版本中，可以在对象字面量中将字符串直接用作属性名，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">'first name'</span>: <span class="string">'Nicholas'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br></pre></td></tr></table></figure>
<p>但是前提是这个属性名事先已知，并且能用字符串表示。如果用对象字面量语法创建对象时，想为它定义一个尚未确定名称的属性，ES5是做不到这点的。但是ES6可以呀！</p>
<p>在 ES6 中，需计算属性名是对象字面量语法的一部分，它用的也是方括号表示法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lastName = <span class="string">'last name'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">'first name'</span>: <span class="string">'Nicholas'</span>,</span><br><span class="line">  [lastName]: <span class="string">'Zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zakas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])</span><br></pre></td></tr></table></figure>
<p>在对象字面量内的方括号表明该属性需要计算，其结果是一个字符串。这意味着其中可以包含表达式，像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">' name'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  [<span class="string">'first'</span> + suffix]: <span class="string">'Nicholas'</span>,</span><br><span class="line">  [<span class="string">'last'</span> + suffix]: <span class="string">'Zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zakas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'last name'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="重复的对象字面量属性"><a href="#重复的对象字面量属性" class="headerlink" title="重复的对象字面量属性"></a>重复的对象字面量属性</h2><p>在 ES5 严格模式下如果出现重复的对象字面量属性，会抛出错误。但 ES6 移除了重复属性的检查，严格模式与非严格模式都不在检查重复的属性。当存在重复属性时，排在后面的属性的值会成为该属性的实际值。</p>
<h1 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h1><p>ES6 并没有定义对象属性的枚举顺序，而是把该问题留给了 JS 引擎厂商。而 ES6 则严格定义了对象自有属性在被枚举时返回的顺序。这对 <code>Object.getOwnPropertyNames()</code> 与 <code>Reflect.ownKeys</code> 如何返回属性造成了影响，还同样影响了 <code>Object.assign()</code> 处理属性的顺序。</p>
<p>自有属性枚举时基本顺序如下：</p>
<div class="note info">
            <ol><li>所有的数字类型键，按升序排列。</li><li>所有的字符串类型键，按被添加到对象的顺序排列。</li><li>所有的符号类型键，也按添加顺序排列。</li></ol>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.d = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0,1,2,a,c,b,d</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">','</span>))</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong><code>for-in</code> 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 <code>Object.keys()</code> 和 <code>JSON.stringify()</code> 也使用了与 <code>for-in</code> 一样的枚举顺序。</strong></p>
          </div>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><div class="note warning">
            <ul><li><code>super</code> 是指向<strong>当前对象</strong>的原型的一个引用，并且 <code>super</code> 只能在对象的简写方法中使用。</li><li>虽然 <code>super</code> 是当前对象原型的一个引用，但是通过 <code>super</code> 调用原型方法时，被调用的原型方法内部的 <code>this</code> 会与当前对象方法内部的 <code>this</code> 保持一致。</li><li><del><code>super</code> 就是 <code>Object.getPrototypeOf(this)</code> 的值。</del>这其实是错误的。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;</span><br><span class="line">  where: <span class="string">'proto 自己'</span>,</span><br><span class="line">  func () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.where + <span class="string">'调用 proto 的 func'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> superObj = &#123;</span><br><span class="line">  where: <span class="string">'superObj'</span>,</span><br><span class="line">  find () &#123;</span><br><span class="line">    <span class="keyword">super</span>.func()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> callObj = &#123;</span><br><span class="line">  where: <span class="string">'callObj'</span>,</span><br><span class="line">  find () &#123;</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).func()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(superObj, proto)</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(callObj, proto)</span><br><span class="line"></span><br><span class="line"><span class="comment">// superObj 调用 proto 的 func</span></span><br><span class="line">superObj.find()</span><br><span class="line"></span><br><span class="line"><span class="comment">// proto 自己调用 proto 的 func</span></span><br><span class="line">callObj.find()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherProto = &#123;</span><br><span class="line">  where: <span class="string">'otherProto 自己'</span>,</span><br><span class="line">  func () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.where + <span class="string">'调用 otherProto 的 func'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherObj = &#123;</span><br><span class="line">  where: <span class="string">'otherObj'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(otherObj, otherProto)</span><br><span class="line"></span><br><span class="line"><span class="comment">// otherObj 调用 proto 的 func</span></span><br><span class="line">superObj.find.call(otherObj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// otherProto 自己调用 otherProto 的 func</span></span><br><span class="line">callObj.find.call(otherObj)</span><br></pre></td></tr></table></figure>
<h1 id="正式的“方法”定义"><a href="#正式的“方法”定义" class="headerlink" title="正式的“方法”定义"></a>正式的“方法”定义</h1><p>在 ES6 之前，“方法”的概念从未被正式定义，它从前仅指对象的函数属性（而非数据属性）。ES6 则正式做出了定义：方法是一个拥有 <code>[[HomeObject]]</code> 内部属性的函数，此内部属性指向该方法所属的对象。</p>
<div class="note info">
            <p>使用 <code>super</code> 调用原型方法时，背后的工作流程。</p><ol><li>在 <code>[[HomeObject]]</code> 上调用 <code>Object.getPrototypeOf()</code> 来获取对原型的引用。</li><li>在该原型上查找同名函数。</li><li>创建 <code>this</code> 绑定并调用该方法。</li></ol>
          </div>
<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h1><p>该方法接受一个接收者，以及任意数量的供应者，接收者会按照供应者在参数中的顺序来依次接收它们的属性，最后返回接收者。在这一过程中如果出现属性名重复的情况，则后面的会覆盖前面的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;</span><br><span class="line">  name: <span class="string">'origin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(receiver,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'js'</span>,</span><br><span class="line">    name: <span class="string">'file.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'css'</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; type: 'css', name: 'file.js' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong><code>Object.assign()</code> 并未在接收者上创建访问器属性，即使供应者拥有访问器属性。由于 <code>Object.assign()</code> 使用赋值运算符，供应者的访问器属性就会转变成接收者的数据属性</strong>，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;,</span><br><span class="line">  supplier = &#123;</span><br><span class="line">    <span class="keyword">get</span> name () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'file.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, supplier)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(receiver, <span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.js</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get)</span><br></pre></td></tr></table></figure>
<h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h1><p><code>Object.create(proto, [propertiesObject])</code> 以 <code>proto</code> 为原型创建一个新的对象。<code>Object.create()</code> 方法的第二个参数与 <code>Object.defineProperties()</code> 方法的第二个参数格式相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Nicholas'</span>,</span><br><span class="line">  friend: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">'Greg'</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person.isPrototypeOf(anotherPerson))</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greg</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'Shelby', 'Court', 'Van' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.friend)</span><br></pre></td></tr></table></figure>
<h1 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h1><p>当比较两个值的时候，大多数开发者倾向于使用严格相等运算符（<code>===</code>），但是它有一点小瑕疵。例如，它认为 <code>+0</code> 与 <code>-0</code> 相等，即使这两者在引擎中有不同的表示。另外 <code>NaN === NaN</code> 会返回 <code>false</code>，因此有必要使用 <code>Number.isNaN()</code> 函数来正确检测 <code>NaN</code>。</p>
<p>ES6 引入了 <code>Object.is()</code> 方法来弥补严格相等运算符残留的怪异点。此方法接受两个参数，并会在二者的值相等时返回 <code>true</code>，此时要求二者类型相同并且值也相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>))</span><br></pre></td></tr></table></figure>
<p>在许多情况下，<code>Object.is()</code> 的结果与 <code>===</code> 运算符是相同的，仅有的例外是：它会认为 <code>+0</code> 与 <code>-0</code> 不相等，而且 <code>NaN</code> 等于 <code>NaN</code>。</p>
<h1 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf"></a>Object.setPrototypeOf</h1><p>ES6 添加了 <code>Object.setPrototypeOf</code> 方法，此方法允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  getGreeting () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'woof'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog)</span><br><span class="line"></span><br><span class="line"><span class="comment">// woof</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/posts/9a3eeeca/</url>
    <content><![CDATA[<h1 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A+"></a>Promises/A+</h1><p>本来想仔细描述一下 Promises 的各种特性的，但由于翻译水平有限，最后觉得还是直接查看 Promises/A+ 的规范更精确。</p>
<p>所以，请先移步 <a href="https://promisesaplus.com" target="_blank" rel="noopener">Promises/A+</a>。</p>
<div class="note warning">
            <ul><li>规范中提到“then may be called multiple times on the same promise”，它的意思是同一个 <code>Promise</code> 实例上可以挂载多个 <code>then</code>，而不是同一个 <code>then</code> 被调用多次。</li><li>规范中说的 object 是指 <code>Object.prototype.toString.call(value)</code> 返回值为 <code>&quot;[object Object]&quot;</code> 的数据，而不是广义上的 Object 的实例。</li><li>与 <code>resolve()</code> 的复杂规则不同。调用 <code>reject(reason)</code> 时，不论传给它的值是什么，它都会将 <code>Promise</code> 实例的状态置为 <code>rejected</code>，将 <code>Promise</code> 实例的值设置为 <code>reason</code>。</li></ul>
          </div>
<h1 id="Promises-A-的补充说明"><a href="#Promises-A-的补充说明" class="headerlink" title="Promises/A+ 的补充说明"></a>Promises/A+ 的补充说明</h1><div class="note info">
            <p>在根据 Promises/A+ 实现 Promise 时，各种引擎又添加了如下规则：</p><ul><li>如果在 <code>Promise</code> 构造器中抛出了一个错误，则会 <code>reject(err)</code>。</li><li>规范中的 <code>resolve</code> 和 <code>reject</code> 函数，既可以在 <code>Promise</code> 构造器中的使用，也可以单独使用，如 <code>Promise.resolve()</code> 和 <code>Promise.reject()</code>。这样做的相当于直接创建了一个 <code>fulfilled</code> 或 <code>rejected</code> 状态的 <code>Promise</code> 实例，跳过了前序的 <code>pending</code> 状态。这样做的好处是可以很方便的将 thenable 类型数据转换为标准的 <code>Promise</code> 实例。</li><li>可能是为了实现方便，如果传递给 <code>resolve</code> 的是一个 <code>Promise</code> 实例，它会原封不动的将该 <code>Promise</code> 实例返回。</li><li><code>Promise.prototype.catch(onRejected)</code> 等价于 <code>Promise.prototype.then(null, onRejected)</code>。</li><li><code>Promise.prototype.finally(onFinally)</code> 中的 <code>onFinally()</code> 不接受任何参数，它会在 <code>Promise</code> 实例被决议且 execution context stack 为空时被调用，但它会原封不动的将调用它的那个 <code>Promise</code> 实例作为返回值。<strong>它是 ES8 中引入中，所以可能会存在一些兼容性问题。</strong></li><li>与 <code>Promise.prototype.then</code> 一样，同一个 <code>Promise</code> 实例上也可以挂在多个 <code>Promise.prototype.catch</code> 和 <code>Promise.prototype.finally</code>。</li></ul>
          </div>
<p>基础用法如下，详细的可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="thenable"><a href="#thenable" class="headerlink" title="thenable"></a>thenable</h1><div class="note warning">
            <p>在按照规范实现 Promise 的同时，也实现了许多额外的方法，如 <code>Promise.all</code>、<code>Promise.race</code> 等。这些方法同样兼容 thenable。</p>
          </div>
<h1 id="全局的-Promise-拒绝处理"><a href="#全局的-Promise-拒绝处理" class="headerlink" title="全局的 Promise 拒绝处理"></a>全局的 Promise 拒绝处理</h1><p>Promise 最有争议的方面之一就是：当一个 <code>Promise</code> 实例被拒绝时若缺少拒绝处理函数，就会静默失败。有人认为这是规范中最大的缺陷，因为这是 JS 语言所有组成部分中唯一不让错误清晰可见的。</p>
<p>由于 Promise 的本质，判断一个 <code>Promise</code> 实例的拒绝是否已被处理并不直观。例如，研究以下示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此刻 rejected 不会被处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段时间后……</span></span><br><span class="line">rejected.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 现在 rejected 已经被处理了</span></span><br><span class="line">  <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>无论 <code>Promise</code> 实例是否已被决议，你都可以在任何时候调用 <code>then()</code> 或 <code>catch()</code> 并使它们正确工作，这导致很难准确知道一个 <code>Promise</code> 实例何时会被处理。</p>
<p>虽然下个版本的 ES 可能会处理此问题，不过 Node 与浏览器已经实施了变更来解决开发者的这个痛点。这些变更不是 ES6 规范的一部分，但却是使用 Promise 时的宝贵工具。</p>
<h2 id="Node-的拒绝处理"><a href="#Node-的拒绝处理" class="headerlink" title="Node 的拒绝处理"></a>Node 的拒绝处理</h2><p>在 Node 中，<code>process</code> 对象上存在两个关联到 <code>Promise</code> 实例的拒绝处理的事件：</p>
<div class="note info">
            <ul><li><code>unhandledRejection</code>：当一个 <code>Promise</code> 实例被拒绝、而在事件循环本轮次中没有任何拒绝处理函数被调用时，该事件就会被触发。</li><li><code>rejectionHandled</code>：当一个 <code>Promise</code> 实例被拒绝、并从事件循环的下一个轮次开始才有拒绝处理函数被调用时，该事件就会被触发。</li></ul>
          </div>
<p>这两个事件旨在共同帮助识别已被拒绝但未曾被处理的 <code>Promise</code> 实例。</p>
<p><code>unhandledRejection</code> 事件处理函数接受的参数是拒绝原因（常常是一个错误对象）以及被拒绝的 Promise。以下代码展示了 <code>unhandledRejection</code>的应用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Explosion!</span></span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)             </span><br><span class="line"></span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(rejected === promise)       </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion!'</span>))</span><br></pre></td></tr></table></figure>
<p><code>rejectionHandled</code> 事件处理函数则只有一个参数，即已被拒绝的 <code>Promise</code> 实例。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'rejectionHandled'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(rejected === promise)       </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion!'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟添加拒绝处理函数</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  rejected.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Explosion!</span></span><br><span class="line">    <span class="built_in">console</span>.log(reason.message)          </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>此处的 <code>rejectionHandled</code> 事件在拒绝处理函数最终被调用时触发。若在 <code>rejected</code> 被创建后直接将拒绝处理函数附加到它上面，那么此事件就不会被触发。因为立即附加的拒绝处理函数在 <code>rejected</code> 被创建的事件循环的同一个轮次内就会被调用，这样 <code>rejectionHandled</code> 就不会起作用。</p>
<p>为了正确追踪潜在的未被处理的拒绝，使用 <code>unhandledRejection</code> 与 <code>rejectionHandled</code> 事件就能保持包含这些 <code>Promise</code> 实例的一个列表，之后等待一段时间再检查此列表。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个拒绝未被处理，将其添加到 map</span></span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">  possiblyUnhandledRejections.set(promise, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'rejectionHandled'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  possiblyUnhandledRejections.delete(promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做点事来处理这些拒绝</span></span><br><span class="line">    handleRejection(promise, reason)</span><br><span class="line">  &#125;)</span><br><span class="line">  possiblyUnhandledRejections.clear()</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>
<h2 id="浏览器的拒绝处理"><a href="#浏览器的拒绝处理" class="headerlink" title="浏览器的拒绝处理"></a>浏览器的拒绝处理</h2><p>浏览器同样能触发两个事件，来帮助识别未处理的拒绝。这两个事件会被 <code>window</code> 对象触发，并完全等效于 Node 的相关事件：</p>
<div class="note info">
            <ul><li><code>unhandledrejection</code>：当一个 <code>Promise</code> 实例被拒绝、而在事件循环的本轮次中没有任何拒绝处理函数被调用时，该事件就会被触发。</li><li><code>rejectionhandled</code>：当一个 <code>Promise</code> 实例被拒绝、并从事件循环的下一个轮次开始才有拒绝处理函数被调用时，该事件就会被触发。</li></ul>
          </div>
<p>Node 的实现会传递分离的参数给事件处理函数，而浏览器的两个事件处理函数则只会接收到包含下列属性的一个对象：</p>
<div class="note info">
            <ul><li><code>type</code>：事件的名称（<code>unhandledrejection</code> 或 <code>rejectionhandled</code>）。</li><li><code>promise</code>：被拒绝的 <code>Promise</code> 实例。</li><li><code>reason</code>：<code>Promise</code> 实例的值，即 <code>reason</code>。</li></ul>
          </div>
<p>除了事件处理函数接收的参数有所区别外，浏览器的事件处理函数用法可以仿照 Node。</p>
<h1 id="手写一个-Promise-A"><a href="#手写一个-Promise-A" class="headerlink" title="手写一个 Promise/A+"></a>手写一个 Promise/A+</h1><div class="note warning">
            <p>Implementations should not set arbitrary limits on the depth of thenable chains, and assume that beyond that arbitrary limit the recursion will be infinite. Only true cycles should lead to a TypeError; if an infinite chain of distinct thenables is encountered, recursing forever is the correct behavior.</p>
          </div>
<div class="note info">
            <p>可以使用 <a href="https://github.com/promises-aplus/promises-tests" target="_blank" rel="noopener">promises-aplus-tests</a> 进行测试</p><ol><li><code>npm install promises-aplus-tests -g</code></li><li>将下面代码保存至 test.js</li><li><code>promises-aplus-tests test.js</code></li></ol>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">privateFulfill</span> (<span class="params">promise, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2.2.2.3 it must not be called more than once</span></span><br><span class="line">  <span class="keyword">if</span> (promise.status !== MyPromise.PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise.status = MyPromise.FULFILLED;</span><br><span class="line">  promise.value = value;</span><br><span class="line">  promise.onFulfilledCallbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">privateReject</span> (<span class="params">promise, reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2.2.3.3 it must not be called more than once</span></span><br><span class="line">  <span class="keyword">if</span> (promise.status !== MyPromise.PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise.status = MyPromise.REJECTED;</span><br><span class="line">  promise.reason = reason;</span><br><span class="line">  promise.onRejectedCallbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveEngine</span> (<span class="params">promise, x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason</span></span><br><span class="line">  <span class="keyword">if</span> (promise === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> privateReject(promise, <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.3.2 If x is a promise, adopt its state</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="comment">// 2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.</span></span><br><span class="line">    <span class="comment">// 2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.</span></span><br><span class="line">    <span class="comment">// 2.3.2.3 If/when x is rejected, reject promise with the same reason.</span></span><br><span class="line">    <span class="keyword">if</span> (x.status === MyPromise.PENDING) &#123;</span><br><span class="line">      x.then(</span><br><span class="line">        (value) =&gt; &#123;</span><br><span class="line">          privateFulfill(promise, value);</span><br><span class="line">        &#125;,</span><br><span class="line">        (reason) =&gt; &#123;</span><br><span class="line">          privateReject(promise, reason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.</span></span><br><span class="line">    <span class="keyword">if</span> (x.status === MyPromise.FULFILLED) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateFulfill(promise, x.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3.2.3 If/when x is rejected, reject promise with the same reason.</span></span><br><span class="line">    <span class="keyword">if</span> (x.status === MyPromise.REJECTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateReject(promise, x.reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Object]'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.3.3 Otherwise, if x is an object or function</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.1 Let then be x.then</span></span><br><span class="line">      <span class="keyword">const</span> then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3 If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise</span></span><br><span class="line">        <span class="keyword">var</span> called = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          then.call(</span><br><span class="line">            x,</span><br><span class="line">            (y) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              MyPromise.resolve.call(promise, y);</span><br><span class="line">            &#125;,</span><br><span class="line">            (r) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              MyPromise.reject.call(promise, r);</span><br><span class="line">            &#125;,</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          MyPromise.reject.call(promise, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.4 If then is not a function, fulfill promise with x</span></span><br><span class="line">        <span class="keyword">return</span> privateFulfill(promise, x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.2 If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason</span></span><br><span class="line">      <span class="keyword">return</span> privateReject(promise, err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.3.4 If x is not an object or function, fulfill promise with x</span></span><br><span class="line">    <span class="keyword">return</span> privateFulfill(promise, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">static</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line">  <span class="keyword">static</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> resolve (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> resolveEngine(<span class="keyword">new</span> MyPromise(), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> resolveEngine(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'this is not an instance of MyPromise'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateReject(<span class="keyword">new</span> MyPromise(), reason);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateReject(<span class="keyword">this</span>, reason);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'this is not an instance of MyPromise'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = MyPromise.PENDING;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> executor === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(MyPromise.resolve.bind(<span class="keyword">this</span>), MyPromise.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        privateReject(<span class="keyword">this</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then (onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 2.2.7 then must return a promise</span></span><br><span class="line">    <span class="comment">// promise2 = promise1.then(onFulfilled, onRejected)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 2.2.1 Both onFulfilled and onRejected are optional arguments</span></span><br><span class="line">      <span class="comment">// 2.2.2 If onFulfilled is a function</span></span><br><span class="line">      <span class="comment">// 2.2.3 If onRejected is a function</span></span><br><span class="line">      <span class="comment">// 2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code</span></span><br><span class="line">      <span class="comment">// 2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value)</span></span><br><span class="line">      <span class="keyword">const</span> fulfillCallback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x)</span></span><br><span class="line">              resolve(onFulfilled(<span class="keyword">this</span>.value));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason</span></span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.7.3 If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1</span></span><br><span class="line">            resolve(<span class="keyword">this</span>.value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">const</span> rejectCallback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x)</span></span><br><span class="line">              resolve(onRejected(<span class="keyword">this</span>.reason))</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason</span></span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.7.4 If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1</span></span><br><span class="line">            reject(<span class="keyword">this</span>.reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code</span></span><br><span class="line">      <span class="comment">// 2.2.6 then may be called multiple times on the same promise.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === MyPromise.PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.push(fulfillCallback);</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(rejectCallback);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === MyPromise.FULFILLED) &#123;</span><br><span class="line">        setTimeout(fulfillCallback);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === MyPromise.REJECTED) &#123;</span><br><span class="line">        setTimeout(rejectCallback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">    <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for promises-aplus-tests</span></span><br><span class="line">MyPromise.deferred = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  result.promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    result.resolve = resolve;</span><br><span class="line">    result.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Reflect 与 Proxy</title>
    <url>/posts/27777a89/</url>
    <content><![CDATA[<p>ES6 让开发者能进一步接近 JS 引擎的能力，这些能力原先只存在于内置对象上。语言通过代理暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变 JS 引擎的底层操作。</p>
<h1 id="代理与反射是什么？"><a href="#代理与反射是什么？" class="headerlink" title="代理与反射是什么？"></a>代理与反射是什么？</h1><p><strong><code>Proxy</code> 对象用于在目标对象上定义一些基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。</strong></p>
<div class="note info">
            <p><strong>语法</strong>：<code>let proxy = new Proxy(target, handler)</code>。<code>target</code> 与 <code>handler</code> 参数都是必填项。</p><ul><li><code>target</code>：用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li><code>handler</code>：一个包含特定方法的对象，这些特定的方法又叫做<strong>陷阱函数</strong>。</li><li><strong>陷阱函数</strong>：用来拦截 <code>target</code> 对象上的特定操作、并用自定义行为替代这些特定操作的默认行为。陷阱函数内部的 <code>this</code> 指向 <code>handler</code>。</li></ul>
          </div>
<p>观察下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> targetObj =  &#123;</span><br><span class="line">name: <span class="string">'target object'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handlerObj = &#123;</span><br><span class="line">  <span class="comment">// get陷阱函数，用于拦截对象的属性访问操作</span></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'change the underlying operation'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetObj, handlerObj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// target object</span></span><br><span class="line"><span class="built_in">console</span>.log(targetObj.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// change the underlying operation</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(targetObj.notExist) </span><br><span class="line"></span><br><span class="line"><span class="comment">// change the underlying operation</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.notExist)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>proxyObj</code> 是通过 <code>Proxy</code> 对 <code>targetObj</code> 进行了包装得到的代理对象，在对 <code>proxyObj</code> 的属性进行访问时，调用的是 <code>handlerObj</code> 中的 <code>get</code> 方法，因为陷阱函数 <code>get</code> 的存在，拦截了所有对 <code>proxy</code> 属性进行访问的操作。</p>
<p><strong><code>Reflect</code> 对象是一个内置的对象，它是给底层操作提供默认行为的方法的集合。每个陷阱函数都可以在 <code>Reflect</code> 对象上找到与之对应的同名方法，这个方法也叫做反射接口，陷阱函数与反射接口之间是一一对应的，并且它们接收的参数是相同的。</strong></p>
<p><strong>另外需要注意的是，<code>Reflect</code> 不是一个函数对象，因此它不可以被当作构造器使用。</strong></p>
<div class="note info">
            <p><strong>每个陷阱函数都可以重写 JS 对象的一个特定默认行为，允许你拦截并修改它。如果你仍然需要使用原先的默认行为，则可使用 <code>Reflect</code> 的对应反射接口。</strong></p>
          </div>
<p>下面表格中列出了陷阱函数、对应的操作和对应的默认行为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代理陷阱</th>
<th style="text-align:center">对应操作</th>
<th style="text-align:center">默认行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>get</strong></td>
<td style="text-align:center"><strong>读取一个属性的值</strong></td>
<td style="text-align:center"><strong>Reflect.get()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>set</strong></td>
<td style="text-align:center"><strong>写入一个属性的值</strong></td>
<td style="text-align:center"><strong>Reflect.set()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>has</strong></td>
<td style="text-align:center"><strong>in运算符</strong></td>
<td style="text-align:center"><strong>Reflect.has()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>deleteProperty</strong></td>
<td style="text-align:center"><strong>delete运算符</strong></td>
<td style="text-align:center"><strong>Reflect.deleteProperty()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>getPrototypeOf</strong></td>
<td style="text-align:center"><strong>Object.getPrototypeOf()</strong></td>
<td style="text-align:center"><strong>Reflect.getPrototypeOf()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>setPrototypeOf</strong></td>
<td style="text-align:center"><strong>Object.setPrototypeOf()</strong></td>
<td style="text-align:center"><strong>Reflect.setPrototypeOf()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>isExtensible</strong></td>
<td style="text-align:center"><strong>Object.isExtensible()</strong></td>
<td style="text-align:center"><strong>Reflect.isExtensible()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>preventExtensions</strong></td>
<td style="text-align:center"><strong>Object.preventExtensions()</strong></td>
<td style="text-align:center"><strong>Reflect.preventExtensions()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>getOwnPropertyDescriptor</strong></td>
<td style="text-align:center"><strong>Object.getOwnPropertyDescriptor()</strong></td>
<td style="text-align:center"><strong>Reflect.getOwnPropertyDescriptor()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>defineProperty</strong></td>
<td style="text-align:center"><strong>Object.defineProperty()</strong></td>
<td style="text-align:center"><strong>Reflect.defineProperty()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>ownKeys</strong></td>
<td style="text-align:center"><strong>Object.keys()</strong>、<br><strong>Object.getOwnPropertyNames()</strong>、<br><strong>Object.getOwnPropertySymbols()</strong></td>
<td style="text-align:center"><strong>Reflect.ownKeys()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>apply</strong></td>
<td style="text-align:center"><strong>调用一个函数</strong></td>
<td style="text-align:center"><strong>Reflect.apply()</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>construct</strong></td>
<td style="text-align:center"><strong>使用new调用一个函数</strong></td>
<td style="text-align:center"><strong>Reflect.construct()</strong></td>
</tr>
</tbody>
</table>
</div>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><div class="note info">
            <ol><li><code>handler.get()</code>/<code>Reflect.get()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li><li><code>key</code>：目标属性的键。</li><li><code>receiver</code>：最初被调用的对象（通常是代理对象，但也可能是以代理对象为原型的其他对象）。</li></ul></li><li><code>handler.get()</code> 的返回值：<ul><li>可以返回任何值。</li></ul></li><li><code>handler.get()</code>的限制：<ul><li>如果目标属性是目标对象的自有属性、不可写且不可配置，那么返回值必须与该目标属性的值相同，否则会抛出错误。</li><li>如果目标属性是目标对象的自有属性、不可配置且没有定义 <code>getter</code>，那么返回值必须为 <code>undefined</code> ，否则会抛出错误。</li></ul></li></ol>
          </div>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><div class="note info">
            <ol><li><code>handler.set()</code>/<code>Reflect.set()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li><li><code>key</code>：目标属性的键。</li><li><code>value</code>：目标属性的值。</li><li><code>receiver</code>：最初被调用的对象（通常是代理对象，但也可能是以代理对象为原型的其他对象）。</li></ul></li><li><code>handler.set()</code>的返回值：<ul><li>会自动将返回值转换为对应的布尔值，<code>true</code> 代表操作成功，<code>false</code> 代表操作失败。</li><li>在严格模式下，如果返回 <code>false</code>，会抛出错误。</li></ul></li><li><code>handler.set()</code>的限制：<ul><li>如果目标属性是不可写且不可配置的，那么不允许改变它的值，否则会抛出错误。</li><li>如果目标属性是不可配置，并且没有定义 <code>setter</code>，那么不允许设置它的值，否则会抛出错误。</li><li><strong>关于上面两个限制，是对象自己的限制，跟 <code>handler.set()</code> 没啥关系。</strong></li></ul></li></ol>
          </div>
<h1 id="has"><a href="#has" class="headerlink" title="has"></a>has</h1><div class="note info">
            <ol><li><code>handler.has()</code>/<code>Reflect.has()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li><li><code>key</code>：目标属性的键。</li></ul></li><li><code>handler.has()</code> 的返回值：<ul><li>会自动将返回值转换为对应的布尔值。</li></ul></li><li><code>handler.has()</code> 的限制：<ul><li>如果目标属性是目标对象的自有属性，且是不可配置的，那么不允许返回 <code>false</code>，否则会抛出错误。</li><li>如果目标属性是目标对象的自有属性，且目标对象是不可扩展的，那么不允许返回 <code>false</code>，否则会抛出错误。</li></ul></li></ol>
          </div>
<h1 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h1><div class="note info">
            <ol><li><code>handler.deleteProperty()</code>/<code>Reflect.deleteProperty()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li><li><code>key</code>：目标属性的键。</li></ul></li><li><code>handler.deleteProperty()</code> 的返回值：<ul><li>会自动将返回值转换为对应的布尔值，<code>true</code> 代表操作成功，<code>false</code> 代表操作失败。</li><li>在严格模式下，如果返回 <code>false</code>，会抛出错误。</li></ul></li><li><code>handler.deleteProperty()</code> 的限制：<ul><li>如果目标属性是目标对象的自有属性，且是不可配置的，那么不允许删除该属性，否则会返回 <code>false</code>。</li></ul></li></ol>
          </div>
<h1 id="Object-与R-eflect的区别"><a href="#Object-与R-eflect的区别" class="headerlink" title="Object 与R eflect的区别"></a>Object 与R eflect的区别</h1><p><code>Object</code> 对象和 <code>Reflect</code> 对象上存在着一些同名方法，比如 <code>getPrototypeOf()</code>、<code>setPrototypeOf()</code>、<code>isExtensible</code> 等等。它们不仅名称相同，功能也大致相同，这会让人产生疑惑，会有一种“既然有了 <code>Object</code>，何必又出现 <code>Reflect</code>”的感觉。</p>
<div class="note info">
            <p><strong><code>Reflect</code> 对象上的方法属于底层方法、是对 JS 语言内部方法进行封装（并附加了一些输入验证）后得到的。而 <code>Object</code> 对象上的方法属于高级方法，它们会在调用 JS 语言内部方法之前添加一些步骤、并检查返回值。</strong>。</p>
          </div>
<h1 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h1><div class="note info">
            <ol><li><code>handler.getPrototypeOf()</code>/<code>Reflect.getPrototypeOf()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li></ul></li><li><code>handler.getPrototypeOf()</code> 的返回值：<ul><li>返回值必须是一个对象或者 <code>null</code>，否则会抛出错误。</li></ul></li><li><code>handler.getPrototypeOf()</code> 的限制：<ul><li>如果目标对象是不可扩展的，那么返回值必须是目标对象的原型（即 <code>Object.getPrototypeOf(target)</code>），否则会抛出错误。</li></ul></li></ol>
          </div>
<div class="note warning">
            <p><strong><code>Object.getPrototypeOf</code> 与 <code>Reflect.getPrototypeOf</code> 的区别：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Object.getPrototypeOf</th><th style="text-align:center">Reflect.getPrototypeOf</th></tr></thead><tbody><tr><td style="text-align:center"><strong>接收的参数不是对象时，会先将其转换为对象</strong></td><td style="text-align:center"><strong>接收的参数不是对象时，会抛出错误</strong></td></tr></tbody></table></div>
          </div>
<h1 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h1><div class="note info">
            <ol><li><code>handler.setPrototypeOf()</code>/<code>Reflect.setPrototypeOf()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li><li><code>proto</code>：需要被用作原型的对象。</li></ul></li><li><code>handler.setPrototypeOf()</code> 的返回值：<ul><li>会自动将返回值转换为对应的布尔值，<code>true</code> 代表操作成功，<code>false</code> 代表操作失败;</li><li>如果返回 <code>false</code>，会导致 <code>Object.setPrototypeOf()</code> 抛出错误。</li></ul></li><li><code>handler.setPrototypeOf()</code> 的限制：<ul><li>如果目标对象是不可扩展的，那么必须保证传入的 <code>proto</code> 参数就是目标对象的原型（即 <code>Object.getPrototypeOf(target)</code>），否则会抛出错误。</li></ul></li></ol>
          </div>
<div class="note warning">
            <p><strong><code>Object.setPrototype</code> 与 <code>Reflect.setPrototype</code> 的区别：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Object.setPrototype</th><th style="text-align:center">Reflect.setPrototype</th></tr></thead><tbody><tr><td style="text-align:center"><strong>接收的第一个参数不是对象时，会先将其转换为对象</strong></td><td style="text-align:center"><strong>接收的第一个参数不是对象时，会抛出错误</strong></td></tr><tr><td style="text-align:center"><strong>操作成功会将接收的第一个参数作为自身的返回值，操作失败会抛出错误</strong></td><td style="text-align:center"><strong>操作成功返回 true，操作失败返回 false</strong></td></tr></tbody></table></div>
          </div>
<h1 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h1><div class="note info">
            <ol><li><code>handler.isExtensible()</code>/<code>Reflect.isExtensible()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li></ul></li><li><code>handler.isExtensible()</code> 的返回值：<ul><li>会自动将返回值转换为对应的布尔值。</li></ul></li><li><code>handler.isExtensible()</code> 的限制：<ul><li>返回值必须与 <code>Object.isExtensible(target)</code> 的值相同，否则会抛出错误。</li></ul></li></ol>
          </div>
<div class="note warning">
            <p><strong><code>Object.isExtensible</code> 与 <code>Reflect.isExtensible</code> 的区别：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Object.isExtensible</th><th style="text-align:center">Reflect.isExtensible</th></tr></thead><tbody><tr><td style="text-align:center"><strong>接收的参数不是对象时，会返回 false</strong></td><td style="text-align:center"><strong>接收的参数不是对象时，会抛出错误</strong></td></tr></tbody></table></div>
          </div>
<h1 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h1><div class="note info">
            <ol><li><code>handler.preventExtensions()</code>/<code>Reflect.preventExtensions()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li></ul></li><li><code>handler.preventExtensions()</code> 的返回值：<ul><li>会自动将返回值转换为对应的布尔值，<code>true</code> 代表操作成功，<code>false</code> 代表操作失败。</li><li>如果返回 <code>false</code>，会抛出错误。</li></ul></li><li><code>handler.preventExtensions()</code> 的限制：<ul><li>只有当<code>Object.isExtensible(target)</code> 的值为 <code>false</code> 时，才允许返回 <code>true</code>，否则会抛出错误。</li></ul></li></ol>
          </div>
<div class="note warning">
            <p><strong><code>Object.preventExtensions</code> 与 <code>Reflect.preventExtensions</code> 的区别：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Object.preventExtensions</th><th style="text-align:center">Reflect.preventExtensions</th></tr></thead><tbody><tr><td style="text-align:center"><strong>总是将接收的参数作为自身的返回值，即使该参数不是一个对象</strong></td><td style="text-align:center"><strong>接收的参数不是对象时，会抛出错误。<br>参数是一个对象时，会在操作成功时返回 true，失败时返回 false</strong></td></tr></tbody></table></div>
          </div>
<h1 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor"></a>getOwnPropertyDescriptor</h1><div class="note info">
            <ol><li><code>handler.getOwnPropertyDescriptor()</code>/<code>Reflect.getOwnPropertyDescriptor()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li><li><code>key</code>：目标属性的键。</li></ul></li><li><code>handler.getOwnPropertyDescriptor()</code> 的返回值：<ul><li>返回值必须是一个对象或者 <code>undefined</code>，否则会抛出错误。</li><li>如果返回一个对象，会忽略对象中的其他属性，只保留 <code>configurable</code>、<code>enumerable</code>、<code>writable</code>、<code>value</code>、<code>get</code> 或 <code>set</code>。</li><li>如果返回一个对象，其中数据属性与访问器属性不能同时存在，否则会抛出错误。</li><li>如果返回一个对象，默认 <code>{ value: undefined, writable: false, enumerable: false, configurable: false }</code>。</li></ul></li><li><code>handler.getOwnPropertyDescriptor()</code> 的限制：<ul><li>如果目标属性是目标对象的自有属性，且是不可配置的，那么返回值必须与 <code>Object.getOwnPropertyDescriptor(target)</code> 相同，否则会抛出错误。</li><li>如果目标属性是目标对象的自有属性，且是可配置的，那么只允许返回 <code>undefined</code> 或者 <code>configurable</code> 属性为 <code>true</code> 的对象，否则会抛出错误。</li><li>如果目标属性是目标对象的自有属性，且目标对象是不可扩展的，那么不允许返回 <code>undefined</code>，否则会抛出错误（<strong>注意目标属性是否可配置，然后结合上面两条规则，取交集</strong>）。</li><li>如果目标属性不是目标对象的自有属性，且目标对象是不可扩展的，那么必须返回 <code>undefined</code>，否则会抛出错误。</li><li>如果目标属性不是目标对象的自有属性，那么只可以返回 <code>undefined</code> 或者 <code>configurable</code> 属性为 <code>true</code> 的对象，否则会抛出错误。</li></ul></li></ol>
          </div>
<div class="note warning">
            <p><strong><code>Object.getOwnPropertyDescriptor</code> 与 <code>Reflect.getOwnPropertyDescriptor</code> 的区别：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Object.getOwnPropertyDescriptor</th><th style="text-align:center">Reflect.getOwnPropertyDescriptor</th></tr></thead><tbody><tr><td style="text-align:center"><strong>接收的第一个参数不是对象时，会先将其转换为对象</strong></td><td style="text-align:center"><strong>接收的第一个参数不是对象时，会抛出错误</strong></td></tr></tbody></table></div>
          </div>
<h1 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h1><div class="note info">
            <ol><li><code>handler.defineProperty()</code>/<code>Reflect.defineProperty()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li><li><code>key</code>：目标属性的键。</li><li><code>descriptor</code>：为该属性准备的描述符对象。</li></ul></li></ol><ol><li><code>handler.defineProperty()</code> 的返回值：<ul><li>会自动将返回值转换为对应的布尔值，<code>true</code> 代表操作成功，<code>false</code> 代表操作失败。</li><li>如果返回 <code>false</code>，会导致 <code>Object.defineProperty()</code> 抛出错误。</li></ul></li></ol><ol><li><code>handler.defineProperty()</code> 的限制：<ul><li>如果目标对象不可扩展，那么不允许添加属性，否则会抛出错误。</li><li>如果目标属性是目标对象的自有属性，且是不可配置，那么不允许修改其描述符，否则会抛出错误。</li></ul></li></ol>
          </div>
<div class="note warning">
            <p><strong><code>Object.defineProperty</code> 与 <code>Reflect.defineProperty</code> 的区别：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Object.defineProperty</th><th style="text-align:center">Reflect.defineProperty</th></tr></thead><tbody><tr><td style="text-align:center"><strong>总是返回接收到的第一个参数</strong></td><td style="text-align:center"><strong>成功时返回 true，失败时返回 false</strong></td></tr></tbody></table></div>
          </div>
<h1 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h1><div class="note info">
            <ol><li><code>handler.ownKeys()</code>/<code>Reflect.ownKeys()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象。</li></ul></li></ol><ol><li><code>handler.ownKeys()</code> 的返回值：<ul><li>会自动将返回值转换为一个数组（用内部的 <code>CreateListFromArrayLike</code> 方法），所以如果返回的是基本类型值，会抛出错误。</li><li>这个数组的元素必须是字符串类型或者符号类型，否则会抛出错误。</li></ul></li></ol><ol><li><code>handler.ownKeys()</code> 的限制：<ul><li><code>Object.keys(proxy)</code> 的结果是对 <code>Object.keys(target)</code> 与返回的数组取交集。</li><li><code>Object.getOwnPropertyNames(proxy)</code> 会将返回的数组中所有符号类型的键过滤。</li><li><code>Object.getOwnPropertySymbols(proxy)</code> 会将返回的数组中所有字符串类型的键过滤。</li><li>如果目标对象中包含不可配置的属性，那么返回的数组中必须包含该属性的键，否则会抛出错误。</li><li>如果目标对象不可扩展，那么返回的数组必须包含目标对象的所有自有属性，且不能包含多余的内容，否则会抛出错误。</li></ul></li></ol>
          </div>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><div class="note info">
            <ol><li><code>handler.apply()</code>/<code>Reflect.apply()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象（被执行的函数）。</li><li><code>thisArg</code>：调用过程中函数内部的 <code>this</code> 值。</li><li><code>argumentsList</code>：被传递给函数的参数数组。</li></ul></li></ol><ol><li><code>handler.apply()</code> 的返回值：<ul><li>可以返回任何值。</li></ul></li></ol><ol><li><code>handler.apply()</code> 的限制：<ul><li><code>trapTarget</code> 参数必须是一个函数，否则会抛出错误。</li></ul></li></ol>
          </div>
<h1 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h1><div class="note info">
            <ol><li><code>handler.construct()</code>/<code>Reflect.construct()</code> 的参数：<ul><li><code>trapTarget</code>：目标对象（被执行的函数）。</li><li><code>argumentsList</code>：被传递给函数的参数数组。</li><li><code>newTarget</code>（可选参数）：<code>new.target</code> 的值。</li></ul></li></ol><ol><li><code>handler.construct()</code> 的返回值：<ul><li>返回值必须是一个对象，否则会抛出错误。</li></ul></li></ol><ol><li><code>handler.construct()</code> 的限制：<ul><li><code>trapTarget</code> 参数必须是一个函数，否则会抛出错误。</li></ul></li></ol>
          </div>
<p>关于 <code>newTarget</code> 参数，请看下面例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">target</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  construct (trapTarget, argumentsList, newTarget) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newTarget)</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Function: target]</span></span><br><span class="line"><span class="keyword">new</span> target()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Function: target]</span></span><br><span class="line"><span class="built_in">Reflect</span>.construct(target, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Function: a]</span></span><br><span class="line"><span class="built_in">Reflect</span>.construct(target, [], <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Function: target]</span></span><br><span class="line"><span class="keyword">new</span> proxy()                                     </span><br><span class="line"></span><br><span class="line"><span class="comment">// [Function: target]</span></span><br><span class="line"><span class="built_in">Reflect</span>.construct(proxy, [])                        </span><br><span class="line"></span><br><span class="line"><span class="comment">// [Function: b]</span></span><br><span class="line"><span class="built_in">Reflect</span>.construct(proxy, [], <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="调用构造器而无须使用-new"><a href="#调用构造器而无须使用-new" class="headerlink" title="调用构造器而无须使用 new"></a>调用构造器而无须使用 new</h1><p>假设 <code>Numbers</code> 函数是硬编码的，无法被修改，一直该代码依赖于 <code>new.target</code>，而你想要在调用函数时避免这个检查。在“必须使用 <code>new</code>”这一限制已经确定的情况下，你可以使用 <code>apply</code> 陷阱函数来规避它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'This function must be called with new.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.values = values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> NumbersProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Numbers, &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params">trapTarget, thisArg, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面两种方式都是可以的</span></span><br><span class="line">    <span class="comment">// return Reflect.construct(trapTarget, argumentsList)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> trapTarget(...argumentsList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = NumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.values)</span><br></pre></td></tr></table></figure>
<h1 id="重写抽象基础类的构造器"><a href="#重写抽象基础类的构造器" class="headerlink" title="重写抽象基础类的构造器"></a>重写抽象基础类的构造器</h1><p>在抽象基础类的构造器中，<code>new.target</code> 被要求不能是构造器自身的。但是通过 <code>construct</code> 陷阱函数，我们可以规避这个限制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractNumbers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (...values) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractNumbers) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'This function must be inherited from.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.values = values</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> AbstractNumbersProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(AbstractNumbers, &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span> (<span class="params">trapTarget, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentsList, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> AbstractNumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.values)</span><br></pre></td></tr></table></figure>
<h1 id="可被撤销的代理"><a href="#可被撤销的代理" class="headerlink" title="可被撤销的代理"></a>可被撤销的代理</h1><p>在被创建之后，代理通常就不能再从目标对象上被解绑，但有的情况下你可能想撤销一个代理以便让它不能再被使用。当你想通过公共接口向外提供一个安全的对象，并且要求随时都能切断对某些功能的访问，这种情况下被撤销的代理就会非常有用。</p>
<div class="note info">
            <p>你可以使用 <code>Proxy.revocable()</code> 方法来创建一个可被撤销的代理，该方法接受的参数与 <code>Proxy</code> 构造器的相同：一个目标对象、一个代理处理器，而返回值是包含下列属性的一个对象：</p><ul><li><code>proxy</code>：可被撤销的代理对象。</li><li><code>revoke</code>：用于撤销代理的函数。</li></ul>
          </div>
<p>当 <code>revoke()</code> 函数被调用后，就不能再对该 <code>proxy</code> 对象进行更多操作，任何与该代理对象交互的意图都会触发代理的陷阱函数，从而抛出一个错误。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  name: <span class="string">'target'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)     </span><br><span class="line"></span><br><span class="line">revoke()</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Cannot perform 'get' on a proxy that has been revoked</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br></pre></td></tr></table></figure>
<h1 id="实现MyArray类"><a href="#实现MyArray类" class="headerlink" title="实现MyArray类"></a>实现MyArray类</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> numericKey = toUint32(key)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length=0) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>, &#123;</span><br><span class="line">      <span class="keyword">set</span> (trapTarget, key, value) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentLength = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">'length'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (isArrayIndex(key)) &#123;</span><br><span class="line">          <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key)</span><br><span class="line">          <span class="keyword">if</span> (numericKey &gt;= currentLength) &#123;</span><br><span class="line">            <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">'length'</span>, numericKey + <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'length'</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value &lt; currentLength) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> index = currentLength - <span class="number">1</span>; index &gt;= value; index--) &#123;</span><br><span class="line">              <span class="built_in">Reflect</span>.deleteProperty(trapTarget, index)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无论键的类型是什么，都要执行这行代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> MyArray(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> MyArray)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)              </span><br><span class="line"></span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line">colors[<span class="number">1</span>] = <span class="string">'green'</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">'blue'</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">'black'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)              </span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)              </span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])                  </span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>])                  </span><br><span class="line"></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>])                  </span><br><span class="line"></span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h1 id="将代理对象作为原型使用"><a href="#将代理对象作为原型使用" class="headerlink" title="将代理对象作为原型使用"></a>将代理对象作为原型使用</h1><p>在使用代理对象作为原型时，仅当操作的默认行为会按惯例追踪达到原型时，代理陷阱才会被调用，这就限制了代理对象作为原型时的能力。考虑这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="comment">// 永远不会被调用</span></span><br><span class="line">  defineProperty(trapTarget, name, descriptor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> newTarget = <span class="built_in">Object</span>.create(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(newTarget, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'newTarget'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// newTarget</span></span><br><span class="line"><span class="built_in">console</span>.log(newTarget.name)                     </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(newTarget.hasOwnProperty(<span class="string">'name'</span>))</span><br></pre></td></tr></table></figure>
<p>尽管在把代理对象作为原型时会受到严重限制，但仍然存在几个很有用的陷阱函数。</p>
<h2 id="在原型上使用-get-陷阱函数"><a href="#在原型上使用-get-陷阱函数" class="headerlink" title="在原型上使用 get 陷阱函数"></a>在原型上使用 get 陷阱函数</h2><p>当使用代理作为原型时，只有在对象不存在指定名称的自有属性时，才会触发原型上的 <code>get</code> 陷阱函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="keyword">get</span> (trapTarget, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(proxy)</span><br><span class="line"></span><br><span class="line">thing.name = <span class="string">'thing'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有触发 get 陷阱函数</span></span><br><span class="line"><span class="comment">// thing</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.name)         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发了 get 陷阱函数</span></span><br><span class="line"><span class="comment">// ReferenceError: unknow doesn't exist</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.unknow)</span><br></pre></td></tr></table></figure>
<p>这个例子中 <code>trapTarget</code> 与 <code>receiver</code> 是不同的对象，这对理解本例是非常重要的。<code>trapTarget</code> 为 <code>target</code>，<code>receiver</code> 为 <code>thing</code>。</p>
<h2 id="在原型上使用-set-陷阱函数"><a href="#在原型上使用-set-陷阱函数" class="headerlink" title="在原型上使用 set 陷阱函数"></a>在原型上使用 set 陷阱函数</h2><p>当使用代理作为原型时，只有在对象不存在指定名称的自有属性时，才会触发原型上的 <code>set</code> 陷阱函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="keyword">set</span> (trapTarget, key, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(proxy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发了 set 陷阱函数</span></span><br><span class="line">thing.name = <span class="string">'thing'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// thing</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.name)                         </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.hasOwnProperty(<span class="string">'name'</span>))       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有触发 set 陷阱函数</span></span><br><span class="line">thing.name = <span class="string">'boo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// boo</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.name)</span><br></pre></td></tr></table></figure>
<h2 id="在原型上使用-has-陷阱函数"><a href="#在原型上使用-has-陷阱函数" class="headerlink" title="在原型上使用 has 陷阱函数"></a>在原型上使用 has 陷阱函数</h2><p>当使用代理作为原型时，只有在对象不存在指定名称的自有属性时，才会触发原型上的 <code>has</code> 陷阱函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  has (trapTarget, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(trapTarget, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(proxy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发了 has 陷阱函数</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> thing)       </span><br><span class="line"></span><br><span class="line">thing.name = <span class="string">'thing'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有触发 has 陷阱函数</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> thing)</span><br></pre></td></tr></table></figure>
<h2 id="将代理作为类的原型"><a href="#将代理作为类的原型" class="headerlink" title="将代理作为类的原型"></a>将代理作为类的原型</h2><p>类不能直接被修改为将代理用作自身的原型，因为它们的 <code>prototype</code> 属性是不可写入的。然而你可以使用一点变通手段，利用继承来创建一个把代理作为自身原型的类。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">Super.prototype = proxy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Sub()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instanceProto = <span class="built_in">Object</span>.getPrototypeOf(instance)</span><br><span class="line"><span class="keyword">let</span> secondLevelProto = <span class="built_in">Object</span>.getPrototypeOf(instanceProto)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceProto === Sub.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(secondLevelProto === proxy)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>RegExp</title>
    <url>/posts/ce76031c/</url>
    <content><![CDATA[<h1 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h1><p>正则表达式可以通过 <code>var expression = /pattern/flags</code> 的字面量形式来创建。其中的 <code>pattern</code> 代表任何简单或复杂的正则表达式，<code>flag</code> 代表一个或多个标志。</p>
<div class="note info">
            <ul><li><code>g</code>：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止。</li><li><code>i</code>：表示不区分大小写模式。</li><li><code>m</code>：表示多行模式。</li><li><code>y</code>：表示从正则表达式的 <code>lastIndex</code> 属性值的位置开始向后检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索并返回 <code>null</code></li></ul>
          </div>
<p>同样也支持使用 <code>RegExp</code> 构造函数来创建正则表达式，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pattern1 和 pattern2 的作用是完全一样的</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'[bc]at'</span>, <span class="string">'i'</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>由于 <code>RegExp</code> 构造函数的模式参数都是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此。</p>
          </div>
<h1 id="复制正则表达式"><a href="#复制正则表达式" class="headerlink" title="复制正则表达式"></a>复制正则表达式</h1><p>在 ES5 中，你可以将正则表达式传递给 <code>RegExp</code> 构造器来复制它，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span></span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1)</span><br></pre></td></tr></table></figure>
<p><code>re2</code> 变量只是 <code>re1</code> 的一个副本。但如果你向 <code>RegExp</code> 构造器传递了第二个参数，即正则表达式的标志，那么该代码就无法正常工作，正如该范例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5中会抛出错误，ES6中可用</span></span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">'g'</span>)</span><br></pre></td></tr></table></figure>
<p>如果你在 ES5 中运行这段代码，那么你会收到一条错误信息，表示在第一个参数已经是正则表达式的情况下不能再使用第二个参数。ES6 则修改了这个行为，允许使用第二个参数，并且让它覆盖第一个参数中的标志。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 中会抛出错误，ES6 中可用</span></span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// /ab/i</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.toString())     </span><br><span class="line"></span><br><span class="line"><span class="comment">// /ab/g</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.toString())     </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">'ab'</span>))     </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">'ab'</span>))     </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">'AB'</span>))     </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">'AB'</span>))</span><br></pre></td></tr></table></figure>
<h1 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h1><p>在 ES5 中，你可以使用 <code>source</code> 属性来获取正则表达式的文本，但若想获取标志字符串，你必须解析 <code>toString()</code> 方法的输出，就像下面展示的那样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFlags</span> (<span class="params">re</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text = re.toString();</span><br><span class="line">  <span class="keyword">return</span> text.substring(text.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, text.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString() 的输出为 "/ab/g"</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/ab/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getFlags(re));</span><br></pre></td></tr></table></figure>
<p>ES6 新增了 <code>flags</code> 属性用于配合 <code>source</code> 属性，让标志的获取变得更容易。这两个属性均为只有 <code>get</code> 函数，无 <code>set</code> 函数的访问器属性，因此都是只读的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/ab/gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ab</span></span><br><span class="line"><span class="built_in">console</span>.log(re.source)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// gi</span></span><br><span class="line"><span class="built_in">console</span>.log(re.flags)</span><br></pre></td></tr></table></figure>
<h1 id="y-标志"><a href="#y-标志" class="headerlink" title="y 标志"></a>y 标志</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'hello1 hello2 hello3'</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/hello\d\s?/</span></span><br><span class="line"><span class="keyword">var</span> globalPattern = <span class="regexp">/hello\d\s?/g</span></span><br><span class="line"><span class="keyword">var</span> stickyPattern = <span class="regexp">/hello\d\s?/y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = pattern.exec(text)</span><br><span class="line"><span class="keyword">var</span> globalResult = globalPattern.exec(text)</span><br><span class="line"><span class="keyword">var</span> stickyResult = stickyPattern.exec(text)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello1</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>])                  </span><br><span class="line"></span><br><span class="line"><span class="comment">// hello1</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>])            </span><br><span class="line"></span><br><span class="line"><span class="comment">// hello1</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>])            </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex)          </span><br><span class="line"></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex)    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex)    </span><br><span class="line"></span><br><span class="line">pattern.lastIndex = <span class="number">1</span></span><br><span class="line">globalPattern.lastIndex = <span class="number">1</span></span><br><span class="line">stickyPattern.lastIndex = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">result = pattern.exec(text)</span><br><span class="line">globalResult = globalPattern.exec(text)</span><br><span class="line">stickyResult = stickyPattern.exec(text)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello1</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>])                  </span><br><span class="line"></span><br><span class="line"><span class="comment">// hello2</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>])            </span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property '0' of null</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>有两个关于粘连标志的微妙细节需要牢记：</p>
<div class="note warning">
            <ul><li>只有调用正则表达式对象上的方法（例如 <code>exec()</code> 与 <code>test()</code> 方法），<code>lastIndex</code> 属性才会生效。而将正则表达式作为参数传递给字符串上的方法（例如 <code>match()</code> 方法），并不会体现粘连特性；</li><li>当使用 <code>^</code> 字符来匹配字符串的起始处时，粘连的正则表达式只会匹配字符串的起始处（或者在多行模式下匹配行首）。当 <code>lastIndex</code> 为 0 时，<code>^</code> 不会让粘连的正则表达式与非粘连的有任何区别。而当 <code>lastIndex</code> 不为 0 时，粘连的正则表达式永远不会匹配成功。</li></ul>
          </div>
<p>可以使用如下方法来检测粘连标志是否被支持：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpY</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'.'</span>, <span class="string">'y'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h1><div class="note info">
            <p><code>exec()</code> 方法在一个指定字符串中 <strong>执行一次匹配搜索</strong>。如果匹配失败，返回 <code>null</code>。如果匹配成功，返回一个数组。这个数组有以下特点：</p><ul><li>该方法一次只会返回一个匹配项（第一个匹配项），这个匹配项被保存在数组的第一项。</li><li>捕获组从数组第二项开始保存。如果没有捕获组，则返回的数组只包含一项。</li><li>具有 <code>input</code> 属性，表示应用正则表达式的字符串。</li><li>具有 <code>index</code> 属性，表示匹配项在字符串中的索引。</li><li>具有 <code>groups</code> 属性，表示一个捕获组或 <code>undefined</code>（如果没有定义命名捕获组）</li></ul>
          </div>
<div class="note warning">
            <p><strong>对于 <code>exec()</code> 方法而言，即使在模式中设置了 <code>g</code> 标志，它每次也只会返回一个匹配项。在不设置 <code>g</code> 标志的情况下，在同一个字符串上多次调用 <code>exec()</code> 将始终返回第一个匹配项的信息。而在设置了 <code>g</code> 标志的情况下，每次调用 <code>exec()</code> 都会在字符串中继续查找新匹配项</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'mom and dad and baby'</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom (and dad (and baby)?)?/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'mom and dad and baby', 'and dad and baby', 'and baby', index: 0, input: 'mom and dad and baby', groups: undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.exec(text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'cat, bat, sat, fat'</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="regexp">/.at/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.exec(str))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.exec(str))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="regexp">/.at/g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.exec(str))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'bat', index: 5, input: 'cat, bat, sat, fat', groups: undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.exec(str))</span><br></pre></td></tr></table></figure>
<h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><p><code>test()</code>方法接收一个字符串参数，在模式与该参数匹配的情况下返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h1 id="常用总结"><a href="#常用总结" class="headerlink" title="常用总结"></a>常用总结</h1><h2 id="常用元字符概述"><a href="#常用元字符概述" class="headerlink" title="常用元字符概述"></a>常用元字符概述</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">匹配字符串的起始位置。如果多行标志被设置为 <code>true</code>，那么也匹配换行符后紧跟的位置。</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:center">匹配字符串的结束位置。如果多行标志被设置为 <code>true</code>，那么也匹配换行符前的位置。</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">匹配一个词的起始或结束位置。<br>例如，<code>\bm</code> 匹配 <code>moon</code> 中的 <code>m</code>，而 <code>oo\b</code> 并不匹配 <code>moon</code> 中的 <code>oo</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>\B</code></td>
<td style="text-align:center">匹配组成一个词的各个字符的中间位置。<br>例如，<code>\B..</code> 匹配 <code>noonday</code> 中的 <code>oo</code>，而 <code>y\B..</code> 匹配 <code>possibly yesterday</code> 中的 <code>yes</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:center">将元字符转义为字面量。例如，如果想在字符串中匹配 <code>^</code>，那么可以使用 <code>\^</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>{n}</code></td>
<td style="text-align:center">匹配前一个表达式 <code>n</code> 次。<code>n</code> 必须为正整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>{n,}</code></td>
<td style="text-align:center">至少匹配前一个表达式 <code>n</code> 次。<code>n</code> 必须为正整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>{n,m}</code></td>
<td style="text-align:center">匹配前一个表达式 <code>n</code> 次到 <code>m</code> 次之间（包括 <code>n</code> 和 <code>m</code>）。<code>n</code> 和 <code>m</code> 必须为正整数，且 <code>n &lt; m</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">匹配前一个表达式 0 次或多次，等价于 <code>{0,}</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">匹配前一个表达式 1 次或多次，等价于 <code>{1,}</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">匹配前一个表达式 0 次或 1 次，等价于 <code>{0,1}</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">匹配除换行符之外的任意单个字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>(xyz)</code></td>
<td style="text-align:center">匹配 <code>xyz</code> 并记住匹配项，括号内的内容被称为<strong>捕获组</strong>。<br>例如，<code>(foo)(bar)\1\2</code> 等价于 <code>foobarfoobar</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>(?:xyz)</code></td>
<td style="text-align:center">匹配 <code>xyz</code> 但不记住匹配项。</td>
</tr>
<tr>
<td style="text-align:center"><code>x(?=y)</code></td>
<td style="text-align:center">当且仅当 <code>x</code> 后面紧跟着 <code>y</code> 时，匹配 <code>x</code>。这叫做<strong>先行断言</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>x(?!=y)</code></td>
<td style="text-align:center">当且仅当 <code>x</code>后面没有紧跟着 <code>y</code> 时，匹配 <code>x</code>。这叫做<strong>正向否定查找</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>(?&lt;=y)x</code></td>
<td style="text-align:center">当且仅当 <code>x</code> 前面就是 <code>y</code> 时，匹配 <code>x</code>。这叫做<strong>后行断言</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>(?&lt;!y)x</code></td>
<td style="text-align:center">当且仅当 <code>x</code> 前面不是 <code>y</code> 时，匹配 <code>x</code>。这叫做<strong>反向否定查找</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>x&#124;y</code></td>
<td style="text-align:center">匹配 <code>x</code> 或 <code>y</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>[xyz]</code></td>
<td style="text-align:center">匹配一个出现在方括号中的字符。<strong>在方括号内部，你可以使用破折号 <code>-</code> 来指定一个范围</strong>。<br>例如，<code>[a-z]</code> 代表匹配一个小写字母。</td>
</tr>
<tr>
<td style="text-align:center"><code>[^xyz]</code></td>
<td style="text-align:center">匹配一个没有出现在方括号中的字符。<strong>在方括号内部，你可以使用破折号 <code>-</code> 来指定一个范围</strong>。<br>例如，<code>[^a-z]</code> 代表匹配一个小写字母以外的其他字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>[\b]</code></td>
<td style="text-align:center">匹配一个退格。</td>
</tr>
<tr>
<td style="text-align:center"><code>\cX</code></td>
<td style="text-align:center">当 <code>X</code> 是处于 <code>A-Z</code> 之间的字符时，匹配字符串中的一个控制字符。<br>例如，<code>\cM</code> 匹配字符串中的 <code>control-M</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>\d</code></td>
<td style="text-align:center">匹配一个数字字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\D</code></td>
<td style="text-align:center">匹配一个非数字字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">匹配一个换页符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">匹配一个换行符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">匹配一个回车符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\s</code></td>
<td style="text-align:center">匹配一个空白符，包括空格、制表符、换页符和换行符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\S</code></td>
<td style="text-align:center">匹配一个非空白字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">匹配一个水平制表符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">匹配一个垂直制表符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\w</code></td>
<td style="text-align:center">匹配一个单子字符（字母、数字或者下划线）。等价于 <code>[A-Za-z0-9_]</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>\W</code></td>
<td style="text-align:center">匹配一个非单子字符。等价于 <code>[^A-Za-z0-9_]</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>\number</code></td>
<td style="text-align:center">正数代表第 <code>number</code> 个捕获组。<br>例如，<code>apple(,)\sorange\1</code> 匹配 <code>apple, orange, cherry</code> 中的 <code>apple, orange,</code>。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="贪婪-非贪婪匹配"><a href="#贪婪-非贪婪匹配" class="headerlink" title="贪婪/非贪婪匹配"></a>贪婪/非贪婪匹配</h2><p>参考自<a href="https://dailc.github.io/2017/07/06/regularExpressionGreedyAndLazy.html" target="_blank" rel="noopener">【正则表达式系列】贪婪与非贪婪模式</a></p>
<div class="note info">
            <ul><li><strong>贪婪匹配</strong><ul><li><strong>定义</strong>：会尽量多的匹配符合条件的内容。</li><li><strong>元字符</strong>：<code>+</code>、<code>?</code>、<code>*</code>、<code>{n}</code>、<code>{n,}</code>、<code>{n,m}</code>。</li></ul></li><li><strong>非贪婪匹配</strong><ul><li><strong>定义</strong>：会尽量少的匹配符合条件的内容，一旦发现符合规则的内容就立刻终止匹配。</li><li><strong>元字符</strong>：<code>+?</code>、<code>??</code>、<code>*?</code>、<code>{n}?</code>、<code>{n,}?</code>、<code>{n,m}?</code>。</li></ul></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'aacbacbc'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// aacbacb</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/.*b/</span>)[<span class="number">0</span>])   </span><br><span class="line"></span><br><span class="line"><span class="comment">// aacb</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/.*?b/</span>)[<span class="number">0</span>])  </span><br><span class="line"></span><br><span class="line"><span class="comment">// cb</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/.?b/</span>)[<span class="number">0</span>])   </span><br><span class="line"></span><br><span class="line"><span class="comment">// cb</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/.??b/</span>)[<span class="number">0</span>])  </span><br><span class="line"></span><br><span class="line"><span class="comment">// aacbacb</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/.+b/</span>)[<span class="number">0</span>])   </span><br><span class="line"></span><br><span class="line"><span class="comment">// aacb</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/.+?b/</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Set 与 Map</title>
    <url>/posts/d766545b/</url>
    <content><![CDATA[<p><code>Set</code> 是不包含重复值的列表。你一般不会像对待数组那样来访问 <code>Set</code> 中的某个项。相反更常见的是，只在 <code>Set</code> 中检查某个值是否存在。</p>
<p><code>Map</code> 则是键与相对应的值的集合。因此，<code>Map</code> 中的每个项都存储了两块数据，通过指定所需读取的键即可检索对应的值。<code>Map</code> 常被用作缓存，存储数据以便此后快速检索。</p>
<h1 id="ES5-中的-Set-与-Map"><a href="#ES5-中的-Set-与-Map" class="headerlink" title="ES5 中的 Set 与 Map"></a>ES5 中的 Set 与 Map</h1><p>在 ES5 中，开发者使用对象属性来模拟 <code>Set</code> 与 <code>Map</code>，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = Object.create(null)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.foo = true</span><br><span class="line"></span><br><span class="line">// 检查属性的存在性</span><br><span class="line">if (<span class="keyword">set</span>.foo) &#123;</span><br><span class="line">  <span class="comment">// 一些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中的 <code>set</code> 变量是一个原型为 <code>null</code> 的对象，确保在此对象上没有继承属性。使用对象的属性作为需要检查的唯一值在 ES5 中是很常用的方法。当一个属性被添加到 <code>set</code> 对象时，它的值也被设为 <code>true</code>，因此条件判断语句就可以简单判断出该值是否存在。</p>
<p>使用对象模拟 <code>Set</code> 与模拟 <code>Map</code> 之间唯一真正的区别是所存储的值。例如：以下例子将对象作为 <code>Map</code> 使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">map.foo = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取一个值</span></span><br><span class="line"><span class="keyword">let</span> value = map.foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br></pre></td></tr></table></figure>
<p>此代码将字符串值 <code>&quot;bar&quot;</code> 存储在 <code>foo</code> 键上。与 <code>Set</code> 不同，<code>Map</code> 多数被用来提取数据，而不是仅检查键的存在性。</p>
<h1 id="变通方法的问题"><a href="#变通方法的问题" class="headerlink" title="变通方法的问题"></a>变通方法的问题</h1><p>尽管在简单情况下将对象作为 <code>Set</code> 与 <code>Map</code> 来使用都是可行的，但一旦接触到对象属性的局限性，此方式就会遇到更多麻烦。研究如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">let</span> key1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> key2 = <span class="string">'5'</span></span><br><span class="line"><span class="keyword">let</span> key3 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key4 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">map[key1] = <span class="string">'number'</span></span><br><span class="line"></span><br><span class="line">map[key3] = <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(map[key2])      </span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(map[key4])      </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; '5': 'number', '[object Object]': 'foo' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br></pre></td></tr></table></figure>
<p>造成上面例子中问题的原因是对象属性只可以是字符串或符号类型，所以当你为对象定义属性时，如果属性名不是字符串或符号类型，那么它会调用属性名的 <code>toString()</code> 方法将属性名转换为字符串，然后再进行后续操作。所以 <code>map[key1] === map[key2]</code>、<code>map[key3] === map[key4]</code>。</p>
<h1 id="ES6-的-Set"><a href="#ES6-的-Set" class="headerlink" title="ES6 的 Set"></a>ES6 的 Set</h1><p>ES6 新增了 <code>Set</code> 类型，这是一种无重复值的有序列表。<code>Set</code> 允许对它包含的数据进行快速访问，从而增加了一个追踪离散值的更有效方式。</p>
<h2 id="创建-Set-并添加项目"><a href="#创建-Set-并添加项目" class="headerlink" title="创建 Set 并添加项目"></a>创建 Set 并添加项目</h2><p><code>Set</code> 使用 <code>new Set()</code> 来创建，而调用 <code>add()</code> 方法就能向 <code>Set</code> 中添加项目，检查 <code>size</code> 属性还能查看其中包含有多少项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add('5')</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">console.log(<span class="keyword">set</span>.size)</span><br></pre></td></tr></table></figure>
<p><code>Set</code> 不会使用强制类型转换来判断值是否重复。这意味着 <code>Set</code> 可以同时包含数值 <code>5</code> 与字符串 <code>&quot;5&quot;</code>，将它们都作为相对独立的项（在 <code>Set</code> 内部的比较使用了 <code>Object.is()</code> 方法来判断两个值是否相等，唯一的例外是+0与-0被判断为是相等的）。你还可以向 <code>Set</code> 添加多个对象，它们不会被合并为同一项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">let key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key1)</span><br><span class="line"><span class="keyword">set</span>.add(key2)</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">console.log(<span class="keyword">set</span>.size)</span><br></pre></td></tr></table></figure>
<p>由于 <code>key1</code> 与 <code>key2</code> 并不会被转换为字符串，所以它们在这个 <code>Set</code> 内部被认为是两个不同的项（记住：如果它们被转换为字符串，那么都会等于 <code>&quot;[object Object]&quot;</code>）。</p>
<p>如果 <code>add()</code> 方法用相同值进行了多次调用，那么在第一次之后的调用实际上会被忽略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add('5')</span><br><span class="line"></span><br><span class="line">// 重复了，该调用被忽略</span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">console.log(<span class="keyword">set</span>.size)</span><br></pre></td></tr></table></figure>
<p>你可以使用数组来初始化一个 <code>Set</code>，并且 <code>Set</code> 构造器会确保不重复地使用这些值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 5, 5, 5, 5])</span><br><span class="line"></span><br><span class="line">// 5</span><br><span class="line">console.log(<span class="keyword">set</span>.size)</span><br></pre></td></tr></table></figure>
<p><code>Set</code> 构造器实际上可以接收任意可迭代对象作为参数。能使用数组是因为它们默认就是可迭代的，<code>Map</code> 也是一样的。</p>
<p>你可以使用 <code>has()</code> 方法来检测某个值是否存在于 <code>Set</code> 中，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add('5')</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(5))     </span><br><span class="line"></span><br><span class="line">// false</span><br><span class="line">console.log(<span class="keyword">set</span>.has(6))</span><br></pre></td></tr></table></figure>
<h2 id="移除值"><a href="#移除值" class="headerlink" title="移除值"></a>移除值</h2><p>使用 <code>delete()</code> 方法可以移除 <code>Set</code> 中的某个值，使用 <code>clear()</code> 方法可以移除 <code>Set</code> 中的所有值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add('5')</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.delete(5)</span><br><span class="line"></span><br><span class="line">// false</span><br><span class="line">console.log(<span class="keyword">set</span>.has(5))     </span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.clear()</span><br><span class="line"></span><br><span class="line">// 0</span><br><span class="line">console.log(<span class="keyword">set</span>.size)</span><br></pre></td></tr></table></figure>
<h2 id="Set-上的-forEach-方法"><a href="#Set-上的-forEach-方法" class="headerlink" title="Set 上的 forEach() 方法"></a>Set 上的 forEach() 方法</h2><p>Set上 的 <code>forEach()</code> 方法类似于数组中的 <code>forEach()</code> 方法，它接收两个参数：要在每一项上运行的函数和（可选的）运行该函数时的 <code>this</code> 值。传入的函数会接收三个参数：Set 元素的值，Set 元素的值和目标 Set 自身。你没看错，第一个和第二个参数是完全相同的，这么设计的目的是为了保持所有对象上 <code>forEach()</code> 方法的统一。</p>
<h2 id="将-Set-转换为数组"><a href="#将-Set-转换为数组" class="headerlink" title="将 Set 转换为数组"></a>将 Set 转换为数组</h2><p>使用扩展运算符可以很轻松的将 <code>Set</code> 转换为数组，用一个数组去重的例子来展示它是如何转换的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eliminateDuplicates</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="keyword">let</span> noDuplicates = eliminateDuplicates(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(noDuplicates)</span><br></pre></td></tr></table></figure>
<h2 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h2><p>由于 <code>Set</code> 类型存储对象引用的方式，它也可以被称为 Strong Set。对象存储在 <code>Set</code> 的一个实例中时，实际上相当于把对象存储在变量中。只要对 <code>Set</code> 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">let key = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">console.log(<span class="keyword">set</span>.size)       </span><br><span class="line"></span><br><span class="line">// 取消原始引用</span><br><span class="line">key = null</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">console.log(<span class="keyword">set</span>.size)       </span><br><span class="line"></span><br><span class="line">// 重新获得原始引用</span><br><span class="line">key = [...<span class="keyword">set</span>][0]</span><br></pre></td></tr></table></figure>
<p>在本例中，将 <code>key</code> 设置为 <code>null</code> 清楚了对 <code>key</code> 对象的一个引用，但是另一个引用还存在于 <code>set</code> 内部。你仍然可以使用扩展运算符将 <code>Set</code> 转换为数组，然后访问数组的第一项，<code>key</code> 变量就取回了原先的对象。</p>
<p>为了缓解这个问题，<strong>ES6 也包含了 Weak Set，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收。</strong></p>
<h3 id="创建-Weak-Set"><a href="#创建-Weak-Set" class="headerlink" title="创建 Weak Set"></a>创建 Weak Set</h3><p>Weak Set 使用 <code>WeakSet</code> 构造器来创建，并包含 <code>add()</code> 方法、<code>has()</code> 方法以及 <code>delete()</code> 方法。以下例子使用了这三个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet()</span><br><span class="line">let key = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key))       </span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.delete(key)</span><br><span class="line"></span><br><span class="line">// false</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key))</span><br></pre></td></tr></table></figure>
<p>使用 Weak Set 很像在使用正规的 <code>Set</code>。你可以在 Weak Set 上添加、移除或检查引用，也可以给构造器传入一个可迭代对象来初始化 Weak Set的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet([key1, key2])</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key1))      </span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key2))</span><br></pre></td></tr></table></figure>
<p>在本例中，一个数组被传给了 <code>WeakSet</code> 构造器。由于该数组包含了两个对象，这些对象就被添加到了 Weak Set 中。要记住若数组中包含了非对象的值，就会抛出错误，因为 <code>WeakSet</code> 构造器不接受基本类型的值。</p>
<h3 id="Set-类型之间的关键差异"><a href="#Set-类型之间的关键差异" class="headerlink" title="Set 类型之间的关键差异"></a>Set 类型之间的关键差异</h3><p>Weak Set 与正规 Set 之间最大的区别是对象的弱引用。此处有个例子说明了这种差异：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet()</span><br><span class="line">let key = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key))       </span><br><span class="line"></span><br><span class="line">// 移除对于键的最后一个强引用，同时从Weak Set中移除</span><br><span class="line">key = null</span><br></pre></td></tr></table></figure>
<p>当代码被执行后，Weak Set 中的 <code>key</code> 引用就不能再访问了。核实这一点是不可能的，因为需要把对于该对象的一个引用传递给 <code>has()</code> 方法（而只要存在其他引用，Weak Set 内部的弱引用就不会消失）。这会使得难以对 Weak Set 的引用特征进行测试，但 JS 引擎已经正确地将引用移除了，这一点你可以信任。</p>
<p>这些例子演示了 Weak Set 与正规 Set 的一些共有特征，但是它们还有一些关键的差异，即：</p>
<div class="note info">
            <ul><li>对于 <code>WeakSet</code> 的实例，若调用 <code>add()</code> 方法时传入非对象的参数，就会抛出错误（<code>has()</code> 或 <code>delete()</code> 则会在传入了非对象的参数时返回 <code>false</code>）。</li><li>Weak Set 不可迭代，因此不能被用在 <code>for-of</code> 循环中。</li><li>Weak Set 无法暴露出任何迭代器，因此没有任何编程手段可用于判断 Weak Set 的内容。</li><li>Weak Set 没有 <code>forEach()</code> 方法。</li><li>Weak Set 没有 <code>clear()</code> 方法。</li><li>Weak Set 没有 <code>size</code> 属性。</li></ul>
          </div>
<h1 id="ES6-的-Map"><a href="#ES6-的-Map" class="headerlink" title="ES6 的 Map"></a>ES6 的 Map</h1><p>ES6 的 <code>Map</code> 类型是键值对的有序列表，而键和值都可以是任意类型。</p>
<h2 id="创建-Map"><a href="#创建-Map" class="headerlink" title="创建 Map"></a>创建 Map</h2><p><code>Map</code> 对键的处理方式与 <code>Set</code> 对值的处理一样，采用的是 <code>Object.is()</code> 方法，而不会进行强制类型转换，唯一的例外是 +0 与 -0 被判断为是相等的。</p>
<p>你可以调用 <code>set()</code> 方法并给它传递一个键与一个关联的值，来给 Map 添加项。此后使用键名来调用 <code>get()</code> 方法便能提取对应的值。如果任意一个键不存在于Map中，则 <code>get()</code> 方法就会返回特殊值 <code>undefined</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">map.set(key1, <span class="number">5</span>)</span><br><span class="line">map.set(key2, <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="number">111</span>))</span><br></pre></td></tr></table></figure>
<p>此代码使用了对象 <code>key1</code> 与 <code>key2</code> 作为 Map 的键，并存储了两个不同的值。由于这些键不会被强制转换成其他形式，每个对象就都被认为是唯一的。这允许你给对象关联额外数据，而无须修改对象自身。</p>
<p>与 Set 类似，你能将数组传递给 <code>Map</code> 构造器，以便使用数据来初始化一个 <code>Map</code>。该数组中的每一项也必须是数组，内部数组的首个项会作为键，第二项则为对应值。因此整个 Map 就被这些双项数组所填充。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'Nicholas'</span>], [<span class="string">'age'</span>, <span class="number">25</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'name'</span>))    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'age'</span>))</span><br></pre></td></tr></table></figure>
<p>虽然有数组构成的数组看起来有点奇怪，但这对于准确表示键来说却是必要的。因为键允许是任意数据类型，将键存储在数组中，是确保它们在被添加到 Map 之前不会被强制转换为其他类型的唯一方法。</p>
<h2 id="Map-的方法及属性"><a href="#Map-的方法及属性" class="headerlink" title="Map 的方法及属性"></a>Map 的方法及属性</h2><div class="note info">
            <ul><li><code>has(key)</code>：判断指定的键是否存在于 Map 中。</li><li><code>delete(key)</code>：移除 Map 中的键以及对应的值。</li><li><code>clear()</code>：移除 Map 中所有的键与值。</li><li><code>size</code>：用于指示包含了多少个键值对。</li></ul>
          </div>
<h2 id="Map-上的-forEach-方法"><a href="#Map-上的-forEach-方法" class="headerlink" title="Map 上的 forEach 方法"></a>Map 上的 forEach 方法</h2><p>Map 的 <code>forEach()</code> 方法类似于 Set 与数组上的 <code>forEach()</code> 方法，不过它是按照键值对被添加到 Map 中的顺序来迭代的。它接收两个参数：要在每一项上运行的函数和（可选的）运行该函数时的 <code>this</code> 值。传入的函数会接收三个参数：Map 项的值、该值所对应的的键和目标Map自身。</p>
<h2 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h2><h3 id="使用Weak-Map"><a href="#使用Weak-Map" class="headerlink" title="使用Weak Map"></a>使用Weak Map</h3><p>ES6 的 <code>WeakMap</code> 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。<code>WeakMap</code> 的接口与 <code>Map</code> 的非常相似，都使用 <code>set()</code> 与 <code>get()</code> 方法来分别添加与提取数据。</p>
<p>类似于 Weak Set，它没有 <code>size</code> 属性，没有任何办法可以确定 Weak Map 是否为空。在其他引用被移除后，由于对键的引用不再有残留，也就无法调用 <code>get()</code> 方法来去取对应的值。Weak Map 已经切断了对于该值的访问，其所占的内存在垃圾回收器运行时便会被释放。</p>
<h3 id="Weak-Map-的初始化"><a href="#Weak-Map-的初始化" class="headerlink" title="Weak Map 的初始化"></a>Weak Map 的初始化</h3><p>为了初始化 Weak Map，需要把一个由数组构成的数组传递给 <code>WeakMap</code> 构造器。就像正规 Map 那样，每个内部数组都应当有两个项，第一项是作为键的对象，第二项则是对应的值（任意类型）。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[key1, <span class="string">'hello'</span>], [key2, <span class="number">42</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(key1))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(key2))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2))</span><br></pre></td></tr></table></figure>
<p>对象 <code>key1</code> 与 <code>key2</code> 被用作 Weak Map 的键，<code>get()</code> 与 <code>has()</code> 方法则能访问他们。在传递给 <code>WeakMap</code> 构造器的参数中，若任意键值对使用了非对象的键，构造器就会抛出错误。</p>
<h3 id="Weak-Map-的方法"><a href="#Weak-Map-的方法" class="headerlink" title="Weak Map 的方法"></a>Weak Map 的方法</h3><p>Weak Map 只有两个附加方法能用来与键值对交互。<code>has()</code> 方法用于判断指定的键是否存在于 Map 中，而 <code>delete()</code> 方法则用于移除一个特定的键值对。<code>clear()</code> 方法不存在，这是因为没有必要对键进行枚举，并且枚举 Weak Map 也是不可能的，这与 Weak Set 相同。</p>
<h3 id="对象的私有数据"><a href="#对象的私有数据" class="headerlink" title="对象的私有数据"></a>对象的私有数据</h3><p>ES5 中的创建私有数据的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateData = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> privateId = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'_id'</span>, &#123;</span><br><span class="line">      value: privateId++</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    privateData[<span class="keyword">this</span>._id] = &#123;</span><br><span class="line">      name: name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> privateData[<span class="keyword">this</span>._id].name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>此例用 IIFE 包裹了 <code>Person</code> 的定义，其中含有两个私有属性：<code>privateData</code> 和 <code>privateId</code>。<code>privateData</code> 对象存储了每个实例的私有信息，而 <code>privateId</code> 则被用于为每个实例产生一个唯一ID。当 <code>Person</code> 构造器被调用时，一个不可枚举、不可配置、不可写入的 <code>_id</code> 属性就被添加了。</p>
<p>接下来在 <code>privateData</code> 对象中建立了与实例ID对应的一个入口，其中存储着 <code>name</code> 的值。随后在 <code>getName()</code> 函数中，就能使用 <code>this._id</code> 作为 <code>privateData</code> 的键来提取该值。由于 <code>privateData</code> 无法从 IIFE 外部进行访问，实际的数据就是安全的，尽管 <code>this._id</code> 在 <code>privateData</code> 对象上依然是公开暴露的。</p>
<p>此方式的最大问题在于 <code>privateData</code> 中的数据永远不会消失，因为在对象实例被销毁时没有任何方法可以获知该数据，<code>privateData</code> 对象就将永远包含多余的数据。这个问题现在可以换用 Weak Map 来解决了，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> privateData = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    privateData.set(<span class="keyword">this</span>, &#123; <span class="attr">name</span>: name &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> privateData.get(<span class="keyword">this</span>).name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>此版本的 <code>Person</code> 范例使用了 Weak Map 而不是对象来保存私有数据。由于 <code>Person</code> 对象的实例本身能被作为键来使用，于是也就无须再记录单独的 ID。当 <code>Person</code> 构造器被调用时，将 <code>this</code> 作为键在 Weak Map 上建立了一个入口，而包含私有信息的对象成为了对应的值，其中只存放了 <code>name</code> 属性。通过将 <code>this</code> 传递给 <code>privateData.get()</code> 方法，以获取值对象并访问其 <code>name</code> 属性，<code>getName()</code> 函数便能提取私有信息。这种技术让私有信息能够保持私有状态，并且当与之关联的对象实例被销毁时，私有信息也会被同时销毁。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>async/await</title>
    <url>/posts/ca9ee217/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>JavaScript 是单线程的，为了处理异步操作，先是使用<strong>回调函数</strong>，接着使用 <a href="https://aadonkeyz.com/posts/9a3eeeca/">Promise</a>，然后又使用 <a href="https://aadonkeyz.com/posts/9a3eeeca/#异步任务运行">generator/yield</a>，最后到本文要介绍的 <strong>async/await</strong>。</p>
<p>引用阮一峰大大的一句话 <a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async 函数就是 generator 函数的语法糖。</a></p>
<p>首先看一个结合 Promise 和 generator 处理异步的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task = taskDef()</span><br><span class="line">  <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(result.value)</span><br><span class="line">      promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        result = task.next(value)</span><br><span class="line">        step()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        result = task.throw(err)</span><br><span class="line">        step()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generator = <span class="function"><span class="keyword">function</span> * (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'./verify.js'</span>)</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'./readline.js'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(generator)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>通过这个例子，大家也看出来了，<strong>用 generator 函数处理异步的麻烦之处在于，它还需要自己定义执行器。</strong></p>
          </div>
<p>接下来用 async 函数改写这个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncInstance = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'./verify.js'</span>)</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'./readline.js'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncInstance()</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><strong>一比较就会发现，<code>async</code> 函数就是将 generator 函数的星号（*）替换成 <code>async</code>，将 <code>yield</code> 替换成 <code>await</code>。而且 <code>async</code> 函数不需要自己定义执行器！</strong></p>
          </div>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><div class="note warning">
            <ol><li>区别于生成器的定义，可以使用箭头函数定义 <code>async</code>。</li><li>与 <code>yield</code> 一样，<code>await</code> 只能用在 <code>async</code> 函数内部，用于其他任意位置都是语法错误，即使在 <code>async</code> 函数内部的函数中也不行。</li><li><code>async</code> 函数返回的是 <code>Promise</code> 实例。</li><li>如果 <code>async</code> 函数内抛出了错误，并且没有被 <code>try...catch</code> 包裹，<code>async</code> 会直接以该错误作为原因，返回一个状态为 rejected 的 <code>Promise</code> 实例。</li><li>如果 <code>await</code> 后面是一个非 <code>Promise</code> 非 thenable 的值，则直接返回。</li><li>如果 <code>await</code> 后面是一个 <code>Promise</code> 实例。<br>6.1 当 <code>Promise</code> 实例被 fulfill 时，返回 <code>Promise</code> 实例的值。<br>6.2 当 <code>Promise</code> 实例被 reject 时，则将 <code>Promise</code> 被 reject 的值作为错误在此处抛出（同 4）。</li><li>如果 <code>await</code> 后面是一个 thenable 对象，会现将其作为 <code>Promise</code> 实例进行处理（同 6）。</li></ol>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFun = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'resolved'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = asyncFun();</span><br><span class="line">promise</span><br><span class="line">  .then(</span><br><span class="line">    (value) =&gt; &#123;</span><br><span class="line">      <span class="comment">// resolved</span></span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFun = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'err'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = asyncFun();</span><br><span class="line">promise</span><br><span class="line">  .then(</span><br><span class="line">    (value) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// err</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFun = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'rejected'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = asyncFun();</span><br><span class="line">promise</span><br><span class="line">  .then(</span><br><span class="line">    (value) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// rejected</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>import 与 export</title>
    <url>/posts/588c1481/</url>
    <content><![CDATA[<h1 id="何为模块？"><a href="#何为模块？" class="headerlink" title="何为模块？"></a>何为模块？</h1><div class="note info">
            <p>模块是使用不同方式加载的 JS 文件（与 JS 原先的脚本加载方式相对）。这种不同模式很有必要，因为它与脚本（script）有大大不同的语义：</p><ul><li>模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式。</li><li>在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域内部存在。</li><li>模块顶级作用域的 <code>this</code> 值为 <code>undefined</code>。</li><li>模块不允许在代码中使用HTML风格的注释。</li><li>对于需要让模块外部代码访问的内容，模块必须导出它们。</li><li>允许模块从其他模块导入绑定。</li></ul>
          </div>
<p>CommonJS 是在 ES6 之前的模块规范，至今仍然被广泛使用。<a href="https://aadonkeyz.com/posts/b3fe2fad/">点击这里了解 CommonJS</a>！</p>
<h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><p>ES6 的导出有两种形式：命名导出和默认导出。</p>
<h2 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h2><p>命名导出要求导出的内容必须有自己的标识符，这就意味着不能使用这种方式来导出匿名函数或匿名类。</p>
<p>你可以将 <code>export</code> 放置在任意变量、函数或类声明之前，从模块中将它们公开出去，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">'Nicholas'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> magicNumber = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用花括号包裹想要导出内容的标识符，一起将它们导出。在使用这种方式的时候，允许你对导出的内容进行重命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; multiply, sum <span class="keyword">as</span> add &#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><p>模块的默认值是使用 <code>default</code> 关键字所指定的单个变量、函数或类，而你在每个模块中最多只能设置一个默认导出，将 <code>default</code> 关键字用于多个导出会是语法错误。</p>
<p>使用 <code>default</code> 可以导出匿名函数或匿名类，实际上默认导出并不在乎导出内容的标识符，就算导出的内容原本是有标识符的，在其他模块中引入时，也会忽略它原本的标识符。</p>
<p>以下三种用法都是正确的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 <code>default</code> 导出的内容必须是已经声明过或正在声明的，否则会抛出错误：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReferenceError: sum is not defined</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><h2 id="导入的语法"><a href="#导入的语法" class="headerlink" title="导入的语法"></a>导入的语法</h2><p>创建了 a.js 文件用于导出，b.js 文件用于导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">666</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> num</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; count &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum <span class="keyword">as</span> add, multiply &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count)        </span><br><span class="line"></span><br><span class="line"><span class="comment">// [Function: sum]</span></span><br><span class="line"><span class="built_in">console</span>.log(add)            </span><br><span class="line"></span><br><span class="line"><span class="comment">// [Function: multiply]</span></span><br><span class="line"><span class="built_in">console</span>.log(multiply)       </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moduleA <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//      multiply: [Function: multiply],</span></span><br><span class="line"><span class="comment">//      sum: [Function: sum],</span></span><br><span class="line"><span class="comment">//      count: 0,</span></span><br><span class="line"><span class="comment">//      color: 'red',</span></span><br><span class="line"><span class="comment">//      default: 666</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(moduleA)        </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> default1 <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 666</span></span><br><span class="line"><span class="built_in">console</span>.log(default1)       </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> default2 &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//666</span></span><br><span class="line"><span class="built_in">console</span>.log(default2)       </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> default3, &#123; color &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 666</span></span><br><span class="line"><span class="built_in">console</span>.log(default3)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>根据上面例子，总结以下几点注意事项：</p><ul><li>在使用 <code>import</code> 引入一个模块的内容时，除了默认导出，其他导出均需要根据标识符来进行匹配。</li><li>默认导出是一个特立独行的存在，它在原模块中的标识符是被忽略的。比如上面例子中的 <code>moduleA</code> 对象不包含 <code>num</code> 属性，但是包含 <code>default</code> 属性。</li></ul>
          </div>
<h2 id="只读绑定"><a href="#只读绑定" class="headerlink" title="只读绑定"></a>只读绑定</h2><p>ES6 的 <code>import</code> 语句为变量、函数与类创建了<strong>只读绑定</strong>，不允许修改这个只读绑定的值，否则会抛出错误。</p>
<div class="note warning">
            <p><strong>其实只要不是重写这个导入的变量，其他任何操作都是可以的，比如修改对象的属性。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">'Nicholas'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setName</span> (<span class="params">newName</span>) </span>&#123;</span><br><span class="line">  name = newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, obj, setName &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(name)       </span><br><span class="line"></span><br><span class="line">setName(<span class="string">'Greg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greg</span></span><br><span class="line"><span class="built_in">console</span>.log(name)       </span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;a: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxError: "name" is read-only</span></span><br><span class="line">name = <span class="string">'Nicholas'</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>setName(&#39;Greg&#39;)</code> 会回到导出 <code>setName()</code> 的模块内部，并在那里执行，从而将 a.js 文件内的 <code>name</code> 设置为 <code>&#39;Greg&#39;</code>，注意这个变化会自动反映到 b.js 文件内所导入的 <code>name</code> 绑定上。</p>
<h2 id="模块的实例化与缓存"><a href="#模块的实例化与缓存" class="headerlink" title="模块的实例化与缓存"></a>模块的实例化与缓存</h2><div class="note warning">
            <p><strong>无论你对同一个模块使用了多少次 <code>import</code> 语句，该模块都只会被执行一次。在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 <code>import</code> 所引用。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> b <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> c <span class="keyword">from</span> <span class="string">'./c.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js: b change c.obj</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a.js: <span class="subst">$&#123;c.obj.b&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> c <span class="keyword">from</span> <span class="string">'./c.js'</span></span><br><span class="line"></span><br><span class="line">c.obj.b = <span class="string">'b change c.obj'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="绑定的再导出"><a href="#绑定的再导出" class="headerlink" title="绑定的再导出"></a>绑定的再导出</h1><p>也许有时你会想将当前模块已导入的内容重新再导出，你可以这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;</span><br></pre></td></tr></table></figure>
<p>此方法能奏效，但还可以使用单个语句来完成相同的任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>
<p>这种形式的 <code>export</code> 会进入指定模块查看 <code>sum</code> 的定义，随后将其导出。当然，你也可以选择一个值用不同名称导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> add &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>
<p>若你想将来自另一个模块的所有值完全导出，可以使用星号（<code>*</code>）模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>
<p>使用完全导出，就可以导出目标模块的默认值及所有具名导出，但这可能影响你从当前模块所能导出的值。例如，假设 example.js 具有一个默认导出，当你使用这种语法时，你就无法为当前模块另外再定义一个默认导出。</p>
<h1 id="无绑定的导入"><a href="#无绑定的导入" class="headerlink" title="无绑定的导入"></a>无绑定的导入</h1><p>有些模块也许没有进行任何导出，相反只是修改全局作用域的对象。尽管这种模块的顶级变量、函数或类最终并不会自动被加入全局作用域，但这并不意味着该模块无法访问全局作用域。诸如 <code>Array</code> 与 <code>Object</code> 之类的内置对象的共享定义在模块内部可访问的，并且对于这些对象的修改会反映到其他模块中。</p>
<p>例如，若你想为所有数组添加一个 <code>pushAll()</code> 方法，你可以像下面这样定义一个模块文件 a.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="comment">// 没有导出与导入的模块</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.pushAll = <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// items 必须是一个数组</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(items)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Argument must be an array.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用内置的 push() 与扩展运算符</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.push(...items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个有效的模块，尽管此处没有任何导出与导入。此代码可以作为模块或脚本来使用。由于它没有导出任何东西，你可以使用简化的导入语法来执行此模块的代码，而无须导入任何绑定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> items = []</span><br><span class="line"></span><br><span class="line">items.pushAll(colors)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 'green', 'blue' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(items)</span><br></pre></td></tr></table></figure>
<p>此代码导入并执行了包含 <code>pushAll()</code> 的模块，于是 <code>pushAll()</code> 就被添加到数组的原型上。这意味着现在 <code>pushAll()</code> 在当前模块内的所有数组上都可用。</p>
<h1 id="import-export-的限制"><a href="#import-export-的限制" class="headerlink" title="import/export 的限制"></a>import/export 的限制</h1><p><code>import</code> 与 <code>export</code> 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部。例如，以下代码会抛出错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryImport</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// SyntaxError: 'import' and 'export' may only appear at the top level</span></span><br><span class="line">  <span class="keyword">import</span> flag <span class="keyword">from</span> <span class="string">'./a.js'</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError: 'import' and 'export' may only appear at the top level</span></span><br><span class="line">  <span class="keyword">export</span> flag                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模块的循环引用"><a href="#模块的循环引用" class="headerlink" title="模块的循环引用"></a>模块的循环引用</h1><p>ES6 根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">'./odd.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">'./even'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./even.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.even(<span class="number">10</span>))     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(m.counter)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.even(<span class="number">20</span>))     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="built_in">console</span>.log(m.counter)</span><br></pre></td></tr></table></figure>
<p>调用 <code>m.even(10)</code> 时，参数 <code>n</code> 从 10 变为 0 的过程中，<code>even()</code> 一共会执行 6 次，所以 <code>counter</code> 等于 6。调用 <code>m.even(20)</code> 时，参数 <code>n</code> 从 20 变为 0，<code>even()</code> 一共会执行 11 次，加上前面的 6 次，所以变量 <code>counter</code> 等于 17。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>this</title>
    <url>/posts/d213b25d/</url>
    <content><![CDATA[<h1 id="关于-this"><a href="#关于-this" class="headerlink" title="关于 this"></a>关于 this</h1><p>当一个函数被<strong>调用</strong>时，会创建一个活动记录（执行上下文、执行环境、context）。这个活动记录会包含函数在哪里被调用、函数的调用方法、传入的参数等信息。<code>this</code> 就是活动记录中的一个属性，会在函数执行的过程中用到。</p>
<p><code>this</code> 是在运行时绑定的，它的绑定取决于函数调用时的各种方式。<strong><code>this</code> 的绑定和函数的声明位置、函数的调用位置没有任何关系，只取决于函数的调用方式</strong>。</p>
<p>关于 <code>this</code> 是什么有很多说法：函数本身、函数作用域、函数的执行上下文等，这里有的说法是错误的，有的说法不够准确。我觉得就不要纠结 <code>this</code> 到底是什么东西了，<code>this</code> 就是 <code>this</code>，你只要知道它的绑定规则和用法，就 ok 了！</p>
<h1 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h1><p>因为 <code>this</code> 的绑定取决于函数的调用方式，所以下面我们从函数的调用方式分析 <code>this</code> 的绑定规则。</p>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。</p>
<p>默认绑定是指当函数被调用时，是直接使用不带任何修饰的函数引用进行调用的，这种情况下，如果运行在非严格模式中，<code>this</code> 会绑定到全局对象上。如果运行在严格模式下，<code>this</code> 会绑定到 <code>undefined</code> 上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>在调用函数的时候，如果以对象方法的形式进行调用，这个时候<code>this</code>就会绑定到这个方法所属的对象上。<br>ps：如果对象的某个属性是函数，就称这个属性为对象的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">obj.foo()   </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">42</span>,</span><br><span class="line">  obj: obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">obj2.obj.foo()</span><br></pre></td></tr></table></figure>
<p>一定要区分开默认绑定和隐式绑定，下面的例子里包含了让人容易忽略的情况。再次强调<strong> <code>this</code> 的绑定和函数的声明位置、函数的调用位置没有任何关系，只取决于函数的调用方式</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">  other: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认绑定</span></span><br><span class="line">    foo()   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'oops, global'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认绑定</span></span><br><span class="line"><span class="comment">// oops, global</span></span><br><span class="line">bar()       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// oops, global</span></span><br><span class="line">obj.other()</span><br></pre></td></tr></table></figure>
<h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>通过 <code>apply()</code> 和 <code>call()</code> 方法来调用函数时，<code>this</code> 的绑定为显示绑定，<code>this</code> 会绑定到传给 <code>apply()</code> 或 <code>call()</code> 方法的第一个参数上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">foo.call(obj)</span><br></pre></td></tr></table></figure>
<p>如果传给 <code>apply()</code> 或 <code>call()</code> 方法的第一个参数为基本数据类型，那么这个基本类型值会被转换为对应的对象形式（new String()、 new Boolean()等）。</p>
<p>硬绑定是显示绑定的一个变种，硬绑定是使用 <code>bind()</code> 方法强制指定 <code>this</code>，该方法返回一个新的函数实例。</p>
<div class="note warning">
            <ul><li><strong><code>apply()</code> 和 <code>call()</code> 是要指定函数运行时的 <code>this</code> 并运行函数，而 <code>bind()</code> 是返回一个 <code>this</code> 已经绑定完的函数实例。并且 <code>bind()</code> 是遵守就近原则的</strong>。</li><li><strong>如果用来指定 <code>this</code> 值的参数是基本数据类型，那么这个基本类型值会被转换为对应的基本包装类型（new String()、 new Boolean()等）。</strong></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a + <span class="keyword">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line">print.bind(&#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>&#125;).bind(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>使用 <code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>
<div class="note info">
            <ol><li>创建一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的 <code>this</code>。</li><li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象。</li></ol>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.a)</span><br></pre></td></tr></table></figure>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><div class="note info">
            <p><strong>new &gt; 显示 &gt; 隐式 &gt; 默认</strong></p>
          </div>
<h1 id="bind-的-Polyfill"><a href="#bind-的-Polyfill" class="headerlink" title="bind 的 Polyfill"></a>bind 的 Polyfill</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">下面的代码来源于MDN</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">      fToBind = <span class="keyword">this</span>,     <span class="comment">// 利用闭包记住调用bind方法的函数</span></span><br><span class="line">      fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">      fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// fBound是要被返回的新函数</span></span><br><span class="line">        <span class="comment">// 这个return里的this含义与外面的不同</span></span><br><span class="line">        <span class="comment">// 这里this的绑定取决于函数的调用方式是new操作符调用还是其他方式调用</span></span><br><span class="line">        <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound</span><br><span class="line">          ? <span class="keyword">this</span>      <span class="comment">// 这里是new绑定的优先级高于显示绑定优先级的原因</span></span><br><span class="line">          : oThis,</span><br><span class="line">          <span class="comment">// 这里是bind方法可以进行柯里化的原因</span></span><br><span class="line">          <span class="comment">// 这里的arguments是fBound函数的，与外面的那个不是同一个</span></span><br><span class="line">          aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑到可能使用new，所以是要继承原型链</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">    &#125;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="意料之外的绑定"><a href="#意料之外的绑定" class="headerlink" title="意料之外的绑定"></a>意料之外的绑定</h1><h2 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h2><p>如果你把 <code>null</code> 或者 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、<code>apply</code> 或者 <code>bind</code>，这些值在调用时会被忽略，实际应用的是默认绑定规则。一般都是在函数并不关心 <code>this</code> 的情况下才会传入 <code>null</code> 或者 <code>undefined</code> 作为参数。</p>
<p>但是如果某个函数确实使用了 <code>this</code>，那么这种做法就会产生一些副作用（如修改全局对象）。</p>
<p>所以比较推荐的做法是传入 <code>Object.create(null)</code> 替代 <code>null</code> 和 <code>undefined</code>。</p>
<h2 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h2><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo &#125;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">o.foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">(p.foo = o.foo)()</span><br></pre></td></tr></table></figure>
<p>赋值表达式 <code>p.foo = o.foo</code> 的返回值是目标函数的引用，因此 <code>(p.foo = o.foo)()</code> 等价于 <code>foo()</code>，所以会应用默认绑定。</p>
<h2 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h2><p>软绑定的原理类似于硬绑定，直接上代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> curried = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(</span><br><span class="line">        (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global)) ? obj : <span class="keyword">this</span>),</span><br><span class="line">        curried.concat.apply(curried, <span class="built_in">arguments</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bound.prototype = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">    <span class="keyword">return</span> bound</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'obj'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">'obj2'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">'obj3'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooObj = foo.softBind(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj</span></span><br><span class="line">fooObj()        </span><br><span class="line"></span><br><span class="line">obj2.foo = foo.softBind(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj2</span></span><br><span class="line">obj2.foo()      </span><br><span class="line"></span><br><span class="line"><span class="comment">// obj3</span></span><br><span class="line">fooObj.call(obj3)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// obj</span></span><br><span class="line">setTimeout(obj2.foo, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，软绑定版本的 <code>foo()</code> 可以手动将 <code>this</code> 绑定到 <code>obj2</code> 或者 <code>obj3</code> 上，但如果应用默认绑定，则会将 <code>this</code> 绑定到 <code>obj</code>。</p>
<h1 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h1><p>ES6 的箭头函数并不使用 <code>function</code> 关键字定义，而是使用被称为“胖箭头”的操作符 <code>=&gt;</code> 定义的。箭头函数不使用 <code>this</code> 的四种标准规则，而是根据词法作用域来决定 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个箭头函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// this继承自foo()</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">bar.call(obj2)</span><br></pre></td></tr></table></figure>
<p><code>foo()</code> 内部创建的箭头函数会捕获调用时 <code>foo()</code> 的 <code>this</code>。由于 <code>foo()</code> 的 <code>this</code> 绑定到 <code>obj1</code>，<code>bar</code>（引用箭头函数）的 <code>this</code> 也会绑定到 <code>obj1</code>，<strong>箭头函数的绑定无法被修改</strong></p>
<p><strong>箭头函数可以像 <code>bind()</code> 一样确保函数的 <code>this</code> 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的this机制</strong>。</p>
<p><a href="https://aadonkeyz.com/posts/9595c646/#箭头函数">有关箭头函数的详细介绍点这里</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>函数&amp;作用域&amp;闭包</title>
    <url>/posts/f1587c53/</url>
    <content><![CDATA[<h1 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h1><p>定义函数的两种常用方式为函数声明和函数表达式，他们有如下区别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数声明</th>
<th style="text-align:center">函数函数表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">会被提升</td>
<td style="text-align:center">不会被提升</td>
</tr>
<tr>
<td style="text-align:center">名称标识符会存在于所在的作用域中</td>
<td style="text-align:center">名称标识符只能在这个函数的内部被访问，外部作用域则不行</td>
</tr>
</tbody>
</table>
</div>
<h1 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h1><h2 id="引擎、编译器、作用域"><a href="#引擎、编译器、作用域" class="headerlink" title="引擎、编译器、作用域"></a>引擎、编译器、作用域</h2><div class="note info">
            <ul><li><strong>引擎</strong>：从头到尾负责整个JavaScript程序的编译及执行过程。</li><li><strong>编译器</strong>：负责语法分析及代码生成。JavaScript的编译发生在代码执行前的几微秒（甚至更短！）的时间内。</li><li><strong>作用域</strong>：一套设计良好的、用来存储变量并能够根据名称方便地查找这些变量的规则。</li></ul>
          </div>
<p>以 <code>var a = 2</code> 为例，实际上引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。</p>
<div class="note info">
            <ol><li>首先，当遇到 <code>var a</code> 时编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中（也就是说在<strong>当前作用域</strong>中该变量是否已经存在）。如果是，编译器会忽略该声明，否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 <code>a</code>;</li><li>接下来，编译器会为引擎生成运行时所需的代码，这些代码被用来处理 <code>a = 2</code> 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 <code>a</code> 的变量，如果是，引擎会使用这个变量。否则引擎会继续在外层作用域中查找该变量。</li></ol>
          </div>
<h2 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h2><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域是由你在写代码时将变量、块和函数写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的，不过存在例外）。</p>
<p><strong>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<p>词法作用域查找只会查找一级标识符，例如如果代码中引用了 <code>a.b.c</code>，词法作用域查找只会试图查找 <code>a</code> 标识符，找到这个变量之后，它就不管了，后续的 <code>b</code> 和 <code>c</code> 标识符的查找被交给对象属性访问规则了。</p>
<p><code>eval()</code> 和 <code>with</code> 的使用都会欺骗词法作用域，如果引擎在代码中发现了 <code>eval()</code> 或 <code>with</code>，它只能简单地假设关于标识符位置的判断都是无效的，因为无法确定 <code>eval()</code> 或 <code>with</code> 会带来什么样的影响。这样造成的结果就是引擎无法在编译阶段完成一些性能的优化从而造成性能下降。</p>
<h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，<strong>动态作用域链是基于调用栈的，而不是代码中的作用域嵌套</strong>。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 <code>foo()</code> 在执行时会输出 3。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<p>为什么会这样？因为当 <code>foo()</code> 无法找到 <code>a</code> 变量的引用时，会顺着调用栈在调用 <code>foo()</code> 的地方查找 <code>a</code>，而不是在嵌套的词法作用域链中向上查找。由于 <code>foo()</code> 是在 <code>bar()</code> 中调用的，引擎会检查 <code>bar()</code> 的作用域，并在其中找到值为 3 的变量 <code>a</code>。</p>
<div class="note warning">
            <p><strong>需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 <code>this</code> 机制某种程度上很像动态作用域。</strong></p>
          </div>
<h2 id="执行环境、变量对象、作用域链"><a href="#执行环境、变量对象、作用域链" class="headerlink" title="执行环境、变量对象、作用域链"></a>执行环境、变量对象、作用域链</h2><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。当引擎查找某个变量时，首先从当前作用域开始查找，如果可以找到则返回该变量。如果在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p>
<p>那么引擎怎么知道当前作用域的外层作用域是谁，又该怎么找到它呢？答案是通过作用域链。</p>
<div class="note info">
            <ul><li><strong>执行环境</strong>：每个块或函数都有自己的执行环境，执行环境中定义了在块或函数内部有权访问的其他数据，决定了它们各自的行为。全局执行环境是最外围的一个执行环境。</li><li><strong>变量对象</strong>：执行环境中定义的所有变量和函数都保存在这个对象中，我们在编程时无法访问这个对象。如果执行环境是一个函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量（函数的参数），即 <code>arguments</code> 对象（箭头函数没有 <code>arguments</code> 对象，而且不鼓励使用 <code>arguments</code> 对象）。</li><li><strong>（词法）作用域链</strong>：从当前执行环境的变量对象出发，将外层每一个执行环境的变量对象串联起来，保证对当前执行环境有权访问的所有数据的有序访问。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</li></ul>
          </div>
<h2 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h2><div class="note info">
            <ul><li><strong>LHS</strong>：试图找到变量的<strong>容器本身</strong>，并对其进行<strong>赋值</strong>；</li><li><strong>RHS</strong>：找到该变量<strong>对应的值</strong>，并<strong>使用</strong>这个值。</li></ul>
          </div>
<p><strong>将函数声明理解为先声明变量、再进行赋值并不合适。因为这样理解的话这个函数声明将需要进行LHS查询，但实际中并不是这样的。</strong></p>
<p>为什么区分 LHS 和 RHS 是一件很重要的事情？因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。</p>
<p>如果 RHS 查询不到所需的变量，引擎就会抛出 ReferenceError 异常。</p>
<p>相比之下，当 LHS 查询不到变量时，如果在非严格模式下，就会在<strong>全局作用域</strong>中创建一个具有该名称的变量。但如果是在非严格模式下，就会抛出错误。</p>
<h2 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h2><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。</p>
<p>根据作用域嵌套和作用域链的概念可以知晓，内部作用域可以访问外部作用域中的变量，但是反过来则不可以。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outter = <span class="string">'我在外面'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="string">'我在里面'</span></span><br><span class="line">  <span class="built_in">console</span>.log(outter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我在外面</span></span><br><span class="line">foo()       </span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: inner is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(inner)</span><br></pre></td></tr></table></figure>
<p>在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>虽然这种技术可以解决一些问题，但是也产生了一些副作用。首先必须声明一个具名函数 <code>foo()</code>，意味着 <code>foo</code> 这个名称本身“污染”了所在作用域，其次必须显示地调用 <code>foo()</code>。下面介绍一种解决这两个问题的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// function</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo)    </span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br></pre></td></tr></table></figure>
<p>首先，包装函数的声明是以圆括号开始的，尽管开上去这并不是一个很显眼的细节，但实际上确实非常重要的区别。函数会被当做函数表达式而不是一个标准的函数声明来处理。</p>
<p>上面的代码中使用了 IIFE：<strong>立即执行函数表达式</strong>。在一个函数表达式后面加上一对圆括号就表示要立即调用这个函数。</p>
<div class="note warning">
            <p><strong>函数声明和函数表达式之间最重要的区别是它们的名称标识符会绑定在何处！函数声明的名称标识符会存在于所在的作用域中。而函数表达式的名称标识符只能在这个函数的内部被访问，外部作用域则不行。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际的代码</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = ...self...</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>用 <code>with</code> 从对象中创建出的作用域仅在 <code>with</code> 声明中而非外部作用域中有效。</p>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h4><p>非常少有人会注意到 ES3 规范中规定 <code>try/catch</code> 的 <code>catch</code> 分句会创建一个块作用域，其中声明的变量仅在 <code>catch</code> 内部有效。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 执行一个非法操作来强制制造一个异常</span></span><br><span class="line">  <span class="literal">undefined</span>()         </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 能够正常执行！</span></span><br><span class="line">  <span class="built_in">console</span>.log(err)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReferenceError: err not found</span></span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br></pre></td></tr></table></figure>
<h4 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h4><p>ES6 中引入了新的 <code>let</code> 关键字，提供了除 <code>var</code> 以外的另一种变量声明方式。<code>let</code> 关键字可以将变量绑定到所在的任意作用域中（通常是{…}内部）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(bar)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: bar is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br></pre></td></tr></table></figure>
<p><code>const</code> 和 <code>let</code> 的性质类似，主要的区别在于 <code>const</code> 是用来定义常量的。有关它们的详细特性后续就不在这里展开说了。</p>
<h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><h2 id="如何提升"><a href="#如何提升" class="headerlink" title="如何提升"></a>如何提升</h2><p>提升：包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。但是只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。</p>
<p>另外值得注意的是，每个作用域都会进行提升操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========实际代码=========</span></span><br><span class="line">foo()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====编译器眼中的代码=====</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>函数声明会被提升，但是函数表达式不会。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提升前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError</span></span><br><span class="line">foo()   </span><br><span class="line"></span><br><span class="line"><span class="comment">// ReferenceError</span></span><br><span class="line">bar()   </span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提升后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError</span></span><br><span class="line">foo()  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ReferenceError</span></span><br><span class="line">bar()   </span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = ...self...</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提升前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">foo ()    </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提升后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">foo () </span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，<code>var foo</code> 尽管出现在 <code>function foo()</code> 的声明之前，但是函数声明会首先被提升，所以 <code>var foo</code> 被当作重复的声明而忽略了。</p>
<p>如果有重复的函数声明，后面的会覆盖前面的，看下面例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3</span></span><br><span class="line">foo()   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包：当函数可以记住并访问所在的<strong>词法作用域</strong>时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 这就是闭包的效果</span></span><br><span class="line">baz()</span><br></pre></td></tr></table></figure>
<p>在 <code>foo()</code> 执行后，通常会将 <code>foo()</code> 的整个内部作用域都销毁，但是由于闭包的存在，<code>foo()</code> 的内部作用域被保存下来了。拜 <code>bar()</code> 所声明的位置所赐，它拥有涵盖 <code>foo()</code> 内部作用域的闭包，使得该作用域能够一直存活，以供 <code>bar()</code> 在之后任何时间进行引用。如果想要释放被闭包住的内存，需要解除对 <code>bar</code> 的引用，即执行 <code>baz = null</code>。</p>
<h2 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h2><p>先运行下面的例子，观察结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以每秒一次的频率输出五次 6</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以每秒一次的频率以此输出 1、2、3、4、5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, j * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过下面的例子，详细解释闭包与循环的爱恨纠葛。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> array = createFunctions()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">1</span>]())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">2</span>]())     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的等价形式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">1</span></span><br><span class="line">  result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">2</span></span><br><span class="line">  result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> array = createFunctions()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">1</span>]()) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">2</span>]())</span><br></pre></td></tr></table></figure>
<p>内部函数中使用了 <code>createFunctions</code> 的活动对象的属性 <code>i</code>，而在真正调用内部函数时，这个 <code>i</code> 的值是 3，所以它们返回的都是 3。</p>
<p>实际上在 <code>for</code> 循环中使用 <code>let</code> 代替 <code>var</code> 就可以轻松解决这个问题，具体原因就先不赘述了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> array = createFunctions()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">1</span>]())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">2</span>]())</span><br></pre></td></tr></table></figure>
<h1 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h1><p>严格来讲，JavaScript 中没有私有成员的概念，所有对象属性都是公开的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能再函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p>
<p>我们把有权访问私有变量和私有函数的公有方法成为特权方法。可以在构造函数中定义特权方法，基本模式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 特权方法</span></span><br><span class="line">  <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++</span><br><span class="line">    <span class="keyword">return</span> privateFunction()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建 <code>MyObject</code> 的实例后，除了使用 <code>publicMethod()</code> 这一个途径外，没有任何办法可以直接访问 <code>privateVariable</code> 和 <code>privateFunction()</code>。</p>
<p>不过在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。构造函数的缺点是针对每一个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。</p>
<h2 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  MyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++</span><br><span class="line">    <span class="keyword">return</span> privateFunction()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式，函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明 <code>MyObject</code> 时用 <code>var</code> 关键字（记住：初始化未经声明的变量，在非严格模式下会创建一个全局变量，在严格模式下会抛出错误），这样 <code>MyObject</code> 就成了一个全局变量。而且特权方法是在原型上定义的，因此所有实例都能使用同一个函数。这个特权方法作为一个闭包，总是保存着对包含作用域的引用。</p>
<div class="note warning">
            <p><strong>以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。</strong></p>
          </div>
<h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式则是为单例创建私有变量和特权方法。所谓单例，指的就是只有一个实例的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicProperty: <span class="literal">true</span>,</span><br><span class="line">    publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      privateVariable++</span><br><span class="line">      <span class="keyword">return</span> privateFunction()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h2 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h2><p>这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加特权/公有属性和方法</span></span><br><span class="line">  object.publicProperty = <span class="literal">true</span></span><br><span class="line">  object.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++</span><br><span class="line">    <span class="keyword">return</span> privateFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回这个对象</span></span><br><span class="line">  <span class="keyword">return</span> object</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>函数</title>
    <url>/posts/9595c646/</url>
    <content><![CDATA[<h1 id="带参数默认值的函数"><a href="#带参数默认值的函数" class="headerlink" title="带参数默认值的函数"></a>带参数默认值的函数</h1><h2 id="ES6-中的参数默认值"><a href="#ES6-中的参数默认值" class="headerlink" title="ES6 中的参数默认值"></a>ES6 中的参数默认值</h2><p>ES6 能更容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时使用。在函数声明中能指定任意一个参数的默认值，即使该参数排在未指定默认值的参数之前也是可以的。</p>
<p><strong>只有在某个参数未传递，或明确传递 <code>undefined</code> 时，才会应用参数的默认值。<code>null</code> 值被认为是有效的。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认的timeout</span></span><br><span class="line">makeRequest(<span class="string">'/foo'</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params">body</span>) </span>&#123;</span><br><span class="line">  doSomething(body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认的timeout</span></span><br><span class="line">makeRequest(<span class="string">'/foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用默认值</span></span><br><span class="line">makeRequest(<span class="string">'/foo'</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">body</span>) </span>&#123;</span><br><span class="line">  doSomething(body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="默认值表达式和暂时性死区"><a href="#默认值表达式和暂时性死区" class="headerlink" title="默认值表达式和暂时性死区"></a>默认值表达式和暂时性死区</h2><p>参数默认值最有意思的特性或许就是默认值并不要求一定是基本类型的值。例如，你可以执行一个函数来产生参数的默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>需要注意的是，仅在调用 <code>add()</code> 函数而未提供第二个参数时，<code>getValue()</code> 函数才会被调用，而在 <code>getValue()</code> 函数声明初次被解析时并不会进行调用。另外在书写代码时要小心，将函数调用作为参数的默认值时一定不要遗漏了括号，否则含义就变了。</p>
<p>参数默认值与 <code>let</code> 和 <code>const</code> 声明类似，都存在着暂时性死区。函数每个参数都会创建一个新的标识符绑定，它在初始化之前不允许被访问，否则会抛出错误。参数初始化会在函数被调用时进行，无论是给参数传递了一个值、还是使用了参数的默认值。</p>
<p>所以在为函数参数指定默认值时，后面的参数可以使用前面的参数，反过来则会抛出错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后面参数使用前面参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span> (<span class="params">first, second = getValue(first</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">1</span>, <span class="number">1</span>))     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">1</span>))        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面参数使用后面参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span> (<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="number">1</span>, <span class="number">1</span>))             </span><br><span class="line"></span><br><span class="line"><span class="comment">// ReferenceError: second is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="literal">undefined</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h1 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h1><p>剩余参数由三个点(…)与一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组，名称中的“剩余”也由此而来。需要注意的是，函数的 <code>length</code> 属性用于指示具名参数的数量，而剩余参数对其毫无影响。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span> (<span class="params">string, ...keys</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pick.length)</span><br><span class="line">  <span class="built_in">console</span>.log(string)</span><br><span class="line">  <span class="built_in">console</span>.log(keys)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">pick()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [2]</span></span><br><span class="line">pick(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>剩余参数的两个限制条件：</p>
<div class="note warning">
            <ul><li>函数只能有一个剩余参数，并且它必须被放在最后。</li><li>在对象访问器属性的 <code>set</code> 函数中，不能使用剩余参数。原因是对象的 <code>set</code> 被限定只能使用单个参数，而剩余参数按照定义是不限制参数数量的。</li></ul>
          </div>
<h1 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><p>与剩余参数关联最密切的就是扩展运算符。剩余参数允许你把多个独立的参数合并到一个数组中。而扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数。</p>
<p>用扩展运算符传递参数，使得更容易将数组作为函数参数来使用，你会发现在大部分场景中扩展运算符都是 <code>apply()</code> 方法的合适替代品。并且扩展运算符可以与其他参数混用。</p>
<div class="note warning">
            <p><strong>扩展运算符的使用没有位置和数量限制。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="keyword">let</span> others = [<span class="number">789</span>, <span class="number">234</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values))   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 789</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, ...others)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 110</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">110</span>))</span><br></pre></td></tr></table></figure>
<h1 id="ES6-的名称属性"><a href="#ES6-的名称属性" class="headerlink" title="ES6 的名称属性"></a>ES6 的名称属性</h1><p>定义函数有各种各样的方式，在 JavaScript 中识别函数就变得很有挑战性。此外，匿名函数表达的流行使得调试有点困难，经常导致堆栈跟踪难以被阅读与解释。正因为此，ES6 给所有函数添加了 <code>name</code> 属性。</p>
<p><strong>需要注意的是，函数的 <code>name</code> 属性值未必会关联到同名变量。<code>name</code> 属性是为了在调试时获得有用的相关信息，所以不能用 <code>name</code> 属性值去获取对函数的引用。</strong></p>
<h2 id="选择合适的名称"><a href="#选择合适的名称" class="headerlink" title="选择合适的名称"></a>选择合适的名称</h2><p>ES6 中所有函数都有适当的 <code>name</code> 属性值。为了理解其实际运作，请看下例————它展示了一个函数与一个函数表达式，并将二者的 <code>name</code> 属性都打印出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doSomething</span></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// doAnotherThing</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name)</span><br></pre></td></tr></table></figure>
<p>在此代码中，由于是一个函数声明，<code>doSomething()</code> 就拥有一个值为 <code>&quot;doSomething&quot;</code> 的 <code>name</code> 属性。而匿名函数表达式 <code>doAnotherThing()</code> 的 <code>name</code> 属性值是 <code>&quot;doAnotherThing&quot;</code>，因为这是该函数所赋值的变量的名称。</p>
<h2 id="名称属性的特殊情况"><a href="#名称属性的特殊情况" class="headerlink" title="名称属性的特殊情况"></a>名称属性的特殊情况</h2><p>虽然函数声明与函数表达式的名称易于查找，但 ES6 更进一步确保了所有函数都拥有合适的名称。为了表明这点，请参考如下程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="keyword">get</span> firstName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Nicholas'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doSomethingElse</span></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name)		</span><br><span class="line"></span><br><span class="line"><span class="comment">// sayName</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name)	</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// get firstName</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get.name)</span><br></pre></td></tr></table></figure>
<p>本例中的 <code>doSomething.name</code> 的值是 <code>&quot;doSomethingElse&quot;</code>，因为该函数表达式自己拥有一个名称，并且此名称的优先级要高于赋值目标的变量名。<code>person.sayName()</code> 的 <code>name</code> 属性值是 <code>&quot;sayName&quot;</code>，正如对象字面量指定的那样。类似的， <code>person.firstName</code> 实际上是个访问器属性的 <code>get</code> 函数，因此它的名称是 <code>&quot;get firstName&quot;</code>，以标明它的特征。同样，访问器属性的 <code>set</code> 函数也会带有 <code>set</code> 前缀（ <code>get</code> 与 <code>set</code> 函数都必须用 <code>Object.getOwnPropertyDescriptor()</code> 来检索）。</p>
<p>函数名称还有另外两个特殊情况。使用 <code>bind()</code> 创建的函数会在名称属性值之前带有 <code>&quot;bound&quot;</code> 前缀。而使用 <code>Function</code> 构造器创建的函数，其名称属性则会有 <code>&quot;anonymous&quot;</code> 前缀，正如此例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bound doSomething</span></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.bind().name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// anonymous</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name)</span><br></pre></td></tr></table></figure>
<h1 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h1><p>JavaScript 为函数提供了两个不同的内部方法：<code>[[Call]]</code> 和 <code>[[Construct]]</code>。当函数未使用 <code>new</code> 进行调用时，<code>[[Call]]</code> 方法会被执行，运行的是代码中显示的函数体。而当函数使用 <code>new</code> 进行调用时，<code>[[Construct]]</code> 方法则会被执行，负责创建一个新的对象，并且使用该对象作为 <code>this</code> 去执行函数体。</p>
<p>记住并不是所有函数都拥有 <code>[[Construct]]</code> 方法（比如箭头函数），因此不是所有函数都可以用 <code>new</code> 来调用。</p>
<h2 id="在-ES5-中判断函数如何被调用"><a href="#在-ES5-中判断函数如何被调用" class="headerlink" title="在 ES5 中判断函数如何被调用"></a>在 ES5 中判断函数如何被调用</h2><p>在 ES5 中判断函数是不是使用了 <code>new</code> 来调用，最流行的方式是使用 <code>instanceof</code>，但是这个方式存在漏洞。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'you must use new with Person.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功了</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>)		</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">var</span> person = Person(<span class="string">'Nicholas'</span>)			</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本应抛出错误，但是用 call 方法更改 this 值，产生了欺骗</span></span><br><span class="line"><span class="comment">// 成功了</span></span><br><span class="line"><span class="keyword">var</span> notPerson = Person.call(person, <span class="string">'Michael'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="new-target元属性"><a href="#new-target元属性" class="headerlink" title="new.target元属性"></a>new.target元属性</h2><p>为了解决上述问题，ES6 引入了 <code>new.target</code> 元属性。当函数的 <code>[[Construct]]</code> 方法被调用时，<code>new.target</code> 的值为一个指向该构造函数的引用。而当 <code>[[Call]]</code> 方法被调用时，<code>new.target</code> 的值为 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'you must use new with Person.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功了</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>)             </span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> AnotherPerson(<span class="string">'Nicholas'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6 最有意思的一个新部分就是箭头函数。箭头函数正如名称所示那样使用一个“箭头”（<code>=&gt;</code>）来定义，但它的行为在很多重要方面与传统的 JavaScript 函数不同：</p>
<div class="note info">
            <ul><li><strong>没有 <code>this</code>、<code>super</code>、<code>arguments</code> 和 <code>new.target</code></strong>：箭头函数本身没有 <code>this</code>、<code>super</code>、<code>arguments</code> 和 <code>new.target</code>，如果在箭头函数中引用了这些变量，那这些变量也是外层作用域的，跟它没关系。</li><li><strong>不能被使用 <code>new</code> 调用</strong>：箭头函数没有 <code>[[Construct]]</code> 方法，因此不能被用为构造函数，使用 <code>new</code> 调用箭头函数会抛出错误。</li><li><strong>没有原型</strong>：既然不能对箭头函数使用 <code>new</code>，那么它也不需要原型，也就是没有 <code>prototype</code> 属性。</li><li><strong>不允许重复的具名参数</strong>：箭头函数不允许拥有重复的具名参数，无论是否在严格模式下。而相对来说，传统函数只有在非严格模式下才禁止这种重复。</li><li><strong>不能用于创建生成器函数</strong></li></ul>
          </div>
<h2 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h2><div class="note warning">
            <p><strong>没有花括号，就不允许有 <code>return</code>，否则会抛出错误</strong>。</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">'Temp'</span>&#125;)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id: id,</span><br><span class="line">    name: <span class="string">'Temp'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Nicholas'</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Nicholas'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建立即调用函数表达式"><a href="#创建立即调用函数表达式" class="headerlink" title="创建立即调用函数表达式"></a>创建立即调用函数表达式</h2><p>使用传统函数创建立即调用函数表达式时，<code>(function(){/*函数体*/})()</code> 与 <code>(function(){/*函数体*/}())</code> 两种方式都是可行的。</p>
<p>但若使用箭头函数，只有 <code>(()=&gt;{/*函数体*/})()</code> 这一种方式可行，也就是说括号必须仅包裹箭头函数的定义。</p>
<h2 id="没有-this-绑定"><a href="#没有-this-绑定" class="headerlink" title="没有 this 绑定"></a>没有 this 绑定</h2><p>JavaScript 最常见的错误领域之一就是在函数内的 <code>this</code> 绑定。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="number">123456</span>,</span><br><span class="line">  </span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 运行init时会抛出错误</span></span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling'</span> + type + <span class="string">'for'</span> + <span class="keyword">this</span>.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>this.doSomething()</code> 会抛出错误的原因是 <code>this</code> 是对事件目标对象（在此案例中就是 <code>document</code>）的一个引用，而不是被绑定到 <code>PageHandler</code> 上。下面的代码将使用 <code>bind()</code> 方法修复这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="number">123456</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 没有错误</span></span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type)</span><br><span class="line">    &#125;).bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling'</span> + type + <span class="string">'for'</span> + <span class="keyword">this</span>.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在此代码能像预期那样运行，但看起来有点奇怪。接着让我们看看使用箭头函数如何解决这个问题的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="number">123456</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling'</span> + type + <span class="string">'for'</span> + <span class="keyword">this</span>.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>因为箭头函数没有 <code>this</code> 绑定，意味着在箭头函数内部使用 <code>this</code> 值时，引擎是通过作用域链来确定的，而 JavaScript 中的作用域机制是<a href="https://aadonkeyz.com/posts/f1587c53/#词法作用域">词法作用域</a>，所以这个箭头函数内部使用的 <code>this</code> 是 <code>init()</code> 方法的 <code>this</code>。</p><p>因为箭头函数没有 <code>this</code> 绑定，所以对箭头函数使用 <code>call()</code>、<code>apply()</code> 或 <code>bind()</code> 方法时，函数内的 <code>this</code> 并不会受影响。</p><p><strong>永远要记住，<code>this</code> 是在函数调用时进行绑定的！</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span> <span class="title">showThisA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;)()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  func: obj1.func</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">obj1.func()    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">obj2.func()</span><br></pre></td></tr></table></figure>
<p>上面例子中箭头函数内使用的 <code>this</code> 是函数 <code>showThisA</code> 的 <code>this</code>，但是函数 <code>showThisA</code> 的 <code>this</code> 具体绑定到哪里是由它的调用方式决定的。</p>
<h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p>在 ES6 中对函数最有趣的改动或许就是一项引擎优化，它改变了尾部调用的系统。尾调用指的是调用函数的语句是另一个函数的最后语句，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 尾调用</span></span><br><span class="line">  <span class="keyword">return</span> doSomethingElse()	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ES5 引擎中实现的尾调用，其处理就像其他函数调用一样：一个新的栈帧被创建并推到调用栈之上，用于表示该次函数调用。这意味着之前每个栈帧都被保留在内存中，当调用栈太大时会出问题。</p>
<p>ES6 在严格模式下力图为特定尾调用减少调用栈的大小（非严格模式的尾调用则保持不变）。当满足以下条件时，尾调用优化会清除当前栈帧并在此利用它，而不是为尾调用创建新的栈帧：</p>
<div class="note info">
            <ul><li>尾调用的函数内部不能引用当前栈帧中的变量（意味着该函数不能是闭包）。</li><li>进行尾调用的函数在尾调用返回结果后不能做额外操作。</li><li>尾调用的结果作为当前函数的返回值。</li></ul>
          </div>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>块级绑定</title>
    <url>/posts/3432e35f/</url>
    <content><![CDATA[<h1 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h1><p>块指由花括号封闭的代码块。</p>
<p>块级声明包括 <code>let</code> 和 <code>const</code> 两种声明方式，首先介绍它们之间的共性特点：</p>
<div class="note info">
            <ul><li><strong>块级作用域</strong>：块级声明的变量，无法在指定的块作用域外访问；</li><li><strong>禁止重复声明</strong>：如果一个标识符已经在代码块内部被定义，那么禁止在此代码块内部对同一个标识符进行块级声明，否则会抛出错误；</li><li><strong>暂时性死区</strong>：块级声明的变量不仅不会进行变量提升，在代码运行到声明处之前还会被存放在<strong>暂时性死区（TDZ）</strong>的区域内。如果在声明处之前试图访问变量会导致一个引用错误，即使是使用 <code>typeof</code> 运算符也是如此！</li></ul>
          </div>
<p><code>let</code> 和 <code>const</code> 之间的差异在于，用 <code>const</code> 声明的变量会被认为是常量，意味着它们的值在被设置完成后就不能再被改变。如果使用 <code>const</code> 声明了一个对象，变量中保存的是对象的引用，所以只要不重写对象，其他的也都随意更改。</p>
<h1 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h1><p>开发者最需要使用变量的块级作用域的场景，或许就是在 <code>for</code> 循环内，也就是想让一次性的循环计数器只能在循环内部使用。例如，以下代码在 JavaScript 中并不罕见：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i在此处仍然可被访问</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br></pre></td></tr></table></figure>
<p>在其他默认使用块级作用域的语言中，这个例子能够按照预期工作，也就是只有 <code>for</code> 才能访问变量 <code>i</code>。然后在JavaScript中，循环结束后 <code>i</code> 仍然可被访问，因为 <code>var</code> 声明导致了变量提升。若像如下代码那样换为使用 <code>let</code>，则会看到逾期行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i在此处不可访问，抛出错误</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br></pre></td></tr></table></figure>
<h2 id="循环内的函数"><a href="#循环内的函数" class="headerlink" title="循环内的函数"></a>循环内的函数</h2><p>长期以来，<code>var</code> 的特点使得循环变量在循环作用域外仍然可被访问，于是在循环内部创建函数就变得很有问题。考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i) &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 输出数值 10 十次</span></span><br><span class="line">  func()		</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>为了修正上述问题，开发者在循环内使用立即调用函数表达式（IIFE），以便在每次迭代中强制创建变量的一个新副本，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs.push((<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;(i)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">  func()		</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>虽然解决了问题，但是这种写法相对繁琐。幸运的是，使用 <code>let</code> 与 <code>const</code> 的块级绑定可以在 ES6 中为你简化这个循环。</p>
<h2 id="循环内的-let-声明"><a href="#循环内的-let-声明" class="headerlink" title="循环内的 let 声明"></a>循环内的 let 声明</h2><p><code>let</code> 声明通过有效模仿上例中的 IIFE 的作用而简化了循环。在每次迭代中，都会创建一个新的同名变量并对其进行初始化。这意味着你可以完全省略 IIFE 从而获得预期的结果，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">  func()		</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>与使用 <code>var</code> 声明以及 IIFE 相比，这里代码能达到相同效果，但无疑更加简洁。在循环中 <code>let</code> 声明每次都创建了一个新的 <code>i</code> 变量，因此在循环内部创建的函数获得了各自的 <code>i</code> 副本，而每个 <code>i</code> 副本的值都在每次循环迭代声明变量的时候被确定了。这种方式在 <code>for-in</code> 和 <code>for-of</code> 循环中同样适用，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  a: <span class="literal">true</span>,</span><br><span class="line">  b: <span class="literal">true</span>,</span><br><span class="line">  c: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依次输出a、b、c</span></span><br><span class="line">  func()		</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>本例中的 <code>for-in</code> 循环体现出了与 <code>for</code> 循环相同的行为。每次循环，一个新的 <code>key</code> 变量绑定就被创建，因此每个函数都能够拥有它自身的 <code>key</code> 变量副本，结果每个函数都输出了一个不同的值。</p>
<p>需要重点了解的是：<code>let</code> 声明在循环内部的行为是在规范中特别定义的，而与不提升变量声明的特征没有必然联系。事实上，在早期 <code>let</code> 的实现中并没有这种行为，它是后来才添加的。</p>
<h2 id="循环内的-const-声明"><a href="#循环内的-const-声明" class="headerlink" title="循环内的 const 声明"></a>循环内的 const 声明</h2><p>ES6规范没有明确禁止在循环中使用 <code>const</code> 声明，然而它会根据循环方式的不同而有不同行为。在常规的 <code>for</code> 循环中，你可以在初始化时使用 <code>const</code>，但循环会在你试图改变该变量的值时抛出错误。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一次迭代后抛出错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此代码中，<code>i</code> 被声明为一个常量。循环的第一次迭代成功执行，此时 <code>i</code> 的值为0。在 <code>i++</code> 执行时，一个错误会被抛出，因为该语句试图更改常量的值。因此，在循环中你只能使用 <code>const</code> 来声明一个不会被更改的变量。</p>
<p>而另一方面，<code>const</code> 变量在 <code>for-in</code> 或 <code>for-of</code> 循环中使用时，与 <code>let</code> 变量效果相同。因此下面代码不会导致出错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  a: <span class="literal">true</span>,</span><br><span class="line">  b: <span class="literal">true</span>,</span><br><span class="line">  c: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会导致出错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依次输出a、b、c</span></span><br><span class="line">  func()		</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码与“循环内的 let 声明”小节的第二个例子几乎完全一样，唯一的区别是 <code>key</code> 的值在循环内不能被更改。<code>const</code> 能够在 <code>for-in</code> 与 <code>for-of</code> 循环内工作，是因为循环为每次迭代创建了一个新的变量绑定，而不是试图去修改已绑定的变量的值。</p>
<h1 id="全局块级绑定"><a href="#全局块级绑定" class="headerlink" title="全局块级绑定"></a>全局块级绑定</h1><p><code>let</code> 与 <code>const</code> 不同于 <code>var</code> 的另一个方面是在全局作用域上的表现。当在全局作用域上使用 <code>var</code> 时，它会创建一个新的全局变量，并成为全局对象（在浏览器中是 <code>window</code>）的一个属性。这意味着使用 <code>var</code> 可能会无意覆盖一个已有的全局属性，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp)      </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ncz = <span class="string">'hi'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ncz)</span><br></pre></td></tr></table></figure>
<p>尽管全局的 <code>RegExp</code> 是定义在 <code>window</code> 上的，它仍然不能防止被 <code>var</code> 重写。这个例子声明了一个新的全局变量 <code>RegExp</code> 而覆盖了原有对象。类似地，<code>ncz</code> 定义为全局变量后就立即成为了 <code>window</code> 的一个属性。</p>
<p><strong>然而若你在全局作用域上使用 <code>let</code> 或 <code>const</code>，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上</strong>。这也就意味着你不能使用 <code>let</code> 或 <code>const</code> 来覆盖一个全局变量，你只能将其屏蔽。这里有个范例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>)                         </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp === <span class="built_in">RegExp</span>)       </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ncz = <span class="string">'hi'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hi</span></span><br><span class="line"><span class="built_in">console</span>.log(ncz)                            </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ncz'</span> <span class="keyword">in</span> <span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>
<p>此代码的 <code>let</code> 声明创建了 <code>RegExp</code> 的一个绑定，并屏蔽了全局的 <code>RegExp</code>。这表示 <code>window.RegExp</code> 与 <code>RegExp</code> 是不同的，因此全局作用域没有被污染。同样，<code>const</code> 声明创建了 <code>ncz</code> 的一个绑定，但并未在全局对象上创建属性。当你不想在全局对象上创建属性时，这种特性会让 <code>let</code> 与 <code>const</code> 在全局作用域中更安全。</p>
<h1 id="块级绑定新的最佳实践"><a href="#块级绑定新的最佳实践" class="headerlink" title="块级绑定新的最佳实践"></a>块级绑定新的最佳实践</h1><p>在默认情况下使用 <code>const</code>，并且只在知道变量值需要被更改的情况下才使用 <code>let</code>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>对象&amp;原型&amp;继承</title>
    <url>/posts/bb5d40f2/</url>
    <content><![CDATA[<h1 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h1><h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。</p>
<div class="note info">
            <ul><li><code>configurable</code>：表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，这个特性默认值为 <code>true</code>。</li><li><code>enumerable</code>：表示能否通过 <code>for-in</code> 循环返回属性。直接在对象上定义的属性，这个特性默认值为 <code>true</code>。</li><li><code>writable</code>：表示能否修改属性的值。直接在对象上定义的属性，这个特性默认值为 <code>true</code>。</li><li><code>value</code>：包含这个属性的数据值。读取属性值得时候，从这个位置读。写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 <code>undefined</code>。</li></ul><hr><p>可以使用 <code>Object.defineProperty(obj, prop, descriptor)</code> 修改数据属性的特性：</p><ul><li><code>obj</code>：数据属性所在的对象。</li><li><code>prop</code>：数据属性的名称，可以是字符串或符号。</li><li><code>descriptor</code>：描述符对象，可包含的属性有 <code>configurable</code>、<code>enumerable</code>、<code>writable</code> 和 <code>value</code>。</li></ul><p><strong>如果通过 <code>Object.defineProperty(obj, prop, descriptor)</code> 定义一个新的数据属性，<code>descriptor</code> 中缺失的特性会被赋予 <code>false</code> 或 <code>undefined</code>。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">test</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(desc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'demo'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'demo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, writable: false, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(desc)</span><br></pre></td></tr></table></figure>
<p><strong>关于writable</strong>：当 <code>writable</code> 为 <code>false</code> 时，在非严格模式下通过赋值语句修改属性值，赋值操作将被忽略。在严格模式下则会抛出错误。<strong>但是如果通过 Object.defineProperty() 方法修改 value 特性则不会有任何问题</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">test</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.test = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; test: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)       </span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123;</span><br><span class="line">    value: <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; test: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>
<p><strong>关于configurable</strong>：当 <code>configurable</code> 为 <code>false</code> 时，不允许删除属性，不允许修改属性的 <code>enumerable</code>、<code>configurable</code>，不可以将 <code>writable</code> 由 <code>false</code> 修改为 <code>true</code>，但是可以将 <code>writable</code>由 <code>true</code> 修改为 <code>false</code>，也可以修改属性的 <code>value</code> 特性。</p>
<p><strong>当 writable 和 configurable 均为 false 时，不允许通过任何方式修改属性值，直接赋值或者通过 Object.defineProperty() 都不可以！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面的实验运行于非严格模式下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">test</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 configurable 为 false 时尝试删除属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">delete</span> obj.test</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; test: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)        </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, writable: true, enumerable: true, configurable: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(desc)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 configurable 为 false 时尝试修改 enumerable</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: test</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 configurable 为 false 时尝试修改 configurable</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: test</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123; </span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 configurable 为 false 时尝试修改 value</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123;</span><br><span class="line">  value: <span class="string">'此时 configurable 为 false'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; test: "此时 configurable 为 false" &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 configurable 为 false 时尝试将 writable 由 true 修改为 false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: "此时 configurable 为 false", writable: false, enumerable: true, configurable: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(desc)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 configurable 为 false 时尝试将 writable 由 false 修改为 true</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: test</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123; </span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 configurable 和 writable 均为 false时，尝试修改属性值</span></span><br><span class="line">obj.test = <span class="string">'直接赋值可以吗'</span></span><br><span class="line"><span class="comment">// &#123;test: "此时configurable为false"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)       </span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: test</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'test'</span>, &#123;</span><br><span class="line">  value: <span class="string">'通过 Object.defineProperty 可以吗'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值。它们包含一对 <code>get</code> 和 <code>set</code> 函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 <code>get</code> 函数，这个函数负责返回有效的值。在写入访问器属性时，会调用 <code>set</code> 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。</p>
<div class="note info">
            <ul><li><code>configurable</code>：表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。直接在对象上定义的属性，它们的这个特性默认值为 <code>true</code>。</li><li><code>enumerable</code>：表示能否通过 <code>for-in</code> 循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为 <code>true</code>。</li><li><code>get</code>：在读取属性时调用的函数。默认值为 <code>undefined</code>。</li><li><code>set</code>：在写入属性时调用的函数。默认值为 <code>undefined</code>。</li></ul>
          </div>
<p><strong>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  _year: <span class="number">2004</span>,</span><br><span class="line">  edition: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">'year'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> _this.year</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._year = newValue</span><br><span class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; _year: 2005, edition: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(book)</span><br></pre></td></tr></table></figure>
<p>不一定非要同时指定 <code>get</code>和 <code>set</code>。只指定 <code>get</code> 意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 <code>get</code> 函数的属性会抛出错误。而读取只指定 <code>set</code> 的属性会返回 <code>undefined</code></p>
<p><strong>可以通过 Object.defineProperty() 实现数据属性与访问器属性的转换，但是切记不能同时指定数据属性和访问器属性，这样会抛出错误！</strong></p>
<h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>ES5 定义了一个 <code>Object.defineProperties()</code> 方法用来为对象定义多个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value</span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> _this.year</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>使用 ES5 的 <code>Object.getOwnPropertyDescriptor()</code> 方法可以取得给定属性的描述符。该方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。<strong>这个方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用。</strong></p>
<h2 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h2><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 <code>Object.preventExtensions()</code>。如果想检测一个对象是否可以添加新属性，可以使用 <code>Object.isExtensible()</code>。</p>
<div class="note warning">
            <p><strong>不可以添加新属性，但是删除旧属性还是可以的。</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(myObject)</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(myObject))  </span><br><span class="line"></span><br><span class="line">myObject.b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myObject.a</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a)</span><br></pre></td></tr></table></figure>
<p>在非严格模式下，创建属性 <code>b</code> 会静默失败。在严格模式下，将会抛出 <code>TypeError</code> 错误。</p>
<h2 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h2><p><code>Object.seal()</code> 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 <code>Object.preventExtensions()</code> 并把所有现有属性标记为 <code>configurable: false</code>。</p>
<h2 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h2><p><code>Object.freeze()</code> 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 <code>Object.seal()</code> 并把所有“数据访问”属性标记为 <code>writable: false</code>。</p>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式就是调用函数返回一个包含特定属性和方法的对象，工厂模式的问题在于<strong>它没有解决对象识别的问题（即怎样知道一个对象的类型）</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'Nicholas'</span>, <span class="number">29</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'Greg'</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>ES 中可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，下面使用构造函数模式重写工厂模式中的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person)  </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person)</span><br></pre></td></tr></table></figure>
<p><strong>构造函数模式与工厂模式的区别</strong>：</p>
<div class="note info">
            <ul><li>没有显示地创建对象.</li><li>直接将属性和方法赋给了 <code>this</code> 对象.</li><li>没有 <code>return</code> 语句。</li></ul>
          </div>
<p><strong>要创建 <code>Person</code> 的新实例，必须使用 <code>new</code> 操作符</strong>。以这种方式调用构造函数实际上会经历一下 4 个步骤：</p>
<div class="note info">
            <ol><li>创建一个新对象（因为用了 <code>new</code>）。</li><li>为新对象连接原型。</li><li>将构造函数的作用域内的 <code>this</code> 绑定到这个新对象。</li><li>执行构造函数的代码。</li><li>返回新对象。 </li></ol>
          </div>
<div class="note warning">
            <p>使用 <code>new</code> 创建新对象的时候，如果存在类的继承，那么在 ES5 和 ES6 中这个过程是有差别的。<a href="https://aadonkeyz.com/posts/e1a12c4d/#继承内置对象">查看详情</a></p>
          </div>
<p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 <code>new</code> 操作符来调用，那么它就可以作为构造函数。</p>
<p>构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍，但是有的方法是所有实例都应该共享的，没有创建多次的必要。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><div class="note warning">
            <p><strong>我们创建的每一个函数都有一个 <code>prototype</code>（原型）属性，这个属性值是一个对象的引用，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</strong></p>
          </div>
<h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p><strong>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，这个属性指向函数的原型对象。</strong>在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Nicholas'</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">'Software Engineer'</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">person1.sayName()   </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">person2.sayName()   </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/JavaScript/%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="理解原型对象"></p>
<p>上图展示了 <code>Person</code> 构造函数、<code>Person</code> 的原型属性以及 <code>Person</code> 现有的两个实例之间的关系。注意 <code>Person</code> 的每个实例，<code>person1</code> 和 <code>person2</code> 都包含一个内部属性 <code>[[Prototype]]</code>，该属性仅仅指向了 <code>Person.prototype</code>。换句话说，<strong>对象实例与构造函数没有直接的关系</strong>。</p>
<div class="note info">
            <ul><li><code>isPrototypeOf()</code>：用于测试一个对象是否存在于另一个对象的原型链上。</li><li><code>hasOwnProperty()</code>：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在，该方法是从 <code>Object</code> 继承而来的。</li><li><code>Object.getPrototypeOf()</code>：返回指定对象的原型（对象内部 <code>[[Prototype]]</code> 属性的值）。</li></ul>
          </div>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例开始，如果在实例中找到了具有给定名字的属性，则返回该属性。如果没有找到，则沿着对象的原型链向上逐层查找具有给定名字的属性，如果找到了则返回这个属性的值。</p>
<h3 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h3><p>当<strong>用赋值语句</strong>给实例对象设置已经在原型链上层存在的同名属性时，会有以下三种情况：</p>
<div class="note info">
            <ul><li>如果在原型链上层存在的同名属性没有被标记为只读，即 <code>writable: true</code>，那么会直接在实例中添加一个同名的新属性，它是屏蔽属性。</li><li>如果在原型链上层存在的同名属性被标记为只读，即 <code>writable: false</code>，那么无法修改已有属性，也无法在实例对象上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。如果在非严格模式下，赋值语句会被忽略。</li><li>如果在原型链上层存在的同名属性具有 <code>set</code> 描述符，那么一定会调用这个 <code>set</code>。实例对象上并不会添加新的属性，也不会重新定义这个 <code>set</code>。</li></ul>
          </div>
<p><strong>但是 JS 这门语言很灵活，如果上述所说的存在于原型链上层的同名属性中保存的是某一个引用类型值的引用，那么你还是可以修改这个引用类型的值的（并没有违反规则，因为保存的引用并没有改变）！比如，这个属性保存的是某一个数组的引用，那么我就可以通过 <code>push</code> 方法去改变这个数组。</strong></p>
<p><strong>如果你无论如何也想要屏蔽原型链上层的属性，那么你可以使用 <code>Object.defineProperty()</code> 方法！</strong></p>
<p>有些情况下会隐式产生屏蔽，一定要当心。思考下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create(anotherObject)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">anotherObject.a     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">myObject.a          </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">anotherObject.hasOwnProperty(<span class="string">'a'</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">'a'</span>)        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式屏蔽！</span></span><br><span class="line">myObject.a++    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">anotherObject.a     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">myObject.a          </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="属性的获取"><a href="#属性的获取" class="headerlink" title="属性的获取"></a>属性的获取</h3><p>有两种方式使用 <code>in</code> 操作符：单独使用和在 <code>for-in</code> 循环中使用。</p>
<p>在单独使用时，<code>in</code> 操作符会在通过对象能够访问给定属性时返回 <code>true</code>，无论该属性存在于实例中还是原型中。</p>
<p>在使用 <code>for-in</code> 循环时返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包含存在于原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在 <code>for-in</code> 循环中返回。</p>
<p>要取得对象上所有可枚举的实例属性，可以使用 ES5 的 <code>Object.keys()</code> 方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<p>如果你想要得到所有实例属性，无论它是否可枚举，可以使用 <code>Object.getOwnPropertyNames()</code> 方法。</p>
<h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p>简单来说就是用对象字面量形式来重写 <code>Person.prototype</code>，但是这样会导致新原型对象的 <code>constructor</code> 属性指向 <code>Object</code> 而不是 <code>Person</code>，尽管此时 <code>instanceof</code> 操作符还能返回正确的结果，但是通过 <code>constructor</code> 已经无法确定对象的类型了，所以如果 <code>constructor</code> 属性比较重要的话，还需要用 <code>Object.defineProperty()</code> 方法定义 <code>constructor</code> 的数据属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">'Nicholas'</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">'Software Engineer'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor === <span class="built_in">Object</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor === Person)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor === Person)</span><br></pre></td></tr></table></figure>
<h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来。即使是<strong>先创建了实例后修改原型</strong>也是如此。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person ()</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi</span></span><br><span class="line">friend.sayHi()</span><br></pre></td></tr></table></figure>
<p>但是如果<strong>先创建了实例然后重写整个原型对象</strong>，那么情况就不一样了。具体的变化看图吧!</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/JavaScript/%E9%87%8D%E5%86%99%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="重写原型对象"></p>
<p><strong>此时 <code>instanceof</code> 操作符已经不好使了！</strong><br><strong>构造函数找不到最初的原型对象了！</strong><br><strong>现有实例也找不到新的原型对象了！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">'Nicholas'</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">'Software Engineer'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: friend.sayName is not a function</span></span><br><span class="line">friend.sayName()</span><br></pre></td></tr></table></figure>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型模式的最大问题。原型模式的最大问题是由其共享的本性所导致的（主要针对引用类型值的属性来说）。</p>
<h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存，另外这种混成模式还支持向构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>)</span><br><span class="line">person1.friends.push(<span class="string">'Van'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["Shelby", "Court", "Van"]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ["Shelby", "Court"]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)</span><br></pre></td></tr></table></figure>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>动态原型模式把所有信息封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效来决定是否需要初始化原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">friend.sayName()</span><br></pre></td></tr></table></figure>
<p><strong>在使用动态原型模式时，禁止使用对象字面量重写原型！</strong></p>
<h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><p>在前面几种模式都不适用的情况下，可以使用寄生构造函数模式，这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.job = job</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">friend.sayName()</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Person</code> 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。除了使用 <code>new</code> 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。<strong>构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 <code>return</code> 语句，可以重写调用构造函数时返回的值。</strong></p>
<p>关于寄生构造函数模式，有一点需要说明：返回的对象与构造函数或者与构造函数的原型属性之间没有关系。也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 <code>instanceof</code> 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。</p>
<h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>道格拉斯·克罗克福德发明了 JavaScript 中的稳妥对象这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 <code>this</code> 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 <code>this</code> 和 <code>new</code>），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与计生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 <code>this</code>。二是不使用 <code>new</code> 操作符调用构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建要返回的对象</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以在这里定义私有变量和函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">friend.sayName()</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/JavaScript/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.png" alt="创建对象模式总结"></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())</span><br></pre></td></tr></table></figure>
<p>我觉得用文字解释这个原型链有点绕嘴，没有上图方便，就直接看下面的图片吧！</p>
<p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<div class="note info">
            <ul><li><code>instanceof</code> 操作符用于测试构造函数的 <code>prototype</code> 属性是否出现在对象的原型链中。</li><li><code>isPrototypeOf()</code> 方法用于测试一个对象是否存在于另一个对象的原型链上。</li><li>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。</li><li>在通过原型链实现继承时，不能使用对象字面量语法重写原型。</li></ul>
          </div>
<p>原型链的第一个问题类似于上面介绍的原型模式的问题，这里就不详细介绍了。<br>它的第二个问题是在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数的技术。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数（通过 <code>call()</code> 或 <code>apply()</code> 方法）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承了SuperType，同时还传递了参数</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">'Nicholas'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.name)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 29</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age)</span><br></pre></td></tr></table></figure>
<p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题-方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Nicholas'</span>, <span class="number">29</span>)</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line">instance1.sayName()                 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 29</span></span><br><span class="line">instance1.sayAge()                  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Greg'</span>, <span class="number">27</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// Greg</span></span><br><span class="line">instance2.sayName()                 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 27</span></span><br><span class="line">instance2.sayAge()</span><br></pre></td></tr></table></figure>
<p>两个实例上的 <code>colors</code> 属性屏蔽了原型链上的同名属性。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>object()</code> 函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质讲，<code>object()</code> 对传入其中的对象执行了一次浅复制。ES5 新增的 <a href="https://aadonkeyz.com/posts/a7625ff7#Object-create"><code>Object.create()</code></a> 方法规范化了原型式继承。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承是与原型式继承紧密相关的一种思路，寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span> (<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">  <span class="keyword">var</span> clone = object(original)    </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回这个对象</span></span><br><span class="line">  <span class="keyword">return</span> clone                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Nicholas'</span>,</span><br><span class="line">  friengd: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi</span></span><br><span class="line">anotherPerson.sayHi()</span><br></pre></td></tr></table></figure>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>前面说过组合继承是 JavaScript 最常用的继承函数，不过它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)              </span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()        </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决上述问题，我们使用寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span> (<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype)     </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增强对象</span></span><br><span class="line">  prototype.constructor = subType                 </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定原型</span></span><br><span class="line">  subType.prototype = prototype                   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子的高效率体现在它只调用了一次 <code>SuperType</code> 构造函数，并因此避免了在 <code>SubType.prototype</code> 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用 <code>instanceof</code> 和 <code>isPrototypeOf()</code>。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://blog-images-1258719270.cos.ap-shanghai.myqcloud.com/JavaScript/%E7%BB%A7%E6%89%BF%E6%80%BB%E7%BB%93.png" alt="继承总结"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>引用类型</title>
    <url>/posts/71de0ab2/</url>
    <content><![CDATA[<h1 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h1><p><a href="https://aadonkeyz.com/posts/bb5d40f2/">对象&amp;原型&amp;继承</a></p>
<p><a href="https://aadonkeyz.com/posts/a7625ff7/">Object</a></p>
<h1 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h1><p><a href="https://aadonkeyz.com/posts/6e01c1fe/">Array</a></p>
<h1 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h1><p><a href="https://aadonkeyz.com/posts/ce76031c/">RegExp</a></p>
<h1 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h1><p><a href="https://aadonkeyz.com/posts/f1587c53/">函数&amp;作用域&amp;闭包</a></p>
<p><a href="https://aadonkeyz.com/posts/9595c646/">函数</a></p>
<h1 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h1><p>通过 <code>var now = new Date()</code> 可以创建一个日期对象，在调用 <code>Data</code> 构造函数而不传参数时，新创建的对象自动获得当前日期和时间（<strong>当前日期和时间是浏览器从本机操作系统获取的时间，所以不一定准确！</strong>）。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 2017 年 1 月 1 日午夜起至该日期经过的毫秒数）。为了简化这一计算过程，ES提出了两个方法：<code>Date.parse()</code>和<code>Date.UTC()</code>。</p>
<div class="note info">
            <ul><li><code>Date.parse()</code>：接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。但是它支持哪种日期格式并不一定。</li><li><code>Date.UTC()</code>：同样返回表示日期的毫秒数，但接收参数分别为年份、<strong>基于0的月份</strong>、月中的哪一天、小时、分钟、秒以及毫秒。这些参数中只有年和月是必需的。</li></ul>
          </div>
<p>其实，在使用 <code>Date()</code> 构造函数创建日期对象时，后台会根据传入的参数自动调用 <code>Date.parse()</code> 或 <code>Date.UTC()</code> 方法，所以根本不需要我们去主动的调用它们。<br>ES5添加了 <code>Date.now()</code> 方法，返回表示调用这个方法时的日期和时间的毫秒数。在不兼容它的情况下可以使用 <code>+ new Date()</code> 来达到相同的效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">now                    <span class="comment">// 2020-10-17T04:56:29.512Z</span></span><br><span class="line">now.getFullYear()      <span class="comment">// 2020</span></span><br><span class="line">now.getMonth()         <span class="comment">// 0-11</span></span><br><span class="line">now.getDate()          <span class="comment">// 1-31</span></span><br><span class="line">now.getDay()           <span class="comment">// 0-6，0代表周日，6代表周六</span></span><br><span class="line">now.getHours()         <span class="comment">// 0-23</span></span><br><span class="line">now.getMinutes()       <span class="comment">// 0-59</span></span><br><span class="line">now.getSeconds()       <span class="comment">// 0-59</span></span><br><span class="line">now.getMilliseconds()  <span class="comment">// 0-999</span></span><br></pre></td></tr></table></figure>
<h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><p>ES提供了 3 个<strong>特殊的引用类型</strong>：<code>Boolean</code>、<code>Number</code> 和 <code>String</code>。这些类型与引用类型相似，但同时也具有与各自的基本类型相应的特殊行为，我们称它们为基本包装类型。</p>
<p><strong>实际上，每当读取一个基本类型值的时候，后台会自动创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</strong></p>
<p><strong>引用类型与基本包装类型的主要区别就是对象的生存期。</strong>使用 <code>new</code> 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而<strong>自动创建</strong>的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建了一个基本类型值并保存在s1中</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">'some text'</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对应的基本包装类型</span></span><br><span class="line">s1.color = <span class="string">'red'</span>       </span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined，因为基本包装类型的生存期已过</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.color)    </span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s1)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示的创建了String的实例对象并保存在s2中，实际上就是创建了一个引用类型值</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'some text'</span>)    </span><br><span class="line">s2.color = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String &#123;"some text", color: "red"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s2)        </span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s2)</span><br></pre></td></tr></table></figure>
<p>通过上面例子认识到通过 <code>new</code> 显示创建的就是一个引用类型值，它已经不能称之为基本包装类型了。换句话说，基本包装类型都是后台自己创建的，不存在显示创建的情况。在第六章会介绍，通过 <code>new</code> 显示创建的就是一个引用类型的实例对象。<strong>记住最好别用new将基本包装类型给实例化就行。</strong></p>
<p><strong>要注意的是，使用 <code>new</code> 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">'25'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转型函数</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj)</span><br></pre></td></tr></table></figure>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>没啥说的。</p>
<h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><div class="note info">
            <ul><li><code>toFixed()</code>：按照指定的小数位返回数值的字符串表示，银行家喜欢用这个方法，这个方法不是真正意义的四舍五入。</li><li><code>toExponential()</code>：返回以指数表示法表示的数值的字符串形式。</li><li><code>toPrecision()</code>：返回固定大小格式，也可能返回指数格式。</li></ul>
          </div>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p><code>charAt()</code> 和 <code>charCodeAt()</code>方法都接收一个参数，即基于 0 的字符位置。<code>charAt()</code> 方法以单字符字符串的形式返回给定位置的那个字符，而 <code>charCodeAt()</code> 方法返回的是字符编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// e</span></span><br><span class="line"><span class="built_in">console</span>.log(string.charAt(<span class="number">1</span>))       </span><br><span class="line"><span class="comment">// 101</span></span><br><span class="line"><span class="built_in">console</span>.log(string.charCodeAt(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>ES5 还定义了访问个别字符的方法，可以像数组那样使用索引来访问某个位置的字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// e</span></span><br><span class="line"><span class="built_in">console</span>.log(string[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="提取子字符串方法"><a href="#提取子字符串方法" class="headerlink" title="提取子字符串方法"></a>提取子字符串方法</h4><div class="note info">
            <ul><li><code>slice()</code>：类比于数组的<code>slice()</code>方法。</li><li><code>substr()</code>：第一个参数用于指定子字符串的开始位置，第二个参数用于指定返回的字符个数;</li><li><code>substring()</code>：类比于数组的<code>slice()</code>方法。</li></ul>
          </div>
<p>当传递负值作为参数时，<code>slice()</code> 方法会将传入的负值与字符串的长度相加。<code>substr()</code> 方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。<code>substring()</code> 方法会把所有负值参数都转换为0。</p>
<p><strong>另外需要注意的是，<code>substring()</code> 方法会将参数中较小的数作为开始位置，将较大的数作为结束位置。即 <code>string.substring(3, 0)</code> 等价于 <code>string.substring(0, 3)</code></strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rld</span></span><br><span class="line"><span class="built_in">console</span>.log(string.slice(<span class="number">-3</span>))         </span><br><span class="line"><span class="comment">// hello world  </span></span><br><span class="line"><span class="built_in">console</span>.log(string.substring(<span class="number">-3</span>))     </span><br><span class="line"><span class="comment">// rld  </span></span><br><span class="line"><span class="built_in">console</span>.log(string.substr(<span class="number">-3</span>))          </span><br><span class="line"></span><br><span class="line"><span class="comment">// lo w</span></span><br><span class="line"><span class="built_in">console</span>.log(string.slice(<span class="number">3</span>, <span class="number">-4</span>))       </span><br><span class="line"><span class="comment">// hel </span></span><br><span class="line"><span class="built_in">console</span>.log(string.substring(<span class="number">3</span>, <span class="number">-4</span>))    </span><br><span class="line"><span class="comment">// ''</span></span><br><span class="line"><span class="built_in">console</span>.log(string.substr(<span class="number">3</span>, <span class="number">-4</span>))</span><br></pre></td></tr></table></figure>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>类比于数组的<code>concat()</code>方法。</p>
<h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>ES5 定义了这个方法，会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>该方法接收一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.repeat(<span class="number">3</span>))          </span><br><span class="line"></span><br><span class="line"><span class="comment">// hellohello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>.repeat(<span class="number">2</span>))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// abcabcabcabc</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span>.repeat(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p><code>indexOf(searchValue[, fromIndex])</code> 和 <code>lastIndexOf(searchValue[, fromIndex])</code> 都是找到就返回索引，找不到就返回 -1。</p>
<h3 id="大小写转换方法"><a href="#大小写转换方法" class="headerlink" title="大小写转换方法"></a>大小写转换方法</h3><p><code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code> 和 <code>toLocaleUpperCase()</code> 方法。</p>
<h3 id="模式匹配方法"><a href="#模式匹配方法" class="headerlink" title="模式匹配方法"></a>模式匹配方法</h3><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><div class="note info">
            <ul><li><code>match()</code>：如果没有匹配成功就返回 <code>null</code>。如果匹配成功了，根据下面情况返回不同的内容。<ul><li>如果正则表达式使用了 <code>g</code> 标志，则返回所有匹配项组成的数组，该数组无特殊属性。</li><li>如果正则表达式没有使用 <code>g</code> 标志，则仅返回第一个匹配项与捕获组组成的数组，该数组还含有3个特殊属性。<ul><li><code>index</code>：匹配项在字符串中的索引。</li><li><code>input</code>：输入的字符串。</li><li><code>group</code>：一个捕获组或 <code>undefined</code>（如果没有定义命名捕获组）。</li></ul></li></ul></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'mom and dad and baby'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'mom and dad and baby' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/mom (and dad (and baby)?)?/g</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'mom and dad and baby', 'and dad and baby', 'and baby', index: 0, input: 'mom and dad and baby', groups: undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/mom (and dad (and baby)?)?/</span>))</span><br></pre></td></tr></table></figure>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><div class="note info">
            <p><code>search()</code> 方法接收正则表达式作为参数，返回字符串中第一个匹配项的索引，如果没有找到匹配项则返回-1。</p>
          </div>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><div class="note info">
            <p><code>replace()</code>：该方法接收两个参数，第一个参数可以是正则表达式或一个字符串，第二个参数可以是一个字符串或一个函数。<strong>如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的办法就是提供正则表达式作为第一参数，并且要指定全局标志</strong>。第二个参数与正则表达式的捕获组有关。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter" target="_blank" rel="noopener">如果第二个参数是字符串</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter" target="_blank" rel="noopener">如果第二个参数是函数</a></li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'cat, bat, sat, fat'</span></span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="string">'at'</span>, <span class="string">'ond'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cond, bat, sat, fat</span></span><br><span class="line"><span class="built_in">console</span>.log(result)     </span><br><span class="line"></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">'ond'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cond, bond, sond, fond</span></span><br><span class="line"><span class="built_in">console</span>.log(result)     </span><br><span class="line"></span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">'word ($1)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// word (cat), word (bat), word (sat), word (fat)</span></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><div class="note info">
            <p><code>split()</code> 方法可以基于指定的分隔符将一个字符串分割成多个子字符串并将结果存放在一个数组中。分隔符可以是字符串，也可以是一个正则表达式。该方法有一个可选的第二参数，用于指定数组的大小。<strong>如果将空字符串作为分隔符传递给 <code>split()</code>，那么字符串会基于每一个 UTF-16 codeunit 进行划分。如果传递给 <code>split()</code> 的正则表达式中包含捕获组，那么捕获组会被保留下来</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">'red,blue,green,yellow'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 'blue', 'green', 'yellow' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="string">','</span>))         </span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 'blue' ]  </span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="string">','</span>, <span class="number">2</span>))       </span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 'blue', 'green', 'yellow' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="regexp">/\,/</span>))          </span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', ',', 'blue', ',', 'green', ',', 'yellow' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="regexp">/(\,)/</span>))        </span><br><span class="line"></span><br><span class="line"><span class="comment">// [ '', ',', ',', ',', '' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="regexp">/[^\,]+/</span>))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// [ '', 'red', ',', 'blue', ',', 'green', ',', 'yellow', '' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(colorText.split(<span class="regexp">/([^\,]+)/</span>))</span><br></pre></td></tr></table></figure>
<h4 id="识别子字符串的方法"><a href="#识别子字符串的方法" class="headerlink" title="识别子字符串的方法"></a>识别子字符串的方法</h4><p>ES6新增了三个方法：</p>
<div class="note info">
            <ul><li><code>includes(searchString[, fromIndex])</code>：在给定文本出现在字符串的任意位置时返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>startsWith(searchString[, fromIndex])</code>：在给定文本出现在字符串起始处时返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>endsWith(searchString[, length])</code>：在给定文本出现在字符串结尾处时返回 <code>true</code>，否则返回 <code>false</code>。</li></ul>
          </div>
<p>详细 API 请移步 MDN，这里有 demo。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'hello'</span>))   </span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'o'</span>)) </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'o'</span>, <span class="number">4</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">'!'</span>))         </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">'world!'</span>))  </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">'o'</span>, <span class="number">8</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">'o'</span>))</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">'x'</span>))</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">'o'</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<h3 id="localeCompare"><a href="#localeCompare" class="headerlink" title="localeCompare"></a>localeCompare</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare" target="_blank" rel="noopener">MDN 上的介绍</a></p>
<h3 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode"></a>fromCharCode</h3><p>该方法接收一个或多个字符编码，然后将它们转换成字符串。</p>
<h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>模板字面量的最简单语法，是使用反引号（`）来包裹普通字符串，而不是用双引号或单引号。若你想在字符串中包含反引号，只需要使用反斜杠（\）转义即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">`hello \` world`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hello ` world</span></span><br><span class="line"><span class="built_in">console</span>.log(message)</span><br></pre></td></tr></table></figure>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>ES6 的模板字面量使多行字符串更易创建，因为它不需要特殊的语法。只需在想要的位置包含换行即可，而且它会显示在结果中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">`Multiline</span></span><br><span class="line"><span class="string">string`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiline</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(message)            </span><br><span class="line">                                </span><br><span class="line"><span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(message.length)</span><br></pre></td></tr></table></figure>
<p>反斜杠之内的所有空白符都是字符串的一部分，因此需要留意缩进。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">`Multiline</span></span><br><span class="line"><span class="string">              string`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiline</span></span><br><span class="line"><span class="comment">//              string</span></span><br><span class="line"><span class="built_in">console</span>.log(message)            </span><br><span class="line"></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(message.length)</span><br></pre></td></tr></table></figure>
<p>如果让多行文本保持合适的缩进对你来说很重要，请考虑将多行模板字面量的第一行空置并在此后进行缩进，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;Title&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>.trim()</span><br></pre></td></tr></table></figure>
<h4 id="制造替换位"><a href="#制造替换位" class="headerlink" title="制造替换位"></a>制造替换位</h4><p>此时模板字面量看上去仅仅是普通 JavaScript 字符串的升级版，但二者之间真正的区别在于前置的“替换位”。替换位允许你将任何有效的 JavaScript 表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分。</p>
<p>替换位由起始的 <code>${</code> 与结束的 <code>}</code> 来界定，之间允许放入任意的 JavaScript 表达式。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Nicholas'</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hello, Nicholas.</span></span><br><span class="line"><span class="built_in">console</span>.log(message)        </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> price = <span class="number">0.25</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10 items cost $2.50.</span></span><br><span class="line"><span class="built_in">console</span>.log(message)        </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Nicholas'</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`hello, <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">  <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">&#125;</span>.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hello, my name is Nicholas.</span></span><br><span class="line"><span class="built_in">console</span>.log(message)</span><br></pre></td></tr></table></figure>
<h4 id="标签化模板"><a href="#标签化模板" class="headerlink" title="标签化模板"></a>标签化模板</h4><p>一个标签仅是一个函数，只不过这个函数的调用形式有些特别：<code>tagName`模板字面量数据` </code></p>
<p>标签函数会将调用时接收的模板字面量数据中的非替换位提取出来保存为一个数组，这个数组将作为标签函数的第一个参数；数据中的每个替换位的解释值都将作为标签函数的参数传递进来。为了方便处理，一般在定义标签函数时使用<a href="http://aadonkeyz.com/posts/9595c646/#剩余参数">剩余参数</a>形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span> (<span class="params">literals, ...substitutions</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ["", " items cost $", ""]</span></span><br><span class="line">  <span class="built_in">console</span>.log(literals)           </span><br><span class="line"></span><br><span class="line">  <span class="comment">// [10, "2.50"]</span></span><br><span class="line">  <span class="built_in">console</span>.log(substitutions)     </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="string">'返回啥都行'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> price = <span class="number">0.25</span></span><br><span class="line"><span class="keyword">var</span> message = passthru<span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<p>注意观察上面的例子，<strong><code>literals</code> 数组的第一个和最后一个元素均为空字符串，说明标签函数在对传入的模板字面量进行处理时，总是以非替换位形式的字符串作为数据的开始和结尾；如果模板字面量实际上是以替换位作为开始和结尾，那么会自动在开始和结尾处添加上空字符串！所以 <code>literals</code> 的长度总是比 <code>substitutions</code> 的长度多 1</strong>。</p>
<p>模板标签也能访问字符串的原始信息，主要指的是可以访问字符在转义之前的形式。获取原始字符串值的最简单方式是使用内置的 <code>String.raw()</code> 标签。不过我按照书中例子试验的时候，关于原始形式这里有些出入，详细的就不介绍了。</p>
<h1 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h1><p>内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显示地实例化内置对象，因为它们已经实例化了。前面介绍的 <code>Object</code>、<code>Array</code>、<code>String</code> 等都是内置对象，除此之外还有两个单体内置对象：<code>Global</code> 和 <code>Math</code>。</p>
<h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><p><code>Global</code> (全局)对象可以说是 ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ES中的<code>Global</code> 对象在某种意义上是作为一个终极的“兜底儿的对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数。所有在全局作用域中定义的属性和函数，都是 <code>Global</code> 对象的属性。</p>
<p>ES虽然没有指出如何直接访问 <code>Global</code> 对象,但 Web 浏览器都是将这个全局对象作为 <code>window</code> 对象的一部分加以实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得 Global 对象的方法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="URI编码方法"><a href="#URI编码方法" class="headerlink" title="URI编码方法"></a>URI编码方法</h3><p>Gloabl对象的 <code>encodeURI()</code> 和 <code>encodeURIComponent()</code> 方法可以对URI进行编码，以便发送给浏览器</p>
<p>它们的主要区别在于，<code>encodeURI()</code> 不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号。而 <code>encodeURIComponent()</code> 则会对它发现的任何非标准字符串进行编码</p>
<p>与它们相对应的方法是 <code>decodeURI()</code> 和 <code>decodeURIComponent()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">'http://www.wrox.com/illegal value.html#start'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.wrox.com/illegal%20value.html#start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri))</span><br><span class="line"></span><br><span class="line"><span class="comment">// http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri))</span><br></pre></td></tr></table></figure>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><div class="note info">
            <p>属性：</p><ul><li><code>Math.E</code>：自然对数的底数，即常量 e 的值。</li><li><code>Math.LN10</code>：10 的自然对数。</li><li><code>Math.LN2</code>：2 的自然对数。</li><li><code>Math.LOG2E</code>：以 2 为底 e 的对数。</li><li><code>Math.LOG10E</code>：以 10 为底 e 的对数。</li><li><code>Math.PI</code>：π 的值。</li><li><code>Math.SQRT1_2</code>：1/2 的平方根（即 2 的平方根的倒数）。</li><li><code>Math.SQRT2</code>：2 的平方根。</li></ul><hr><p>方法：</p><ul><li><code>Math.abs(x)</code>：返回<code>x</code>的绝对值。</li><li><code>Math.pow(x, y)</code>：返回 $x^y$。</li></ul>
          </div>
<h3 id="min-amp-amp-max"><a href="#min-amp-amp-max" class="headerlink" title="min &amp;&amp; max"></a>min &amp;&amp; max</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">console</span>.log(max, min)       <span class="comment">// 54 3 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values))   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h3 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h3><div class="note info">
            <ul><li><code>Math.ceil()</code>：执行向上（大）舍入，即它总是将数值向上舍入为最接近的整数。</li><li><code>Math.floor()</code>：执行向下（小）舍入，即它总是将数值向下舍入为最接近的整数。</li><li><code>Math.round()</code>：执行标准舍入，即它总是将数值四舍五入为最接近的整数。</li></ul><hr><p><code>Math.round()</code> 在数值是负数且小数部分恰好是 0.5 时会出现例外，如 <code>Math.round(-1.5)</code> 的值为 -1.</p>
          </div>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p><code>Math.random()</code> 方法返回介于 0 和 1 之间的一个随机数，包括 0，但不包括 1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到一个随机数，包括 min，不包括 max</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomArbitrary</span> (<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个随机整数，包括 min，不包括 max</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span> (<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  min = <span class="built_in">Math</span>.ceil(min)</span><br><span class="line">  max = <span class="built_in">Math</span>.floor(max)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个随机整数，包括 min 和 max</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomIntInclusive</span> (<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  min = <span class="built_in">Math</span>.ceil(min)</span><br><span class="line">  max = <span class="built_in">Math</span>.floor(max)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>基本概念</title>
    <url>/posts/2c31c1a2/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>ECMAScript 的变量是松散类型的，可以用来保存任何类型的数据，换句话说，变量只是一个用于保存值得占位符而已，变量没有类型，数据才有类型！</p>
<div class="note info">
            <ul><li>使用 <code>var</code> 声明变量，变量为声明该变量的作用域中的局部变量。即在全局作用域中声明的变量为全局变量，在局部作用域中声明的变量为局部变量。</li><li>使用 <code>var</code> 声明的变量如果未初始化，则变量保存的值默认为 <code>undefined</code>。</li><li>对没有声明的变量直接进行赋值操作（或者说是 LHS 操作），在非严格模式下，会创建一个全局变量。但是在严格模式下，会抛出错误。</li></ul>
          </div>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>JavaScript 的数据类型分为“基本数据类型”和“引用数据类型”两种。</p>
<div class="note info">
            <ul><li><strong>基本数据类型</strong>：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code> 和 <code>Symbol</code>（ES6 提出）。</li><li><strong>引用数据类型</strong>：<code>Object</code>。</li></ul>
          </div>
<h2 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h2><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p>对一个值使用 <code>typeof</code> 操作符，可能返回下列某个字符串（均为英文单词小写形式）：</p>
<div class="note info">
            <ul><li><code>&quot;undefined&quot;</code>: 如果这个值未定义。</li><li><code>&quot;boolean&quot;</code>: 如果这个值是布尔值。</li><li><code>&quot;string&quot;</code>: 如果这个值是字符串。</li><li><code>&quot;number&quot;</code>: 如果这个值是数值。</li><li><code>&quot;symbol&quot;</code>: 如果这个值是符号。</li><li><code>&quot;function&quot;</code>: 如果这个值是函数（其实函数属于对象的一种）。</li><li><code>&quot;object&quot;</code>: 如果这个值是对象或 <code>null</code>。</li></ul>
          </div>
<h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><p>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<p><code>object instanceof constructor</code> =&gt; <code>true | false</code></p>
<p>《JavaScript 高级程序设计》中说：“<del>根据规定，所有引用数据类型的值都是Object的实例。因此，在检测一个引用数据类型值和Object构造函数时，instanceof操作符始终会返回true。</del>”<br><strong>随着版本的迭代，这个说法变得不准确了，有例外了！！！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><p>返回一个表示类型的字符串，详情请看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener">MDN官网</a>。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><p><code>Undefined</code> 类型只有一个值，即特殊的 <code>undefined</code>。在使用 <code>var</code> 声明变量但未对其加以初始化时，这个变量的值就是 <code>undefined</code>。对未初始化的变量执行 <code>typeof</code> 操作会返回 <code>undefined</code> ，而对未声明的变量执行 <code>typeof</code> 操作同样会返回 <code>undefined</code>。</p>
<p>除了可以对未声明的变量执行 <code>typeof</code> 操作之外，在非严格模式下还可以对其进行 <code>delete</code> 操作。除了这两种情况之外，对未声明的变量进行任何其他操作，都会抛出错误。</p>
<h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p><code>Null</code> 类型也只有一个值 - <code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>      <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) === <span class="literal">false</span>     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p><code>Boolean</code> 类型的字面值 <code>true</code> 和 <code>false</code> 是区分大小写的。也就是说，<code>True</code> 和 <code>False</code> 都不是 <code>Boolean</code> 值，只是标识符。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><div class="note info">
            <ul><li>八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。</li><li>浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。</li><li>绝对值超过 <code>Number.MAX_VALUE</code> 的值会被自动转换为 <code>infinity</code> 或 <code>-infinity</code>。</li><li>可以使用 <code>isFinite()</code> 函数来确定数值是否为无穷。如果不是无穷，则返回 <code>true</code>。</li><li><code>NaN</code> 与自身都不相等，可以使用 <code>isNaN()</code> 或 <code>Number.isNaN()</code> 确定数值是否为 <code>NaN</code>。在传入数据非数值时，<code>isNaN()</code> 会首先调用 <code>Number()</code> 将其转换为数值类型再进行判断，而 <code>Number.isNaN()</code> 则会直接返回 <code>false</code>。</li><li><code>Number()</code> 用于把任何类型数据转换为数值。</li><li><code>parseInt()</code> 和 <code>parseFloat()</code> 用于把字符串转换为数值。</li><li><code>parseInt()</code> 在转换字符串时比 <code>Number()</code> 好用，但是最好为 <code>parseInt()</code> 提供第二个参数（转换的基数2、8、10、16）。</li></ul>
          </div>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><div class="note info">
            <ul><li>任何字符串的长度都可以通过访问其 <code>length</code> 属性取得，包含双子节字符的可能不准确。</li><li>字符串是不可变的，一旦创建就不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串然后再用新的替代。</li><li>数值、布尔值、对象和字符串值都有 <code>toString()</code> 方法，并且数值的 <code>toString()</code> 方法可以接收一个参数（数值的基数），但是 <code>null</code> 和 <code>undefined</code> 没有。</li><li>在不知道要转换值的类型时，可以使用 <code>String()</code> 方法。</li></ul>
          </div>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><strong>ECMAScript 中的对象其实就是一组数据和功能的集合，它的属性或方法是没有顺序之分的！！！</strong></p>
<p>Object 类型是所有它的实例的基础，它所具有的任何属性和方法也同样存在于更具体的对象中。Object 的每个实例都具有下列属性和方法：</p>
<div class="note info">
            <ul><li><code>constructor</code></li><li><code>hasOwnProperty(propertyName)</code></li><li><code>isPrototypeOf(object)</code></li><li><code>propertyIsEnumerable(propertyName)</code></li><li><code>toLocaleString()</code></li><li><code>toString()</code></li><li><code>valueOf()</code></li></ul>
          </div>
<h2 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h2><p>在将一个值赋给变量时，如果这个值是基本数据类型，则变量中保存的是这个值本身。如果这个值是引用数据类型，则变量中保存的只是该值的一个引用（通过引用，可以在内存中找到这个引用数据类型的值）！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ===================================================</span></span><br><span class="line"><span class="comment">// 在从一个变量向另一个变量复制基本数据类型值和引用数据类型值的区别</span></span><br><span class="line"><span class="comment">// ===================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制基本数据类型值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b)   <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制引用数据类型值</span></span><br><span class="line"><span class="comment">// c 和 d 中保存的都是指向内存中同一对象的引用</span></span><br><span class="line"><span class="keyword">var</span> c = &#123; <span class="attr">num</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> d = c</span><br><span class="line">d.num = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(c.num, d.num)   <span class="comment">//2, 2</span></span><br></pre></td></tr></table></figure>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript 中所有函数的参数都是按值传递的。简单来说就是数据进行复制，然后传递给给函数作为参数。</p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h2><p>ECMAScript 对象的属性没有顺序。因此，通过 <code>for-in</code> 循环输出的属性名的顺序是不可预测的。</p>
<p><code>for-in</code> 不能对 <code>null</code> 和 <code>undefined</code> 进行迭代。</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），并且每个 case 的值不一定是常量，可以是变量，甚至是表达式。</p>
<p>switch对 case 进行匹配时，遵循的是 <code>===</code> 严格相等。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h2><p><strong>首先说明我的观点，不推荐使用 <code>arguments</code> ！！！</strong></p>
<p>ECMAScript 中的函数参数是用一个数组来表示的，可以通过 <code>arguments</code> 对象来访问这个数组，<code>arguments</code> 是一个类数组对象。</p>
<p>关于 <code>arguments</code> 和 <code>命名参数</code> 之间是如何相互影响的，《JavaScript高级程序设计》与《深入理解ES6》的说法有些矛盾，我在谷歌浏览器中简单的试了一下，他们之间的同步关系好像是双向的。</p>
<h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>ECMAScript 中的函数没有重载，如果声明了多个同名函数，后面的会覆盖前面的。</p>
<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><p>JavaScript 中的变量分为全局变量和局部变量，其中全局变量一直存在，不会被清除。</p>
<p>而局部变量只在函数执行的过程中存在，当函数执行结束后，局部变量会被自动清除。</p>
<p>当然如果存在闭包的话，局部变量被清除的时机需要取决于闭包。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>强制类型转换</title>
    <url>/posts/1750eb3e/</url>
    <content><![CDATA[<h1 id="强制类型转换规则"><a href="#强制类型转换规则" class="headerlink" title="强制类型转换规则"></a>强制类型转换规则</h1><h2 id="引用类型转换为基本类型"><a href="#引用类型转换为基本类型" class="headerlink" title="引用类型转换为基本类型"></a>引用类型转换为基本类型</h2><div class="note info">
            <ol><li>调用自身的 <code>valueOf()</code> 方法，如果返回基本类型的值，则转换成功。</li><li>如果 <code>valueOf()</code> 方法返回的还是引用类型值，则改为调用自身的 <code>toString()</code> 方法。如果 <code>toString()</code> 方法返回基本类型的值，则转换成功。</li><li>如果 <code>toString()</code> 方法返回的是引用类型值，抛出错误。</li></ol><p>需要注意的是，<strong>数组的默认 <code>toString()</code> 方法经过了重新定义，会将所有单元字符串化以后再用 <code>&quot;,&quot;</code> 连接起来。</strong></p>
          </div>
<h2 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h2><div class="note info">
            <ul><li><code>null</code>：<code>&quot;null&quot;</code>。</li><li><code>undefined</code>：<code>&quot;undefined&quot;</code>。</li><li>布尔值：<code>&quot;true&quot;</code> 或 <code>&quot;false&quot;</code>。</li><li>数值：通常直接转换为字符串即可，但是对于极小或极大的数值，会使用指数形式。</li><li>引用类型值：返回自身的 <code>toString()</code> 方法的返回值。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// "null"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">null</span>))                    </span><br><span class="line"></span><br><span class="line"><span class="comment">// "undefined"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">undefined</span>))                  </span><br><span class="line"></span><br><span class="line"><span class="comment">// "false"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">false</span>))                      </span><br><span class="line"></span><br><span class="line"><span class="comment">// "123"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">123</span>))                        </span><br><span class="line"></span><br><span class="line"><span class="comment">// "1.23e+21"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">123</span> * <span class="number">10000000000000000000</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;))                     </span><br><span class="line"></span><br><span class="line"><span class="comment">// "1,2,3"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="转换为数值"><a href="#转换为数值" class="headerlink" title="转换为数值"></a>转换为数值</h2><div class="note info">
            <ul><li><code>null</code>：<code>0</code>。</li><li><code>undefined</code>：<code>NaN</code>。</li><li>布尔值：<code>0</code> 或 <code>1</code>。</li><li>字符串：十进制数值或 <code>NaN</code>。</li><li>引用类型值：先将引用类型值转换为基本类型值，然后再将该基本类型值转换为数值。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>))           </span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>))          </span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'123'</span>))          </span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'123abc'</span>))       </span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;))         </span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))      </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">array.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(obj))            </span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(array))</span><br></pre></td></tr></table></figure>
<h2 id="转换为布尔值"><a href="#转换为布尔值" class="headerlink" title="转换为布尔值"></a>转换为布尔值</h2><div class="note info">
            <p>在将值转换为布尔值时，<strong>除了下述 5 种情况，其他所有情况都会转换为 <code>true</code></strong>：</p><ul><li><code>null</code></li><li><code>undefined</code></li><li><code>false</code></li><li><code>+0</code>、<code>-0</code> 或 <code>NaN</code></li><li><code>&quot;&quot;</code></li></ul>
          </div>
<h1 id="显示强制类型转换"><a href="#显示强制类型转换" class="headerlink" title="显示强制类型转换"></a>显示强制类型转换</h1><div class="note info">
            <ul><li>一元运算符 <code>+</code>、<code>-</code>、<code>++</code> 和 <code>--</code> 都会调用 <code>Number()</code> 将其他类型转换为数值，或将日期对象转换为对应的毫秒数。注意不要混淆 <code>+</code>、<code>++</code>、<code>+ +</code>，<code>-</code>、<code>--</code>、<code>- -</code>。</li><li>一元运算符 <code>~</code> 会先将值强制类型转换为 32 位数值，然后执行按位非操作，可以将 <code>~x</code> 等价于 <code>-(x+1)</code>。但是 <code>~-1</code> 的结果是 <code>0</code> 而不是 <code>-0</code>，因为 <code>~</code> 是字位操作而非数学运算。</li><li>将值转换为布尔值时，可以使用 <code>!</code> 运算符。</li></ul>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> b = +a</span><br><span class="line"><span class="keyword">var</span> c = -a</span><br><span class="line"><span class="keyword">var</span> d = - -a</span><br><span class="line"><span class="keyword">var</span> e = --a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(c)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(d)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(e)      </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1557055687256</span></span><br><span class="line"><span class="built_in">console</span>.log(+f)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">-42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 41</span></span><br><span class="line"><span class="built_in">console</span>.log(~x)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'0'</span></span><br><span class="line"><span class="keyword">var</span> b = []</span><br><span class="line"><span class="keyword">var</span> c = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="string">''</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> g</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!a)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!b)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!c)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!d)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!e)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!f)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!g)</span><br></pre></td></tr></table></figure>
<h1 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h1><div class="note warning">
            <p><strong><code>+</code> 和 <code>-</code> 作为一元运算符和作为多元运算符时具有不同的含义，别混淆了！</strong></p>
          </div>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="+ 运算符"></a>+ 运算符</h2><p><code>+</code> 运算符既能用于数值加法，也能用于字符串拼接。JavaScript 怎样来判断我们要执行的是哪个操作？</p>
<div class="note info">
            <ol><li>如果操作数中有字符串，进行字符串拼接操作。</li><li>如果操作数中有引用类型值，首先将引用类型值转换为基本类型值，然后进行后续操作。</li><li>其他情况全都进行数值加法。</li></ol>
          </div>
<h2 id="运算符-1"><a href="#运算符-1" class="headerlink" title="- 运算符"></a>- 运算符</h2><p>与 <code>+</code> 运算符不同，<code>-</code> 运算符会只会执行减法运算。所以它会先将非数值类型的数据转换为数值，然后进行减法运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'12'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(a-b)</span><br></pre></td></tr></table></figure>
<h1 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h1><div class="note info">
            <ul><li><code>==</code> 允许在相等比较中进行强制类型转换，而 <code>===</code> 不允许。</li><li><code>NaN</code> 不等于 <code>NaN</code>。</li><li><code>+0</code> 严格等于 <code>-0</code>。</li><li><code>!=</code> 与 <code>!==</code> 分别类似于 <code>==</code> 与 <code>===</code>。</li></ul>
          </div>
<p>下面主要介绍 <code>==</code> 是如何进行强制类型转换的。</p>
<h2 id="字符串和数值"><a href="#字符串和数值" class="headerlink" title="字符串和数值"></a>字符串和数值</h2><div class="note info">
            <p>首先将字符串转换为数值类型，然后进行比较。</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'42'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a == b)</span><br></pre></td></tr></table></figure>
<h2 id="其他类型和布尔类型"><a href="#其他类型和布尔类型" class="headerlink" title="其他类型和布尔类型"></a>其他类型和布尔类型</h2><div class="note info">
            <p>首先将布尔类型的值转换为数值类型，然后进行比较。</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'42'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a == b)         </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> == <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><div class="note info">
            <p>在 <code>==</code> 中 <code>null</code> 和 <code>undefined</code> 相等（它们也与其自身相等），除此之外其他情况都不相等。</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a == b)         </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="literal">null</span>)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b == <span class="literal">null</span>)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="literal">false</span>)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b == <span class="literal">false</span>)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="string">''</span>)        </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b == <span class="string">''</span>)        </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">0</span>)         </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="引用类型和基本类型"><a href="#引用类型和基本类型" class="headerlink" title="引用类型和基本类型"></a>引用类型和基本类型</h2><div class="note info">
            <p>首先将引用类型转换为基本类型，然后进行比较。</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">42</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a == b)</span><br></pre></td></tr></table></figure>
<h2 id="引用类型和引用类型"><a href="#引用类型和引用类型" class="headerlink" title="引用类型和引用类型"></a>引用类型和引用类型</h2><p>这种情况就是判断两个变量的引用是否相同</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>符号与符号属性</title>
    <url>/posts/67215a69/</url>
    <content><![CDATA[<p>在 JS 已有的基本类型之外，ES6 引入了一种新的基本类型：符号（Symbol）。符号起初被设计用于创建对象私有成员，而这也是JS开发者期待已久的特性。</p>
<h1 id="创建符号值"><a href="#创建符号值" class="headerlink" title="创建符号值"></a>创建符号值</h1><p><strong>符号没有字面量形式</strong>，这在JS的基本类型中是独一无二的。你可以使用全局 <code>Symbol</code> 函数来创建一个符号值，正如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">person[firstName] = <span class="string">'Nicholas'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName])</span><br></pre></td></tr></table></figure>
<p>此代码创建了一个符号类型的 <code>firstName</code> 变量，并将它作为 <code>person</code> 对象的一个属性，而每次访问该属性都要使用这个符号值。</p>
<p><strong>由于符号值是基本类型的值，因此调用 <code>new Symbol()</code> 将会抛出错误。你可以通过 <code>new Object(yourSymbol)</code> 来创建一个符号实例，但尚不清楚这能有什么作用。</strong></p>
<p><code>Symbol</code> 函数还可以接受一个额外的参数用于描述符号值，该描述并不能用来访问对应属性，但它能用于调试，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">'first name'</span>)</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">person[firstName] = <span class="string">'Nicholas'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'first name'</span> <span class="keyword">in</span> person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol(first name)</span></span><br><span class="line"><span class="built_in">console</span>.log(firstName)</span><br></pre></td></tr></table></figure>
<p>符号的描述信息被存储在内部属性 <code>[[Description]]</code> 中，当符号的 <code>toString()</code> 方法被显式或隐式调用时，该属性都会被读取。</p>
<p>由于符号是基本类型的值，你可以使用 <code>typeof</code> 运算符来判断一个变量是否为符号。ES6 扩充了 <code>typeof</code> 的功能以便让它在作用于符号值的时候能够返回 <code>symbol</code>。</p>
<h1 id="使用符号值"><a href="#使用符号值" class="headerlink" title="使用符号值"></a>使用符号值</h1><p>你可以在任意能使用“需计算属性名”的场合使用符号。此外还可以在 <code>Object.defineProperty()</code> 或 <code>Object.defineProperties()</code> 调用中使用它。</p>
<p><strong>由于符号不存在字面量形式，所以如果以符号作为对象的属性名，就算该属性的 <code>enumerable</code> 被设置为 <code>true</code>，该属性也无法用 <code>for-in</code> 循环，并且不会显示在 <code>Object.keys()</code> 的结果中。但是你可以使用 <code>in</code> 操作符来判断该属性是否存在！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">'first name'</span>)</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [firstName]: <span class="string">'Nicholas'</span>,</span><br><span class="line">  normalAttr: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, firstName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(desc.value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(desc.writable)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(desc.enumerable)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(desc.configurable)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(firstName <span class="keyword">in</span> person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'normalAttr' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person))    </span><br><span class="line"></span><br><span class="line"><span class="comment">// normalAttr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="共享符号值"><a href="#共享符号值" class="headerlink" title="共享符号值"></a>共享符号值</h1><p>你或许想在不同的代码段中使用相同的符号值，例如：假设在应用中需要在两个不同的对象类型中使用同一个符号属性，用来表示一个唯一标识符。跨越文件或代码来追踪符号值是很困难并且易错的，为此，ES6 提供了“全局符号注册表”供你在任意时间点进行访问。</p>
<p>若你想创建共享符号值，应使用 <code>Symbol.for()</code> 方法而不是 <code>Symbol()</code> 方法。<strong><code>Symbol.for()</code> 方法仅接受单个字符串类型的参数，作为目标符号值的标识符，同时此参数也会成为该符号的描述信息</strong>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"><span class="keyword">let</span> object = &#123;&#125;</span><br><span class="line"></span><br><span class="line">object[uid] = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 123456</span></span><br><span class="line"><span class="built_in">console</span>.log(object[uid])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol(uid)</span></span><br><span class="line"><span class="built_in">console</span>.log(uid)</span><br></pre></td></tr></table></figure>
<p><code>Symbol.for()</code> 方法首先会搜索全局符号注册表，看是否存在一个键值为 <code>&quot;uid&quot;</code> 的符号值。若是，该方法会返回这个已存在的符号值。否则，会创建一个新的符号值，并使用该键值将其记录到全局符号注册表中，然后返回这个新的符号值。这就意味着此后使用同一个键值去调用 <code>Symbol.for()</code> 方法都将返回同一个符号值，就像下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  [uid]: <span class="number">123456</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123456</span></span><br><span class="line"><span class="built_in">console</span>.log(object[uid])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol(uid)</span></span><br><span class="line"><span class="built_in">console</span>.log(uid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(uid === uid2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123456</span></span><br><span class="line"><span class="built_in">console</span>.log(object[uid2])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol(uid)</span></span><br><span class="line"><span class="built_in">console</span>.log(uid2)</span><br></pre></td></tr></table></figure>
<p>共享符号值还有另一个独特用法，你可以使用 <code>Symbol.keyFor()</code> 方法在全局符号注册表中根据符号值检索出对应的键值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// uid</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// uid</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid3 = <span class="built_in">Symbol</span>(<span class="string">'uid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid3))</span><br></pre></td></tr></table></figure>
<p>注意：使用符号值 <code>uid</code> 与 <code>uid2</code> 都返回了键值 <code>&quot;uid&quot;</code>，而符号值 <code>uid3</code> 在全局符号注册表中并不存在，因此没有关联的键值，<code>Symbol.keyFot()</code> 只会返回 <code>undefined</code>。</p>
<h1 id="符号值的转换"><a href="#符号值的转换" class="headerlink" title="符号值的转换"></a>符号值的转换</h1><p>类型转换是 JS 语言重要的一部分，能够非常灵活地将一种数据类型转换为另一种。然而符号类型在进行转换时非常不灵活，因为其他类型缺乏与符号值的合理等价，尤其是符号值无法被转换为字符串值或数值。因此将符号作为属性所达成的效果，是其他类型所无法替代的。</p>
<p>在之前的例子中使用了 <code>console.log()</code> 来展示符号值的输出，能这么做是由于自动调用了符号值的 <code>String()</code> 方法来产生输出。你也可以直接调用 <code>String()</code> 方法来获取相同的结果，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"><span class="keyword">let</span> desc = <span class="built_in">String</span>(uid)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol(uid)</span></span><br><span class="line"><span class="built_in">console</span>.log(desc)</span><br></pre></td></tr></table></figure>
<p><code>String()</code> 方法调用了 <code>uid.toString()</code> 来获取符号的字符串描述信息。但若你想直接将符号转换为字符串，则会引发错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引发错误</span></span><br><span class="line"><span class="keyword">let</span> desc = uid + <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>将<code>uid</code>与空字符串相连接，会首先要求把<code>uid</code>转换为一个字符串，而这会引发错误，从而阻止了转换行为。</p>
<p>相似地，你也不能将符号转换为数值，对符号使用所有数学运算符都会引发错误，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引发错误</span></span><br><span class="line"><span class="keyword">let</span> desc = uid / <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此例试图把符号值除以 1，同样引发了错误。无论对符号使用哪种数学运算符都会导致错误，但使用逻辑运算符则不会，因为符号值在运算符中会被认为等价于 <code>true</code>。</p>
<h1 id="检索符号属性"><a href="#检索符号属性" class="headerlink" title="检索符号属性"></a>检索符号属性</h1><p><strong>只能使用 ES6 新增的 <code>Object.getOwnPropertySymbols()</code> 方法用来检索对象的符号属性。<code>Object.keys()</code> 和 <code>Object.getOwnPropertyNames()</code> 方法都不行。</strong></p>
<h1 id="使用知名符号暴露内部方法"><a href="#使用知名符号暴露内部方法" class="headerlink" title="使用知名符号暴露内部方法"></a>使用知名符号暴露内部方法</h1><p>ES6 定义了“知名符号”来代表JS中一些公共行为，而这些行为此前被认为只能是内部操作。每一个知名符号都对应全局 <code>Symbol</code> 对象的一个属性，这些知名符号是：</p>
<div class="note info">
            <ul><li><code>Symbol.hasInstance</code>：供 <code>instanceof</code> 运算符使用的一个方法，用于判断对象继承关系。</li><li><code>Symbol.isConcatSpreadable</code>：一个布尔类型值，在集合对象作为参数传递给 <code>Array.prototype.concat()</code> 方法时，指示是否要将该集合的元素扁平化。</li><li><code>Symbol.iterator</code>：返回迭代器的一个方法。</li><li><code>Symbol.match</code>：供 <code>String.prototype.match()</code> 函数使用的一个方法，用于比较字符串。</li><li><code>Symbol.replace</code>：供 <code>String.prototype.replace()</code> 函数使用的一个方法，用于替换子字符串。</li><li><code>Symbol.search</code>：供 <code>String.prototype.search()</code> 函数使用的一个方法，用于定位子字符串。</li><li><code>Symbol.species</code>：用于产生派生对象的构造器。</li><li><code>Symbol.split</code>：供 <code>String.prototype.split()</code> 函数使用的一个方法，用于分割字符串。</li><li><code>Symbol.toPrimitive</code>：返回对象所对应的基本类型值的一个方法。</li><li><code>Symbol.toStringTag</code>：供 <code>String.prototype.toString()</code> 函数使用的一个方法，用于创建对象的描述信息。</li><li><code>Symbol.unscopables</code>：一个对象，该对象的属性指示了那些属性名不允许被包含在 <code>with</code> 语句中。</li></ul>
          </div>
<p>下面将介绍其中的一些知名符号。</p>
<h2 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h2><p>每个函数都具有一个 <code>Symbol.hasInstance</code> 方法，用于判断指定对象是否为本函数的一个实例。这个方法定义在 <code>Function.prototype</code> 上，因此所有函数都继承了面对 <code>instanceof</code> 运算符时的默认行为。<code>Symbol.hasInstance</code> 属性自身是不可写入、不可配置、不可枚举的，从而保证它不会被错误地重写。</p>
<p><code>Symbol.hasInstance</code> 方法只接受单个参数，即需要检测的值。如果该值是本函数的一个实例，则方法会返回 <code>true</code>。为了理解该方法是如何工作的，可研究下述代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">Array</span>[<span class="built_in">Symbol</span>.hasInstance](obj)</span><br></pre></td></tr></table></figure>
<p>ES6 从本质上将 <code>instanceof</code> 运算符重定义为上述方法调用的简写语法，这样使用 <code>instanceof</code> 便会出发一次方法调用，实际上允许你改变该运算符的工作。</p>
<p>假设你想定义一个函数，使得任意对象都不会被判断为该函数的一个实例，你可以采用硬编码的方式来让该函数的 <code>Symbol.hasInstance</code> 方法始终返回 <code>false</code>，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(MyObject, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">  value (v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyObject()</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> MyObject)</span><br></pre></td></tr></table></figure>
<p>上例中通过 <code>Object.defineProperty()</code> 方法在 <code>MyObject</code> 对象上设置了 <code>Symbol.hasInstance</code> 属性，从而屏蔽了原型上不可写入的 <code>Symbol.hasInstance</code> 属性。</p>
<h2 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h2><p>首先请看下面数组 <code>concat()</code> 方法的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors1 = [ <span class="string">'red'</span>, <span class="string">'green'</span> ]</span><br><span class="line"><span class="keyword">let</span> colors2 = colors1.concat([ <span class="string">'blue'</span>, <span class="string">'black'</span> ])</span><br><span class="line"><span class="keyword">let</span> colors3 = colors1.concat([ <span class="string">'blue'</span>, <span class="string">'black'</span> ], <span class="string">'brown'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 'green', 'blue', 'black' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2)    </span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 'green', 'blue', 'black', 'brown' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors3)</span><br></pre></td></tr></table></figure>
<p><code>concat()</code> 方法会区别对待自己接收到的参数，如果参数为数组类型，那么它会自动的将数组扁平化（即分离数组中的元素）。而其他非数组类型的参数无需如此处理。在 ES6 之前，没有任何手段可以改变这种行为。</p>
<p><code>Symbol.isConcatSpreadable</code> 属性是一个布尔类型的属性，它默认情况下并不会作为任意常规对象的属性。它只出现在特定类型的对象上，用来标示该对象作为 <code>concat()</code> 参数时应如何工作。</p>
<p>成功使用这个属性的前提条件是拥有该属性的对象，要在两个方面与数组类似：<strong>拥有数值类型的键</strong>和<strong>拥有 <code>length</code> 属性</strong>。</p>
<p>当该属性为 <code>true</code> 时，将该属性所属对象传递给 <code>concat()</code> 方法时，将所属对象扁平化。当该属性为 <code>false</code> 时，所属对象不会被扁平化。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'hello'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'world'</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> messages1 = [ <span class="string">'hi'</span> ].concat(obj1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'hi', 'hello', 'world' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(messages1)      </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'hello'</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> messages2 = [ <span class="string">'hi'</span> ].concat(obj2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'hi', &#123; '0': 'hello', length: 2, [Symbol.isConcatSpreadable]: false &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(messages2)</span><br></pre></td></tr></table></figure>
<h2 id="Symbol-match、Symbol-replace、Symbol-search-与-Symbol-split"><a href="#Symbol-match、Symbol-replace、Symbol-search-与-Symbol-split" class="headerlink" title="Symbol.match、Symbol.replace、Symbol.search 与 Symbol.split"></a>Symbol.match、Symbol.replace、Symbol.search 与 Symbol.split</h2><p>在 JS 中，字符串与正则表达式有着密切的联系，尤其是字符串具有几个可以接受正则表达式作为参数的方法：<a href="https://aadonkeyz.com/posts/71de0ab2/#模式匹配方法">match、replace、search和split方法</a>。</p>
<p>在 ES6 之前这些方法的实现细节对开发者是隐藏的，使得开发者无法将自定义对象模拟成正则表达式（并将它们传递给字符串的这些方法）。而 ES6 定义了 4 个符号以及对应的方法，将原生行为外包到内置的 <code>RegExp</code> 对象上。</p>
<div class="note info">
            <ul><li><code>Symbol.match</code>：此函数接受一个字符串参数，并返回一个包含匹配结果的数组。若匹配失败，则返回 <code>null</code>。</li><li><code>Symbol.replace</code>：此函数接受一个字符串参数与一个替换用的字符串，并返回替换后的结果字符串。</li><li><code>Symbol.search</code>：此函数接受一个字符串参数，并返回匹配结果的数值索引。若匹配失败，则返回 -1。</li><li><code>Symbol.split</code>：此函数接受一个字符串参数，并返回一个用匹配值分割而成的字符串数组。</li></ul>
          </div>
<p>在对象上定义这些属性，允许你创建能过进行模式匹配的对象，而无需使用这则表达式，并且允许在任何需要正则表达式的方法中使用该对象。这里有一个例子，展示了这些符号的使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有效等价于/^.&#123;10&#125;$/</span></span><br><span class="line"><span class="keyword">let</span> hasLengthOf10 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match] (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length === <span class="number">10</span> ? [value.substring(<span class="number">0</span>, <span class="number">10</span>)] : <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.replace] (value, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length === <span class="number">10</span> ?</span><br><span class="line">      replacement + value.substring(<span class="number">10</span>) : value</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.search] (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length === <span class="number">10</span> ? <span class="number">0</span> : <span class="number">-1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.split] (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length === <span class="number">10</span> ? [ <span class="string">''</span>, <span class="string">''</span> ] : [value]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11 characters</span></span><br><span class="line"><span class="keyword">let</span> message1 = <span class="string">'Hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10 characters</span></span><br><span class="line"><span class="keyword">let</span> message2 = <span class="string">'Hello John'</span>     </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> match1 = message1.match(hasLengthOf10)</span><br><span class="line"><span class="keyword">let</span> match2 = message2.match(hasLengthOf10)</span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(match1)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'Hello John' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(match2)     </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> replace1 = message1.replace(hasLengthOf10, <span class="string">'Howdy!'</span>)</span><br><span class="line"><span class="keyword">let</span> replace2 = message2.replace(hasLengthOf10, <span class="string">'Howdy!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(replace1)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// Howdy!</span></span><br><span class="line"><span class="built_in">console</span>.log(replace2)   </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> search1 = message1.search(hasLengthOf10)</span><br><span class="line"><span class="keyword">let</span> search2 = message2.search(hasLengthOf10)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(search1)    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(search2)    </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> split1 = message1.split(hasLengthOf10)</span><br><span class="line"><span class="keyword">let</span> split2 = message2.split(hasLengthOf10)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'Hello world' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(split1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ '', '' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(split2)</span><br></pre></td></tr></table></figure>
<h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h2><p><code>Symbol.toPrimitive</code> 方法被定义在所有常规类型的原型上，规定了在对象被转换为基本类型值的时候会发生什么。当需要转换时，<code>Symbol.toPrimitive</code> 会被调用，并按照规范传入一个提示性的字符串参数。该参数有 3 种可能：当参数值为 <code>number</code> 的时候，应当返回一个数值。当参数值为 <code>string</code> 的时候，应当返回一个字符串。而当参数为 <code>default</code> 的时候，对返回值类型没有特别要求。</p>
<p>对于大部分常规对象，“数值模式”依次会有下述行为：</p>
<div class="note info">
            <ol><li>调用 <code>valueOf()</code> 方法，如果方法返回值是一个基本类型值，那么返回它。</li><li>否则，调用 <code>toString()</code> 方法，如果方法返回值是一个基本类型值，那么返回它。</li><li>否则，抛出一个错误。</li></ol>
          </div>
<p>类似的，对于大部分常规对象，“字符串模式”依次会有下述行为：</p>
<div class="note info">
            <ol><li>调用 <code>toString()</code> 方法，如果方法返回值是一个基本类型值，那么返回它。</li><li>否则，调用 <code>valueOf()</code> 方法，如果方法返回值是一个基本类型值，那么返回它。</li><li>否则，抛出一个错误。</li></ol>
          </div>
<p>在多数情况下，常规对象的默认模式都等价于数值模式（只有 <code>Date</code> 类型例外，它默认使用字符串模式）。通过定义 <code>Symbol.toPrimitive</code> 方法，你可以重写这些默认的转换行为。</p>
<p>使用 <code>Symbol.toPrimitive</code> 属性并将一个函数赋值给它，便可以重写默认的转换行为，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Temperature</span> (<span class="params">degrees</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.degrees = degrees</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Temperature.prototype[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span> (<span class="params">hint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.degrees + <span class="string">'\u00b0'</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.degrees</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.degrees + <span class="string">' degrees'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> freezing = <span class="keyword">new</span> Temperature(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32 degrees!</span></span><br><span class="line"><span class="built_in">console</span>.log(freezing + <span class="string">'!'</span>)     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(freezing / <span class="number">2</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 32°</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(freezing))</span><br></pre></td></tr></table></figure>
<h2 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h2><p>JS 最有趣的课题之一是在多个不同的全局执行环境中使用，这种情况会在浏览器页面包含内联帧（iframe）的时候出现，此时页面与内联帧均拥有各自的全局执行环境。大多数情况下这并不是一个问题，使用一些轻量级的转换操作就能够在不同的运行环境之间传递数据。问题出现在想要识别目标对象到底是什么类型的时候，而此时该对象已经在环境之间经历了传递。</p>
<p>该问题的典型例子就是从内联帧向容器页面传递数组，或者反过来。在 ES6 术语中，内联帧与包含它的容器页面分别拥有一个不同的“域”，以作为 JS 的运行环境，每个“域”都拥有各自的全局作用域以及各自的全局对象拷贝。无论哪个“域”创建的数组都是正规的数组，但当它跨域进行传递时，使用 <code>instanceof Array</code> 进行检测却会得到 <code>false</code> 的结果，因为该数组是由另外一个“域”的数组构造器创建的，有别于当前“域”的数组构造器。</p>
<h3 id="识别问题的变通解决方案"><a href="#识别问题的变通解决方案" class="headerlink" title="识别问题的变通解决方案"></a>识别问题的变通解决方案</h3><p>变通的解决方案为 <code>Object.prototype.toString.call()</code>。</p>
<h3 id="ES6-给出的答案"><a href="#ES6-给出的答案" class="headerlink" title="ES6 给出的答案"></a>ES6 给出的答案</h3><p>ES6 通过 <code>Symbol.toStringTag</code> 重定义了相关行为，该符号是对象的一个属性，定义了 <code>Object.prototype.toString.call()</code> 被调用时应当返回什么值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'Person'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [object Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(me.toString())                          </span><br><span class="line"></span><br><span class="line"><span class="comment">// [object Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(me))     </span><br><span class="line"></span><br><span class="line">Person.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(me.toString())                          </span><br><span class="line"></span><br><span class="line"><span class="comment">// [object Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(me))</span><br></pre></td></tr></table></figure>
<h2 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h2><p>尽管将来的代码无疑会停用 <code>with</code> 语句，但 ES6 仍然在非严格模式中提供了对于 <code>with</code> 语句的支持，以便向下兼容。为此需要寻找方法让使用 <code>with</code> 语句的代码能够适当地继续工作。为了理解这个任务的复杂性，可研究如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> color = <span class="string">'black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (colors) &#123;</span><br><span class="line">  push(color)</span><br><span class="line">  push(...values)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 'green', 'blue', 'black', 1, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br></pre></td></tr></table></figure>
<p>在此例中，<code>...values</code> 引用了 <code>with</code> 语句之外的变量 <code>values</code>。</p>
<p>但ES6为数组添加了一个 <code>values</code> 方法（迭代器与生成器的知识），这意味着在 ES6 的环境中，<code>with</code> 语句内部的 <code>values</code> 并不会指向 <code>with</code> 语句之外的变量 <code>values</code>，而是会指向数组的 <code>values</code> 方法，从而会破坏代码的意图。这也是 <code>Symbol.unscopables</code> 符号出现的理由。</p>
<p><code>Symbol.unscopables</code> 符号在 <code>Array.prototype</code> 上使用，以指定哪些属性不允许在 <code>with</code> 语句内被绑定。<code>Symbol.unscopables</code> 属性是一个对象，当提供该属性时，它的键就是用于忽略 <code>with</code> 语句绑定的标识符，键值为 <code>true</code> 代表屏蔽绑定。以下是数组的 <code>Symbol.unscopables</code> 属性的默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认内置在 ES6 中</span></span><br><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables] = <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(<span class="literal">null</span>), &#123;</span><br><span class="line">  copyWithin: <span class="literal">true</span>,</span><br><span class="line">  entries: <span class="literal">true</span>,</span><br><span class="line">  fill: <span class="literal">true</span>,</span><br><span class="line">  find: <span class="literal">true</span>,</span><br><span class="line">  findIndex: <span class="literal">true</span>,</span><br><span class="line">  keys: <span class="literal">true</span>,</span><br><span class="line">  values: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>解构</title>
    <url>/posts/2798ec73/</url>
    <content><![CDATA[<h1 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h1><p>在对象解构语法出现之前，如果你想将一个对象的多个属性值分别赋值给本地的多个变量，需要书写许多相似的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = obj.a</span><br><span class="line"><span class="keyword">let</span> b = obj.b</span><br><span class="line"><span class="keyword">let</span> c = obj.c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure>
<p>对象解构是如何做的呢，它将需要被赋值的变量全都放入一个花括号内，然后在后面添加等号，并指定提供数据的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, b, c &#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure>
<p>对象解构语法会自动根据等号左侧的变量名在右侧对象中查找同名属性，并将属性值赋给对应的变量。</p>
<p><strong>当使用对象解构来配合 <code>var</code>、<code>let</code> 或 <code>const</code> 声明变量时，必须提供初始化器（即等号右侧的值）</strong>。下面的代码都会因为缺失初始化器而抛出错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line"><span class="keyword">var</span> &#123; type, name &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line"><span class="keyword">const</span> &#123; type, name &#125;</span><br></pre></td></tr></table></figure>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>以上对象解构示例都用于变量声明。不过，也可以在赋值的时候使用解构。例如，你可能想在变量声明之后改变它们的值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> type = <span class="string">'Literal'</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用解构来分配不同的值</span></span><br><span class="line">(&#123; type, name &#125; = node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(type)</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure>
<p>在本例中，<code>type</code> 与 <code>name</code> 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 <code>node</code> 对象来更改这两个变量的值。注意你必须使用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符（即等号）左侧出现。圆括号标示了里面的花括号并不是块语句，而应该被解释为表达式，从而允许完成赋值操作。</p>
<p><strong>解构赋值表达式的值为等号右侧的对象。所以在调用函数时如果使用解构赋值表达式的话，实际上传递的参数为等号右侧的对象。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> type = <span class="string">'Literal'</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputInfo</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj === node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">outputInfo(&#123; type &#125; = node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(type)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure>
<p>上面例子中的 <code>outputInfo({ type } = node)</code> 实际上做了两件事情：</p>
<div class="note info">
            <ul><li>将 <code>node.type</code> 赋值给为本地变量 <code>type</code>；</li><li>将 <code>node</code> 对象作为参数传递给函数 <code>outputInfo</code>。</li></ul>
          </div>
<p><strong>当解构赋值表达式的右侧计算结果为 <code>null</code> 或 <code>undefined</code> 时，会抛出错误。因为任何读取 <code>null</code> 或 <code>undefined</code> 的企图都会导致“运行时”错误</strong>。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为 <code>undefined</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(type)</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br></pre></td></tr></table></figure>
<p>此代码定义了一个额外的本地变量 <code>value</code>，并试图对其赋值。然而，<code>node</code> 对象中不存在同名属性，因此 <code>value</code> 不出预料地被赋值为 <code>undefined</code>。</p>
<p>你可以选择性地定义一个默认值，以便在指定属性不存在时使用该值。若要这么做，需要在属性名后面添加一个等号并指定默认值，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="literal">true</span> &#125; = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(type)</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br></pre></td></tr></table></figure>
<p>在此例中，变量 <code>value</code> 被指定了一个默认值 <code>true</code>，只有在 <code>node</code> 的对应属性缺失、或对应的属性值为 <code>undefined</code> 的情况下，该默认值才会被使用。</p>
<h2 id="赋值给不同的本地变量名"><a href="#赋值给不同的本地变量名" class="headerlink" title="赋值给不同的本地变量名"></a>赋值给不同的本地变量名</h2><p>以上使用解构赋值的例子中，都是本地变量名称与对象属性同名的情况，那么如果名称不相同呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(localType)</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(localName)</span><br></pre></td></tr></table></figure>
<p>此代码使用了解构赋值来声明 <code>localType</code> 和 <code>localName</code> 变量，分别获得了 <code>node.type</code> 和 <code>node.name</code> 属性的值。 <code>type: localType</code> 这种语法表示要读取名为 <code>type</code> 的属性，并把他的值存储在变量 <code>localType</code> 中。该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，则是名称在右边，需要进行值读取的位置则被放在了左边。</p>
<p>你也可以给变量别名添加默认值，依然是在本地变量名称后添加等号与默认值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName = <span class="string">'bar'</span> &#125; = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(localType)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(localName)</span><br></pre></td></tr></table></figure>
<h2 id="嵌套的对象解构"><a href="#嵌套的对象解构" class="headerlink" title="嵌套的对象解构"></a>嵌套的对象解构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span>,</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于let localStart = node.loc.start</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; <span class="attr">start</span>: localStart &#125;&#125; = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(localStart.line)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(localStart.column)</span><br></pre></td></tr></table></figure>
<h1 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h1><p>数组解构的语法看起来与对象解构非常相似，只是将对象字面量换成了数组字面量。数组解构时，是根据变量的位置索引来进行的，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor] = colors</span><br><span class="line"></span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(firstColor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [, , thirdColor] = colors</span><br><span class="line"></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"><span class="built_in">console</span>.log(thirdColor)</span><br></pre></td></tr></table></figure>
<p>与对象解构相似，在使用 <code>var</code>、<code>let</code> 或 <code>const</code> 进行数组解构时，你必须提供初始化器。</p>
<h2 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>你可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号内，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> firstColor = <span class="string">'black'</span></span><br><span class="line"><span class="keyword">let</span> secondColor = <span class="string">'purple'</span>;</span><br><span class="line"></span><br><span class="line">[firstColor, secondColor] = colors</span><br><span class="line"></span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(firstColor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor)</span><br></pre></td></tr></table></figure>
<p>使用数组解构来互换两个变量的值是非常轻松的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>
<p>与对象解构赋值相同，若等号右侧的计算结果为 <code>null</code> 或 <code>undefined</code>，那么数组解构赋值表达式会抛出错误。</p>
<h2 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h2><p>数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为 <code>undefined</code>，那么该默认值就会被使用。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor = <span class="string">'green'</span>] = colors</span><br><span class="line"></span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(firstColor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor)</span><br></pre></td></tr></table></figure>
<h2 id="嵌套的解构"><a href="#嵌套的解构" class="headerlink" title="嵌套的解构"></a>嵌套的解构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, [<span class="string">'green'</span>, <span class="string">'lightgreen'</span>], <span class="string">'blue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [firstColor, [secondColor]] = colors</span><br><span class="line"></span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(firstColor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor)</span><br></pre></td></tr></table></figure>
<h2 id="剩余项"><a href="#剩余项" class="headerlink" title="剩余项"></a>剩余项</h2><p>我们以前介绍过函数的剩余参数，而数组解构有个类似的、名为剩余项的概念，它使用 <code>...</code> 语法来将剩余的项目赋值给一个指定的变量，此处有个范例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [firstColor, ...restColors] = colors</span><br><span class="line"></span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(firstColor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'green', 'blue' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors)</span><br></pre></td></tr></table></figure>
<p>使用剩余项语法可以很方便地实现数组的克隆。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> [...cloneColors] = colors</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'red', 'green', 'blue' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(cloneColors)</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>需要注意的是剩余项必须是数组解构模式中最后的部分，之后不能再有逗号，否则就是语法错误。</strong></p>
          </div>
<h1 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h1><p>对象与数组解构能被用在一起，以创建更复杂的解构表达式。在对象与数组混合而成的结构中，能准确提取其中你想要的信息片段。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span>,</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  range: [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  loc: &#123; start &#125;,</span><br><span class="line">  range: [stratIndex]</span><br><span class="line">&#125; = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.line)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stratIndex)</span><br></pre></td></tr></table></figure>
<h1 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h1><p>解构还有一个特别有用的场景，即在传递函数参数时。当函数接收大量可选参数时，一个常用模式是创建一个 <code>options</code> 对象，其中包含了附加的参数，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// options 上的属性表示附加参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> secure = options.secure</span><br><span class="line">  <span class="keyword">let</span> path = options.path</span><br><span class="line">  <span class="keyword">let</span> domain = options.domain</span><br><span class="line">  <span class="keyword">let</span> expires = options.expires</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数映射到 options</span></span><br><span class="line">setCookie(<span class="string">'type'</span>, <span class="string">'js'</span>, &#123;</span><br><span class="line">  secure: <span class="literal">true</span>,</span><br><span class="line">  expires: <span class="number">60000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>很多 JS 的库都包含了类似于此例的 <code>setCookie()</code> 函数。在此函数内，<code>name</code> 与 <code>value</code> 参数是必需的，而 <code>secure</code>、<code>path</code>、<code>domain</code> 与 <code>expires</code> 则不是。并且因为此处对于其余数据并没有顺序要求，将它们作为 <code>options</code> 对象的具名属性会更有效率，而无须列出一堆额外的具名参数。这种方法很有用，但无法仅通过查看函数定义就判断出函数所期望的输入，你必须阅读函数的代码。</p>
<p>参数解构提供了更清楚地标明函数期望输入的替代方案。它使用对象或数组解构的模式替代了具名参数。要看到其实际效果，请查看下例中重写版本的 <code>setCookie()</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">name, value, &#123; secure, path, domain, expires &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置cookie的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">'type'</span>, <span class="string">'js'</span>, &#123;</span><br><span class="line">  secure: <span class="literal">true</span>,</span><br><span class="line">  expires: <span class="number">60000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此函数的行为类似上例，但此时第三个参数使用了解构来抽取必要的数据。现在对于 <code>setCookie()</code> 函数的使用者来说，解构参数之外的参数明显是必需的；而可选项目存在于额外的参数组中，这同样是非常明确的；同时，若使用了第三个参数，其中应当包含什么值当然也是极其明确的。解构参数在没有传递值的情况下类似于常规参数，它们会被设为 <code>undefined</code>。</p>
<h2 id="解构的参数也是必需的"><a href="#解构的参数也是必需的" class="headerlink" title="解构的参数也是必需的"></a>解构的参数也是必需的</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出错！</span></span><br><span class="line">setCookie(<span class="string">'type'</span>, <span class="string">'js'</span>)</span><br></pre></td></tr></table></figure>
<p>调用时第三个参数缺失了，因此它不出预料地等于 <code>undefined</code>。这导致了一个错误，因为参数解构实际上只是解构声明的简写。当 <code>setCookie()</code> 函数被调用时，JS 引擎实际上是这么做的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置cookie的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然在赋值右侧的值为<code>null</code>或<code>undefined</code>时，解构会抛出错误，那么未向<code>setCookie()</code>函数传递第三个参数就同样会出错。</p>
<p>若你让解构的参数作为必选参数，那么上述行为并不会令人困扰。但若你要求它是可选的，可以给解构的参数提供默认值来处理这种行为，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置cookie的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数解构的默认值"><a href="#参数解构的默认值" class="headerlink" title="参数解构的默认值"></a>参数解构的默认值</h2><p>你可以为参数解构提供可解构的默认值，就像在解构赋值时所做的那样，只需在其中每个参数后面添加等号并指定默认值即可。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">name, value,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    secure = false,</span></span></span><br><span class="line"><span class="function"><span class="params">    path = <span class="string">'/'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    domain = <span class="string">'example.com'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    expires = new Date(Date.now(</span>) + 360000000)</span></span><br><span class="line"><span class="function">  &#125; = </span>&#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 设置cookie的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码中参数解构给每个属性都提供了默认值，所以你可以避免检查指定属性是否已被传入（以便在未传入时使用正确的值）。而整个解构的参数同样有一个默认值，即一个空对象，令该参数成为可选参数。这么做使得函数声明看起来比平时要复杂一些，但却是为了确保每个参数都有可用的值而付出的微小代价。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/posts/9393c5c/</url>
    <content><![CDATA[<p>请移步 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">MDN</a>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/posts/990a6acc/</url>
    <content><![CDATA[<p>许多编程语言都将迭代数据的方式从使用 <code>for</code> 循环转变到使用迭代器对象，<code>for</code> 循环需要初始化变量以便追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。迭代器使操作集合变得更简单，JS 语言的很多新成分中都有迭代器的身影，如 <code>for-of</code> 和扩展运算符。</p>
<h1 id="何为迭代器？"><a href="#何为迭代器？" class="headerlink" title="何为迭代器？"></a>何为迭代器？</h1><p>迭代器是被设计专用于迭代的对象，带有特定接口。所有迭代器对象都拥有 <code>next()</code> 方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的 <code>value</code>，以及一个布尔类型的 <code>done</code>，其值为 <code>true</code> 时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了 <code>next()</code> 方法，迭代器就会返回相应的下一个值。</p>
<p>若你在最后一个值返回后再调用 <code>next()</code>，所返回的 <code>done</code> 属性值会是 <code>true</code>，并且 <code>value</code> 属性值会是迭代器自身的返回值（return value，即使用 return 语句明确返回的值）。该“返回值”不是原数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用 <code>undefined</code>。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。</p>
<p>记住这些后，在 ES5 中创建一个迭代器就相当简单了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span> (<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个迭代器</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next () &#123;</span><br><span class="line">      <span class="keyword">var</span> done = (i &gt;= items.length)</span><br><span class="line">      <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done,</span><br><span class="line">        value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; done: false, value: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; done: false, value: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>正如此例演示，根据迭代器的规则来书写一个迭代器，是有一点复杂的。为此，ES6 提供了生成器，让创建迭代器对象变得更简单。</p>
<h1 id="何为生成器？"><a href="#何为生成器？" class="headerlink" title="何为生成器？"></a>何为生成器？</h1><p>生成器是能返回一个迭代器的函数。生成器由放在 <code>function</code> 关键字之后的一个星号（<code>*</code>）来表示，并能使用新的 <code>yield</code> 关键字。将星号紧跟在 <code>function</code> 关键字之后，或是在中间留出空格，都是没问题的，正如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 4, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>生成器函数最有意思的方面可能就是它们会在每个 <code>yield</code> 语句后停止执行。例如，此代码中 <code>yield 1</code> 执行后，该函数将不会再执行任何操作，直到迭代器的 <code>next()</code> 方法被调用，此时才继续执行 <code>yield 2</code>。</p>
<p><code>yield</code> 关键字可以和值或是表达式一起使用，因此你可以通过生成器给迭代器添加项目，而不是机械化地将项目一个个列出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span> (<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> items[i]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'returnValue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'returnValue', done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong><code>yield</code> 关键字只能用在生成器内部，用于其他任意位置都是语法错误，即使在生成器内部的函数中也不行！</strong></p>
          </div>
<p>例如下面的写法就是错误的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span> (<span class="params">items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 语法错误</span></span><br><span class="line">    <span class="keyword">yield</span> item + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管 <code>yield</code> 严格位于 <code>createIterator()</code> 内部，此代码仍然有语法错误，因为 <code>yield</code> 无法穿越函数边界。从这点上来说，<code>yield</code> 与 <code>return</code> 非常相似，在一个被嵌套的函数中无法将值返回给包含它的函数。</p>
<h2 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h2><p>你可以使用函数表达式来创建一个生成器，只要在 <code>function</code> 关键字与圆括号之间使用一个星号（<code>*</code>）即可。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> * (<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> items[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>不能将箭头函数创建为生成器</strong>。</p>
          </div>
<h2 id="生成器对象方法"><a href="#生成器对象方法" class="headerlink" title="生成器对象方法"></a>生成器对象方法</h2><p>由于生成器就是函数，因此也可以被添加到对象中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  createIterator: <span class="function"><span class="keyword">function</span> * (<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ES6 的方法简写形式也是可以的</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  *createIterator (items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="可迭代对象和Symbol-iterator"><a href="#可迭代对象和Symbol-iterator" class="headerlink" title="可迭代对象和Symbol.iterator"></a>可迭代对象和Symbol.iterator</h1><div class="note info">
            <ol><li>首先要记住迭代器是一个对象，是一个带有特定接口、专门用来迭代的对象</li><li>生成器是一个用于生成迭代器的函数</li><li>只要具有 <code>Symbol.iterator</code> 方法的对象，就是可迭代对象</li><li><code>Symbol.iterator</code> 知名符号定义了为指定对象返回迭代器的函数，换句话说，<code>Symbol.iterator</code> 方法是可迭代对象的生成器方法</li><li>生成器创建的所有迭代器都是可迭代对象，因为生成器默认就会为 <code>Symbol.iterator</code> 属性赋值</li></ol>
          </div>
<p>在 ES6 中，所有的集合对象（数组、Set和Map）以及字符串都是可迭代对象，因此它们都被指定了默认的迭代器。</p>
<h1 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for-of循环"></a>for-of循环</h1><p><code>for-of</code> 首先会调用可迭代对象的 <code>Symbol.iterator</code> 来生成迭代器，然后在循环中调用迭代器的 <code>next()</code> 方法，并将迭代器的 <code>value</code> 值存储在一个变量上，循环过程会持续到迭代器的 <code>done</code> 属性变为 <code>true</code> 为止。</p>
<h2 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h2><p>你可以使用 <code>Symbol.iterator</code> 来访问对象上的默认迭代器，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>既然 <code>Symbol.iterator</code> 指定了默认迭代器，你就可以使用它来检测一个对象是否能进行迭代，正如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))     </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'hello'</span>))        </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()))      </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>()))  </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>()))</span><br></pre></td></tr></table></figure>
<p>这个 <code>isIterable()</code> 函数仅仅查看对象是否存在一个类型为函数的默认迭代器。<code>for-of</code> 循环在执行之前会做类似的检查。</p>
<h2 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h2><p>开发者自定义对象默认情况下不是可迭代对象，但你可以创建一个包含生成器的 <code>Symbol.iterator</code> 属性，让它们成为可迭代对象。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">  items: [],</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator] () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">      <span class="keyword">yield</span> item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection.items.push(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">  <span class="comment">// 依次打印 1, 2, 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内置的迭代器"><a href="#内置的迭代器" class="headerlink" title="内置的迭代器"></a>内置的迭代器</h1><h2 id="集合的迭代器"><a href="#集合的迭代器" class="headerlink" title="集合的迭代器"></a>集合的迭代器</h2><p>ES6 具有三种集合对象类型：数组、Map 和 Set。这三种类型都拥有如下迭代器，有助于探索它们的内容：</p>
<div class="note info">
            <ul><li><code>entries()</code>：返回一个包含键值对的迭代器。</li><li><code>values()</code>：返回一个包含集合中的值的迭代器。</li><li><code>keys()</code>：返回一个包含集合中的键的迭代器。</li></ul>
          </div>
<h3 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h3><p><code>entries()</code> 迭代器会在每次 <code>next()</code> 被调用时返回一个双项数组，此数组代表了集合中每个元素的键与值：对于数组来说，第一项是数值索引。对于 Set，第一项也是值。对于 Map，第一项就是键。</p>
<div class="note warning">
            <p><strong>记住，第一项是键，第二项才是值，别用混了……</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span> ]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'Understanding ES6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> colors.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ 0, 'red' ]</span></span><br><span class="line"><span class="comment">// [ 1, 'green' ]</span></span><br><span class="line"><span class="comment">// [ 2, 'blue' ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ 1234, 1234 ]</span></span><br><span class="line"><span class="comment">// [ 5678, 5678 ]</span></span><br><span class="line"><span class="comment">// [ 9012, 9012 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ 'title', 'Understanding ES6' ]</span></span><br><span class="line"><span class="comment">// [ 'format', 'ebook' ]</span></span><br></pre></td></tr></table></figure>
<h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><p><code>values()</code> 迭代器仅仅能返回存储在集合内的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span> ]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'Understanding ES6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1234</span></span><br><span class="line"><span class="comment">// 5678</span></span><br><span class="line"><span class="comment">// 9012</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> data.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Understanding ES6</span></span><br><span class="line"><span class="comment">// ebook</span></span><br></pre></td></tr></table></figure>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p><code>keys()</code> 迭代器能返回集合中的每一个键。对于数组来说，它只返回了数值类型的键，永不返回数组的其他自有属性。Set 的键与值时相同的，因此它的 <code>keys()</code> 与 <code>values()</code> 返回了相同的迭代器。对于 Map，<code>keys()</code> 迭代器返回了每个不重复的键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span> ]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'Understanding ES6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> colors.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> tracking.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1234</span></span><br><span class="line"><span class="comment">// 5678</span></span><br><span class="line"><span class="comment">// 9012</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> data.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// title</span></span><br><span class="line"><span class="comment">// format</span></span><br></pre></td></tr></table></figure>
<h3 id="集合类型的默认迭代器"><a href="#集合类型的默认迭代器" class="headerlink" title="集合类型的默认迭代器"></a>集合类型的默认迭代器</h3><p>当 <code>for-of</code> 循环没有显示指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。<code>values()</code> 方法是数组与 Set 的默认迭代器，而 <code>entries()</code> 方法则是 Map 的默认迭代器。</p>
<p>Map 默认迭代器的行为有助于在 <code>for-of</code> 循环中使用解构，正如此例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'Understanding ES6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与使用 data.entries() 相同</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> data) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">'='</span> + value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串和-NodeList"><a href="#字符串和-NodeList" class="headerlink" title="字符串和 NodeList"></a>字符串和 NodeList</h2><p>需要记住，<strong>可以对字符串和 <code>NodeList</code> 使用 <code>for-of</code>循环！</strong></p>
<h1 id="扩展运算符与非数组的可迭代对象"><a href="#扩展运算符与非数组的可迭代对象" class="headerlink" title="扩展运算符与非数组的可迭代对象"></a>扩展运算符与非数组的可迭代对象</h1><p>扩展运算符能作用于所有可迭代对象，并且会使用默认迭代器来判断需要使用哪些值。所有的值都从迭代器中被读取出来并插入数组，遵循迭代器返回值的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="string">'name'</span>, <span class="string">'Nicholas'</span>], [<span class="string">'age'</span>, <span class="number">25</span>] ])</span><br><span class="line"><span class="keyword">let</span> array1 = [...mySet]</span><br><span class="line"><span class="keyword">let</span> array2 = [...myMap]</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(array1)      </span><br><span class="line"></span><br><span class="line"><span class="comment">// [ [ 'name', 'Nicholas' ], [ 'age', 25 ] ]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2)</span><br></pre></td></tr></table></figure>
<h1 id="迭代器高级功能"><a href="#迭代器高级功能" class="headerlink" title="迭代器高级功能"></a>迭代器高级功能</h1><h2 id="传递参数给迭代器"><a href="#传递参数给迭代器" class="headerlink" title="传递参数给迭代器"></a>传递参数给迭代器</h2><p>你可以通过 <code>next()</code> 方法向迭代器传递参数。当一个参数被传递给 <code>next()</code> 方法时，该参数就会成为生成器内部 <code>yield</code> 语句的值。此处有个基本范例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4 + 2</span></span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>    </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5 + 3</span></span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span>                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 6, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>))       </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 8, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>))       </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p><strong>对于 <code>next()</code> 的首次调用是一个特殊情况，传给它的任意参数都会被忽略</strong>。由于传递给 <code>next()</code> 的参数会成为 <code>yield</code> 语句的值，该 <code>yield</code> 语句指的是上次生成器中断执行处的语句。而 <code>next()</code> 方法第一次被调用时，生成器函数才刚刚开始执行，没有所谓的“上一次中断处的 <code>yield</code> 语句”可供赋值。因此在第一次调用 <code>next()</code> 时，不存在任何向其传递参数的理由。</p>
<p>在第二次调用 <code>next()</code> 时，<code>4</code> 作为参数被传递进去，这个 <code>4</code> 最终被赋值给了生成器函数内部的 <code>first</code> 变量。在包含赋值操作的第一个 <code>yield</code> 语句中，表达式右侧在第一次调用 <code>next()</code> 时被计算，而表达式左侧则在第二次调用 <code>next()</code> 方法、并在生成器函数继续执行前被计算。由于第二次调用 <code>next()</code> 传入了 <code>4</code>，这个值就被赋给了 <code>first</code> 变量，之后生成器继续执行。</p>
<p>第二个 <code>yield</code> 使用了第一个 <code>yield</code> 的结果并加上了 <code>2</code>，也就是返回了一个 <code>6</code>。当 <code>next()</code> 被第三次调用时，传入了参数 <code>5</code>。这个值被赋给了 <code>second</code> 变量，并随后用在了第三个 <code>yield</code> 语句中，返回了 <code>8</code>。</p>
<h2 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h2><p>能传递给迭代器的不仅是数据，还可以是错误条件。迭代器可以选择实现一个 <code>throw()</code> 方法，用于指示迭代器应在恢复执行时抛出一个错误。这是对异步编程来说很重要的一个能力，同时也会增加生成器内部的灵活度，能够既模仿返回一个值，又模仿抛出错误。你可以传递一个错误对象给 <code>throw()</code> 方法，当迭代器继续进行处理时应当抛出此错误。例如：</p>
<div class="note warning">
            <p><strong>如果你不使用 <code>throw()</code> 传递一个错误给迭代器，而是通过 <code>next()</code> 传递一个错误给迭代器，那么迭代器内部不会抛出错误！</strong></p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// yield 4 + 2 ，然后抛出错误</span></span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>        </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 永不会被执行</span></span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span>                            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())            </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 6, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>))                </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从生成器中抛出了错误</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom'</span>)))</span><br></pre></td></tr></table></figure>
<p>了解这些之后，你就可以在生成器内部使用一个 <code>try-catch</code> 块来捕捉这种错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> second</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// yield 4 + 2 ，然后抛出错误</span></span><br><span class="line">    second = <span class="keyword">yield</span> first + <span class="number">2</span>                </span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="comment">// 当出错时，给变量另外赋值</span></span><br><span class="line">    second = <span class="number">6</span>                              </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())            </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 6, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>))           </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 9, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom'</span>)))  </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>本例使用一个 <code>try-catch</code> 块包裹了第二个 <code>yield</code> 语句。尽管这个 <code>yield</code> 自身的执行不会出错，但在对 <code>second</code> 变量赋值之前，错误就在此时被抛出，于是 <code>catch</code> 部分捕捉错误并将这个变量赋值为 <code>6</code>，然后再继续执行到下一个 <code>yield</code> 处并返回了 <code>9</code>。</p>
<p>要注意一件有趣的事情发生了：<code>throw()</code> 方法就像 <code>next()</code> 方法一样返回了一个结果对象。由于错误在生成器内部被捕捉，代码继续执行到下一个 <code>yield</code> 处并返回了下一个值，也就是 <code>9</code>。</p>
<p>将 <code>next()</code> 与 <code>throw()</code> 都当作迭代器的指令，会有助于思考。<code>next()</code> 方法指示迭代器继续执行，而 <code>throw()</code> 方法则指示迭代器通过抛出一个错误继续执行。</p>
<h2 id="生成器的-return"><a href="#生成器的-return" class="headerlink" title="生成器的 return"></a>生成器的 return</h2><p>由于生成器是函数，你可以在它内部使用 <code>return</code> 语句，既可以让生成器早一点退出执行，也可以指定在 <code>next()</code> 方法最后一次调用时的返回值。在生成器内，<code>return</code> 表明所有的处理已完成，因此 <code>done</code> 属性会被设为 <code>true</code>，而如果提供了返回值，就会被用于 <code>value</code> 字段。此处有个例子，单纯使用 <code>return</code> 让生成器更早返回：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())      </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>你也可以指定一个返回值，会被用于最终返回的结果对象中的 <code>value</code> 字段。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 42, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p><strong>扩展运算符与 <code>for-of</code> 循环会忽略 <code>return</code> 语句所指定的任意值。一旦它们看到 <code>done</code> 的值为 <code>true</code>，它们就会停止操作而不会读取对应的 <code>value</code> 值。</strong></p>
          </div>
<h2 id="生成器委托"><a href="#生成器委托" class="headerlink" title="生成器委托"></a>生成器委托</h2><p>在某些情况下，将两个迭代器的值合并一起会更有用。生成器可以用星号（<code>*</code>）配合 <code>yield</code> 这一特殊形式来委托其他的迭代器。正如生成器的定义，星号出现在何处是不重要的，只要落在 <code>yield</code> 关键字与生成器函数名之间即可。此处有个范例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'red'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'green'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">  <span class="keyword">yield</span> *createColorIterator()</span><br><span class="line">  <span class="keyword">yield</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())      </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'red', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'green', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: true, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>此例中的 <code>createCombinedIterator()</code> 生成器依次委托了 <code>createNumberIterator()</code> 与 <code>createColorIterator()</code>。返回的迭代器从外部看来就是一个单一的迭代器，用于产生所有的值。每次对 <code>next()</code> 的调用都会委托给合适的生成器，直到使用 <code>createNumberIterator()</code> 与 <code>createColorIterator()</code> 创建的迭代器全部清空为止。然后最终的 <code>yield</code> 会被执行以返回<code>true</code>。</p>
<p>生成器委托也能让你进一步使用生成器的返回值。这是访问这些返回值的最简单方式，并且在执行复杂任务时会非常有用。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'repeat'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">  <span class="keyword">yield</span> *createRepeatingIterator(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())     </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'repeat', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'repeat', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'repeat', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p><strong>注意观察，第三次调用 <code>next()</code> 方法时,代码在 <code>createNumberIterator()</code> 内的 <code>return</code> 语句处并没有停止执行，而是直接运行到 <code>createCombinedIterator()</code> 内的下一个 <code>yield</code> 处才停止执行的</strong>。</p>
<p>此处 <code>createCombinedIterator()</code> 生成器委托了 <code>createNumberIterator()</code> 并将它的返回值赋值给了 <code>result</code> 变量。由于 <code>createNumberIterator()</code> 包含 <code>return 3</code> 语句，该返回值就是 <code>3</code>。<code>result</code> 变量接下来会作为参数传递给 <code>createRepeatingIterator()</code> 生成器，指示同一个字符串需要被重复几次。</p>
<p>你也可以直接在字符串上使用 <code>yield *</code>，字符串的默认迭代器会被使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> * <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'h', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'e', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'l', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'l', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 'o', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())        </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<h1 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h1><p>执行异步操作的传统方式是调用一个包含回调的函数。例如，在 Node 中从磁盘读取一个文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'config.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doSomethingWith(contents)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当你拥有数量少而有限的任务需要完成时，这么做很有效。然而当你需要嵌套回调函数，或者要按顺序处理一系列的异步任务时，传统方式就会非常麻烦。在这种场合下，生成器与 <code>yield</code> 会很有用。</p>
<h2 id="一个简单的任务运行器"><a href="#一个简单的任务运行器" class="headerlink" title="一个简单的任务运行器"></a>一个简单的任务运行器</h2><p>由于 <code>yield</code> 能停止运行，并在重新运行前等待 <code>next()</code> 方法被调用，你就可以在没有回调函数的情况下实现异步调用。首先，你需要一个能够调用生成器并启动迭代器的函数，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建迭代器，让它在别处可用</span></span><br><span class="line">  <span class="keyword">let</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动任务</span></span><br><span class="line">  <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归使用函数来保持对 next() 的调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果还有更多要做的</span></span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      result = task.next()</span><br><span class="line">      step()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始处理过程</span></span><br><span class="line">  step()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配合这个已实现的 <code>run()</code> 函数，你就可以运行一个包含多条 <code>yield</code> 语句的生成器，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">run (<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此例只是将三个数值输出到控制台，单纯用于表明对 <code>next()</code> 的所有调用都已被执行。然而，仅仅使用几次 <code>yield</code> 并不太有意义，下一步是要把值传进迭代器并获取返回数据。</p>
<h2 id="带数据的任务运行"><a href="#带数据的任务运行" class="headerlink" title="带数据的任务运行"></a>带数据的任务运行</h2><p>传递数据给任务运行器最简单的方式，就是把 <code>yield</code> 返回的值传入下一次的 <code>next()</code> 调用。为此，你仅需传递 <code>result.value</code>，正如以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建迭代器，让它在别处可用</span></span><br><span class="line">  <span class="keyword">let</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动任务</span></span><br><span class="line">  <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归使用函数来保持对 next() 的调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果还有更多要做的</span></span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      result = task.next(result.value)</span><br><span class="line">      step()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始处理过程</span></span><br><span class="line">  step()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run (<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(value)     </span><br><span class="line">     </span><br><span class="line">  value = <span class="keyword">yield</span> value + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(value)          </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="异步任务运行器"><a href="#异步任务运行器" class="headerlink" title="异步任务运行器"></a>异步任务运行器</h2><p>下面的代码是一个使用生成器来运行异步任务的例子。</p>
<p>ps. 为了保持纯粹，这个例子中并没有使用 Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是异步操作</span></span><br><span class="line">    fs.readFile(filename, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建迭代器，让它在别处可用</span></span><br><span class="line">  <span class="keyword">let</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动任务</span></span><br><span class="line">  <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归使用函数来保持对 next() 的调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果还有更多要做的</span></span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行异步操作，并传递一个函数作为参数callback</span></span><br><span class="line">        result.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            result = task.throw(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          result = task.next(data)</span><br><span class="line">          step()  </span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = task.next(result.value)</span><br><span class="line">        step()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始处理过程</span></span><br><span class="line">  step()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run (<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">'config.json'</span>)</span><br><span class="line">  doSomethingWith(contents)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Cookie</title>
    <url>/posts/59cc01ec/</url>
    <content><![CDATA[<h1 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h1><p>对于一个网站来说，如果想要做到仅允许特定用户进行访问，或者为不同用户提供不同的内容，前提条件都是它能够识别当前用户。但由于 HTTP 是无状态协议，所以需要额外使用 Cookie 来辅助完成用户的识别。</p>
<div class="note info">
            <p>Cookie 技术有四个组成部分：</p><ul><li>HTTP 响应头中的一行 cookie 信息</li><li>HTTP 请求头中的一行 cookie 信息</li><li>保存在用户终端的 cookie 文件</li><li>服务端用于存储 cookie 数据库</li></ul><hr><p>Cookie 工作流程：</p><ol><li>客户端发送 HTTP 请求到服务器</li><li>当服务器收到请求后，在响应头中添加一个 <code>Set-Cookie</code> 字段</li><li>浏览器收到响应后将 Cookie 保存下来</li><li>后续对该服务器的每一次请求，浏览器都会自动为其添加对应的 Cookie 请求头（安全政策允许的话）</li></ol>
          </div>
<h1 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h1><h2 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h2><p>cookie 的 <code>Name</code> 由 US-ASCII 字符组成，不允许包含：控制字符（CTLs）、空格、制表符（Tab）、<code>()@,;:\&quot;/[]?={}</code>。</p>
<p>虽然 RFC 并没有规定必须使用 URL encoding 对 <code>Name</code> 进行编码，但是编码可以保证 <code>Name</code> 中不会出现不符合规定的字符。</p>
<p>如果 <code>Name</code> 是以 <code>__Secure-</code> 为前缀，那么必须同时设置 <code>Secure</code> 属性。</p>
<p>如果 <code>Name</code> 是以 <code>__Host-</code> 为前缀，那么必须同时设置 <code>Secure</code> 属性、禁止设置 <code>Domain</code> 属性、<code>Path</code> 属性的值必须为 <code>/</code>。</p>
<h2 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h2><p>cookie 的 <code>Value</code> 由 US-ASCII 字符组成，不允许包含：控制字符（CTLs）、空格、双引号、逗号、分号、反斜线。</p>
<p>虽然 RFC 并没有规定必须使用 URL encoding 对 <code>Value</code> 进行编码，但是编码可以保证 <code>Value</code> 中不会出现不符合规定的字符。</p>
<h2 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h2><p><code>Domain</code> 属性指定了那些域名可以接受这条 cookie。</p>
<p>如果不指定，那么默认值为当前文档访问地址中的域名，<strong>不包含子域名</strong>。</p>
<p>如果指定了 <code>Domain</code>，则子域名也会包含在内。</p>
<p>因此，指定 <code>Domain</code> 比省略它的限制要少。通常当子域名需要共享有关用户信息时，会指定 <code>Domain</code> 属性。</p>
<div class="note warning">
            <p><a href="https://stackoverflow.com/a/23086139" target="_blank" rel="noopener">stackoverflow: Share cookie between subdomain and domain</a><br>In <a href="https://tools.ietf.org/html/rfc2109" target="_blank" rel="noopener">RFC 2109</a>, a domain without a leading dot meant that it could not be used on subdomains, and only a leading dot (<code>.mydomain.com</code>) would allow it to be used across multiple subdomains.</p><p>However, all modern browsers respect the newer specification <a href="https://tools.ietf.org/html/rfc6265" target="_blank" rel="noopener">RFC 6265</a>, and will ignore any leading dot, meaning you can use the cookie on subdomains as well as the top-level domain.</p>
          </div>
<div class="note warning">
            <p><a href="https://stackoverflow.com/a/5258477" target="_blank" rel="noopener">stackoverflow: Domain set cookie for subdomain</a><br>The user agent will accept a cookie with a Domain attribute of <code>example.com</code> or of <code>foo.example.com</code> from <code>foo.example.com</code>, but the user agent will not accept a cookie with a Domain attribute of <code>bar.example.com</code> or of <code>baz.foo.example.com</code> from <code>foo.example.com</code>.</p>
          </div>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p><code>Path</code> 属性制定了一个 URL 路径片段，该路径片段必须出现在要请求的资源路径中才可以携带这条 cookie。假设 <code>Path=/docs</code>，那么 <code>/docs/Web</code> 会携带 cookie，<code>/test</code> 则不会携带 cookie。</p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>cookie 的最长有效时间，形式为符合 HTTP-date 规范的时间戳。</p>
<p>如果没有设置这个属性，那么表示这是一个 <strong>会话期 cookie</strong>，当客户端关闭后，会话结束，会话期 cookie 会被浏览器移除。</p>
<div class="note warning">
            <p>很多浏览器支持会话恢复功能，这个功能可以使浏览器保留所有的tab标签，然后在重新打开浏览器的时候将其还原。与此同时，会话期 cookie 也会恢复，就跟从来没有关闭浏览器一样。</p>
          </div>
<h2 id="Max-Age"><a href="#Max-Age" class="headerlink" title="Max-Age"></a>Max-Age</h2><p>在 cookie 失效前需要经过的秒数。秒数为 <code>0</code> 或负数会使 cookie 直接过期。</p>
<p>如果同时设置了 <code>Expires</code> 和 <code>Max-Age</code>，<code>Max-Age</code> 的优先级更高。</p>
<h2 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h2><p>设置该属性后，除 localhost 外，仅使用 <code>HTTPS</code> 的请求才能使用 cookie。</p>
<p>HTTP 站点无法为 cookie 设置 <code>Secure</code> 属性（在 Chrome 52+ 和 Firefox 52+ 中新引入的限制）。</p>
<h2 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h2><p>设置该属性后，无法通过 <code>document.cookie</code> 访问到这条 cookie。通过该属性可以防止 XSS 攻击获取 cookie 信息。</p>
<h2 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h2><div class="note info">
            <p>该属性用于控制在跨站请求时，是否允许携带这条 cookie。</p><ul><li><code>Lax</code>（默认值）：跨站请求时不能携带这条 cookie，但如果是由外部站点导航的请求（如一个链接），可以携带这条 cookie。</li><li><code>Strict</code>：跨站请求不能携带这条 cookie。</li><li><code>None</code>：只有同时设置了 <code>Secure</code> 时，<code>SameSite = None</code> 才会生效，此时允许跨站请求携带这条 cookie。</li></ul>
          </div>
<h1 id="如何设置-cookie"><a href="#如何设置-cookie" class="headerlink" title="如何设置 cookie"></a>如何设置 cookie</h1><h2 id="Set-Cookie-响应头"><a href="#Set-Cookie-响应头" class="headerlink" title="Set-Cookie 响应头"></a>Set-Cookie 响应头</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Path=&lt;path-value&gt;; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly; SameSite=Strict</span><br></pre></td></tr></table></figure>
<h2 id="Document-cookie"><a href="#Document-cookie" class="headerlink" title="Document.cookie"></a>Document.cookie</h2><p>通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie" target="_blank" rel="noopener">document.cookie</a> 来访问/修改 cookie，该方法只能访问到没有设置 <code>HttpOnly</code> 的 cookie。</p>
<h1 id="Cookie-的不足"><a href="#Cookie-的不足" class="headerlink" title="Cookie 的不足"></a>Cookie 的不足</h1><ul>
<li>cookie 只能以纯文本的形式保存，任何人都有可能对其进行修改</li>
<li>不同浏览器对 cookie 的限制不同，通常 cookie 文件总大小被限制在 4kb 以内，单个域名下的 cookie 个数被限制在 20 以内</li>
<li>在跨站请求时，cookie 有可能被禁止使用，即不会在请求时在头部附加对应 cookie 信息</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">MDN: Cookie</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">MDN: Set-Cookie</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie" target="_blank" rel="noopener">MDN: Document.cookie</a></li>
<li><a href="https://stackoverflow.com/a/23086139" target="_blank" rel="noopener">stackoverflow: Share cookie between subdomain and domain</a></li>
<li><a href="https://stackoverflow.com/a/5258477" target="_blank" rel="noopener">stackoverflow: Domain set cookie for subdomain</a></li>
<li><a href="https://tools.ietf.org/html/rfc2109" target="_blank" rel="noopener">RFC 2109</a></li>
<li><a href="https://tools.ietf.org/html/rfc6265" target="_blank" rel="noopener">RFC 6265</a></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP Caching</title>
    <url>/posts/8837602f/</url>
    <content><![CDATA[<p>我是 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="noopener">MDN</a> 的搬运工。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>如何读取命令行指令</title>
    <url>/posts/1fe87ebc/</url>
    <content><![CDATA[<h1 id="读取命令行指令"><a href="#读取命令行指令" class="headerlink" title="读取命令行指令"></a>读取命令行指令</h1><p>两个链接，读完就懂了：<a href="https://nodejs.org/en/knowledge/command-line/how-to-parse-command-line-arguments/" target="_blank" rel="noopener">How to parse command line arguments</a> 和 <a href="https://github.com/yargs/yargs-parser" target="_blank" rel="noopener">yargs-parser</a>。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://nodejs.org/en/knowledge/command-line/how-to-parse-command-line-arguments/" target="_blank" rel="noopener">How to parse command line arguments</a></li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>如何在 rollup 源码中 debug</title>
    <url>/posts/d9c5729d/</url>
    <content><![CDATA[<h1 id="使项目可以本地运行"><a href="#使项目可以本地运行" class="headerlink" title="使项目可以本地运行"></a>使项目可以本地运行</h1><p>因为 rollup 是使用 ts 编写的，所以需要下载 ts-node 来支持本地运行。过程中主要遇到两类问题：</p>
<ul>
<li>SyntaxError: Cannot use import statement outside a module</li>
<li>ts 报错</li>
</ul>
<p>第一个问题通过修改 tsconfig.json 来避免，第二个问题通过 @ts-ignore 来忽略。</p>
<h1 id="修改-cli-文件"><a href="#修改-cli-文件" class="headerlink" title="修改 cli 文件"></a>修改 cli 文件</h1><p>修改 rollup cli 文件，然后本地运行 cli 文件的，是改动最小的方式。这里的主要改动是让 rollup 去读我们指定的 rollup.config.ts 文件，而不是去项目根目录下寻找。</p>
<h1 id="打包配置"><a href="#打包配置" class="headerlink" title="打包配置"></a>打包配置</h1><p>在项目根目录下创建 learn 文件夹，里面保存着我们的 rollup.config.ts 和 build.ts。然后在 package.json 中添加对应的命令，就可以在源码中进行 debug 了！</p>
<h1 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h1><p>具体修改内容，可参照 <a href="https://github.com/aadonkeyz/rollup/commit/55f0e18bdd0c3fd0276d53c85df52587c87fcf06" target="_blank" rel="noopener">commit</a></p>
<p>如果觉得修改麻烦，可以直接在 learn 分支上进行 debug。</p>
]]></content>
      <categories>
        <category>FE tools</category>
        <category>rollup 2.69.2</category>
      </categories>
  </entry>
  <entry>
    <title>XSS和CSRF</title>
    <url>/posts/5c76f87e/</url>
    <content><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>XSS是跨站脚本攻击（Cross Site Script）的简写。之所以是 X 开头而不是 C 是为了与CSS进行区分。</p>
<div class="note info">
            <p><strong>之所以存在XSS攻击，是因为<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>可以内嵌到大部分HTML标签（<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>除外）内部，且正常工作（即可以弹出提示框）。</strong></p>
          </div>
<p>具体的XSS攻击方式就不在这里展示了，不过<a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noopener">这里挺详细的</a></p>
<p>至于防范XSS攻击的方式，主要为对<code>&lt;</code>、<code>&gt;</code>、<code>script</code>进行转义或过滤。</p>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF是跨站请求伪造（Cross Site Request Forgery）的简写。</p>
<div class="note info">
            <p><strong>之所以存在CSRF攻击，是因为如果浏览器中保存有某一个域名下的Cookie的话，那么每次向该域名下的服务器发送请求都会自动携带上对应的Cookie。而Cookie中通常包含用户的认证信息，所以攻击者可以假冒它是用户来向服务器发起CSRF攻击。</strong></p><hr><p>防范CSRF攻击的方式有：</p><ul><li>使用验证码验证身份。</li><li>使用HTTP请求的<code>Referer</code>首字段检查发送请求的来源地址。<code>Referer</code>首字段的另一个用途是“防止图片盗链”。</li><li>使用token验证Cookie中不包含的信息。</li></ul>
          </div>
<!-- aadonkeyz -->
]]></content>
      <categories>
        <category>待整理</category>
      </categories>
  </entry>
  <entry>
    <title>rollup cli</title>
    <url>/posts/de3a6b85/</url>
    <content><![CDATA[<h1 id="读取-command"><a href="#读取-command" class="headerlink" title="读取 command"></a>读取 command</h1><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argParser <span class="keyword">from</span> <span class="string">'yargs-parser'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> command = argParser(process.argv.slice(<span class="number">2</span>), &#123;</span><br><span class="line">  alias: commandAliases,</span><br><span class="line">  configuration: &#123; <span class="string">'camel-case-expansion'</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我的指令是配置在 package.json 中，为 <code>&quot;build&quot;: &quot;rollup -c&quot;</code>，它对应的 <code>command</code> 变量为</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">command = &#123;</span><br><span class="line">  _: [],</span><br><span class="line">  c: <span class="literal">true</span>,</span><br><span class="line">  config: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="生成-options"><a href="#生成-options" class="headerlink" title="生成 options"></a>生成 options</h1><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; options &#125; = <span class="keyword">await</span> getConfigs(command);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分界线</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getConfigs</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  command: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;</span>&#123; options: MergedRollupOptions[]; warnings: BatchWarnings &#125;&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (command.config) &#123;</span><br><span class="line">    <span class="comment">// getConfigPath 在项目根目录下寻找 rollup.config.(mjs | cjs | ts | js)，然后返回对应文件的绝对路径</span></span><br><span class="line">    <span class="keyword">const</span> configFile = <span class="keyword">await</span> getConfigPath(command.config);</span><br><span class="line">    <span class="keyword">const</span> &#123; options, warnings &#125; = <span class="keyword">await</span> loadAndParseConfigFile(</span><br><span class="line">      configFile,</span><br><span class="line">      command</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> &#123; options, warnings &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> loadConfigFromCommand(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadAndParseConfigFile</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fileName: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  commandOptions: <span class="built_in">any</span> = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;</span>&#123; options: MergedRollupOptions[]; warnings: BatchWarnings &#125;&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> configs = <span class="keyword">await</span> loadConfigFile(fileName, commandOptions);</span><br><span class="line">  <span class="keyword">const</span> warnings = batchWarnings();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> normalizedConfigs: MergedRollupOptions[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> config of configs) &#123;</span><br><span class="line">      <span class="keyword">const</span> options = mergeOptions(config, commandOptions, warnings.add);</span><br><span class="line">      <span class="keyword">await</span> addCommandPluginsToInputOptions(options, commandOptions);</span><br><span class="line">      normalizedConfigs.push(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; options: normalizedConfigs, warnings &#125;;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    warnings.flush();</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="根据-options-进行-build"><a href="#根据-options-进行-build" class="headerlink" title="根据 options 进行 build"></a>根据 options 进行 build</h1><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; options, warnings &#125; = <span class="keyword">await</span> getConfigs(command);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> inputOptions of options) &#123;</span><br><span class="line">  <span class="keyword">await</span> build(inputOptions, warnings, command.silent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分界线</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  inputOptions: MergedRollupOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  warnings: BatchWarnings,</span></span></span><br><span class="line"><span class="function"><span class="params">  silent = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">unknown</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> outputOptions = inputOptions.output;</span><br><span class="line">  <span class="keyword">const</span> useStdout = !outputOptions[<span class="number">0</span>].file &amp;&amp; !outputOptions[<span class="number">0</span>].dir;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> bundle = <span class="keyword">await</span> rollup(inputOptions <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (useStdout) &#123;</span><br><span class="line">    <span class="keyword">await</span> bundle.generate(output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(outputOptions.map(bundle.write));</span><br><span class="line">  <span class="keyword">await</span> bundle.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE tools</category>
        <category>rollup 2.69.2</category>
      </categories>
  </entry>
  <entry>
    <title>rollup 源码解析</title>
    <url>/posts/408e8927/</url>
    <content><![CDATA[<p>首页是对外暴露的 <code>rollup</code> 方法，它调用的是 <code>rollupInternal</code> 方法。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">rollup</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  rawInputOptions: GenericConfigObject</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">RollupBuild</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rollupInternal(rawInputOptions, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 <code>rollupInternal</code>，它负责生成 <code>graph</code>，然后调用 <code>graph.build()</code> 开始对源文件进行解析，最后生成 <code>result</code>。在 <code>result</code> 上具有 <code>generate</code> 和 <code>write</code> 两个输出编译后代码的方法。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rollupInternal</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  rawInputOptions: GenericConfigObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  watcher: RollupWatcher | <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">RollupBuild</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; options: inputOptions, unsetOptions: unsetInputOptions &#125; =</span><br><span class="line">    <span class="keyword">await</span> getInputOptions(rawInputOptions, watcher !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> graph = <span class="keyword">new</span> Graph(inputOptions, watcher);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> useCache = rawInputOptions.cache !== <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> graph.build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result: RollupBuild = &#123;</span><br><span class="line">    cache: useCache ? graph.getCache() : <span class="literal">undefined</span>,</span><br><span class="line">    <span class="keyword">async</span> close() &#123;</span><br><span class="line">      <span class="comment">// xxx</span></span><br><span class="line">    &#125;,</span><br><span class="line">    closed: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">async</span> generate() &#123;</span><br><span class="line">      <span class="comment">// xxx</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watchFiles: <span class="built_in">Object</span>.keys(graph.watchFiles),</span><br><span class="line">    <span class="keyword">async</span> write() &#123;</span><br><span class="line">      <span class="comment">// xxx</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上 <code>generate</code> 和 <code>write</code> 的实现细节基本一致，都是调用的 <code>handleGenerateWrite</code> 函数，只是所传第一个参数不同罢了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleGenerateWrite</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  isWrite: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  inputOptions: NormalizedInputOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  unsetInputOptions: ReadonlySet&lt;<span class="built_in">string</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  rawOutputOptions: GenericConfigObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  graph: Graph</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">RollupOutput</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bundle = <span class="keyword">new</span> Bundle(</span><br><span class="line">    outputOptions,</span><br><span class="line">    unsetOptions,</span><br><span class="line">    inputOptions,</span><br><span class="line">    outputPluginDriver,</span><br><span class="line">    graph</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> generated = <span class="keyword">await</span> bundle.generate(isWrite);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isWrite) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      <span class="built_in">Object</span>.values(generated).map(<span class="function">(<span class="params">chunk</span>) =&gt;</span></span><br><span class="line">        writeOutputFile(chunk, outputOptions)</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createOutput(generated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所见可以看到 rollup 的运行是从创建 <code>Graph</code> 实例开始的，它上面会挂载三个重要属性：</p>
<ul>
<li><code>pluginDriver</code>：管理 plugin。</li>
<li><code>acornParser</code>：生成 ast 语法树。</li>
<li><code>moduleLoader</code>：管理文件。</li>
</ul>
<p><code>Graph.generateModuleGraph</code> 方法会从入口文件开始，通过对源代码进行分析，从而梳理文件之间的依赖关系，逐一的为每个文件生成一个 <code>Module</code> 实例，然后登记在 <code>graph.moduleLoader.modulesById</code> 上。</p>
<p>在对源代码进行分析时，就是通过 <code>graph.acornParse</code> 生成 ast 语法树，然后再基于 rollup 自己定义在 src/nodes/shared 下的节点生成对应的实例，保存在 <code>module.ast</code> 上。在这一系列动作之后，已经知道了当前源文件依赖哪些其他文件，然后就可以顺着依赖关系再对其他文件进行同样的解析。</p>
<p>当然，在这一过程中，会在关键的节点调用 <code>graph.pluginDriver</code> 上的合适方法来抛出对应的钩子，触发用户声明要在编译过程中执行的 plugins。</p>
]]></content>
      <categories>
        <category>FE tools</category>
        <category>rollup 2.69.2</category>
      </categories>
  </entry>
</search>
