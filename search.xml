<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cookie]]></title>
    <url>%2Fposts%2F59cc01ec%2F</url>
    <content type="text"><![CDATA[什么是 Cookie对于一个网站来说，如果想要做到仅允许特定用户进行访问，或者为不同用户提供不同的内容，前提条件都是它能够识别当前用户。但由于 HTTP 是无状态协议，所以需要额外使用 Cookie 来辅助完成用户的识别。 Cookie 技术有四个组成部分：HTTP 响应头中的一行 cookie 信息HTTP 请求头中的一行 cookie 信息保存在用户终端的 cookie 文件服务端用于存储 cookie 数据库Cookie 工作流程：客户端发送 HTTP 请求到服务器当服务器收到请求后，在响应头中添加一个 Set-Cookie 字段浏览器收到响应后将 Cookie 保存下来后续对该服务器的每一次请求，浏览器都会自动为其添加对应的 Cookie 请求头（安全政策允许的话） Cookie 的属性Namecookie 的 Name 由 US-ASCII 字符组成，不允许包含：控制字符（CTLs）、空格、制表符（Tab）、()@,;:\&quot;/[]?={}。 虽然 RFC 并没有规定必须使用 URL encoding 对 Name 进行编码，但是编码可以保证 Name 中不会出现不符合规定的字符。 如果 Name 是以 __Secure- 为前缀，那么必须同时设置 Secure 属性。 如果 Name 是以 __Host- 为前缀，那么必须同时设置 Secure 属性、禁止设置 Domain 属性、Path 属性的值必须为 /。 Valuecookie 的 Value 由 US-ASCII 字符组成，不允许包含：控制字符（CTLs）、空格、双引号、逗号、分号、反斜线。 虽然 RFC 并没有规定必须使用 URL encoding 对 Value 进行编码，但是编码可以保证 Value 中不会出现不符合规定的字符。 DomainDomain 属性指定了那些域名可以接受这条 cookie。 如果不指定，那么默认值为当前文档访问地址中的域名，不包含子域名。 如果指定了 Domain，则子域名也会包含在内。 因此，指定 Domain 比省略它的限制要少。通常当子域名需要共享有关用户信息时，会指定 Domain 属性。 stackoverflow: Share cookie between subdomain and domainIn RFC 2109, a domain without a leading dot meant that it could not be used on subdomains, and only a leading dot (.mydomain.com) would allow it to be used across multiple subdomains.However, all modern browsers respect the newer specification RFC 6265, and will ignore any leading dot, meaning you can use the cookie on subdomains as well as the top-level domain. stackoverflow: Domain set cookie for subdomainThe user agent will accept a cookie with a Domain attribute of example.com or of foo.example.com from foo.example.com, but the user agent will not accept a cookie with a Domain attribute of bar.example.com or of baz.foo.example.com from foo.example.com. PathPath 属性制定了一个 URL 路径片段，该路径片段必须出现在要请求的资源路径中才可以携带这条 cookie。假设 Path=/docs，那么 /docs/Web 会携带 cookie，/test 则不会携带 cookie。 Expirescookie 的最长有效时间，形式为符合 HTTP-date 规范的时间戳。 如果没有设置这个属性，那么表示这是一个 会话期 cookie，当客户端关闭后，会话结束，会话期 cookie 会被浏览器移除。 很多浏览器支持会话恢复功能，这个功能可以使浏览器保留所有的tab标签，然后在重新打开浏览器的时候将其还原。与此同时，会话期 cookie 也会恢复，就跟从来没有关闭浏览器一样。 Max-Age在 cookie 失效前需要经过的秒数。秒数为 0 或负数会使 cookie 直接过期。 如果同时设置了 Expires 和 Max-Age，Max-Age 的优先级更高。 Secure设置该属性后，除 localhost 外，仅使用 HTTPS 的请求才能使用 cookie。 HTTP 站点无法为 cookie 设置 Secure 属性（在 Chrome 52+ 和 Firefox 52+ 中新引入的限制）。 HttpOnly设置该属性后，无法通过 document.cookie 访问到这条 cookie。通过该属性可以防止 XSS 攻击获取 cookie 信息。 SameSite 该属性用于控制在跨站请求时，是否允许携带这条 cookie。Lax（默认值）：跨站请求时不能携带这条 cookie，但如果是由外部站点导航的请求（如一个链接），可以携带这条 cookie。Strict：跨站请求不能携带这条 cookie。None：只有同时设置了 Secure 时，SameSite = None 才会生效，此时允许跨站请求携带这条 cookie。 如何设置 cookieSet-Cookie 响应头1Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Path=&lt;path-value&gt;; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly; SameSite=Strict Document.cookie通过 document.cookie 来访问/修改 cookie，该方法只能访问到没有设置 HttpOnly 的 cookie。 Cookie 的不足 cookie 只能以纯文本的形式保存，任何人都有可能对其进行修改 不同浏览器对 cookie 的限制不同，通常 cookie 文件总大小被限制在 4kb 以内，单个域名下的 cookie 个数被限制在 20 以内 在跨站请求时，cookie 有可能被禁止使用，即不会在请求时在头部附加对应 cookie 信息 参考文献 MDN: Cookie MDN: Set-Cookie MDN: Document.cookie stackoverflow: Share cookie between subdomain and domain stackoverflow: Domain set cookie for subdomain RFC 2109 RFC 6265]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Broswer Event Loop]]></title>
    <url>%2Fposts%2Fcf159629%2F</url>
    <content type="text"><![CDATA[不是我懒惰，是我怕翻译错soHTML Standard - Event LoopHTML Standard - TimersHTML Standard - Microtask QueuingConcurrency model and the event loopIn depth: Microtasks and the JavaScript runtime environmentUsing microtasks in JavaScript with queueMicrotask()Event loop: microtasks and macrotasks]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node Event Loop]]></title>
    <url>%2Fposts%2F1bc69df4%2F</url>
    <content type="text"><![CDATA[下面两段代码，你能说出正确的打印顺序分别是什么吗？ 123456789setTimeout(() =&gt; &#123; console.log('timeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('immediate');&#125;);// 无法确定打印顺序 12345678910111213const fs = require('fs');fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;, 0); setImmediate(() =&gt; &#123; console.log('immediate'); &#125;);&#125;);// 先 immediate// 后 timeout 不是我懒惰，是我怕翻译错soNode 官方解读在这里 下面是写的比较好的博客，它们是一个系列哦： Event Loop and the Big Picture — NodeJS Event Loop Part 1 Timers, Immediates and Process.nextTick — NodeJS Event Loop Part 2 Promises, Next-Ticks, and Immediates — NodeJS Event Loop Part 3 Handling IO — NodeJS Event Loop Part 4 New Changes to the Timers and Microtasks in Node v11.0.0 (and above) Event Loop Best Practices — NodeJS Event Loop Part 5]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Executable Code and Execution Contexts]]></title>
    <url>%2Fposts%2F33ac290%2F</url>
    <content type="text"><![CDATA[Types of Executable CodeThere are three types of ECMAScript executable code: Global code is source text that is treated as an ECMAScript Program. The global code of a particular Program does not include any source text that is parsed as part of a FunctionBody. Eval code is the source text supplied to the built-in eval function. More precisely, if the parameter to the built-in eval function is a String, it is treated as an ECMAScript Program. The eval code for a particular invocation of eval is the global code portion of that Program. Function code is source text that is parsed as part of a FunctionBody. The function code of a particular FunctionBody does not include any source text that is parsed as part of a nested FunctionBody. Function code also denotes the source text supplied when using the built-in Function object as a constructor. More precisely, the last parameter provided to the Function constructor is converted to a String and treated as the FunctionBody. If more than one parameter is provided to the Function constructor, all parameters except the last one are converted to Strings and concatenated together, separated by commas. The resulting String is interpreted as the FormalParameterList for the FunctionBody defined by the last parameter. The function code for a particular instantiation of a Function does not include any source text that is parsed as part of a nested FunctionBody. Lexical EnvironmentA Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a WithStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated. An Environment Record records the identifier bindings that are created within the scope of its associated Lexical Environment. The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment. An outer Lexical Environment may, of course, have its own outer Lexical Environment. A Lexical Environment may serve as the outer environment for multiple inner Lexical Environments. For example, if a FunctionDeclaration contains two nested FunctionDeclarations then the Lexical Environments of each of the nested functions will have as their outer Lexical Environment the Lexical Environment of the current execution of the surrounding function. Lexical Environments and Environment Record values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values. Execution ContextsWhen control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the running execution context. An execution context contains whatever state is necessary to track the execution progress of its associated code. In addition, each execution context has three state components: LexicalEnvironment: Identifies the Lexical Environment used to resolve identifier references made by code within this execution context. VariableEnvironment: Identifies the Lexical Environment whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this execution context. ThisBinding: The value associated with the this keyword within ECMAScript code associated with this execution context. The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created, its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context. An execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to access an execution context. 参考文献 Annotated ES5]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RegExp]]></title>
    <url>%2Fposts%2Fce76031c%2F</url>
    <content type="text"><![CDATA[创建正则表达式正则表达式可以通过 var expression = /pattern/flags 的字面量形式来创建。其中的 pattern 代表任何简单或复杂的正则表达式，flag 代表一个或多个标志。 g：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止。i：表示不区分大小写模式。m：表示多行模式。y：表示从正则表达式的 lastIndex 属性值的位置开始向后检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索并返回 null 同样也支持使用 RegExp 构造函数来创建正则表达式，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。 123// pattern1 和 pattern2 的作用是完全一样的var pattern1 = /[bc]at/ivar pattern2 = new RegExp('[bc]at', 'i') 由于 RegExp 构造函数的模式参数都是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此。 复制正则表达式在 ES5 中，你可以将正则表达式传递给 RegExp 构造器来复制它，就像这样： 12var re1 = /ab/ivar re2 = new RegExp(re1) re2 变量只是 re1 的一个副本。但如果你向 RegExp 构造器传递了第二个参数，即正则表达式的标志，那么该代码就无法正常工作，正如该范例： 1234var re1 = /ab/i// ES5中会抛出错误，ES6中可用var re2 = new RegExp(re1, 'g') 如果你在 ES5 中运行这段代码，那么你会收到一条错误信息，表示在第一个参数已经是正则表达式的情况下不能再使用第二个参数。ES6 则修改了这个行为，允许使用第二个参数，并且让它覆盖第一个参数中的标志。例如： 12345678910111213141516171819202122var re1 = /ab/i// ES5 中会抛出错误，ES6 中可用var re2 = new RegExp(re1, 'g')// /ab/iconsole.log(re1.toString()) // /ab/gconsole.log(re2.toString()) // trueconsole.log(re1.test('ab')) // trueconsole.log(re2.test('ab')) // trueconsole.log(re1.test('AB')) // falseconsole.log(re2.test('AB')) flags在 ES5 中，你可以使用 source 属性来获取正则表达式的文本，但若想获取标志字符串，你必须解析 toString() 方法的输出，就像下面展示的那样： 123456789function getFlags (re) &#123; var text = re.toString(); return text.substring(text.lastIndexOf('/') + 1, text.length);&#125;// toString() 的输出为 "/ab/g"var re = /ab/g;console.log(getFlags(re)); ES6 新增了 flags 属性用于配合 source 属性，让标志的获取变得更容易。这两个属性均为只有 get 函数，无 set 函数的访问器属性，因此都是只读的。 1234567var re = /ab/gi// abconsole.log(re.source) // giconsole.log(re.flags) y 标志12345678910111213141516171819202122232425262728293031323334353637383940414243var text = 'hello1 hello2 hello3'var pattern = /hello\d\s?/var globalPattern = /hello\d\s?/gvar stickyPattern = /hello\d\s?/yvar result = pattern.exec(text)var globalResult = globalPattern.exec(text)var stickyResult = stickyPattern.exec(text)// hello1console.log(result[0]) // hello1console.log(globalResult[0]) // hello1console.log(stickyResult[0]) // 0console.log(pattern.lastIndex) // 7console.log(globalPattern.lastIndex) // 7console.log(stickyPattern.lastIndex) pattern.lastIndex = 1globalPattern.lastIndex = 1stickyPattern.lastIndex = 1result = pattern.exec(text)globalResult = globalPattern.exec(text)stickyResult = stickyPattern.exec(text)// hello1console.log(result[0]) // hello2console.log(globalResult[0]) // Uncaught TypeError: Cannot read property '0' of nullconsole.log(stickyResult[0]) 有两个关于粘连标志的微妙细节需要牢记： 只有调用正则表达式对象上的方法（例如 exec() 与 test() 方法），lastIndex 属性才会生效。而将正则表达式作为参数传递给字符串上的方法（例如 match() 方法），并不会体现粘连特性；当使用 ^ 字符来匹配字符串的起始处时，粘连的正则表达式只会匹配字符串的起始处（或者在多行模式下匹配行首）。当 lastIndex 为 0 时，^ 不会让粘连的正则表达式与非粘连的有任何区别。而当 lastIndex 不为 0 时，粘连的正则表达式永远不会匹配成功。 可以使用如下方法来检测粘连标志是否被支持： 12345678function hasRegExpY () &#123; try &#123; var pattern = new RegExp('.', 'y') return true &#125; catch (ex) &#123; return false &#125;&#125; exec exec() 方法在一个指定字符串中 执行一次匹配搜索。如果匹配失败，返回 null。如果匹配成功，返回一个数组。这个数组有以下特点：该方法一次只会返回一个匹配项（第一个匹配项），这个匹配项被保存在数组的第一项。捕获组从数组第二项开始保存。如果没有捕获组，则返回的数组只包含一项。具有 input 属性，表示应用正则表达式的字符串。具有 index 属性，表示匹配项在字符串中的索引。具有 groups 属性，表示一个捕获组或 undefined（如果没有定义命名捕获组） 对于 exec() 方法而言，即使在模式中设置了 g 标志，它每次也只会返回一个匹配项。在不设置 g 标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。而在设置了 g 标志的情况下，每次调用 exec() 都会在字符串中继续查找新匹配项 123456789101112131415161718192021222324var text = 'mom and dad and baby'var pattern = /mom (and dad (and baby)?)?/// [ 'mom and dad and baby', 'and dad and baby', 'and baby', index: 0, input: 'mom and dad and baby', groups: undefined ]console.log(pattern.exec(text))var str = 'cat, bat, sat, fat'var p1 = /.at/// [ 'cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined ]console.log(p1.exec(str))// [ 'cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined ]console.log(p1.exec(str))var p2 = /.at/g// [ 'cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined ]console.log(p2.exec(str))// [ 'bat', index: 5, input: 'cat, bat, sat, fat', groups: undefined ]console.log(p2.exec(str)) testtest()方法接收一个字符串参数，在模式与该参数匹配的情况下返回 true，否则返回 false。 常用总结常用元字符概述 元字符 描述 ^ 匹配字符串的起始位置。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 $ 匹配字符串的结束位置。如果多行标志被设置为 true，那么也匹配换行符前的位置。 \b 匹配一个词的起始或结束位置。例如，\bm 匹配 moon 中的 m，而 oo\b 并不匹配 moon 中的 oo。 \B 匹配组成一个词的各个字符的中间位置。例如，\B.. 匹配 noonday 中的 oo，而 y\B.. 匹配 possibly yesterday 中的 yes。 \ 将元字符转义为字面量。例如，如果想在字符串中匹配 ^，那么可以使用 \^。 {n} 匹配前一个表达式 n 次。n 必须为正整数。 {n,} 至少匹配前一个表达式 n 次。n 必须为正整数。 {n,m} 匹配前一个表达式 n 次到 m 次之间（包括 n 和 m）。n 和 m 必须为正整数，且 n &lt; m。 * 匹配前一个表达式 0 次或多次，等价于 {0,}。 + 匹配前一个表达式 1 次或多次，等价于 {1,}。 ? 匹配前一个表达式 0 次或 1 次，等价于 {0,1}。 . 匹配除换行符之外的任意单个字符。 (xyz) 匹配 xyz 并记住匹配项，括号内的内容被称为捕获组。例如，(foo)(bar)\1\2 等价于 foobarfoobar。 (?:xyz) 匹配 xyz 但不记住匹配项。 x(?=y) 当且仅当 x 后面紧跟着 y 时，匹配 x。这叫做先行断言。 x(?!=y) 当且仅当 x后面没有紧跟着 y 时，匹配 x。这叫做正向否定查找。 (?&lt;=y)x 当且仅当 x 前面就是 y 时，匹配 x。这叫做后行断言。 (?&lt;!y)x 当且仅当 x 前面不是 y 时，匹配 x。这叫做反向否定查找。 x&#124;y 匹配 x 或 y。 [xyz] 匹配一个出现在方括号中的字符。在方括号内部，你可以使用破折号 - 来指定一个范围。例如，[a-z] 代表匹配一个小写字母。 [^xyz] 匹配一个没有出现在方括号中的字符。在方括号内部，你可以使用破折号 - 来指定一个范围。例如，[^a-z] 代表匹配一个小写字母以外的其他字符。 [\b] 匹配一个退格。 \cX 当 X 是处于 A-Z 之间的字符时，匹配字符串中的一个控制字符。例如，\cM 匹配字符串中的 control-M。 \d 匹配一个数字字符。 \D 匹配一个非数字字符。 \f 匹配一个换页符。 \n 匹配一个换行符。 \r 匹配一个回车符。 \s 匹配一个空白符，包括空格、制表符、换页符和换行符。 \S 匹配一个非空白字符。 \t 匹配一个水平制表符。 \v 匹配一个垂直制表符。 \w 匹配一个单子字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。 \W 匹配一个非单子字符。等价于 [^A-Za-z0-9_]。 \number 正数代表第 number 个捕获组。例如，apple(,)\sorange\1 匹配 apple, orange, cherry 中的 apple, orange,。 贪婪/非贪婪匹配参考自【正则表达式系列】贪婪与非贪婪模式 贪婪匹配定义：会尽量多的匹配符合条件的内容。元字符：+、?、*、{n}、{n,}、{n,m}。非贪婪匹配定义：会尽量少的匹配符合条件的内容，一旦发现符合规则的内容就立刻终止匹配。元字符：+?、??、*?、{n}?、{n,}?、{n,m}?。 12345678910111213141516171819let str = 'aacbacbc'// aacbacbconsole.log(str.match(/.*b/)[0]) // aacbconsole.log(str.match(/.*?b/)[0]) // cbconsole.log(str.match(/.?b/)[0]) // cbconsole.log(str.match(/.??b/)[0]) // aacbacbconsole.log(str.match(/.+b/)[0]) // aacbconsole.log(str.match(/.+?b/)[0])]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Array]]></title>
    <url>%2Fposts%2F6e01c1fe%2F</url>
    <content type="text"><![CDATA[创建数组ES5 及之前数组的每一项都可以保存任何类型的数据，可以通过 Array 构造器和数组字面量语法两种方式创建数组，如果通过 Array 构造器创建数组，new 操作符可以省略。 123456789101112var a = new Array('red', 1);var b = Array('red', 1);var c = ['red', 1];// [ 'red', 1 ]console.log(a)// [ 'red', 1 ]console.log(b)// [ 'red', 1 ]console.log(c) 通过数组的 length 可以清空或截断数组。数组会自动将字符串索引转换为对应数值索引，即array[&#39;0&#39;] === array[0]。 Array 构造器的怪异点 通过 Array 构造器创建数组时，如果只传递一个数值，会创建一个有 length 属性的数组，但内部空空如也，无法进行如 forEach 等迭代操作。 12345678910111213141516171819202122232425262728var normal = Array('3');// [ '3' ]console.log(normal);var empty = Array(3);// [ &lt;3 empty items&gt; ]console.log(empty);// 3console.log(empty.length);for (let i = 0; i &lt; empty.length; i++) &#123; // 0 undefined // 1 undefined // 2 undefined console.log(i, empty[i]);&#125;empty.forEach(item =&gt; &#123; console.log(item);&#125;)// 等价于var a = [];a.forEach((item, index) =&gt; &#123; console.log(item);&#125;) 用 Array.apply 创建数组1234567891011var a = Array.apply(null, &#123; length: 3 &#125;);// [ undefined, undefined, undefined ]console.log(a);a.forEach((item, index) =&gt; &#123; // 0 undefined // 1 undefined // 2 undefined console.log(index, item);&#125;) 通过解构&amp;迭代器创建数组123456789101112var a = [...Array(3).entries()];var b = [...Array(3).keys()];var c = [...Array(3).values()];// [ [ 0, undefined ], [ 1, undefined ], [ 2, undefined ] ]console.log(a);// [ 0, 1, 2 ]console.log(b);// [ undefined, undefined, undefined ]console.log(c); Array.ofES6 引入了 Array.of() 方法来解决 Array 构造器创建数组的怪异点。该方法的作用非常类似 Array 构造器，但在使用单个数值参数的时候并不会导致特殊结果。Array.of() 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。下面例子演示了 Array.of() 的用法： 1234567891011121314151617181920212223242526var a = Array.of(1, 2)// 2console.log(a.length) // 1console.log(a[0]) // 2console.log(a[1]) var b = Array.of(2)// 1console.log(b.length) // 2console.log(b[0]) var c = Array.of('2')// 1console.log(c.length) // '2'console.log(c[0]) Array.of() 方法并没有使用 Symbol.species 属性来决定返回值的类型，而是使用了当前的构造器（即 of() 方法内部的 this）来做决定。例如，MyArray.of() 返回 MyArray 类型的实例，Array.of() 返回 Array 类型的实例。 Array.from将可迭代对象或者类数组对象作为第一个参数传入，Array.from() 就能返回一个数组。这里有个简单的例子： 12345function doSomething() &#123; var args = Array.from(arguments) // 使用 args&#125; 此处调用 Array.from() 方法，使用 arguments 对象创建了一个新数组 args，它是一个数组实例，并且包含了 arguments 对象的所有项，同时还保持了项的顺序。 与 Array.of() 一样，Array.from() 方法同样使用当前的构造器（即 from() 方法内部的 this）来决定要返回什么类型的数组。例如，MyArray.from() 返回 MyArray 类型的实例，Array.from() 返回 Array 类型的实例。 如果你想实行进一步的数组转换，你可以向 Array.from() 方法传递一个映射用的函数作为第二个参数。此函数会将类数组对象的每一个值转换为目标形式，并将其存储在目标数组的对应位置上。例如： 12345678function translate () &#123; return Array.from(arguments, value =&gt; value + 1)&#125;const numbers = translate(1, 2, 3)// [ 2, 3, 4 ]console.log(numbers) 如果映射函数需要在对象上工作，你可以手动传递第三个参数给 Array.from() 方法，从而指定映射函数内部的 this 值。 123456789101112131415let helper = &#123; diff: 1, add (value) &#123; return value + this.diff &#125;&#125;function translate () &#123; return Array.from(arguments, helper.add, helper)&#125;let numbers = translate(1, 2, 3)// [ 2, 3, 4 ]console.log(numbers) 只要一个对象有 length 属性，Array.from() 就会可以通过它得到对应长度的数组 123456let a = &#123; length: 3&#125;// [ undefined, undefined, undefined ]console.log(Array.from(a)) 检测数组ES5 提出了 Array.isArray() 方法来检测数组，不过并不是所有版本的浏览器都兼容这个方法。兼容各种情况的方法如下所示： 123function isArray (value) &#123; return Object.prototype.toString.call(value) == '[object Array]'&#125; 转换方法join()接收一个字符串作为参数，然后以该字符串为分隔符将数组（或类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组中只有一个元素，那么将返回该元素的字符串形式而不使用分隔符。如果没有给join()传递参数，则默认使用,作为分隔符 1234567891011// "Fire,Air,Water"console.log(['Fire', 'Air', 'Water'].join())// "FireAirWater"console.log(['Fire', 'Air', 'Water'].join(''))// "Fire-Air-Water"console.log(['Fire', 'Air', 'Water'].join('-'))// "[object Object],[object Object]"console.log([&#123; a: 1 &#125;, &#123; b: 2 &#125;].join()) 栈方法栈是一种后进先出的数据结构，ECMAScript 为数组提供了 push() 和 pop() 方法来实现类似栈的行为。 push() 方法接收任意数量的参数，把他们逐个添加到数组末尾，然后返回修改后数组的长度.pop() 方法从数组末尾移除最后一项，将数组长度减 1，然后返回移除的项。 队列方法队列的访问规则是先见先出，可以通过 unshift() 和 shift() 配合实现。 unshift() 方法在数组前端添加任意个项, 然后返回新数组的长度。shift() 方法移除数组中的第一项，将数组长度减 1，然后返回移除的项. 排序方法reverse() 方法会反转数组项的顺序。sort() 方法默认按升序排列数组项，并且可以接收一个比较函数作为参数。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数。 123456789101112131415161718192021222324252627var a = [1, 3, 2, 6]a.reverse()// [6, 2, 3, 1]console.log(a)a.sort()// [1, 2, 3, 6]console.log(a)function compare (value1, value2) &#123; if (value1 &gt; value2) &#123; return -1 &#125; else if (value1 &lt; value2) &#123; return 1 &#125; else &#123; return 0 &#125;&#125;var values = [0, 1, 5, 10, 15]values.sort(compare)// [15, 10, 5, 1, 0]console.log(values) 操作方法concatconcat() 方法会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。如果传递的参数是一个或多个数组，则会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单的添加到结果数组的末尾。 1234567var colors = ['red', 'green', 'blue']var colors2 = colors.concat('yellow', ['black', 'brown'])// ['red', 'green', 'blue']console.log(colors) // ['red', 'green', 'blue', 'yellow', 'black', 'brown'] console.log(colors2) sliceslice(start, end) 方法返回一个由原数组索引从 start 到 end-1 的项组成的新数组。 如果省略 start，则默认从 0 开始。如果省略 end 或 end 大于数组长度，则 slice 方法会一直提取到数组末尾（包括最后一个元素）如果 start 或 end 中有负数，则用数组长度加上该数来确定相应的索引。 12345678910111213141516171819var colors = [1, 2, 3, 4]// colors2 = [2, 3]var colors2 = colors.slice(1, 3) // colors3 = [1, 2, 3]var colors3 = colors.slice(undefined, 3) // colors4 = [2, 3, 4]var colors4 = colors.slice(1) // colors5 = [2, 3, 4] var colors5 = colors.slice(1, 100)// colors6 = [2] var colors6 = colors.slice(1, 2) // colors7 = [2] var colors7 = colors.slice(-3, -2) splicesplice(start, deleteNum, replaceItem, replaceItem, replaceItem, ...) 方法返回一个数组，该数组包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。它是最灵活的一个数组操作方法，它可以实现对原始数组的删除、插入和替换操作。 start：操作起始位置的索引。deleteNum：要删除的项数。replaceItem：要插入的项,一个或多个。 123456789101112131415161718192021var colors = ['red', 'green', 'blue']var removed = colors.splice(0, 1)// ['green', 'blue']console.log(colors) // ['red']console.log(removed) removed = colors.splice(1, 0, 'yellow', 'orange')// ['green', 'yellow', 'orange', 'blue']console.log(colors) // [] console.log(removed) removed = colors.splice(1, 1, 'red', 'purple')// ['green', 'red', 'purple', 'orange', 'blue']console.log(colors) // ['yellow'] console.log(removed) fill fill(value, start, end + 1) 方法使用参数 value 去替换数组索引从 start 至 end 的项。如果提供的起始位置（start）或结束位置（end + 1）为负数，则它们会被加上数组的长度来算出最终的位置。请观察下面的例子： 12345678910111213141516let numbers = [1, 2, 3, 4]numbers.fill(1)// [ 1, 1, 1, 1 ]console.log(numbers)numbers.fill(2, 1)// [ 1, 2, 2, 2 ]console.log(numbers)numbers.fill(3, 1, 3)// [ 1, 3, 3, 2 ]console.log(numbers) 需要注意的是，fill() 方法是使用浅复制来完成的。 12345678910111213let a = [1, 2];a.fill([]);// [ [], [] ]console.log(a);a[1].push(33);// [ [ 33 ], [ 33 ] ]console.log(a);// trueconsole.log(a[0] === a[1]); copyWithcopyWithin() 方法与 fill() 类似，可以一次性修改数组的多个元素。不过，与 fill() 使用单个值来修改数组不同，copyWithin() 方法允许你在数组内部复制自身元素。为此你需要传递两个参数给 copyWithin() 方法：从什么位置开始进行修改，以及被用来复制的数据的起始位置索引。 12345678let numbers = [1, 2, 3, 4]// 从索引 2 的位置开始粘贴// 从索引 0 的位置开始复制数据numbers.copyWithin(2, 0)// [ 1, 2, 1, 2 ]console.log(numbers) 默认情况下，copyWithin() 方法总是会一直复制到数组末尾，不过你还可以提供一个可选参数来限制到底有多少元素会被修改。这第三个参数指定了复制停止的位置（不包括该位置自身），这里有个范例： 123456789let numbers = [1, 2, 3, 4]// 从索引 2 的位置开始粘贴// 从索引 0 的位置开始复制数据// 在索引 1 的位置停止复制numbers.copyWithin(2, 0, 1)// [ 1, 2, 1, 4 ]console.log(numbers) 类似于 fill() 方法，如果你向 copyWithin() 方法传递负数参数，数组的长度会自动被加到该参数的值上，以便算出正确的索引位置。 位置方法indexOf(searchValue[, fromIndex]) 和 lastIndexOf(searchValue[, fromIndex]) 都是找到就返回索引，找不到就返回 -1。 迭代方法every arr.every(callback[, thisArg])：对每个数组元素调用 callback() 方法，如果所有 callback() 的返回值都等价于 true，返回 true。否则返回 false。callback(item, index, array)：item：元素。index：元素对应索引。array：arr 的引用。thisArg：作用域对象。 1234var arr = [0, 1, 2];// falseconsole.log(arr.every((item) =&gt; item)); some arr.some(callback[, thisArg])：对每个数组元素调用 callback() 方法，只要有一个 callback() 的返回值都等价于 true，返回 true。否则返回 false。callback(item, index, array)：item：元素。index：元素对应索引。array：arr 的引用。thisArg：作用域对象。 1234var arr = [0, 1, 2];// trueconsole.log(arr.some((item) =&gt; item)); filter arr.every(callback[, thisArg])：对每个数组元素调用 callback() 方法，返回 callback() 返回值等价于 true 对应的元素所组成的新数组。callback(item, index, array)：item：元素。index：元素对应索引。array：arr 的引用。thisArg：作用域对象。 12345var arr = [0, 1, 2];var newArr = arr.filter((item) =&gt; item);// [1, 2]console.log(newArr); forEach arr.forEach(callback[, thisArg])：对每个数组元素调用 callback() 方法，该方法没有返回值。callback(item, index, array)：item：元素。index：元素对应索引。array：arr 的引用。thisArg：作用域对象。 1234567var arr = [0, &#123;&#125;, &#123;&#125;];arr.forEach((item, index) =&gt; &#123; item.index = index;&#125;);// [0, &#123; index: 1 &#125;, &#123; index: 2 &#125;]console.log(arr); map arr.map(callback[, thisArg])：对每个数组元素调用 callback() 方法，返回所有 callback() 返回值组成的新数组。callback(item, index, array)：item：元素。index：元素对应索引。array：arr 的引用。thisArg：作用域对象。 1234567var arr = [0, &#123;&#125;, &#123;&#125;];var newArr = arr.map((item) =&gt; &#123; return !!item;&#125;);// [false, true, true]console.log(newArr); reduce arr.reduce(callback[, initialValue])：对每个数组元素调用 callback() 方法，返回最后一个 callback() 的返回值。callback(accumulator, currentValue[, index[, array]])：该回调函数会在数组中进行迭代，它的返回值将传递给下一次迭代的 accumulator 参数，它的参数介绍如下：accumulator：上一次迭代的返回值。currentValue：迭代的当前值。index：当前索引。array：数组对象。initialValue：作为 callback() 进行第一次迭代时 accumulator 的值。如果没有传入这个参数，那么 callback() 在第一次迭代时会将数组的第一项作为 accumulator 的值。 1234567891011121314151617181920var values = [1, 2, 3]var sum1 = values.reduce((acc, cur, index, array) =&gt; &#123; console.log('acc: ' + acc, 'cur: ' + cur, 'index: ' + index) return acc + cur&#125;)// acc: 1 cur: 2 index: 1// acc: 3 cur: 3 index: 2var sum2 = values.reduce((acc, cur, index, array) =&gt; &#123; console.log('acc: ' + acc, 'cur: ' + cur, 'index: ' + index) return acc + cur&#125;, 10)// acc: 10 cur: 1 index: 0// acc: 11 cur: 2 index: 1// acc: 13 cur: 3 index: 2// 6console.log(sum1) // 16 console.log(sum2) reduceRight arr.reduceRight(callback[, initialValue])：按照倒序对每个数组元素调用 callback() 方法，返回最后一个 callback() 的返回值。callback(accumulator, currentValue[, index[, array]])：该回调函数会在数组中进行迭代，它的返回值将传递给下一次迭代的 accumulator 参数，它的参数介绍如下：accumulator：上一次迭代的返回值。currentValue：迭代的当前值。index：当前索引。array：数组对象。initialValue：作为 callback() 进行第一次迭代时 accumulator 的值。如果没有传入这个参数，那么 callback() 在第一次迭代时会将数组的最后一项作为 accumulator 的值。 1234567891011121314151617181920var values = [1, 2, 3]var sum1 = values.reduceRight((acc, cur, index, array) =&gt; &#123; console.log('acc: ' + acc, 'cur: ' + cur, 'index: ' + index) return acc + cur&#125;)// acc: 3 cur: 2 index: 1// acc: 5 cur: 1 index: 0var sum2 = values.reduceRight((acc, cur, index, array) =&gt; &#123; console.log('acc: ' + acc, 'cur: ' + cur, 'index: ' + index) return acc + cur&#125;, 10)// acc: 10 cur: 3 index: 2// acc: 13 cur: 2 index: 1// acc: 15 cur: 1 index: 0// 6console.log(sum1) // 16console.log(sum2) find arr.find(callback[, thisArg])：对每个数组元素调用 callback() 方法，如果某一个 callback() 返回值为 true，则返回其对应的数组元素。如果有多个 callback() 都返回 true，则只返回第一个。如果所有 callback() 都返回 false，则返回 undefined。callback(item, index, array)：item：元素。index：元素对应索引。array：arr 的引用。thisArg：作用域对象。 1234567const a = [1, 2, 3];// 2console.log(a.find((item, index) =&gt; item === 2 || index === 2));// undefinedconsole.log(a.find(item =&gt; item === 4)); findIndex arr.find(callback[, thisArg])：对每个数组元素调用 callback() 方法，如果某一个 callback() 返回值为 true，则返回其对应的索引。如果有多个 callback() 都返回 true，则只返回第一个。如果所有 callback() 都返回 false，则返回 -1`。callback(item, index, array)：item：元素。index：元素对应索引。array：arr 的引用。thisArg：作用域对象。 1234567const a = [1, 2, 3];// 1console.log(a.findIndex((item, index) =&gt; item === 2 || index === 2));// -1console.log(a.findIndex(item =&gt; item === 4));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Object]]></title>
    <url>%2Fposts%2Fa7625ff7%2F</url>
    <content type="text"><![CDATA[基础概念我们看到的大多数引用类型值都是 Object 类型的实例！对，连数组、函数等都是 Object 类型的实例！ 我所知道的例外有 Object.create(null) 返回的空对象。 创建 Object 实例方式有：new Object() 和对象字面量表示法。对象属性名一定是字符串或符号，如果不是，会自动转换为字符串。访问对象属性的方式：点表示法和方括号表示法。 对象字面量语法属性初始化的速记法在 ES6 中，你可以使用属性初始化的速记法来消除对象名称与本地变量的重复情况。当对象的一个属性名称与本地变量名相同时，你可以简单书写名称而省略冒号与值。例如： 123456function createPerson (name, age) &#123; return &#123; name, age &#125;&#125; 当对象字面量中的属性只有名称时，引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。在本例中，局部变量 name 的值就被赋给了对象的 name 属性。 方法简写ES6 允许在为对象字面量方法赋值时，省略冒号与 function 关键字。 123456var person = &#123; name: 'Nicholas', sayName () &#123; console.log(this.name) &#125;&#125; 需计算属性名在 ES5 及更早版本中，可以在对象字面量中将字符串直接用作属性名，就像这样： 123456var person = &#123; 'first name': 'Nicholas'&#125;// Nicholasconsole.log(person['first name']) 但是前提是这个属性名事先已知，并且能用字符串表示。如果用对象字面量语法创建对象时，想为它定义一个尚未确定名称的属性，ES5是做不到这点的。但是ES6可以呀！ 在 ES6 中，需计算属性名是对象字面量语法的一部分，它用的也是方括号表示法。 123456789101112var lastName = 'last name'var person = &#123; 'first name': 'Nicholas', [lastName]: 'Zakas'&#125;// Nicholasconsole.log(person['first name'])// Zakasconsole.log(person[lastName]) 在对象字面量内的方括号表明该属性需要计算，其结果是一个字符串。这意味着其中可以包含表达式，像下面这样： 123456789101112var suffix = ' name'var person = &#123; ['first' + suffix]: 'Nicholas', ['last' + suffix]: 'Zakas'&#125;// Nicholasconsole.log(person['first name'])// Zakasconsole.log(person['last name']) 重复的对象字面量属性在 ES5 严格模式下如果出现重复的对象字面量属性，会抛出错误。但 ES6 移除了重复属性的检查，严格模式与非严格模式都不在检查重复的属性。当存在重复属性时，排在后面的属性的值会成为该属性的实际值。 自有属性的枚举顺序ES6 并没有定义对象属性的枚举顺序，而是把该问题留给了 JS 引擎厂商。而 ES6 则严格定义了对象自有属性在被枚举时返回的顺序。这对 Object.getOwnPropertyNames() 与 Reflect.ownKeys 如何返回属性造成了影响，还同样影响了 Object.assign() 处理属性的顺序。 自有属性枚举时基本顺序如下： 所有的数字类型键，按升序排列。所有的字符串类型键，按被添加到对象的顺序排列。所有的符号类型键，也按添加顺序排列。 12345678910111213var obj = &#123; a: 1, 0: 1, c: 1, '2': 1, b: 1, 1: 1&#125;obj.d = 1// 0,1,2,a,c,b,dconsole.log(Object.getOwnPropertyNames(obj).join(',')) for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。 super super 是指向当前对象的原型的一个引用，并且 super 只能在对象的简写方法中使用。虽然 super 是当前对象原型的一个引用，但是通过 super 调用原型方法时，被调用的原型方法内部的 this 会与当前对象方法内部的 this 保持一致。super 就是 Object.getPrototypeOf(this) 的值。这其实是错误的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let proto = &#123; where: 'proto 自己', func () &#123; console.log(this.where + '调用 proto 的 func') &#125;&#125;let superObj = &#123; where: 'superObj', find () &#123; super.func() &#125;&#125;let callObj = &#123; where: 'callObj', find () &#123; Object.getPrototypeOf(this).func() &#125;&#125;Object.setPrototypeOf(superObj, proto)Object.setPrototypeOf(callObj, proto)// superObj 调用 proto 的 funcsuperObj.find()// proto 自己调用 proto 的 funccallObj.find()let otherProto = &#123; where: 'otherProto 自己', func () &#123; console.log(this.where + '调用 otherProto 的 func') &#125;&#125;let otherObj = &#123; where: 'otherObj'&#125;Object.setPrototypeOf(otherObj, otherProto)// otherObj 调用 proto 的 funcsuperObj.find.call(otherObj)// otherProto 自己调用 otherProto 的 funccallObj.find.call(otherObj) 正式的“方法”定义在 ES6 之前，“方法”的概念从未被正式定义，它从前仅指对象的函数属性（而非数据属性）。ES6 则正式做出了定义：方法是一个拥有 [[HomeObject]] 内部属性的函数，此内部属性指向该方法所属的对象。 使用 super 调用原型方法时，背后的工作流程。在 [[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用。在该原型上查找同名函数。创建 this 绑定并调用该方法。 Object.assign该方法接受一个接收者，以及任意数量的供应者，接收者会按照供应者在参数中的顺序来依次接收它们的属性，最后返回接收者。在这一过程中如果出现属性名重复的情况，则后面的会覆盖前面的。 12345678910111213141516var receiver = &#123; name: 'origin'&#125;Object.assign(receiver, &#123; type: 'js', name: 'file.js' &#125;, &#123; type: 'css' &#125;)// &#123; type: 'css', name: 'file.js' &#125;console.log(receiver) 需要注意的是，Object.assign() 并未在接收者上创建访问器属性，即使供应者拥有访问器属性。由于 Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者的数据属性，例如： 12345678910111213141516var receiver = &#123;&#125;, supplier = &#123; get name () &#123; return 'file.js' &#125; &#125;Object.assign(receiver, supplier)var descriptor = Object.getOwnPropertyDescriptor(receiver, 'name')// file.jsconsole.log(descriptor.value)// undefinedconsole.log(descriptor.get) Object.createObject.create(proto, [propertiesObject]) 以 proto 为原型创建一个新的对象。Object.create() 方法的第二个参数与 Object.defineProperties() 方法的第二个参数格式相同。 12345678910111213141516171819202122var person = &#123; name: 'Nicholas', friend: ['Shelby', 'Court', 'Van']&#125;var anotherPerson = Object.create(person, &#123; name: &#123; value: 'Greg', enumerable: false, &#125;&#125;)// trueconsole.log(person.isPrototypeOf(anotherPerson))// &#123;&#125;console.log(anotherPerson)// Gregconsole.log(anotherPerson.name)// [ 'Shelby', 'Court', 'Van' ]console.log(anotherPerson.friend) Object.is当比较两个值的时候，大多数开发者倾向于使用严格相等运算符（===），但是它有一点小瑕疵。例如，它认为 +0 与 -0 相等，即使这两者在引擎中有不同的表示。另外 NaN === NaN 会返回 false，因此有必要使用 Number.isNaN() 函数来正确检测 NaN。 ES6 引入了 Object.is() 方法来弥补严格相等运算符残留的怪异点。此方法接受两个参数，并会在二者的值相等时返回 true，此时要求二者类型相同并且值也相等。 12345// falseconsole.log(Object.is(+0, -0))// trueconsole.log(Object.is(NaN, NaN)) 在许多情况下，Object.is() 的结果与 === 运算符是相同的，仅有的例外是：它会认为 +0 与 -0 不相等，而且 NaN 等于 NaN。 Object.setPrototypeOfES6 添加了 Object.setPrototypeOf 方法，此方法允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。 123456789101112131415161718192021222324252627let person = &#123; getGreeting () &#123; return 'hello' &#125;&#125;let dog = &#123; getGreeting () &#123; return 'woof' &#125;&#125;let friend = Object.create(person)// helloconsole.log(friend.getGreeting())// trueconsole.log(Object.getPrototypeOf(friend) === person)Object.setPrototypeOf(friend, dog)// woofconsole.log(friend.getGreeting())// trueconsole.log(Object.getPrototypeOf(friend) === dog)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2Fposts%2Fa80d0031%2F</url>
    <content type="text"><![CDATA[最长有效括号给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。&quot;(()&quot; =&gt; 2&quot;)()())&quot; =&gt; 4&quot;()(())&quot; =&gt; 6 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 1. 定义 dp[i]: * 存在 0 &lt;= x &lt;= i, s[x]...s[i] 为以 s[i] 结尾的最长有效括号子串, dp[i] 为子串长度 * 2. 确定状态转移方程: * 2.1 若 s[i] = '(', 则 dp[i] = 0 * 2.2 若 s[i] = ')' * 2.2.1 若 s[i - 1] = '(', 则 dp[i] = dp[i - 2] + 2 * 2.2.2 若 s[i - 1] = ')' * 2.2.2.1 若 dp[i - 1] = 0, 则 dp[i] = 0 * 2.2.2.2 若 dp[i - 1] &gt; 0 * 2.2.2.2.1 若 s[i - 1 - dp[i - 1]] = '(', 则 dp[i] = dp[i - 1] + 2 + dp[i - 2 - dp[i - 1]] * 2.2.2.2.2 若 s[i - 1 - dp[i - 1]] = ')', 则 dp[i] = 0 * 3. 确定初始条件: * dp[0] = 0 */function longestValidParentheses (s) &#123; let maxLen = 0; const dp = [0]; for (let i = 1; i &lt; s.length; i++) &#123; if (s[i] === '(') &#123; dp[i] = 0; continue; &#125; /** * s[i] === ')' */ if (s[i - 1] === '(') &#123; if (i - 2 &gt;= 0) &#123; dp[i] = dp[i - 2] + 2; &#125; else &#123; dp[i] = 2; &#125; maxLen = Math.max(dp[i], maxLen); continue; &#125; /** * s[i] === ')' * s[i - 1] === ')' */ if (dp[i - 1] === 0) &#123; dp[i] = 0; continue; &#125; /** * s[i] === ')' * s[i - 1] === ')' * dp[i - 1] &gt; 0 */ if (s[i - 1 - dp[i - 1]] === '(') &#123; if (i - 2 - dp[i - 1] &gt;= 0) &#123; dp[i] = dp[i - 1] + 2 + dp[i - 2 - dp[i - 1]]; &#125; else &#123; dp[i] = dp[i - 1] + 2; &#125; maxLen = Math.max(dp[i], maxLen); &#125; else &#123; dp[i] = 0; &#125; &#125; return maxLen;&#125;; 不同路径条数一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步，机器人试图达到网格的右下角。网格中用 0 表示空位置，用 1 表示障碍物。求从左上角到右下角将会有多少条不同的路径。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * !!! 需要注意横纵坐标与给定数组的对应关系 * * 1. 定义dp[i][j]: * 从 (0, 0) 出发到 (i, j) 的路径条数 * 2. 确定状态转移方程: * 2.1 若 obstacleGrid[j][i] === 1, 则 dp[i][j] = 0 * 2.2 若 obstacleGrid[j][i] === 0, 则 dp[i][j] = dp[i - 1][j] + dp[i][j - 1] * 3. 确定初始条件: * dp[0][0] = 1 */function uniquePathsWithObstacles (obstacleGrid) &#123; if (!obstacleGrid) &#123; return 0; &#125; const yLen = obstacleGrid.length; if (yLen &lt;= 0) &#123; return 0; &#125; if (!obstacleGrid[0]) &#123; return 0; &#125; const xLen = obstacleGrid[0].length; if (xLen &lt;= 0) &#123; return 0; &#125; const dp = []; /** * i 是横坐标 * j 是纵坐标 */ for (let i = 0; i &lt; xLen; i++) &#123; dp[i] = []; for (let j = 0; j &lt; yLen; j++) &#123; /** * 初始条件 */ if (i === 0 &amp;&amp; j === 0) &#123; if (obstacleGrid[0][0] === 0) &#123; dp[0][0] = 1; &#125; else &#123; dp[i][j] = 0; &#125; continue; &#125; dp[i][j] = 0; if (obstacleGrid[j][i] === 0) &#123; if (i - 1 &gt;= 0) &#123; dp[i][j] += dp[i - 1][j]; &#125; if (j - 1 &gt;= 0) &#123; dp[i][j] += dp[i][j - 1]; &#125; &#125; &#125; &#125; return dp[xLen - 1][yLen - 1];&#125;; 编辑距离给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行三种操作：插入一个字符、删除一个字符和替换一个字符。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * !!! 之所以 i, j 代表个数而不代表索引，是考虑到空字符串存在的情况，同时状态转移方程强依赖于空字符串存在的情况 * 1. 定义dp[i][j]: * word1 的前 i 个子串转换为 word2 的前 j 个子串 所需要的最少操作数 * 2. 确定状态转移方程: * 2.1 若 word[i] === word[j], 则 dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1]) * 2.2 若 word[i] === word[j], 则 dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + 1) * 3. 确定初始条件: * dp[0][j] = j * dp[i][0] = i */function minDistance (word1, word2) &#123; const m = word1.length; const n = word2.length; const dp = []; /** * 初始条件 */ for (let i = 0; i &lt;= m; i++) &#123; dp[i] = [i]; &#125; for (let j = 0; j &lt;= n; j++) &#123; dp[0][j] = [j]; &#125; for (let i = 1; i &lt;= m; i ++) &#123; for (let j = 1; j &lt;= n; j++) &#123; /** * 最后一步为插入/删除/替换操作时, 所需的步骤总数 * 如果 word1[i - 1] === word2[j - 1], 替换操作 = 无操作 */ const insertActions = dp[i][j - 1] + 1; const deleteActions = dp[i - 1][j] + 1; const replaceActions = word1[i - 1] === word2[j - 1] ? dp[i - 1][j - 1] : dp[i - 1][j - 1] + 1; dp[i][j] = Math.min(insertActions, deleteActions, replaceActions); &#125; &#125; return dp[m][n];&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git Stash]]></title>
    <url>%2Fposts%2F1955d066%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425# save your local modifications to a new stash entry# and roll them back to HEAD$ git stash push [-m &lt;message&gt;]# list the stash entries that you currently have# stash@&#123;0&#125; is the latest entry, stash@&#123;1&#125; is the one before$ git stash list# show the changes recorded in the stash entry as a diff # between the stashed contents and # the commit back when the stash entry was first created$ git stash show [&lt;stash&gt;]# remove a single stashed state from the stash list# and apply it on top of the current working tree state$ git stash pop [&lt;stash&gt;]# like pop, but do not remove the state from the stash list$ git stash apply [&lt;stash&gt;]# remove all the stash entries$ git stash clear# remove a single stash entry from the list of entries$ git stash drop [&lt;stash&gt;] When you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command git stash saves your local modifications away and reverts the working directory to match the HEAD commit. The modifications stashed away by this command can be listed with git stash list, inspected with git stash show, and restored with git stash apply. Calling git stash without any arguments is equivalent to git stash push. A stash is by default listed as “WIP on branchname…”, but you can give a more descriptive message on the command line when you create one. The latest stash you created is stored in refs/stash; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. stash@{0} is the most recently created stash, stash@{1} is the one before it, stash@{2.hours.ago} is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer n is equivalent to stash@{n}).]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git Branching]]></title>
    <url>%2Fposts%2F3557a152%2F</url>
    <content type="text"><![CDATA[Commands123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# create a branch# only create, don't switch# if you don't type existbranch, use current branch$ git branch &lt;newbranch&gt; [&lt;existbranch&gt;]# switch your working directory$ git checkout [&lt;branchname&gt; | &lt;tagname&gt; | &lt;commitsha1&gt;]# rename a branch# if the newbranch is already existed# -m =&gt; rename fail# -M =&gt; delete the existed one, and then rename$ git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt;# create a branch and switch to it# if you don't type existbranch, use current branch$ git checkout -b &lt;newbranch&gt; [&lt;existbranch&gt;]# move the branch pointer$ git branch -f [&lt;branchname&gt; | &lt;tagname&gt; | &lt;commitsha1&gt;]# merge the target branch into your current branch$ git merge &lt;targetbranch&gt;# merge the target branch into your current branch# create a merge commit in all cases# even when the merge could instead be resolved as a fast-forward$ git merge &lt;targetbranch&gt; --no-ff# no options =&gt; local branches list# -r =&gt; remote branches list# -a =&gt; both remote and local branches list$ git branch [-r | -a]# see the last commit on each branch$ git branch -v# filter the list to branches that you have or haven't merged into your current branch$ git branch [--merged | --no-merged]# fetch any data from the given remote that you don't yet have# update your local database# move your remote/branch pointer to its new, more up-to-data position.# if you don't type remote, it will use origin as default$ git fetch [&lt;remotename&gt;]# push the local branch to the remote branch$ git push &lt;remotename&gt; &lt;localbranch:remotebranch&gt;# fetch the upstream branch and merge into the tracking branch$ git pull# set the current branch to track remotebranch# you can use this command to change the relationship between a tracking branch and a upstream branch$ git branch &lt;-u | --set-upstream-to&gt; &lt;[[remotes/]origin/]remotebranch&gt;# if current branch is not a tracking branch, and you want to push it# if remotebranch isn't exist, Git will automatically create it$ git push --set-upstream &lt;remotename&gt; &lt;remotebranch&gt;# see what tracking branches you have set up$ git branch -vv# delete a local branch$ git branch -d &lt;branchname&gt;# delete a remote branch$ git push &lt;remotename&gt; --delete &lt;branchname&gt;# take the patch(s) and replay it/them on top of somewhere else# if there is no argument, it will rebase on the upstream of current local branch$ git rebase [&lt;branchname&gt; | &lt;tagname&gt; | &lt;commitsha1&gt;]# if there is any conflict while rebasing, use this command$ git rebase &lt;--continue | --abort | --skip&gt; Branches in a NutshellTo really understand the way Git does branching, we need to take a back and examine how Git stores its data. Git doesn’t store data as a series of changesets or differents, but instead as a series of snapshots. When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged. This object also contains the author’s name and email address, the message that you typed, and the pointer to the commit or commits that directly came before this commit (its parent or parents): zero parents for the inital commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two of more branches. A branch in Git is simply a lightweight movable pointer to one of these commits. When you create a new branch, Git creates a new pointer for you to move around. And How does Git know what branch you’re currently on? Git keeps a special pointer called HEAD, it is the symbolic name for the currently checkout out commit — it’s essentially what commit you’re working on top of. Normally HEAD attaches to a branch, when you commit, the status of that branch is altered. When HEAD attaches to a commit instead of a branch, this phenomenon is called detach. Basic Branching and Merging 12345$ git checkout -b bugFix$ git commit$ git checkout master$ git commit$ git merge bugFix Remote BranchesLook at an example, let’s say you have a Git server on your network at git.ourcompany.com. If you clone from this, Git’s clone command automatically names it origin for you, pulls down all its data, creates some pointers to correspond to remote branches, the name of remote branchs in local will has a prefix like remotes/ or remotes/origin/. Git also gives you your own local master branch starting at the same places as origin’s master branch, so you have something to work from. If you do some work on your local master branch, and, in the meantime, someone else pushes to git.ourcompany.com and updates its master branch, then your histories move forward differently. Also, as long as you stay out of contact with your origin server, your origin/master pointer doesn’t move. To synchronize your work with a given remote, you run a git fetch &lt;remote&gt; command. This command fetches any data from the given remote that you don’t yet have, and updates your local database, moving your origin/master pointer to its new, more up-to-data position. It’s important to note that when you do a fetch that brings down new remote-tracking branches, you don’t automatically have local, editable copies of them. In other words, in this case, you don’t have a new branch — you have only an origin/master pointer that you can’t modify. When you want to share a branch with the world, you need to push it up to a remote to which you have write access. Your local branches aren’t automatically synchronized to the remotes you write to — you have to explicitly push the branches you want to share. That way, you can use private branches for work you don’t want to share, and push up only the topic branches you want to collaborate on. If you have a branch named serverfix that you want to work on with others, you can push it up the same way you pushed your first branch. Run git push &lt;remote&gt; &lt;branch&gt;: 12345678$ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.Total 24 (delta 2), reused 0 (delta 0)To https://github.com/schacon/simplegit * [new branch] serverfix -&gt; serverfix This is a bit of a shortcut. Git automatically expands the serverfix branchname out to refs/heads/serverfix:refs/heads/serverfix, which means, “Take my serverfix local branch and push it to update the remote’s serverfix branch.” You can also do git push origin serverfix:serverfix, which does the same thing — it says, “Take my serverfix and make it the remote’s serverfix.” You can use this format to push a local branch into a remote branch that is named differently. If you didn’t want it to be called serverfix on the remote, you could instead run git push origin serverfix:awesomebranch to push your local serverfix branch to the awesomebranch branch on the remote project. Checking out a local branch from a remote-tracking branch automatically creates what is called a “tracking branch”, and the branch it tracks is called an “upstream branch”. Tracking branches are local branches that have a direct relationship to a remote branch. If you’re on a tracking branch and type git pull, Git automatically know which server to fetch from and which branch to merge in. If you want to change the upstream branch you’re tracking, you can use the -u or --set-upstream-to option to git branch to explicitly set it at any time. Rebasing It turns out that in addition to the commit SHA-1 checksum, Git also calculates a checksum that is based just on the patch introduced with the commit, this is called a “patch-id”. In addition to merge, if you want to integrate changes from experiment into master, there is another way. You can take the patch of the change that was introduce in C4 and reapply it on top of C3. In Git, this is called rebasing. With the rebase command, you can take all the changes that were committed on one branch and replay them on a different branch. 12$ git checkout experiment$ git rebase master At this point, you can go back to the master branch and do a fast-forward merge. 12$ git checkout master$ git merge experiment Rebasing replays changes from one line of work onto another in the order they were introduced, whereas merging takes the endpoints and merges them together. There is no difference in the end product of the integration, but rebasing makes for a cleaner history. In addition, when you rebase stuff, you’re abanding existing commits and creating new ones that are similar but different. If there is any conflict while you are rebasing, you should fix the conflict, and then use git add to stage the files, use git rebase --continue to finish the rebasing process. In this process, do not use git commit, it will create a commit and detach the HEAD!]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git Basics]]></title>
    <url>%2Fposts%2F22d36175%2F</url>
    <content type="text"><![CDATA[What is GitThe major difference between Git and other VCS (Version Control System) is the way Git thinks about its data. Conceptually, most other systems store information as a list of file-based changes. These other systems think of the information they store as a set of files and the changes made to each file over time. Git dosen’t think of or store its data this way, instead, Git thinks of its data more like a series of snapshots of a miniature filesystem. With Git, every time you commit, or save the state of your project, Git basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot. To be efficient, if files have not changed, Git dosen’t store the file again, just a link to the previous identical file it has already stored. Git thinks about its data more like a stream of snapshots. Because you have the entire history of the project tight there on your local disk, most operations seem almost instantaneous, and most operations in Git need only local files and resources to operate — generally no information is needed from another computer on your network. Git has three main states that your files can reside in:modified: you have changed the file but have not commited it to your database yet.staged: you have marked a modified file in its current version to go into your next commit snapshot.committed: the data is safely stored in your local database.This leads us to the three main sections of a Git project:the working directory: a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.the staging area: a file, generally contained in your Git directory, that stores information about what will go into your next commit. Its technical name in Git parlance is the “index”, but the phrase “staging area” works just so well.the Git directory: stores the metadata and project database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer. Git comes with a tool called git config that lets you get and set configuration variables that control all aspects of how Git looks and operates. These variables can be stored in three different places: /etc/gitconfig file: Contains value applied to every user on the system and all their repositories. If you pass the option --system to git config, it reads and writes from this file specifically.~/.gitconfig or ~/.config/git/config file: Values specific personally to you, the user. You can make Git read and write to this file specifically by passing the --global option, and this affects all of the repositories you work with on your system.config file in the Git directory of whatever repository you’re currently using: Specific to that single repository. You can force Git to read from and write to this file with the --local option, but that is in fact the default Getting a Git RepositoryYou can take a local directory that is currently not under version control, and turn it into a Git repository. 12$ cd /Users/user/my_project$ git init Or, you can clone an existing Git repository from elsewhere. 1$ git clone &lt;url&gt; [target-directory] Recording Changes to the Repository Each file in your working directory can be in one of two states:tracked: Tracked files are files that were in the last snapshot or in the Staging Area. In short, tracked files are files that Git knows about.untracked: Any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven’t edited anything. 123456789101112131415161718192021222324252627# determine which files are in which state$ git status# move a file from the working directory to the staging area# "git add ." means move all files in current directory$ git add &lt;filename&gt;# discard changes in working directory# you can only use this command on tracked files$ git checkout -- &lt;filename&gt;# move a file from the staging area to the working directory$ git reset HEAD &lt;filename&gt;# see what you've changed but not yet staged$ git diff# see what you've staged that will go into your next commit$ git diff --staged# remove a file from Git, and also removes the file from the working directory (which means delete the file)$ git rm &lt;filename&gt;# keep the file in the working directory but remove it from the staging area# this is particulary useful if you forgot to add something to your .gitignore file and accidentally staged it$ git rm --cached &lt;filename&gt;# commit your changes that are in the staging area$ git commit [-m &lt;msg&gt;] Often, you’ll have a class of files that you don’t want Git to automatically add or even show you as being untracked. In such cases, you can create a file listing patterns to match them named .gitignore The rules for the patterns you can put in the gitignore file are as follows:Blank lines or lines starting with # are ignored.Standard glob patterns work, and will be applied recursively throughout the entire working directory.You can start patterns with a forward slash (/) to avoid recursivity.You can end patterns with a forward slash (/) to specify a directory.you can negate a pattern by starting it with an exclamation point (!). Here is an example .gitignore file: 1234567891011121314151617# ignore all .a files*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in any directory named buildbuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directory and any of its subdirectoriesdoc/**/*.pdf Working with RemotesRemote repositories are versions of your project that are hosted on the Internet or network somewhere. 1234567891011121314151617181920212223242526# show the list of the shortnames of each remote handle you've specified$ git remote# show the URLs that Git has stored for the shortname$ git remote -v# add a new remote Git repository$ git remote add &lt;name&gt; &lt;url&gt;# get data from remote repository# this command only downloads the data to your local repository# it doesn't automatically merge it with any of your work of modify what you're currently working on# if you don't type remote, it will use origin as default$ git fetch [&lt;remotename&gt;]# push any commits you've done back up to the server$ git push &lt;remotename&gt; &lt;branchname&gt;# inspect a remote$ git remote show &lt;remotename&gt;# change a remote's shortname$ git remote rename &lt;oldname&gt; &lt;newname&gt;# remove a remote$ git remote remove &lt;remotename&gt; Tagging1234567891011121314151617181920212223# list the existing tags$ git tag# create an tag$ git tag &lt;tagname&gt; [&lt;commit&gt;] [-a] [-m &lt;msg&gt;]# the `git push` command doesn't transfer tags to remote servers# you will have to explicitly push tags to a shared server after you have created them$ git push &lt;remotename&gt; &lt;tagname&gt;# transfer all of your tags to the remote server that are not already there$ git push &lt;remotename&gt; --tags# delete local tag$ git tag -d &lt;tagname&gt;# delete remote tag$ git push &lt;remotename&gt; :refs/tags/&lt;tagname&gt;# or$ git push &lt;remotename&gt; --delete &lt;tagname&gt;# switch your working directory$ git checkout [&lt;branchname&gt; | &lt;tagname&gt; | &lt;commitsha1&gt;]]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法的分析]]></title>
    <url>%2Fposts%2Fcb7b8910%2F</url>
    <content type="text"><![CDATA[渐近记号 如果存在正常数 $c$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq f(n) \leq cg(n)$， 则记为 $f(n) = O(g(n))$。如果存在正常数 $c$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq cg(n) \leq f(n)$， 则记为 $f(n) = \Omega(g(n))$。如果存在正常数 $c_1$、$c_2$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq c_1g(n) \leq f(n) \leq c_2g(n)$，则记为 $f(n) = \Theta(g(n))$。$f(n) = O(g(n)) 且 f(n) = \Omega(g(n))$ $\iff$ $f(n) = \Theta(g(n))$。如果存在正常数 $c$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq f(n) &lt; cg(n)$， 则记为 $f(n) = o(g(n))$。如果存在正常数 $c$ 和 $n_0$，使得当 $n \geq n_0$ 时，$0 \leq cg(n) &lt; f(n)$， 则记为 $f(n) = \omega(g(n))$。 常用函数取整 对任意实数 $x$，$x-1 &lt; \lfloor x \rfloor \leq x \leq \lceil x \rceil &lt; x+1$对任意整数 $n$，$\lceil n/2 \rceil + \lfloor n/2 \rfloor = n$对任意实数 $x \geq 0$ 和整数 $a,b &gt; 0$有$\lceil \frac{\lceil x/a \rceil}{b} \rceil = \lceil \frac{x}{ab} \rceil$$\lfloor \frac{\lfloor x/a \rfloor}{b} \rfloor = \lfloor \frac{x}{ab} \rfloor$$\lceil \frac{a}{b} \rceil \leq \frac{a+(b-1)}{b}$$\lfloor \frac{a}{b} \rfloor \geq \frac{a-(b-1)}{b}$ 模运算 $a \pmod n = a - n\lfloor a/n \rfloor$$0 \leq a \pmod n &lt; n$ 对数 在计算机科学中，认为$lgn = logn = log_2n$ $a = b^{log_ba}$$log_c(ab) = log_ca + log_cb$$log_ba^n = n log_ba$$log_ba = \frac{log_ca}{log_cb}$$log_b(1/a) = -log_ba$$log_ba = \frac{1}{log_ab}$$a^{log_bc} = c^{log_ba}$ 阶乘 详情查看斯特林近似公式$n! = o(n^n)$$n! = \omega(2^n)$ 主定理 主定理的证明请看《算法导论》第三版的 4.6 节。 令 $a \geq 1$ 和 $b &gt; 1$是常数，$f(n)$ 是一个函数，$T(n)$ 是定义在非负整数上的递归式：$T(n) = aT(n/b) + f(n)$其中我们将 $n/b$ 解释为 $\lfloor n/b \rfloor$ 或 $\lceil n/b \rceil$。那么 $T(n)$ 有如下渐近界：若对某个常数 $\epsilon &gt; 0$ 有 $f(n) = O(n^{log_ba-\epsilon})$，则 $T(n)=\Theta(n^{log_ba})$若 $f(n) = \Theta(n^{log_ba})$，则 $T(n) = \Theta(n^{log_ba}lgn)$若对某个常数 $\epsilon &gt; 0$ 有 $f(n) = \Omega(n^{log_ba+\epsilon})$，且对某个常数 $c &lt; 1$ 和所有足够大的 $n$ 有 $af(n/b) \leq cf(n)$，则 $T(n) = \Theta(f(n))$ 对于三种情况的每一种，我们将函数 $f(n)$ 与函数 $n^{log_ba}$ 进行比较。直觉上，两个函数较大者决定了递归式的解。若函数 $n^{log_ba}$ 更大，如情况 1，则解为 $T(n)=\Theta(n^{log_ba})$。若两个函数大小相当，如情况 2，则乘上一个对数因子，解为 $T(n) = \Theta(n^{log_ba}lgn) = \Theta(f(n)lgn) $若函数 $f(n)$ 更大，如情况3，则解为 $T(n) = \Theta(f(n))$。在此直觉之外，我们需要了解一些技术细节。在第一种情况中，不是 $f(n)$ 小于 $n^{log_ba}$ 就够了，而是要多项式意义上的小于。也就是说，$f(n)$ 必须渐近小于 $n^{log_ba}$，要相差一个因子 $n^{\epsilon}$。在第三种情况中，不是 $f(n)$ 大于 $n^{log_ba}$ 就够了，而是要多项式意义上的大于，而且还要满足条件 $af(n/b) \leq cf(n)$。注意，这三种情况并未覆盖 $f(n)$ 的所有可能性。情况 1 和情况 2之间有一定的间隙，情况 2 和情况 3 之间也有一定间隙。这样的情况下就不能使用主定理来求解递归式了。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数的表示及运算]]></title>
    <url>%2Fposts%2F1a664991%2F</url>
    <content type="text"><![CDATA[整数表示无符号数的编码假设有一个整数数据类型有 $w$ 位。我们可以将位向量写成 $\vec{x}$，表示整个向量，或者写成 $[x{w-1},x{w-2},\cdot\cdot\cdot,x_{0}]$，表示向量中的每一位。把 $\vec{x}$ 看做一个二进制表示的数，就获得了 $\vec{x}$ 的无符号表示。在这个编码中，每个位 $x_i$ 都取值为 0 或 1，后一种取值意味着数值 $2^i$ 应为数字道的一部分。我们用一个函数 $B2U_w$ 来表示。 对向量 $\vec{x}=[x{w-1},x{w-2},\cdot\cdot\cdot,x{0}]$，有 $B2U_w(\vec{x})=\sum{i=0}^{w-1}x_i2^i$ $B2U_4([0001])=0\cdot2^3+0\cdot2^2+0\cdot2^1+1\cdot2^0=0+0+0+1=1$$B2U_4([0101])=0\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0=0+4+0+1=5$$B2U_4([1011])=1\cdot2^3+0\cdot2^2+1\cdot2^1+1\cdot2^0=8+0+2+1=11$$B2U_4([1111])=1\cdot2^3+1\cdot2^2+1\cdot2^1+1\cdot2^0=8+4+2+1=15$ 补码编码对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是补码形式。在这个定义中，将字的最高有效位解释为负权。我们用函数 $B2T_w$ 来表示。 对向量 $\vec{x}=[x{w-1},x{w-2},\cdot\cdot\cdot,x{0}]$，有 $B2T_w(\vec{x})=-x{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$ $B2T_4([0001])=-0\cdot2^3+0\cdot2^2+0\cdot2^1+1\cdot2^0=0+0+0+1=1$$B2T_4([0101])=-0\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0=0+4+0+1=5$$B2T_4([1011])=-1\cdot2^3+0\cdot2^2+1\cdot2^1+1\cdot2^0=-8+0+2+1=-5$$B2T_4([1111])=-1\cdot2^3+1\cdot2^2+1\cdot2^1+1\cdot2^0=-8+4+2+1=-1$ 原码和反码 原码：对向量 $\vec{x}=[x{w-1},x{w-2},\cdot\cdot\cdot,x{0}]$，有 $B2S_w(\vec{x})=(-1)^x{w-1}\cdot\sum_{i=0}^{w-2}x_i2^i$反码：对向量 $\vec{x}=[x{w-1},x{w-2},\cdot\cdot\cdot,x{0}]$，有 $B2O_w(\vec{x})=-x{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i$ 整数运算无符号加法 对满足 $0 \leq x, y \leq 2^w$ 的整数 $x$ 和 $y$ 有：$x +^u_w y=\begin{cases} x + y, &amp; x + y \le 2^w \ \ x + y - 2^w, &amp; 2^w \leq x + y &lt; 2^{w+1}\end{cases}$ 对满足 $0 \leq x, y \leq 2^w$ 的 $x$ 和 $y$，令 $s = x +^u_w y$。则 $s &lt; x$ 等价于 $s &lt; y$ 等价于 溢出。 $x$ $y$ $s$ $x +^u_4 y$ 9[1001] 12[1100] 21[10101] 5[0101] 补码加法 对满足 $-2^{w-1} \leq x, y \leq 2^{w-1} - 1$ 的整数 $x$ 和 $y$ 有：$x +^t_w y=\begin{cases} x + y - 2^w, &amp; 2^{w-1} \le x + y \ \ x + y, &amp; -2^{w-1} \leq x + y &lt; 2^{w-1} \ \ x + y + 2^w, &amp; x + y &lt; -2^{w-1}\end{cases}$ 补码加法和无符号加法有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。 对满足 $-2^{w-1} \leq x, y \leq 2^{w-1} - 1$ 的 $x$ 和 $y$，令 $s = x +^t_w y$。当且仅当 $x &gt; 0, y &gt; 0, s \leq 0$ 时，发生了正溢出。当且仅当 $x &lt; 0, y &lt; 0, s \geq 0$ 时，发生了负溢出。 $x$ $y$ $s$ $x +^t_4 y$ -8[1000] -5[1011] -13[10011] 3[0011] -8[1000] -8[1000] -16[10000] 0[0000] -8[1000] 5[0101] -3[11101] -3[1101] 2[0010] 5[0101] 7[00111] 7[0111] 5[0101] 5[0101] 10[01010] -6[1010] 补码的非 举例来说，对于补码 [1000]，它的非是 [0111]。也就是说，$～x = - x + 1$。 无符号乘法 对满足 $0 \leq x, y \leq 2^w - 1$ 的整数 $x$ 和 $y$ 有：$x *^u_w y = (x \cdot y) mod 2^w$乘法的结果，可能需要 $2w$ 位来表示。 $x$ $y$ 二进制计算过程 $x \cdot y$ $x *^u_3 y$ 3[011] 5[101] [011]+[0]+[01100] 15[001111] 7[111] 4[100] 7[111] [100]+[1000]+[10000] 28[011100] 4[100] 3[011] 3[011] [011]+[0110] 9[001001] 1[001] 补码乘法 对满足 $-2^{w-1} \leq x, y \leq 2^{w-1} - 1$ 的整数 $x$ 和 $y$ 有：$x *^t_w y = U2T_w((x \cdot y) mod 2^w)$ 补码乘法和无符号乘法有完全相同的位级表示。 $x$ $y$ $x \cdot y$ $x *^u_3 y$ $x *^t_3 y$ 3[011] -3[101] -9[110111] 7[111] -1[111] -4[100] -1[111] 4[000100] 4[100] -4[100] 3[011] 3[011] 9[001001] 1[001] 1[001] 浮点数表示 IEEE 浮点标准用 $V = (-1)^s \cdot M \cdot 2^E$ 的形式来表示一个数：符号 s：$s = 0$ 代表正数，$s = 1$ 代表负数，而对于数值 0 的符号位解释作为特殊情况处理。阶码 E：E 的作用是对浮点数加权，这个权重是 2 的 E 次幂。它的值由 $exp = e_{k-1} \cdot\cdot\cdot e_1e_0$ 编码决定的。尾数 M：M 是一个二进制小数，它的范围是 $1 \sim 2 - \epsilon$，或者是 $0 \sim 1 - \epsilon$。它的值由 $frac = f{n-1} \cdot\cdot\cdot f_1f_0$ 和 $exp = e{k-1} \cdot\cdot\cdot e_1e_0$ 共同编码决定的。 根据 exp 的值，被编码的值可以分成 3 种不同的情况（最后一种情况有两个变种）。 规格化的：$E = [e_{k-1} \cdot\cdot\cdot e_1e_0] - 2^{k-1} - 1$$M = 1.f_{n-1} \cdot\cdot\cdot f_1f_0$非规格化的：$E = 1 - 2^{k-1} - 1$$M = 0.f_{n-1} \cdot\cdot\cdot f_1f_0$特殊值：此时这个浮点数为无穷大或 NaN。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[存储器]]></title>
    <url>%2Fposts%2Fa9104ae7%2F</url>
    <content type="text"><![CDATA[存储器分类存储器是计算机系统中的记忆设备，用来存放程序和数据。随着计算机发展，存储器在系统中的地位越来越重要。由于超大规模集成电路的制作技术，使 CPU 的速度变得惊人的高，而存储器的取数和存数的速度与它很难适配，这使计算机系统的运行速度在很大程度上受存储器速度的制约。此外，由于 I/O 设备不断增多，如果它们与存储器交换信息都通过 CPU 来实现，这将大大降低 CPU 的工作效率。为此，出现了 I/O 与存储器的直接存取方式（DMA），这也使存储器的地位更为突出。尤其在多处理机的系统中，各处理机在互相通信中，也都需共享存放在存储器中的数据。因此，存储器的地位就更为显要。可见，从某种意义而言，存储器的性能已成为计算机系统的核心。 按存储介质分类存储介质是指能寄存 0、1 两种代码并能区别两种状态的物质或元器件。存储介质主要有半导体器件、磁性材料和光盘等。 半导体存储器：存储元件由半导体件组成的存储器成为半导体存储器。现代半导体存储器都用超大规模集成电路工艺制作芯片，其优点是体积小、功耗低、存取时间短。其缺点是当电源消失时，所存信息也随机丢失，它是一种易失性存储器。磁表面存储器：磁表面存储器是在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读/写操作，故称为磁表面存储器。由于用具有矩形磁滞回线特性的材料作磁表面物质，它们按其剩磁状态的不同而区分 0 或 1，而且剩磁状态不会轻易丢失，故这类存储器具有非易失性的特点。磁芯存储器：磁芯是由硬磁材料做成的环状元件，在磁芯中穿有驱动线（通电流）和读出线，这样便可进行读/写操作。磁芯属磁性材料，故它也是不易失的永久记忆存储器。光盘存储器：光盘存储器是应用激光在记录介质上进行读/写的存储器，具有非易失性的特点。 按存取方式分类 随机存储器（Random Access Memory, RAM）：RAM 是一种可读/写存储器，其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。由于存储信息原理的不同，RAM 又分为静态 RAM（以触发器原理寄存信息）和动态 RAM（以电容充放电原理寄存信息）。只读存储器（Read Only Memory, ROM）：只读存储器是能对其存储的内容读出，而不能对其重新写入的存储器。这种存储器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写入新的信息去改变原始信息。因此，通常用它存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。串行访问存储器：如果对存储单元进行读/写操作时，需按其物理位置的先后顺序寻找地址，则这种存储器称为串行访问存储器。显然这种存储器由于信息所在位置不同，使得的/写时间均不相同。例如，磁带存储器，不论信息处在哪个位置，读/写时必须从其介质的始端开始按顺序寻找，故这类串行访问的存储器又称为顺序存取存储器。还有一种属于部分串行访问的存储器，如磁盘。在对磁盘读/写时，首先直接指出该存储器中的某个小区域（磁道），然后再顺序寻访，直至找到位置。故其前段是直接访问，后段是串行访问，称为直接存取存储器。 按作用分类 存储器的层次结构存储器有 3 个主要性能指标：速度、容量和每位价格（简称位价）。一般来说，速度越快，位价就越高；容量越大，位价就越低，而且容量越大，速度必越低。人们追求大容量、高速度、低位价的存储器，可惜这是很难达到的。 图中由上至下，位价越来越低，速度越来越慢，容量越来越大，CPU 访问的频度也越来越少。最上层的寄存器通常都制作在 CPU 芯片内。寄存器中的数直接在 CPU 内部参与运算，CPU 内可以有十几个、几十个寄存器，它们的速度最快，位价最高，容量最小。主存用来存放将要参与运行的程序和数据，其速度与 CPU 速度差距较大，为了使它们之间速度更好地匹配，在主存与 CPU 之间插入了一种比主存速度更快、容量更小的高速缓冲存储器 Cache，显然其位价要高于主存，现代计算机将 Cache 也制作在 CPU 内。磁盘、磁带属于辅助存储器，其容量比主存大得多，大都用来存放暂时未用到的程序和数据文件。CPU 不能直接访问辅存，辅存只能与主存交换信息，因此辅存的速度比主存慢得多。 实际上，存储系统层次结构主要体现在缓存-主存和主存-辅存这两个存储层次上。CPU 和缓存、主存都能直接交换信息；缓存能直接和 CPU、主存交换信息；主存可以和 CPU、缓存、辅存交换信息。 缓存-主存：主要解决 CPU 和主存速度不匹配的问题。由于缓存的速度比主存的速度高，只要将 CPU 近期要用的信息调入缓存，CPU 便可以直接从缓存中获取信息，从而提高访存速度。但由于缓存的容量小，因此需不断地将主存的内容调入缓存，使缓存中原来的信息被替换掉。主存和缓存之间的数据调动是由硬件自动完成的，对程序员是透明的。从 CPU 角度来看，缓存-主存这一层次的速度接近于缓存，高于主存；其容量和位价却接近于主存，这就从速度和成本的矛盾中获得了理想的解决办法。主存-辅存：主要解决存储系统的容量问题。辅存的速度比主存的速度低，而且不能和 CPU 直接交换信息，但它的容量比主存大得多，可以存放大量暂时未用到的信息。当 CPU 需要用到这些信息时，再将辅存的内容调入主存，供 CPU 直接访问。主存和辅存之间的数据调动是由硬件和操作系统共同完成的。从整体分析，主存-辅存这一层次的速度接近于主存，容量接近于辅存，平均位价也接近于低速、廉价的辅存位价，这又解决了速度、容量、成本这三者的矛盾。 在主存-辅存这一层次的不断发展中，逐渐形成了虚拟存储系统。在这个系统中，程序员编程的地址范围与虚拟存储器的地址空间相对应。例如，机器指令地址码为 24 位，则虚拟存储器存储单元的个数可达 $2^{24}$。可是这个数与主存的实际存储单元的个数相比要大得多，称这类指令地址码为虚地址或逻辑地址，而把主存的实际地址称为实地址或物理地址。物理地址是程序在执行过程中能够真正访问的地址，也是实实在在的主存地址。对具有虚拟存储器的计算机系统而言，程序员编程时，可用的地址空间远远大于主存空间，使程序员以为自己占有一个容量极大的主存，其实这个主存并不存在，这就是将其称为虚拟存储器的原因。对虚拟存储器而言，其逻辑地址变换为物理地址的工作是由计算机系统的硬件和操作系统自动完成的，对程序员是透明的。当虚地址的内容在主存时，机器便可立即使用；若虚地址的内容不在主存，则必须先将此虚地址的内容传递到主存的合适单元后再为机器所用。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[系统总线]]></title>
    <url>%2Fposts%2F693dcbde%2F</url>
    <content type="text"><![CDATA[总线的基本概念计算机系统的五大部件之间的互连方式有两种，一种是各部件之间使用单独的连线，称为分散连接；另一种是将各部件连到一组公共信息传输线上，称为总线连接。 早期的计算机大多用分散连接方式。在以运算器为中心的结构中，内部连线十分复杂，尤其是当 I/O 与存储器交换信息时，都需要经过运算器，致使运算器停止运算，严重影响了 CPU 的工作效率。后来，虽然改进为以存储器为中心的结构，I/O 与存储器交换信息可以不经过运算器，又采用了中断、DMA 等技术，使 CPU 工作效率得到很大的提高，但是仍无法解决 I/O 设备与主机之间连接的灵活性。随着计算机应用领域的不断扩大， I/O 设备的种类和数量也越来越多，人们希望随时增添或减撤设备，用分散连接方式简直是一筹莫展，由此出现了总线连接方式。 总线是连接多个部件的信息传输线，是各部件共享的传输介质。当多个部件与总线相连时，如果出现两个或两个以上部件同时向总线发送信息，势必导致信号冲突，传输无效。因此，在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息。 总线的分类片内总线 片内总线是指芯片内部的总线，如在 CPU 芯片内部，寄存器与寄存器之间、寄存器与算术逻辑单元 ALU 之间都是由片内总线连接。 系统总线系统总线是指 CPU、主存、I/O 设备各大部件之间的信息传输线。由于这些部件通常都安放在主板和各个插件板上，故又称板级总线或板间总线。 数据总线：用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关，一般位 8 位、16 位或 32 位。数据总线的位数称为数据总线宽度，它是衡量系统性能的一个重要参数。如果数据总线的宽度为 8 位，指令字长为 16 位，那么 CPU 在取指阶段必须两次访问主存。地址总线：用来指出数据总线上的源数据或目的数据在主存单元的地址或 I/O 设备的地址。如地址总线为 20 根，则对应的存储单元个数为 $2^{20}$。控制总线：由于数据总线、地址总线都是被挂在总线上的所有部件共享的，如何使各部件能在不同时刻占有总线使用权，需依靠控制总线来完成，因此控制总线是用来发出各种控制信号的传输线。通常对任一控制线而言，它的传输是单向的。例如，存储器读/写命令或 I/O 设备读/写命令都是由 CPU 发出的。但对于控制总线总体来说，又可认为是双向的。例如，当某设备准备就绪时，便向 CPU 发中断请求；当某部件需获得总线使用权时，也向 CPU 发出总线请求。此外，控制总线还起到监视各部件状态的作用。例如，查询该设备是出于“忙”还是“闲”，是否出错等。因此对 CPU 而言，控制信号既有输出，又有输入。 通信总线这类总线用于计算机系统之间或计算机系统与其他系统之间的通信。由于这类联系涉及许多方面，如外部链接、距离远近、速度快慢、工作方式等，差别极大，因此通信总线的类别很多。但按传输方式可分为两种： 串行通信：数据在单条 1 位宽的传输线上，一位一位地按顺序分时传送。并行通信：数据在多条并行 1 位宽的传输线上，同时由源传送到目的地。 总线结构单总线结构 单总线结构是将 CPU、主存、I/O 设备都挂在一组总线上，允许 I/O 设备之间、I/O 设备与 CPU 之间或 I/O 设备与主存之间直接交换信息。这种结构简单，也便于扩充，但所有的传送都通过这组共享总线，因此极易形成计算机系统的瓶颈。它也不允许两个以上的部件在同一时刻向总线传输信息，这就必然会影响系统工作效率的提高。 多总线结构 双总线结构的特点是将速度较低的 I/O 设备从单总线上分离出来，形成主存总线与 I/O 总线分开的结构。图中的通道是一个具有特殊功能的处理器，CPU 将一部分功能下放给通道，使其对 I/O 设备具有统一管理的功能，以完成外部设备与主存储器之间的数据传送，其系统的吞吐能力可以相当大。这种结构大多用于大、中型计算机系统。 如果将速率不同的 I/O 设备进行分类，然后将它们连接在不同的通道上，那么计算机系统的工作效率将会更高，由此发展成多总线结构。这里就不进行详细介绍了。 总线控制由于总线上连接着多个部件，什么时候由哪个部件发送信息，如何给信息传送定时，如何防止信息丢失，如何避免多个部件同时发送，如何规定接收信息的部件等一系列问题都需要由总线控制器统一管理。它主要包括判优控制（或称仲裁逻辑）和通信控制。 总线判优控制总线上所连接的各类设备，按其对总线有无控制功能可分为主设备（模块）和从设备（模块）两种。主设备对总线有控制权，从设备只能响应从主设备发来的总线命令，对总线没有控制权。总线上信息的传送是由主设备启动的，如某个主设备欲与另一个设备（从设备）进行通信时，首先由主设备发出总线请求信号，若多个主设备同时要使用总线时，就由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线。只有获得总线使用权的主设备才能开始传送数据。 总线判优控制可分集中式和分布式两种，前者将控制逻辑集中在一处（如 CPU 中），后者将控制逻辑分散在与总线连接的各个部件或设备上。 常见的集中式控制优先权仲裁方式有以下三种：链式查询：控制总线有 3 根用于总线控制（BS 总线忙、BR 总线请求、BG 总线同意），其中总线同意信号 BG 是串行从一个 I/O 接口送到下一个 I/O 接口。如果 BG 到达的接口有总线请求， BG 信号就不再往下传，意味着该接口获得了总线使用权，并建立总线忙 BS 信号，表示它占用了总线。可见在链式查询中，离总线控制部件最近的设备具有最高的优先级。这种方式的特点是：只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，但对电路故障很敏感，且优先级别低的设备可能很难获得请求。计数器定时查询：与链式查询相比，多了 $log_2n$ 根设备地址线，少了一根总线同意线 BG。总线控制部件接到由 BR 送来的总线请求信号后，在总线未被使用（BS = 0）的情况下，总线控制部件中的计数器开始技术，并通过设备地址线向各设备发出一组地址信号。当某个请求占用总线的设备地址与计数值一致时，便获得总线使用权，此时终止技术查询。这种方法的特点是：计数可以从 0 开始，此时一旦设备的优先次序被固定，设备的优先级就按 0, 1, …, n 的顺序降序排列，而且固定不变；计数也可以从上一次计数的终止点开始，即是一种循环方法，此时设备使用总线的优先级相等；计数器的初始值还可由程序设置，故优先级次序可以改变。这种方式对电路故障不如链式查询方式敏感，但增加了控制线（设备地址）数，控制也较复杂。独立请求方式：每一台设备均有一对总线请求线 $BR_i$ 和 总线同意线 $BG_i$。当设备要求使用总线时，便发出该设备的请求信号。总线控制部件中有一排队电路，可根据优先次序确定响应哪一台设备的请求。这种方式的特点是：响应速度快，优先次序控制灵活（通过程序改变），但控制线数量多，总线控制更复杂。 总线通信控制众多部件共享总线，在争夺总线使用权时，应按各部件的优先等级来解决。在通信时间上，则应按分时方式来处理，即以获得总线使用权的先后顺序分时占用总线，即呢一个部件获得使用权，此刻就由它传送，下一部件获得使用权，接着下一时刻传送。这样一个接一个轮流交替传送。总线通信控制主要解决通信双方如何获知传输开始和传输结束、以及通信双方如何协调如何配合。 通常将完成一次总线操作的时间称为总线周期，可分为以下 4 个阶段：申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定下一传输周期的总线使用权授予某一申请者。寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。传数阶段：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流入目的模块。结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权。 同步通信通信双方由统一时标控制数据传送称为同步通信。时标通常由 CPU 的总线控制部件发出，送到总线上的所有部件；也可以由每个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步。 下面两个图片分别展示了读、写命令的时钟周期。 这种通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主、从模块时间配合属于强制性“同步”，必须在限定时间内完成规定的要求。并且对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而言，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏灵活性。 异步通信异步通信克服了同步通信的缺点，允许各模块速度的不一致性，给设计者充分的灵活性和选择余地。它没有公共的时钟标准，不要求所有部件严格的统一操作时间，而是采用应答方式（又称为握手方式），即当主模块发出请求信号时，一直等待从模块反馈回来响应信号后，才开始通信。当然，这就要求主、从模块之间增加两条应答线。 不互锁方式：主模块发出请求信号后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块已收到请求信号后，便撤销其请求信号；从模块接到请求信号后，在条件允许时发出回答信号，并且经过一段时间确认主模块已收到回答信号后，自动撤销回答信号。可见通信双方并不互锁关系。半互锁方式：主模块发出请求信号后，必须待接到从模块的回答信号后再撤销其请求信号，有互锁关系；而从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一段时间后自动撤销其回答信号，无互锁关系。全互锁方式：主模块发出请求信号，必须待从模块回答后再撤销其请求信号；从模块发出回答信号，必须待获知主模块请求信号已撤销后，再撤销其回答信号。 半同步通信半同步通信既保留了同步通信的基本特点，又像异步通信那样，允许不同速度的模块和谐地工作。为此增设了一条“等待”响应信号线，采用插入时钟（等待）周期的措施来协调通信双方的配合问题。 半同步通信适用于系统工作速度不高但又包含了由许多工作速度差异较大的各类设备组成的简单系统。半同步通信控制方式比异步通信简单，在全系统内各模块又在统一的系统时钟控制下同步工作，可靠性较高，同步结构较方便。其缺点是对系统时钟频率不能要求太高，故从整体上来看，系统工作的速度还不是很高。 分离式通信以上三种通信方式都是从主模块发出地址和读写命令开始，直到数据传输结束。在整个传输周期中，系统总线的使用权完全由占有使用权的主模块和由它选中的从模块占据。进一步分析读命令传输周期，发现除了申请总线这一阶段外，其余时间主要花费在如下 3 个方面。 主模块通过传输总线向从模块发送地址和命令。从模块按照命令进行读数据的必要准备。从模块经数据总线向主模块提供数据。 由第 2 条可见，对系统总线而言，从模块内部读数据过程并无实质性的信息传输，总线纯属空闲等待。为了克服和利用这种消极等待，尤其在大型计算机系统中，总线的负载已处于饱和状态，充分挖掘系统总线每瞬间的潜力，对提高系统性能起到极大作用。为此人们又提出了“分离式”的通信方式，其基本思想是将一个传输周期（或总线周期）分解为两个子周期。在第一个自周期中，主模块 A 在获得总线使用权后将命令、地址以及其他有关信息，包括该模块编号（当有多个主模块时，此编号尤为重要）发到系统总线上，经总线传输后，由有关的从模块 B 接受下来。主模块 A 向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使用权，以便其他模块使用。在第二个子周期中，当 B 模块收到 A 模块发来的有关命令信号后，经选择、译码、读取等一系列内部操作，将 A 模块所需的数据准备好，便由 B 模块申请总线使用权，一旦获准，B 模块便将 A 模块的编号、B 模块的地址、A 模块所需的数据等一系列信息送到总线上，供 A 模块接收。很明显，上述两个传输子周期都只有单方面的信息流，每个模块都变成了主模块。 这种通信方式的特点如下： 各模块欲占用总线使用权都必须提出申请。在得到总线使用权后，主模块在限定的时间内向对方传送信息，采用同步方式传送，不再等待对方的回答信号。各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。总线被占用时都在做有效工作，或通过它发送命令，或者通过它传送数据，不存在空闲等待时间，充分地利用了总线的有效占用，从而实现了总线在多个主、从模块间进行信息交叉重叠并行式传送，这对大型计算机系统是极为重要的。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web Worker]]></title>
    <url>%2Fposts%2Fda19b401%2F</url>
    <content type="text"><![CDATA[特点Web Worker 是让 Web 内容在后台线程中运行脚本的一种简单方法。Worker 线程在执行任务期间不会受到用户交互的干扰，除此之外，还可以使用 XMLHttpRequest 执行 I/O 操作。 Worker 线程运行环境不同于主线程，所以在 Worker 线程中无法使用 document、window 和 parent 这些对象，但是可以使用 navigator 对象和 location 对象。Worker 线程中，this 对象和 self 对象是相同的。Worker 线程不允许读取本地文件，即不能打开本机的文件系统 file://。这样说来，在使用 new Worker() 创建 Worker 线程时也不允许使用本机文件，在学习过程中为了方便，可以使用 window.URL.createObjectURL(new Blob()) 来绕过这一限制。Web Worker 分为专用 Worker 和共享 Worker。在主线程和 Worker 线程之间，通过 postMessage() 来发送数据，通过 message 事件来接收数据。这个过程中数据是被深拷贝的，所以不会彼此干扰。在主线程中，使用 terminate() 中止 Worker 线程。在 Worker 线程中，可以使用 importScript() 加载脚本。Worker 线程运行出错时，会触发 error 事件。该事件不会冒泡并且可以被取消。 demo1234567891011121314151617181920212223242526&lt;script type="text/javascript"&gt; if (Worker) &#123; function worker_function () &#123; self.addEventListener('message', function (event) &#123; console.log(event.data); postMessage('from work thread'); &#125;) &#125; const myWorker = new Worker( URL.createObjectURL( new Blob( ['('+worker_function.toString()+')()'], &#123;type: 'text/javascript'&#125; ) ) ); myWorker.postMessage('from main thread'); myWorker.addEventListener('message', function () &#123; console.log(event.data); myWorker.terminate(); &#125;) &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2Fposts%2F2633a26%2F</url>
    <content type="text"><![CDATA[非 ~~x === -(x+1) 12let num = 25;console.log(~num); // -26 与 &amp;x&amp;1 === x%2 12console.log(5&amp;1); // 1console.log(5%2); // 1 或 |假设一个文件有读、写、删除三种权限。可以使用一个数值来记录权限，这个数值的二进制有 3 位。第 1 位代表是否有读权限，第 2 位代表是否有写权限，第 3 位代表是否有删除权限。 数值1，对应二进制001，代表拥有读权限。数值2，对应二进制010，代表拥有写权限。数值3，对应二进制011，代表拥有读、写权限。数值4，对应二进制100，代表拥有删除权限。数值5，对应二进制101，代表拥有读、删除权限。数值6，对应二进制110，代表拥有写、删除权限。数值7，对应二进制111，代表拥有读、写、删除权限。 异或 ^异或的逆运算也是异或，所以对于任意数 x 和 y，有x === x^y^y和y = y^x^x。下面的例子是交换两个变量上保存的数值。 12345678let x = 12, y = 66;x ^= y;y ^= x;x ^= y;console.log(x) // 66console.log(y) // 12]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[圣杯布局和双飞翼布局的原理]]></title>
    <url>%2Fposts%2Fee7ae9c6%2F</url>
    <content type="text"><![CDATA[圣杯布局 三个部分必须都设置向左浮动。先写 middle，让页面先渲染中间的重要区域。content 设置左右内边距是为了给 left 和 right 留出空间。middle 设置width: 100%，而 left 和 right 的width属性值分别为 content 的左右内边距。为 left 和 right 分别设置margin-left，由于 middle 也是浮动元素，所以这样会使 left 和 right 向上层浮动。通过position: relative，分别将 left 和 right 向左右两侧拉扯。 由于 left 设置了margin-left: -100%，当 content 内容区的宽度小于 left 的宽度时，此时 left 左移的距离小于 left 自身的宽度，导致 left 并不会向上移动到与 middle 同层。简言之，布局乱了。 1234567891011121314151617181920212223242526272829303132333435&lt;div class="content"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.content &#123; padding: 0 200px;&#125;.middle &#123; width: 100%; height: 80px; float: left; background: green;&#125;.left &#123; width: 200px; height: 80px; float: left; margin-left: -100%; position: relative; left: -200px; background: red;&#125;.right &#123; width: 200px; height: 80px; float: left; margin-left: -200px; position: relative; right: -200px; background: blue;&#125;&lt;/style&gt; 双飞翼布局 圣杯布局的升级版，修改 DOM 结构，然后使用margin代替padding。 12345678910111213141516171819202122232425262728293031323334&lt;div class="content"&gt; &lt;div class="middle"&gt; &lt;div class="inner-middle"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.middle &#123; width: 100%; height: 80px; float: left;&#125;.inner-middle &#123; margin: 0 200px; height: 80px; background: green;&#125;.left &#123; width: 200px; height: 80px; float: left; margin-left: -100%; background: red;&#125;.right &#123; width: 200px; height: 80px; float: left; margin-left: -200px; background: blue;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS解析原理]]></title>
    <url>%2Fposts%2Fdf6afb91%2F</url>
    <content type="text"><![CDATA[本文参考自探究 CSS 解析原理 CSS选择器的解析顺序在利用 DOM 和 CSSOM 合成 render tree的时候，需要将样式表中的每一条 CSS 样式规则与对应的 DOM 元素关联起来。然而实际中，样式规则可能数量很大，但是绝大多数不会匹配到任何 DOM 元素上，所以有一个快速的方法来判断 CSS 选择器是否具有匹配的 DOM 元素是极其重要的。 以下面的例子讲解CSS 选择器的解析规则： 12345678910111213&lt;div&gt; &lt;div class="jartto"&gt; &lt;p&gt;&lt;span&gt; 111 &lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt; 222 &lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt; 333 &lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class='yellow'&gt; 444 &lt;/span&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;div &gt; div.jartto p span.yellow&#123; color: yellow;&#125;&lt;/style&gt; 如果采用从左至右的规则，过程如下所示：首先找到所有&lt;div&gt;。在每个&lt;div&gt;内寻找所有class=jartto的子&lt;div&gt;。在步骤二中找到的每个子&lt;div&gt;内接着按 CSS 选择器进行寻找，直到最后。这样的搜索过程对于一个只是匹配很少节点的选择器来说，效率是极低的，因为我们花费了大量的时间在回溯匹配不符合规则的节点。 如果采用从右至左的规则，过程如下所示：首先找到所有class=yellow的&lt;span&gt;。然后判断这些&lt;span&gt;的父元素是否为&lt;p&gt;接着判断这些&lt;p&gt;的父元素是否为class=jartto的&lt;div&gt;。最后判断这些&lt;div&gt;的父元素是否也是&lt;div&gt;。因为每一个元素都只拥有一个父元素，所以从右至左的解析 CSS 选择器可以有效减少无效匹配的次数，从而使匹配更快、性能更优。 computedStyle的计算render tree 生成时，元素的 computedStyle 是经过层叠计算后得到的。在某些特定的情况下，浏览器会让不同元素之间共享它们的 computedStyle。也就是说，如果多个元素的 computedStyle 不通过计算就可以确认它们相等，那么这个 computedStyle 只会被计算一次，从而提高了性能。 只要元素之间满足以下条件，它们之间就可以共享 computedStyle。 元素不能有id属性。元素的标签名必须相同，即必须是同类型的元素。元素的class属性必须相同。元素之间的 mappedAttribute（一些可以影响 CSS ComputedStyle 的 HTML 属性） 必须相等。元素不能有style属性，哪怕是这些元素的style属性值相同也不可以。不能使用 sibling selector。例如，first-child、:last-selector、+ selector。 选择器书写建议 ID 选择器是非常高效的，且 ID 是唯一的，所以在使用的时候应该单独使用，不需要再指定标签名等。避免深层次的选择器。慎用子代选择器。属性选择的的解析速度非常慢，慎用。]]></content>
      <categories>
        <category>待整理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2Fposts%2F9055d217%2F</url>
    <content type="text"><![CDATA[基础概念 迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。适用性：访问一个聚合对象的内容而无需暴露它的内部表示。支持对聚合对象的多种遍历。为遍历不同的聚合结构提供一个统一的接口（即，支持多态迭代）。参与者：Iterator迭代器定义访问和遍历元素的接口。ConcreteIterator具体迭代器实现迭代器的接口。对该聚合遍历时跟踪当前位置。Aggregate聚合定义创建相应迭代器对象的接口。ConcreteAggregate具体聚合实现创建相应迭代器的接口，该操作返回ConcreteAggregate的一个适当的实例。 注意事项 谁控制该迭代：一个基本的问题是决定由哪一方来控制该迭代，是迭代器还是使用该迭代器的客户。当由客户来控制迭代时，该迭代器称为一个外部迭代器，而当由迭代器控制迭代时，该迭代器称为一个内部迭代器。使用外部迭代器的客户必须主动推进遍历的步伐，显示地向迭代器请求下一个元素。相反地，若使用内部迭代器，客户只需向其提交一个待执行的操作，而迭代器对聚合中的每一个元素实施该操作。谁定义遍历算法：迭代器不是唯一可定义遍历算法的地方。聚合本身也可以定义遍历算法，并在遍历过程中用迭代器来存储当前迭代的状态。我们称这种迭代器为一个游标，因为它仅用来指示当前位置。迭代器健壮程度如何：在遍历一个聚合的同时更改这个聚合可能是危险的。如果在遍历聚合的时候增加或删除该聚合元素，可能会导致两次访问同一个元素或者遗漏掉某个元素。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2Fposts%2Ff5c535ea%2F</url>
    <content type="text"><![CDATA[基础概念 适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适用性：你想使用一个已经存在的类，而它的接口不符合你的需求。你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些可能不一定兼容的类）协同工作。参与者：Target定义Client使用的与特定领域相关的接口。Client与符合Target接口的对象协同。Adaptee定义一个已经存在的接口，这个接口需要适配。Adapter对Adaptee的接口与Target的接口进行适配。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器的渲染原理]]></title>
    <url>%2Fposts%2Fb5fc6f17%2F</url>
    <content type="text"><![CDATA[浏览器的进程和线程 浏览器的主要进程：Browser进程：浏览器的主进程，只有一个。作用为：负责浏览器界面显示、与用户的交互。负责各个标签页的管理、创建和关闭。将Renderer进程得到的内存中的Bitmap，绘制到用户界面上网络资源的管理、下载等。插件进程：每种类型的插件对应一个插件进程，仅当使用该插件时才创建对应的插件进程。GPU进程：最多一个，用于3D绘制等。Renderer进程：又叫作浏览器内核，内部有多个线程。默认每个标签页有一个Renderer进程，互不影响。浏览器的优化机制在某些情况下会将多个标签页的Renderer进程合并为一个。Renderer进程的主要线程：GUI渲染线程：负责解析HTML和CSS。JS引擎线程：负责执行JavaScript代码，JS引擎线程与GUI渲染线程互斥，且JS引擎线程的优先级高。事件触发线程：任务队列和交互事件都是它说了算。定时触发器线程：管理setTimeout和setInterval。异步http请求线程：异步http请求收到响应后，就是通过它将对应回调函数放在任务队列中，然后再交给js引擎线程去执行。 输入一个url，浏览器都做了什么 Browser进程收到url，加载资源，然后将资源传递给该标签页对应的Renderer进程。Renderer进程开始分工：GUI渲染线程解析HTML和CSS，分别生成DOM和CSSOM，然后合并为Rendering Tree。GUI渲染线程根据Rendering Tree计算布局，然后渲染页面。JS引擎线程执行JavaScript代码。因为这一过程可能会改变DOM和CSSOM，所以JS引擎线程和GUI渲染线程被设计为互斥的，且JS引擎线程优先级高。Renderer进程渲染页面的过程中，可能需要GPU进程来完成3D绘制。 注意事项 为了更好的用户体验，GUI渲染线程将会尽可能早的将内容呈现到屏幕上，并不会等到所有的HTML和CSS都解析完成之后再去构建Rendering Tree和计算布局。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。reflow一定repaint，repaint不一定reflow。 参考文献 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 浏览器渲染原理及流程]]></content>
      <categories>
        <category>待整理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不同进制之间的转换]]></title>
    <url>%2Fposts%2F8f774f42%2F</url>
    <content type="text"><![CDATA[二进制和十进制将二进制转换为十进制的例子：101011 =&gt; 43。 二进制 101011 转换过程 $1·2^5 + 0·2^4 + 1·2^3 + 0·2^2 + 1·2^1 + 1·2^0$ 十进制 43 将十进制转换为二进制的例子：43 =&gt; 101011。 43 $21·2 + 1$ 1 21 $10·2 + 1$ 1 10 $5·2 + 0$ 0 5 $2·2 + 1$ 1 2 $1·2 + 0$ 0 1 $0·2 + 1$ 1 二进制和十六进制 二进制 0001 0111 0011 1010 0100 1100 十进制 1 7 3 A 4 C 十进制和十六进制将十六进制转换为十进制的例子：4CB2C =&gt; 314156。 十六进制 4CB2C 转换过程 $4·16^4 + 12·16^3 + 11·16^2 + 2·16^1 + 12·16^0$ 十进制 314156 将十进制转换为十六进制的例子：314156 =&gt; 4CB2C。 314156 $19634·16 + 12$ C 19634 $1227·16 + 2$ 2 1227 $76·16 + 11$ B 76 $4·16 + 12$ C 4 $0·16 + 4$ 4]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[min-*、max-*、*的优先级]]></title>
    <url>%2Fposts%2Fdf94ca98%2F</url>
    <content type="text"><![CDATA[本文参考链接理解css中min-width和max-width，width与它们之间的区别联系 width与height的情况是一致的，下面以width为例进行说明。 min-width比width大时 min-width的优先级高于width，即使有!important也是如此。 123456789&lt;div&gt;&lt;/div&gt;&lt;style&gt; div &#123; height: 200px; min-width: 400px; width: 200px !important; background: black; &#125;&lt;/style&gt; min-width比max-width大时 min-width的优先级高于max-width，即使有!important也是如此。 123456789&lt;div&gt;&lt;/div&gt;&lt;style&gt; div &#123; height: 200px; min-width: 400px; max-width: 200px !important; background: black; &#125;&lt;/style&gt; max-width比width小时 max-width的优先级高于width，即使有!important也是如此。 123456789&lt;div&gt;&lt;/div&gt;&lt;style&gt; div &#123; height: 200px; max-width: 200px; width: 400px !important; background: black; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式]]></title>
    <url>%2Fposts%2Fc3176455%2F</url>
    <content type="text"><![CDATA[基础概念 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。参与者：Memento（备忘录）备忘录存储原发器对象在某一时刻的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。防止原发器以外的其它对象访问备忘录内部存储的状态。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。Originator（原发器）原发器创建一个备忘录，用以记录当前时刻它的内部状态。使用备忘录恢复内部状态到某一时刻。Caretaker（管理者）负责保存备忘录。不能对备忘录的内容进行操作或检查。 demo等我遇到实际需求，我再更新demo吧 123456789101112131415161718192021222324252627282930class Originator &#123; constructor () &#123; this.state = 0 &#125; setMemento (memento) &#123; this.state = memento.state &#125; createMemento () &#123; return new Memento(this.state) &#125;&#125;class Memento &#123; constructor (state) &#123; this.state = state &#125;&#125;class Caretaker &#123; constructor (originator) &#123; this.mementoList = [] this.originator = originator &#125; addMemento () &#123; this.mementoList.push(this.originator.createMemento()) &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2Fposts%2F78134e07%2F</url>
    <content type="text"><![CDATA[基础概念 命令模式：将一个命令封装为一个对象，从而使你可用不同的命令对客户进行参数化。适用性：抽象出待执行的命令，以参数化某对象。在不同的时刻指定、排列和执行命令。支持取消操作。支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。参与者：Command声明Execute()的接口。ConcreteCommand将一个接收者对象绑定于一个动作。实现Execute()接口，在该接口中会调用接收者相应的动作。Client创建一个具体命令对象，并设定它的接收者。Invoker保存着命令队列，且由它去触发命令的执行。Receiver命令的接收者，命令是由接收者完成执行的。任何类都可能作为一个接收者。 注意事项 一个命令对象应达到何种智能程度：命令对象的能力可大可小。存在两种极端情况命令对象仅确定一个接收者和一个执行该命令的动作，其他什么也不做。命令对象自己实现所有功能，根本不需要额外的接收者对象。支持取消和重做：如果Command提供方法逆转命令的执行，就可以支持取消和重做功能。为了达到这个目的，ConcreteCommand类可能需要存储额外的状态信息：接收者对象。接收者上执行命令的参数。如果执行命令的动作会改变接收者对象中的某些值，那么这些值必须先存储起来。接收者还必须提供一些动作，以使该命令可将接收者恢复到它先前的状态。避免取消操作过程中的错误累积：在实现一个可靠的、能确保原先语义的取消/重做机制时，可能会遇到滞后影响问题。由于命令重复的执行、取消执行，和重执行的过程可能会累积错误，以至一个应用的状态最终偏离初始值。这就有必要在Command中存入更多的信息以保证这些对象可被精确地复原成它们的初始状态。这里可使用备忘录模式来让该Command访问这些信息而不暴露其他对象的内部信息。 demo呃，懒得想具体的场景了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Command &#123; constructor (receiver, whatToDo) &#123; this.receiver = receiver this.whatToDo = whatToDo &#125; execute () &#123; this.receiver.action.apply(this, this.whatToDo) &#125;&#125;class Client &#123; constructor (name) &#123; this.name = name &#125; setCommand (receiver, whatToDo, invoker) &#123; let command = new Command(receiver, whatToDo) invoker.addCommand(command) &#125;&#125;class Invoker &#123; constructor (name) &#123; this.name = name this.queue = [] &#125; addCommand (command) &#123; this.queue.push(command) &#125; callCommand () &#123; while (this.queue.length !== 0) &#123; this.queue.shift().execute &#125; &#125;&#125;class Receiver &#123; constructor () &#123; this.name = name &#125; action (whatToDo) &#123; // do whatToDo &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨域问题常见解决方案]]></title>
    <url>%2Fposts%2F713a5759%2F</url>
    <content type="text"><![CDATA[我个人将跨域问题分类为两种：网络请求跨域和非网络请求跨域。 网络请求跨域 网络请求跨域的解决方案有：图像imgJSONPCORSNginx反向代理、Nodejs中间件SSE、Web Socket（它们是服务器推送技术，无跨域问题）详细信息在这里 非网络请求跨域document.domain 如果要进行通信的窗口之间主域相同，子域不同，则可以直接将它们的 document.domain 修改为主域，这样就不存在跨域问题了。 12&lt;iframe name="a" src="http://a.domain.com"&gt;&lt;/iframe&gt;&lt;iframe name="b" src="http://b.domain.com"&gt;&lt;/iframe&gt; 12345&lt;!-- domain 初始值为 a.domain.com --&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'a';&lt;/script&gt; 12345&lt;!-- domain 初始值为 b.domain.com --&gt;&lt;script&gt; document.domain = 'domain.com'; alert('get js data from a ---&gt; ' + window.parent.frames.a.user);&lt;/script&gt; location.hash 父窗口 A 修改子窗口 B 的 location.hash 值，会触发对应子窗口 B window 对象的 onhashchange 事件处理程序。这个过程是单向的，但是你可以通过在子窗口 B 中添加一个 iframe 标签，这个 iframe 的 src 域名与父窗口域名相同的，然后在这个 iframe 页面内调用父窗口 A 的函数，此时是不存在跨域的。 window.name window 对象的 name 属性有一个独特之处，一个窗口只要一直存在并且没有被主动的更改 name 属性，那么它的 name 属性会一直保持不变。即窗口的 URL（或 iframe 的 src）随意变化，name 属性也不会变。name 属性内存最大可以支持 2MB，所以可以通过它来传递数据。 window.postMessage通过 window.postMessage 方法和 message 事件完成数据的传递。 参考 前端常见跨域解决方案（全）]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS和CSRF]]></title>
    <url>%2Fposts%2F5c76f87e%2F</url>
    <content type="text"><![CDATA[XSSXSS是跨站脚本攻击（Cross Site Script）的简写。之所以是 X 开头而不是 C 是为了与CSS进行区分。 之所以存在XSS攻击，是因为&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;可以内嵌到大部分HTML标签（&lt;script&gt;、&lt;style&gt;除外）内部，且正常工作（即可以弹出提示框）。 具体的XSS攻击方式就不在这里展示了，不过这里挺详细的 至于防范XSS攻击的方式，主要为对&lt;、&gt;、script进行转义或过滤。 CSRFCSRF是跨站请求伪造（Cross Site Request Forgery）的简写。 之所以存在CSRF攻击，是因为如果浏览器中保存有某一个域名下的Cookie的话，那么每次向该域名下的服务器发送请求都会自动携带上对应的Cookie。而Cookie中通常包含用户的认证信息，所以攻击者可以假冒它是用户来向服务器发起CSRF攻击。防范CSRF攻击的方式有：使用验证码验证身份。使用HTTP请求的Referer首字段检查发送请求的来源地址。Referer首字段的另一个用途是“防止图片盗链”。使用token验证Cookie中不包含的信息。]]></content>
      <categories>
        <category>待整理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2Fposts%2F54788f73%2F</url>
    <content type="text"><![CDATA[基础概念 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。适用性：当一个类不知道它所必须创建的对象的类的时候。当一个类希望由它的子类来指定它所创建的对象的时候。当类创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。参与者：Product定义工厂模式所创建的对象的接口。ConcreteProduct实现Product的接口Creator声明工厂模式，该方法返回一个Product类型的对象。Creator也可以定义一个工厂模式的缺省实现，它返回一个缺省的ConcreteProduct对象。可以调用工厂模式创建一个Product对象。ConcreteCreator重定义工厂模式以返回一个ConcreteProduct实例。 注意事项 主要有三种不同的情况：Creator类是一个抽象类并且不提供它所声明的工厂模式的实现。Creator类是一个具体的类而且为工厂模式提供一个缺省的实现。Creator类是一个抽象的类，但为工厂模式提供一个缺省的实现。参数化工厂模式：一个工厂模式可以创建多中类型的对象。 demo123456789101112131415161718192021222324252627class Product1 &#123; constructor () &#123; this.type = '产品1' &#125;&#125;class Product2 &#123; constructor () &#123; this.type = '产品2' &#125;&#125;class Creator &#123; constructor (typeNum) &#123; if (typeNum === 1) &#123; return new Product1 &#125; else &#123; return new Product2 &#125; &#125;&#125;let p1 = new Creator(1), p2 = new Creator(2)console.log(p1) // Product1 &#123; type: '产品1' &#125;console.log(p2) // Product2 &#123; type: '产品2' &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTPS]]></title>
    <url>%2Fposts%2Fc9a2a716%2F</url>
    <content type="text"><![CDATA[数字加密 密码：对文本进行编码，使偷窥者无法识别的算法。密钥：改变密码行为的数字化参数。对称密钥加密系统：编/解码使用相同的密钥。非对称密钥加密系统：编/解码使用不同的密钥。数字签名：用来验证报文未被伪造或篡改的校验和。数字证书：由一个可信的组织验证和签发的识别信息。 对称密钥加密很多数字加密算法都被称为对称密钥加密技术，这是因为它们在编码时使用的密钥和解码时使用的密钥是相同的。在对称密钥加密技术中，发送端和接收端要共享相同的密钥才能进行通信。发送端用共享的密钥来加密报文，并将得到的密文发送给接收端。接收端收到密文，并对其应用解密函数和相同的共享密钥，恢复出原始的明文。 对称密钥加密技术的缺点：在通信的双方首次传输密钥的过程中，密钥可能会被窃取。发送者和接收者在互相对话之前，一定要有一个共享的保密密钥。如果有$N$个节点，每个节点都要和其他所有$N-1$个节点进行安全对话，总共大概会有$N^2$个保密密钥。 非对称密钥加密非对称密钥加密系统中有一个保密的私有密钥和一个众所周知的公开密钥。 下面用一个例子来说明它们是如何工作的，现有一台Web服务器S，和众多客户端A、B、C等。服务器持有保密的私有密钥，它不会将它泄漏给任何人。众多客户端A、B、C持有与私有密钥对应的公开密钥。客户端向服务器发送信息时，通过公开密钥对信息进行加密，加密后的密文，只有持有私有密钥的服务器才能进行正确解密。服务器向客户端发送信息的时候，通过私有密钥对特定信息进行加密从而生成数字签名，然后将明文报文和数字签名一起发送给客户端。 所有公开密钥非对称加密系统所面临的共同挑战是，要确保即便有人拥有了下面所有的线索，也无法算出保密的私有密钥。 公开密钥一小片拦截下来的密文一条报文及与之相关的密文 RSA算法就是一个满足了所有这些条件的流行的公开密钥加密系统，它的机密技术细节中包括很多繁琐的数学问题，这里就不进行详细介绍了（其实是我不懂）。 混合加密系统和会话密钥任何人只要知道了其公开密钥，就可以向一台公共服务器发送安全报文，所以非对称密钥加密系统是很好用的。两个节点无须为了进行安全的通信而先交换私有密钥，但非对称密钥加密系统的计算可能会很慢。 比较常见的做法是在两节点间通过便捷的公开密钥加密技术建立起安全通信，然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。 数字签名 数字签名是附加在报文上的特殊加密校验和。它有如下用处：签名可以证明是私有密钥拥有者编写了这条报文。签名可以防止报文被篡改。如果有恶意攻击者在报文传输过程中对其进行了修改，校验和就不再匹配了。由于校验和用私有密钥才能产生，所以攻击者无法为篡改了的报文伪造出正确的校验和。 下面用两张图片分别展示数字签名是如何生成的，以及它是如何工作的。 数字证书通过HTTPS建立了一个安全Web事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。服务器证书中包含很多字段，其中包括： Web站点的名称和主机名Web站点的公开密钥签名颁发机构的名称来自签名颁发机构的签名 浏览器收到证书时，会对签名颁发机构进行检查。如果这个机构是个很有权威的公共签名机构，浏览器可能已经知道其公开密钥了（浏览器会预先安装很多签名颁发机构的证书），这样就可以通过验证这个机构的签名来判断这个证书是否真的是这个权威机构颁发的了。如果浏览器对签名颁发机构一无所知，就无法确定是否应该应该信任这个签名颁发机构，它通常会向用户显示一个对话框，看看它是否相信这个签名发布者。 HTTPS概述HTTPS就是在安全的传输层上发送的HTTP。HTTPS没有将未加密的HTTP报文发送给TCP，它在将报文发送给TCP之前，先将其发送给了一个安全层，对其进行加密。现在，HTTP安全层是通过SSL及其现代替代协议TLS来实现的。我们遵循常见的用法，用属于SSL来表示SSL或者TLS。 现在，安全的HTTP是可选的。因此，对Web服务器发起请求时，我们需要有一种方式来告知Web服务器去执行HTTP的安全协议版本。这是在URL的方案中实现的。通常情况下，非安全的HTTP的URL方案前缀为http。在安全HTTPS协议中，URL的方案前缀为https。 请求一个客户端对某Web资源执行某事务时，它会去检查URL的方案。如果URL的方案为http，客户端就会打开一条到服务器端口80（默认情况下）的连接，并向其发送老的HTTP命令。如果URL的方案为https，客户端就会打开一条到服务器端口443（默认情况下）的连接，然后与服务器“握手”，以二进制格式与服务器交换一些SSL安全参数，附上加密的HTTP命令。 建立安全传输由于SSL安全层的存在，在HTTPS中，客户端首先打开一条到Web服务器端口443（安全HTTP的默认端口）的连接。一旦建立了TCP连接，客户端和服务器就会初始化SSL层，对加密参数进行沟通，并交换密钥。握手完成之后，SSL初始化就完成了，客户端就可以将请求报文发送给安全层了。在将这些报文发送给TCP之前，要先对其进行加密。 SSL握手有关 SSL 握手的内容，参考自SSL/TLS 协议运行机制的概述 SSL 握手涉及四次通信，在每一次通信中需要传递的主要内容如下所示：客户端发出请求支持的协议版本，比如 TLS 1.0 版一个客户端生成的随机数，稍后用于生成“对话密钥”支持的加密算法支持的压缩方法想要请求的服务器域名（与虚拟主机有关）服务器回应确认使用的加密通信协议版本，比如 TLS 1.0 版。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信一个服务器生成的随机数，稍后用于生成“对话密钥”确认使用的加密算法服务器证书客户端回应一个客户端生成的随机数，用于生成“对话密钥”。该随机数用服务器公钥加密，防止被窃听编码改变通知，表示随后的信息都将用双方商定的加密算法和密钥发送客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验服务器的最后回应编码改变通知，表示随后的信息都将用双方商定的加密算法和密钥发送服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验 “对话密钥”是使用步骤 1、2 和 3 中的三个随机数生成的对称密钥。使用三个随机数是因为 SSL 协议不信任每个主机都能产生完全随机的随机数，而这样做可以增加随机性 服务器证书SSL支持双向认证，将服务器证书承载回客户端，再将客户端的证书会送给服务器。而现在，浏览器并不经常使用客户端证书。大部分用户甚至都没有自己的客户端证书。服务器可以要求使用客户端证书，但实际中很少出现这种情况。 另一方面，安全HTTPS事务总是要求使用服务器证书的。在一个Web服务器上执行安全事务，比如提交信用卡信息时，你总是希望是在与你所认为的那个组织对话。由知名权威机构颁发的服务器证书可以帮助你在发送信用卡或私人信息之前评估你对服务器的信任度。 站点证书的有效性SSL自身不要求用户检查Web服务器证书，但大部分现代浏览器都会对证书进行简单的完整性检查，并为用户提供进一步彻查的手段。验证步骤如下所示： 日期检测首先，浏览器检查证书的起始日期和结束日期，以确保证书仍然有效。如果证书过期了，或者还未被激活，则证书有效性验证失败，浏览器显示一条错误信息。签名颁发者可信度检测每个证书都是由某些证书颁发机构（CA）签发的，它们负责为服务器担保。证书有不同的等级，每种证书都要求不同级别的背景验证。签名检测一旦判定签名授权是可信的，浏览器就要对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性。站点身份检测为防止服务器复制其他人的证书，或拦截其他人的流量，大部分浏览器都会试着去验证证书中的域名与它们所对话的服务器的域名是否匹配。服务器证书中通常都包含一个域名，但有些CA会为一组或一群服务器创建一些包含了服务器名称列表或通配域名的证书。如果主机名与证书中的标识符不匹配，面向用户的客户端要么就去通知用户，要么就以表示证书不正确的差错报文来终止连接。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2Fposts%2Ff1601c3e%2F</url>
    <content type="text"><![CDATA[基础概念 单例模式：保证一个类仅有一个实例，并提供一个访问该实例的全局访问点。适用性：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。参与者：Singleton定义了一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作（即它是一个静态成员方法）。可能负责创建它自己的唯一实例。 demo 基础概念中介绍的是单例模式的原理，而这个demo中展示的是使用代理来实现透明单例模式的例子，它们有些许不同。 1234567891011121314151617181920212223class CreateSingleton &#123; constructor (name) &#123; this.name = name &#125;&#125;var Singleton = (function () &#123; var instance return function (name) &#123; if(!instance) &#123; instance = new CreateSingleton(name) &#125; return instance &#125;&#125;)()var a = new Singleton('a')console.log(a.name) // avar b = new Singleton('b')console.log(b.name) // aconsole.log(a === b) // true]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础]]></title>
    <url>%2Fposts%2F22f97770%2F</url>
    <content type="text"><![CDATA[HTTP报文结构 实体是要进行传输的数据。实体首部字段存在于报文首部字段之中。实体主体和报文主体在起始时是相同的。如果实体主体过大，需要进行分块传输，会导致报文主体中包含多个实体主体。 HTTP方法GETGET是最常用的方法。通常用于向服务器请求某个资源。 HEADHEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取是集资源的情况下，对资源的首部进行检查。服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。 使用HEAD，可以：在不获取资源的情况下了解资源的情况。比如，判断其类型。通过查看响应中的状态码，看看某个对象是否存在。通过查看首部，测试资源是否被修改了。 PUT与GET从服务器读取文档相反，PUT方法会向服务器写入文档。服务器应使用PUT请求的主体来创建/替换文档。 POSTPOST方法用于向服务器传输数据，由服务器根据情况判断如何使用这些数据。 TRACE客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。 TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一个TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否以及如何被毁坏或修改的。 尽管TRACE可以很方便地用于诊断，但它确实也有缺点，它假定中间应用程序对各种不同类型请求的处理是相同的。很多HTTP应用程序会根据方法的不同做出不同的事情——比如，代理可能会将POST请求直接发送给服务器，而将GET请求发送给另一个HTTP应用程序。TRACE并不提供区分这些方法的机制。通常，中间应用程序会自行决定对TRACE请求的处理方式。 TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本。 OPTIONSOPTIONS方法请求服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。 DELETEDELETE方法所做的事情就是请服务器删除请求URL所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。 GET与POST的区别 GET 请求参数放在 URL 中，POST 请求参数放在请求的 body 中。GET 请求会被浏览器主动缓存，而 POST 则需要手动设置。浏览器对 GET 请求在 URL 中传送的参数是有长度限制的（通常为 2K），而对 POST 请求的限制为 80K - 100K。实际上 GET 和 POST 请求本身对大小是无限制的。GET 请求产生一个 TCP 数据包，而 POST 请求产生两个数据包（Firefox 除外）。POST 请求先发送 header ，服务器响应 100 Continue 后，再接着发送 data，最后服务器响应 200 OK。 状态码 100 Continue：说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应。101 Switching Protocols：说明服务器正在根据客户端的指定，将协议切换成Update首部所列的协议。200 OK：请求没问题，实体的主体部分包含了所请求的资源。204 No Content：响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不专为显示新文档的情况下，对其进行更新。206 Partial Content：客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。301 Moved Permanently：在请求的URL已被移除时使用。响应的Location首部中应包含资源现在所处的URL。302 Found：与301状态码类似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。303 See Other：与302类似，但是303明确表示客户端应当采用GET方法获取资源，这点与302有区别。304 Not Modified：告知客户端它的它所请求的资源不同重新缓存，使用以前的就好。它虽然被划分在3XX类别中，但是和重定向没有关系。307 Temporary Redirect：与302有着相同的含义。尽管302禁止POST变换为GET，但实际使用时大家并不遵守。307会遵照浏览器标准，不会从POST变换为GET。400 Bad Request：请求报文中存在语法错误。401 Unauthorized：发送的请求需要有通过HTTP认证的认证信息，若之前已进行过一次请求，则表示用户认证失败。403 Forbidden：对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。404 Not Found：服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。500 Internal Server Error：服务器端在执行请求时发生了错误。502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter首部字段再返回给客户端。 版本比较HTTP 0.9历史上第一个有记载的 HTTP 版本是 0.9，它诞生在 1991 年。这个协议被设计用于从服务器获取 HTML 文档。 12telent example.com 80GET / 整个协议的请求只有 1 行，只支持 GET 请求，当从服务器返回文档内容后，关闭 TCP 连接。 HTTP 1.0 支持请求/响应头支持响应状态码支持 HEAD、POST 方法 HTTP 1.1 支持持久连接支持并行连接支持管道化连接在 HTTP 1.0 的基础上，对 HTTP 缓存进行优化（加入Etag实体标签）支持 OPTIONS、PUT、DELETE、TRACE、CONNECT 方法 HTTP 2.0 所有数据以二进制格式传输支持信道复用，一个 TCP 连接里可以发送多个请求，不再需要按着顺序来头信息压缩、减少带宽支持服务器推送 HTTP连接方式 串行连接：一个 TCP 连接一次只能发送一次 HTTP 请求。并行连接：通过多条 TCP 连接发起并发的 HTTP 请求。持久连接：重用 TCP 连接，以消除连接及关闭时延。管道化连接：通过共享的 TCP 连接发起并发的 HTTP 请求。 串行连接串行连接中 HTTP 请求只能一个一个发送，且每次发起 HTTP 请求都要进行 TCP 连接和断开操作，时延较长且耗费性能。 并行连接并行连接中 HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。相比于串行连接，每个 TCP 连接的时延会重叠，所以总的网络时延会较小。但是想象一个场景，如果一百个用户同时发出申请，每个用户打开 100 个连接，服务器就要负责处理 10000 个连接，这会造成服务器性能的严重下降。 总结起来，并行连接有如下缺点：每个事务都会打开/关闭一条新的 TCP 连接，会耗费时间和带宽。由于 TCP 拥塞控制的存在，每条新连接的性能都会有所降低。可打开的并行连接数量实际上是有限的。 持久连接 管道化连接HTTP/1.1 允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列，当第一条请求通过网络 流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。 对管道化连接有几条限制：如果 HTTP 客户端无法确认连接是持久的，就不应该使用管道。必须使用与请求相同的顺序回送 HTTP 响应。HTTP 报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。HTTP 客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了 10 条请求，服务器可能在只处理了 5 条请求之后关闭连接，剩下的 5 条请求会失败，客户端必须能够应付这些过早关闭连接的情况，重新发出这些请求。HTTP 客户端不应该使用管道化的方式发送会产生副作用的请求（比如 POST）。总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试 POST 这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险。 首部通用首部 Connection：允许客户端和服务器指定与请求/响应连接有关的选项。Cache-Control：强缓存使用的首部字段。Date：创建报文的日期。MIME-Version：给出了发送端使用的 MIME 版本。Trailer：如果报文采用了分块传输编码，就可以用这个首部列出位于报文拖挂部分的首部集合。Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。Update：给出了发送端可能想要“升级”使用的新版本或协议。Via：显示了报文经过的中间节点（代理、网关）。Warning：错误通知。 请求首部 Accept：告诉服务器能够发送哪些媒体类型。Accept-Charset：告诉服务器能够发送哪些字符集。Accept-Encoding：告诉服务器能够发送哪些内容编码。Accept-Language：告诉服务器能够发送哪些自然语言。Authorization：Web 认证信息。Except：期待服务器的特定行为。From：用户的电子邮箱地址。Host：请求资源所在服务器。If-Match：协商缓存使用的首部字段。If-Modified-Since：协商缓存使用的首部字段。If-Range：允许对文档的某个范围进行条件请求。If-Unmodified-Since：协商缓存使用的首部字段。 响应首部 Accept-Ranges：是否接受字节范围请求。Age：推算资源创建经过时间。Etag：协商缓存使用的首部字段。Location：令客户端重定向至指定 URI。Proxy-Authenticate：代理服务器对客户端的认证信息。Retry-After：对再次发起请求的时机要求。Server：HTTP 服务器的安装信息。Vary：代理服务器缓存的管理信息。WWW-Authenticate：服务器对客户端的认证信息。 实体首部 Allow：资源可支持的 HTTP 方法。Content-Encoding：实体主体使用的编码方式。Content-Language：实体主体的自然语言。Content-Length：实体主体的大小Content-Location：替代对应资源的 URI。Content-MD5：实体主体的报文摘要。Content-Range：实体主题的位置范围。Content-Type：实体主题的媒体类型。Expires：实体主体的日期时间。Last-Modified：资源的最后修改日期时间。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2Fposts%2Fa708a60d%2F</url>
    <content type="text"><![CDATA[基础概念 装饰者模式：动态地给一个对象添加一些额外的职责。适用性：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。处理那些可撤销的职责。当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸式增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。参与者：Component：ConcreteComponent和Decorator的父类定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent定义一个对象，可以给这个对象添加一些职责。Decorator维持一个指向Component对象的指针。定义一个与Component接口一致的接口。ConcreteDecorator实现添加装饰的接口。 注意事项 接口一致性：装饰对象的接口必须与它所装饰的对象的接口是一致的。省略抽象的Decorator类：当你仅需要添加一个装饰时，没有必要定义抽象Decorator类。保持Component类的简单性：如果有Component类，保持这个类的简单性是很重要的，即它应集中于定义接口而不是存储数据。改变对象外壳与改变对象内核：我们可以将Decorator看作一个对象的外壳，它可以改变这个对象的行为。另外一种方法是改变对象的内核（通过策略模式）。当需要改变的对象比较庞大时，推荐使用策略模式而不是装饰者模式。 demo123456789101112131415161718192021class Plane &#123; fire () &#123; console.log('发射普通子弹') &#125;&#125;class EnforePlane &#123; constructor (plane) &#123; this.plane = plane &#125; fire () &#123; this.plane.fire() console.log('发射超级导弹') &#125;&#125;var plane = new Plane()plane = new EnforePlane(plane)plane.fire() // 发射普通子弹 // 发射超级导弹]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图论算法]]></title>
    <url>%2Fposts%2F7de55cdc%2F</url>
    <content type="text"><![CDATA[若干定义 一个图G = (V, E) 由顶点的集V和边的集E组成。每一条边就是一个点对（v, w），有时也把边称作弧。如果点对是有序的，那么图就叫作有向的。有向的图叫作有向图（digraph）。当且仅当$(w, v) \in E$时，称w邻接到v。在一个具有边（v, w）从而具有边（w, v）的无向图中，w邻接到v且v也邻接到w。有时候，边上还有第三种成分，称做权或值。图中的一条路径是一个顶点序列$w1, w_2, w_3, … , w_n$，使得$(w_i, w{i+1}) \in E, 1 \leq i &lt; n$。这样一条路径的长为该路径上的边数（不存在权的情况下）。有向图中的圈是满足$w_1=w_n$且长至少为1的一条路径。如果有一个有向图没有圈，则称其为无圈的。一个有向无圈图也称为DAG。如果在一个无向图中从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是连通的。如果在一个有向图中从每一个顶点到每个其他顶点都存在一条路径，则称该有向图是强连通的。如果一个有向图不是强连通的，但是它的基础图（即其弧上去掉方向所形成的图）是连通的，那么该有向图称为是弱连通的。完全图是其每一对顶点间都存在一条边的图。 为了表示一个图，可以使用邻接矩阵或者邻接表。对于边数较多（即稠密）的图，推荐使用邻接矩阵。如果图是稀疏的，推荐使用邻接表。 拓扑排序拓扑排序是对有向无圈图的顶点的一种排序，使得如果存在一条从$v_i$到$v_j$的路径，那么在排序中$v_j$就在$v_i$的之后出现。它的原理比较简单，直接用下面的图片进行展示了。图片来源与拓扑排序（Topological Sorting） 需要注意的是，在实现拓扑排序时，首先要检查输入是否为有向无圈图。 最短路径问题 对于一个有向附权图，它的边$(vi, v_j)$上的权是$c{i, j+1}$，因此，一条路径$v1v_2…v_n$的值为$\sum{i=1}^{n-1}c_{i,j+1}$，叫作赋权路径长。而无权路径长只是路径上的边数，即n-1。单源最短路径问题：给定一个有向附权图G和一个特定的顶点s作为输入，找出从s到G中每一个其他顶点的最短赋权路径。单源最短路径问题的解可能不唯一。负值圈：如果存在圈，且圈上存在某个边的权值为负数，则称这个圈为负值圈。求解单源最短路径问题时，需要分情况进行讨论，分别是：无权或者权值均为非负。无负值圈但有负权。存在负值圈。这种情况下，在求解最短路径过程中会陷入无限循环，即不存在最短路径。 Dijkstra算法在这里，我们介绍Dijkstra算法，用它来求解情况1下的最短路径。首先，用一张我在网上发现的图片展示Dijkstra算法的原理。图片来源轻松搞懂dijkstra算法+堆优化 || 原理+实战 Dijkstra算法实现步骤：对于每一个顶点，有3条必要信息：distance：代表从开始顶点s到当前顶点的最短距离。s的distance = 0，其他顶点在初始时distance为无穷大。path：与distance对应的路径上的前一个顶点。known：该值为true时表示当前顶点的distance值已经是最小的，后续不会再进行更新。初始时，包括s在内的所有顶点known = false。从s开始遍历每个known = false的顶点，将当前顶点的known标识为true。找出当前顶点可以邻接到的其他顶点，然后依次根据情况决定是否更新这些被邻接到的顶点的distance和path。最后在所有known = false的顶点中找出distance最小的一个，让它成为下一个当前顶点。当所有顶点的known均为true时，算法运行结束。如果有向图是无圈的，则可以改进Dijkstra算法原有的顶点选择方式，按照拓扑排序的顺序选择顶点。 如果想要Dijkstra算法可以正常工作，必须保证有向图中没有负的权值，否则known将失去存在的意义。 无负值圈但有负权 有的人想到在这种情况下给每个边上的权值都加上一个相同的常数，从而消除负权值，再使用Dijkstra算法进行计算。这样做是行不通的，因为这样做会导致边数多的路径相对于边数少的路径，权重更重了。 这种情况的新算法步骤如下所示：每个顶点都有distance和path属性。同时算法还需要维护一个队列，它里面保存的是需要被遍历的顶点。将开始顶点s加入队列中。取出队列中的第一个顶点，找到所有可以被它邻接到的其他顶点，然后依次根据情况决定是否更新这些被邻接到的顶点的distance和path。在进行步骤3时，如果决定更新某个顶点的distance和path，并且这个被更新的顶点不在队列之中，那么就在更新的同时，将它加入到队列中。重复步骤3和步骤4，直到队列为空。这个算法的重点在于加顶点加入队列的判断机制。 网络流问题设给定有向图G，其任意边$(vi, v_j)$上的容量为$c{i,j}$。这里有两个顶点，一个是发点s，一个是收点t。在既不是发点s又不是收点t的任意顶点v，总的进入流必须等于总的发出流。最大流问题就是确定从s到t可以通过的最大流量。例如，下图展示了一个有向图和它的最大流。 从图中看到，顶点s有容量为4和2的两条边流出，而顶点t有容量为3和3的两条边进入。因此，最大流也许可能是6而不是5。然而，下图指出如何证明最大流就是5。我们把图切割成两部分：一部分包含顶点s，而另一部分包含顶点t。既然流必须通过切口，于是切口上所有的边的总容量就是最大流的一个界。从图中恰好可以看到，5就是最大流的一个界。 求解最大流问题的首要想法是分阶段进行。我们从图G开始并构造一个流图（flow graph）$G_f$。$G_f$表示在求解的任意阶段已经达到的流。开始时$G_f$的所有的边都是没有流的，我们希望当算法终止时$G_f$包含最大流。另外，我们还构造一个图$G_r$，称为残余图（residual graph），它表示对于每条边还能再添加上多少流。对于每一条边，可以从容量中减去当前的流而计算除残余的流。$G_r$的边叫作残余边（residual edge）。在每个阶段，我们寻找图$G_r$中从s到t的一条路径，这条路径叫作增长通路（augmenting path）。这条路径上的最小容量就是可以添加到路径每一边上的流的量。下面用一个图展示这些概念。 下面给出求解最大流问题的具体步骤： 在$G_r$中找到任意一条增长通路，根据该增长通路，更新$G_f$中的的流信息，然后在$G_r$将该增长路径调整为相反方向。重复步骤1，直到在$G_r$中找不到增长通路位置。其实步骤1中的增长通路的选择上可以做一些文章从而减少时间复杂度，这里暂时不进行详细分析了。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[观察者模式and发布订阅模式]]></title>
    <url>%2Fposts%2F9a246216%2F</url>
    <content type="text"><![CDATA[按照书中的理解，发布订阅模式属于观察者模式。但是现在常常将二者区分开来了，本文首先介绍观察者模式，然后在过程中介绍发布订阅模式。 基础概念 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。适用性：当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。当一个对象的改变需要同时改变其它对象，而不知道具体有多少对象待改变。当一个对象必须通知其它对象，而它又不能假定其它对象是谁。参与者（未考虑发布订阅模式）：Subject（目标）目标知道它的观察者。可以有任意多个观察者观察同一个目标。提供注册和删除观察者对象的接口。Observer（观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。ConcreteSubject（具体目标）将有关状态存入各具体观察者中。当它的状态发生改变时，向它的各个具体观察者发出通知。ConcreteObserver（具体观察者）存储有关状态，这些状态应与具体目标的状态保持一致。如有需要，可以维护一个指向具体观察者的引用。实现观察者定义的更新接口。 注意事项 创建目标到观察者之间的映射：可以在每个目标中创建一个列表，用于保存与之关联的观察者的引用。缺点是当目标很多而观察者较少时，存储代价比较高。也可以创建一个关联查找机制（例如一个哈希表）用于维护所有目标到观察者的映射。缺点是增加了访问观察者的开销。观察多个目标：在某些情况下，一个观察者依赖于多个目标可能是有意义的。在这种情况下，必须扩展观察者的update()接口，以使观察者知道是哪一个目标送来的通知。目标对象可以简单地将自己作为update()的一个参数，让观察者知道应去检查哪一个目标。谁调用notify()：目标和它的观察者依赖于通知机制来保持一致。但到底由谁调用notify()来触发更新？可以让目标对象在状态改变后自动调用notify()。也可以让观察者在适当时候主动调用目标的notify()。避免对已删除目标的悬挂引用：删除一个目标时应注意不要在其观察者中遗留对该目标的悬挂引用。一种避免悬挂引用的方法是，当一个目标被删除时，让它通知它的观察者将对该目标的引用复位。在调用notify()前确保目标的状态自身是一致的。避免特定于观察者的更新协议——推/拉模型：观察者模式的实现经常需要让目标广播关于其改变的其他一些信息。目标将这些信息作为update()的参数传递出去。这些信息的量可能很小，也可能很大。推模型：目标向观察者发送关于改变的详细信息，而不管它们需要与否。拉模型：目标除最小通知外什么也不送出。显示地指定感兴趣的改变：你可以扩展目标的注册接口，让各观察者注册为仅对特定事件感兴趣，以提高更新的效率。当一个事件发生时，目标仅通知那些已注册为对该事件感兴趣的观察者。封装复杂的更新语义：当目标和观察者间的依赖关系特别复杂时，可能需要一个维护这些关系的对象。我们称这样的对象为更改管理器（ChangeManager）。它的目的是尽量减少观察者反映其目标状态变化所需的工作量。例如，如果一个操作涉及到对几个相互依赖的目标进行改动，就必须保证仅在所有的目标都已更改完毕后，才一次性地通知它们的观察者，而不是每个目标都通知观察者。ChangeManager有三个责任：它将一个目标映射到它的观察者并提供一个接口来维护这个映射。这就不需要由目标来维护对其观察者的引用，反之亦然。它定义一个特定的更新策略。根据一个目标的请求，它更新所有依赖于这个目标的观察者。结合目标类和观察者类：对于不支持多重继承的语言，可以将目标类和观察者类结合，实现一个既是目标又是观察者的类。 上述第8点，就是观察者模式和发布订阅模式的区别所在了。如果不使用ChangeManager则是观察者模式，使用ChangeManager的则是发布订阅模式。 观察者模式demo下面是多个客户关注同一个房产中介，从房产中介获取房源信息的例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Subject &#123; constructor (name= '', stateArray = []) &#123; this.observers = [] &#125; attach (ob) &#123; this.observers.push(ob) console.log(`$&#123;ob.name&#125;开始关注$&#123;this.name&#125;`) &#125; detach (ob) &#123; this.observers.splice(this.observers.indexOf(ob), 1) console.log(`$&#123;ob.name&#125;取消关注$&#123;this.name&#125;`) &#125; notify (info) &#123; this.observers.forEach(item =&gt; &#123; item.update(info) &#125;) &#125;&#125;class HouseAgent extends Subject &#123; constructor (name) &#123; super() this.name = name this.houses = &#123;&#125; &#125; addHouse (&#123;name, price&#125;) &#123; this.houses[name] = &#123;name, price&#125; this.notify(`$&#123;this.name&#125;新增$&#123;name&#125;，价格$&#123;price&#125;`) &#125; deleteHouse (name) &#123; delete this.houses[name] this.notify(`$&#123;this.name&#125;下架$&#123;name&#125;`) &#125;&#125;class Observer &#123; constructor (name) &#123; this.name = name &#125; update (info) &#123; console.log(`$&#123;this.name&#125;知道了$&#123;info&#125;`) &#125;&#125;let agent = new HouseAgent('房屋中介'), customer1 = new Observer('小明'), customer2 = new Observer('小李');agent.attach(customer1) // 小明开始关注房屋中介agent.attach(customer2) // 小李开始关注房屋中介agent.addHouse(&#123;name: '房屋1', price: '100万'&#125;) // 小明知道了房屋中介新增房屋1，价格100万 // 小李知道了房屋中介新增房屋1，价格100万agent.addHouse(&#123;name: '房屋2', price: '200万'&#125;) // 小明知道了房屋中介新增房屋2，价格200万 // 小李知道了房屋中介新增房屋2，价格200万agent.deleteHouse('房屋1') // 小明知道了房屋中介下架房屋1 // 小李知道了房屋中介下架房屋1]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端路由的实现]]></title>
    <url>%2Fposts%2Feb815672%2F</url>
    <content type="text"><![CDATA[前端路由的实现有两种方式：hash 和 history。 hash 此时浏览器显示的 URL 为 https://aadonkeyz.com/posts/eb815672/。执行 location.hash = &#39;#hash&#39; 后，生成一条新的浏览记录，其 URL 为 https://aadonkeyz.com/posts/eb815672/#hash，并将这条新的记录加入到浏览器历史记录的栈顶。与此同时浏览器的浏览状态会跳转到这个最新的记录上。location.hash 改变时，触发了 window 对象上注册的 onhashchange 事件处理程序。页面内容进行对应的更新。当使用前进或者后退时，会再次触发 onhashchange 事件处理程序，页面内容会再次进行相应的更新。前端路由实现。 在 URL 中，# 以及它之后的内容是用于在页面内定位的锚点，它们的改变不会引起浏览器发送网络请求。 history 此时浏览器显示的 URL 为 https://aadonkeyz.com。更新页面内容，同时通过 history.pushState() 或者 history.replaceState() 新增/替换浏览器历史记录的栈顶记录，浏览器的浏览状态跳转到栈顶记录上，此时 URL 为 https://aadonkeyz.com/posts/eb815672。通过这两个方法，不会触发任何事件，也不会引起浏览器的加载行为。当浏览器前进或后退到某条由 history.pushState() 或者 history.replaceState() 生成的浏览记录时，会触发 window 对象上注册的 onpopstate 事件处理程序，并且在事件处理程序的内部，event.state 中保存着该浏览记录的状态对象的拷贝。因此可以根据这个 event.state 更新页面。前端路由实现。 采用这种方式时，为了防止浏览器真的去加载对应的 URL，从而返回 404 Not Found 的尴尬局面，需要服务器的支持，如果 URL 匹配不到任何静态资源，则应该返回根页面 HTML。 更多「前端进阶」彻底弄懂前端路由 中对前端路由进行了简单的实现，感兴趣的可以阅读一下。如果想更细致的了解前端路由的实现方式，可以阅读 react-router 或者 vue-router 的源码。 参考文献 「前端进阶」彻底弄懂前端路由]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP Caching]]></title>
    <url>%2Fposts%2F8837602f%2F</url>
    <content type="text"><![CDATA[我是 MDN 的搬运工。]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[散列（哈希）表]]></title>
    <url>%2Fposts%2F5ff4158%2F</url>
    <content type="text"><![CDATA[基本概念散列表是一种用于以常数平均时间执行插入、删除和查找的技术。但是，那些需要元素间任何序信息的树操作在这里将不会得到有效的支持（如findMin、findMax）。理想的散列表只不过是一个具有固定大小的数组。假定散列表长度为n，当向散列表中插入数据时，将该数据的关键字（key）作为输入传递给一个称作散列函数（hash function）的映射函数，然后得到一个0 ~ n-1的数值，这个数值代表的是该数据插入散列表的位置。给定两个不同的关键字，如果散列函数的输出结果相同，这种情况叫作冲突（collision）。 如果输入的关键字是整数，则一般合理的方法是直接返回 Key mod TableSize，除非 Key 碰巧具有某些不理想的性质。例如，若表的大小是 10 而关键字都以 0 为个位，则此时上述标准的散列函数就是一个坏的选择。为了避免这样的情况，通常保证表的大小是素数，当输入的关键字是随机整数时，散列函数不仅计算起来非常简单，而且关键字的分配也很均匀，减少了冲突的发生。 分离链表法解决冲突的第一种方法叫作分离链表法，其做法是将散列到同一个值的所有元素保留到一个链表中。 为了执行一次 search，需要使用散列函数来确定究竟遍历哪个链表，然后在适当的链表中执行一次查找。为执行insert，需要检查相应的链表看看该元素是否已经处在相应的位置。如果这个元素是个新的元素，那么它将被插入到链表的前端，这不仅是因为方便，而且还因为常常发生这样的事实：新近插入的元素最有可能不久又被访问。 除链表外，任何合理的方案也都可以解决冲突现象，一颗二叉查找树或甚至另一个散列表都将胜任这个工作，但是我们期望，如果散列表是大的并且散列函数是好的，那么所有的链表都应该是短的，从而基本的分离链表法就没有必要再尝试任何复杂的手段了。 我们定义散列表的装填因子λ为散列表中的元素个数对该表大小的比。在上面的例子中，λ = 1.0。链表的平均长度为λ。执行一次查找所需的代价，是计算散列函数值所需要的常数时间加上遍历所用的时间。在一次不成功的查找中，要遍历的节点数平均为λ。一次成功的查找则需要遍历大约1+(λ/2)个链。 开放定址法分离链表法的缺点是使用一些链表，由于给新单元分配地址需要时间，因此这就导致算法的速度有些减慢，同时算法实际上还要求对第二种数据结构的实现。而开放定址法解决冲突的思路是尝试另外一些单元，直到找出空的单元为止。一般来说，对于使用开放定址法的散列表，其装填因子应该满足λ &lt; 0.5。 线性探测法 当发生冲突时，从当前位置开始，依次往后进行探测，当探测到空闲位置时，插入元素。 下面例子中，$hash(x) = x mod n, n = 10$，插入项：{89, 18, 49, 58, 69}。 只要表足够大，使用线性探测法总能够找到一个空闲为止，但是如此花费的时间是相当多的。更糟的是，即使表相对较空，这样占据的为止也会开始形成一些区块，其结果称为一次聚焦，就是说，散列到区块中的任何数据都需要多次试选单元才能够解决冲突，然后该数据被添加到相应的区块中。 平方探测法 当发生冲突时，从当前位置开始，依次探测当前位置之后的第 $1, 2^2, 3^2, 4^2, …$ 个位置，当探测到空闲位置时，插入元素。 下面例子中，$hash(x) = x mod n, n = 10$，插入项：{89, 18, 49, 58, 69}。 使用平方探测时，如果表的大小是素数，同时表至少还有一半的空余位置，那么新的元素一定可以探测到空余位置。 对于线性探测，让散列表几乎填满元素并不是个好主意，因为此时表的性能会降低。对于平方探测情况甚至更糟，一旦表被填满超过一半，或者表的长度不是素数，就不能保证可以探测到空余位置了。这是因为可以用作解决冲突的备选位置最多只有表长度的一半。 虽然平方探测排除了一次聚焦，但是散列到同一位置上的那些元素将探测相同的备选单元。这叫作二次聚焦。二次聚焦是理论上的一个小缺憾。 双散列 当发生冲突时，使用第二个散列函数计算 $d=hash_2(x)$，然后依次探测当前位置之后的第 $d, 2d, 3d, …$ 个位置，当探测到空闲位置时，插入元素。 下面例子中，$hash_1(x) = x mod n, hash_2(x) = 7 - (x mod 7), n = 10$，插入项：{89, 18, 49, 58, 69}。 再散列 再散列是为了解决插入操作运行时间过长的问题，而不是为了解决冲突。 对于使用平方探测的开放定址散列法，如果散列填的太满，那么操作的运行时间将消耗过长，且插入操作可能失败。这可能发生在有太多的删除和插入混杂的场合。此时，一种解决方法是建立另外一个大约两倍大的表（而且使用一个相关的新散列函数），扫描整个原始散列表，计算每个（未删除的）元素的新散列值并将其插入到新表中。 下面用一个例子演示再散列的过程。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[async/await]]></title>
    <url>%2Fposts%2Fca9ee217%2F</url>
    <content type="text"><![CDATA[基础概念JavaScript 是单线程的，为了处理异步操作，先是使用回调函数，接着使用 Promise，然后又使用 generator/yield，最后到本文要介绍的 async/await。 引用阮一峰大大的一句话 async 函数就是 generator 函数的语法糖。 首先看一个结合 Promise 和 generator 处理异步的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041var fs = require('fs')var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) &#123; reject(error) &#125; resolve(data) &#125;) &#125;)&#125;function run (taskDef) &#123; let task = taskDef() let result = task.next() function step () &#123; if (!result.done) &#123; let promise = Promise.resolve(result.value) promise.then(function (value) &#123; result = task.next(value) step() &#125;).catch(function (err) &#123; result = task.throw(err) step() &#125;) &#125; &#125; step()&#125;var generator = function * ()&#123; var f1 = yield readFile('./verify.js') var f2 = yield readFile('./readline.js') console.log(f1.toString()) console.log(f2.toString())&#125;run(generator) 通过这个例子，大家也看出来了，用 generator 函数处理异步的麻烦之处在于，它还需要自己定义执行器。 接下来用 async 函数改写这个例子。 123456789101112131415161718192021var fs = require('fs')var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) &#123; reject(error) &#125; resolve(data) &#125;) &#125;)&#125;var asyncInstance = async function () &#123; var f1 = await readFile('./verify.js') var f2 = await readFile('./readline.js') console.log(f1.toString()) console.log(f2.toString())&#125;asyncInstance() 一比较就会发现，async 函数就是将 generator 函数的星号（*）替换成 async，将 yield 替换成 await。而且 async 函数不需要自己定义执行器！ 注意事项 区别于生成器的定义，可以使用箭头函数定义 async。与 yield 一样，await 只能用在 async 函数内部，用于其他任意位置都是语法错误，即使在 async 函数内部的函数中也不行。async 函数返回的是 Promise 实例。如果 async 函数内抛出了错误，并且没有被 try...catch 包裹，async 会直接以该错误作为原因，返回一个状态为 rejected 的 Promise 实例。如果 await 后面是一个非 Promise 非 thenable 的值，则直接返回。如果 await 后面是一个 Promise 实例。6.1 当 Promise 实例被 fulfill 时，返回 Promise 实例的值。6.2 当 Promise 实例被 reject 时，则将 Promise 被 reject 的值作为错误在此处抛出（同 4）。如果 await 后面是一个 thenable 对象，会现将其作为 Promise 实例进行处理（同 6）。 123456789101112131415const asyncFun = async () =&gt; &#123; return 'resolved'&#125;const promise = asyncFun();promise .then( (value) =&gt; &#123; // resolved console.log(value) &#125; ) .catch(err =&gt; &#123; console.log(err) &#125;) 123456789101112131415const asyncFun = async () =&gt; &#123; throw 'err'&#125;const promise = asyncFun();promise .then( (value) =&gt; &#123; console.log(value) &#125; ) .catch(err =&gt; &#123; // err console.log(err) &#125;) 123456789101112131415const asyncFun = async () =&gt; &#123; await Promise.reject('rejected')&#125;const promise = asyncFun();promise .then( (value) =&gt; &#123; console.log(value) &#125; ) .catch(err =&gt; &#123; // rejected console.log(err) &#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2Fposts%2F45b9746d%2F</url>
    <content type="text"><![CDATA[在某些场景下（scroll、resize 事件等），函数有可能被非常频繁地调用，这样会消耗不必要的性能。为了解决这个问题，引出了防抖（debounce）和节流（throttle）的概念。 debounce 在事件被触发时，设定 n 秒后执行对应的回调函数。如果在 n 秒之内事件被重复触发，则重新计时。如果连续触发事件，对应的回调函数可能永远不会被调用。 1234567891011function debounce (fn, timeRange) &#123; var timer return function (...args) &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.call(this, ...args) &#125;, timeRange) &#125;&#125; throttle 一段时间周期内，最多只执行一次回调函数。 12345678910111213141516function throttle (fn, timeRange) &#123; var timer return function (...args) &#123; if (timer) &#123; return &#125; else &#123; timer = setTimeout(() =&gt; &#123; clearTimeout(timer) timer = null fn.call(this, ...args) &#125;, timeRange) &#125; &#125;&#125; lodash在实际工作中给你，往往都是直接引用 lodash，而 lodash 的 debounce 和 throttle 的规则是可以在进行适当配置的。]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[元素居中的几种方法]]></title>
    <url>%2Fposts%2Ffc526f38%2F</url>
    <content type="text"><![CDATA[本文只讨论元素宽高未知的情况。元素宽高未知指的是在居中的过程中，不依赖于元素的宽高。 通过position和margin 通过margin就可以做到令元素水平居中。再通过position令元素脱离文档流（不脱离无法做到垂直居中），并设置top、right、bottom、left均为0，就可以使得元素在垂直方向上也居中。 1234567891011121314151617181920212223&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #outer &#123; width: 100px; height: 100px; position: relative; border: 1px solid black; &#125; #inner &#123; width: 50px; height: 50px; margin: auto; position: absolute; top: 0; right: 0; bottom: 0; left: 0; border: 1px solid red; &#125;&lt;/style&gt; 通过position和transform 通过position将元素的左上角放到包含元素的中心。再通过transform将元素的中心移动到包含元素的中心。 1234567891011121314151617181920&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #outer &#123; width: 100px; height: 100px; border: 1px solid black; &#125; #inner &#123; width: 50px; height: 50px; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 1px solid red; &#125;&lt;/style&gt; 通过flex12345678910111213141516171819&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #outer &#123; width: 100px; height: 100px; display: flex; justify-content: center; align-items: center; border: 1px solid black; &#125; #inner &#123; width: 50px; height: 50px; border: 1px solid red; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[外部资源的加载和使用规则]]></title>
    <url>%2Fposts%2F7fca0ecb%2F</url>
    <content type="text"><![CDATA[script 标签 带有 src 属性的 &lt;script&gt; 标签不应该在其 &lt;script&gt; 和 &lt;/script&gt; 之间再包含额外的 JavaScript 代码。如果包含了嵌入的代码，也只会加载并执行外部 js 文件，嵌入的代码会被忽略。 在用 &lt;script&gt; 加载外部 js 文件时，只要不存在 defer 和 async 属性，浏览器会按照 &lt;script&gt; 标签在页面中出现的先后顺序依次加载并执行它们。所以如果将 &lt;script&gt; 放在 &lt;head&gt; 中，意味着必须等到全部 JavaScript 代码都被加载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到 &lt;body&gt; 标签时才开始呈现内容）。 如果在使用 &lt;script&gt; 时加入 defer 属性，意味着要并行加载这个 js 文件，但是会延迟到整个页面都被解析完成之后，才开始执行这个这个 js 文件。如果在使用 &lt;script&gt; 时加入 async 属性，意味着要异步加载这个 js 文件，如果在页面解析过程中完成了 js 文件的加载，浏览器会暂时停止页面的解析，转而执行该 js 文件。因为加载 js 文件的过程是异步的，所以无法保证 js 文件是按顺序加载完成的，也就无法保证 js 文件按顺序执行。 用一张图生动的展示页面解析与 js 加载执行过程。 上图来源于深入浅出浏览器渲染原理 link 标签当 &lt;link&gt; 标签的 rel 属性值为 stylesheet 时，代表要加载外部的 CSS 样式表，它不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染（意思就是会阻塞 render tree 的生成，从而让浏览器暂时无法渲染对应的内容）。 但是当 rel 属性值为 preload 时，意味着要浏览器立即加载对应的外部资源，但是并不会去使用它。关于它的具体用法请看 MDN，下面的例子也是来源于MDN。 12345678910111213141516&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS and CSS preload example&lt;/title&gt; &lt;link rel="preload" href="style.css" as="style"&gt; &lt;link rel="preload" href="main.js" as="script"&gt; &lt;link rel="stylesheet" href="style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;bouncing balls&lt;/h1&gt; &lt;canvas&gt;&lt;/canvas&gt; &lt;script src="main.js" defer&gt;&lt;/script&gt;&lt;/body&gt; @import通过 @import 方式引入的样式表，会在整个页面内容都加载完成之后才开始加载、解析。]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原生拖放]]></title>
    <url>%2Fposts%2F2317527%2F</url>
    <content type="text"><![CDATA[拖放事件 拖放事件分为两类：被拖拽元素上的事件和放置目标上的事件被拖拽元素上的事件：dragstart：在被拖拽元素处按下鼠标并开始移动鼠标时触发。drag：紧随dragstart之后被触发，在元素被拖拽期间该事件会持续被触发（每 350 毫秒一次）。dragend：当拖拽停止（无论是把元素放到了有效的放置目标上，还是放到了无效的放置目标上）时触发。放置目标上的事件：dragenter：当元素被拖拽到放置目标上空时触发。dragover：紧随 dragenter 之后被触发，而且只要被拖拽元素还在放置目标的范围内移动，就会持续触发该事件（每 350 毫秒一次）。dragleave：当被拖拽元素离开放置目标时触发。drop：当元素被放置到放置目标上时触发（前提是阻止了 drogover 事件的默认行为）。 可拖拽元素通过元素的 draggable 属性可以设置元素是否可拖拽，true 表示可拖拽，false 表示不可拖拽。 默认情况下 draggable = auto，此时元素是否可拖拽取决于浏览器的默认行为。通常被选中的文本、图片和链接都是默认可拖拽的，并且它们拥有自己的默认 ondragstart 事件处理程序。 可放置目标虽然所有元素都支持放置目标事件（drop 事件），但这些元素默认是不允许放置的。如果想将元素设置为可放置，方法是重写 dragover 事件的默认行为。 假设有一个 ID 为 drop-target 的 &lt;div&gt; 元素，可以用下面的代码将它变成一个放置目标。这样就可以触发放置目标的 drop 事件了。 12345let droptarget = document.getElementById('drop-target')droptarget.ondragover = function () &#123; event.preventDefault()&#125; 为了让 Firefox 支持正常的拖放，还需要取消 drop 事件的默认行为。 dataTransfer只有简单的拖放而没有数据的变化是没有什么用的，而通过事件的 dataTransfer 对象可以进行数据的传递。dataTransfer 对象是事件对象的属性，所以只能在拖拽事件处理程序中访问。下面介绍它的属性和方法 属性：dropEffect：该属性用于设置当被拖拽元素处于放置目标上方时鼠标的显示效果。需要注意的是，该属性必须配合 effectAllowed 属性才会生效。该属性有四个可选值：none、move、copy 和 link。effectAllowed：表示允许哪种 dropEffect。需要注意的是，该属性必须在 ondragstart 事件处理程序中设置才会生效。可选值有：uninitialized：没有设置时的默认值，等同于设置为 all。none：相当于禁止了 dropEffect 的效果。copy：只允许值为 copy 的 dropEffect。link：只允许值为 link 的 dropEffect。move：只允许值为 move 的 dropEffect。copyLink：允许值为 copy 和 link 的 dropEffect。copyMove：允许值为 copy 和 move 的 dropEffect。linkMove：允许值为 link 和 move 的 dropEffect。all：允许任意的 dropEffect。files：被用户拖拽到放置目标中的文件所组成的数组。types（只读）：被拖拽元素所携带数据的类型组成的数组。另外，在 drag 和 dragend 中该属性一直为空数组，我也不知道为什么。方法：setData(format, data)：该方法只有在 ondragstart 事件处理程序中调用才有效，它用于设置拖拽元素要携带的数据，为 format-data对 形式（类似于键值对，这个名字是我自己为了理解自己起的）。一次拖拽可以同时设置多个 format-data对。format：数据的类型，允许指定各种 MIME 类型，通常使用的是 text/plain 和 text/uri-list。我自己尝试着将类型设置为 id、custom-type 之类的，也可以正常工作。data：设置的数据如果不是字符串，会自动被调用 toString() 方法。getData(format)：在放置目标的 4 个事件上均可以使用该方法，它用于根据 format 获取对应的数据，获取的数据一定是字符串。clearData(format)：该方法只有在 ondragstart 事件处理程序中调用才有效，它用于根据 format 清除对应的数据。setDragImage(img, xOffset, yOffset)：默认情况下拖拽元素的时候会自动根据被拖拽的元素生成一个半透明的图片。而通过这个方法可以设置这个半透明的图片。img：可以是一个 &lt;img&gt; 元素或者 &lt;canvas&gt; 元素。xOffset：鼠标指针相对于图片左边界的水平偏移量。yOffset：鼠标指针相对于图片上边界的垂直偏移量。 demo这里偷个懒，不自己想例子了。引用 https://segmentfault.com/a/1190000012427787 中的例子。 说句题外话，这段代码里还涉及了事件流的相关知识点，如果感兴趣可以将 ev.target.classList.add(&#39;over&#39;) 中的 ev.target 换为 this，然后观察一下效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;拖动&lt;/title&gt; &lt;style&gt; h2 &#123; font-size: 20px; color: #0d88c1; &#125; div#left, div#right &#123; width: 120px; float: left; margin: 10px 100px 10px 0px; height: 240px; background-color: #dddddd; overflow-y: auto; &#125; div label &#123; font-size: 22px; font-weight: bold; width: 100%; display: inline-block; padding: 4px 0; text-align: center; margin: 0px 0 2px 0; color: #fff; background-color: #0d88c1; &#125; .over &#123; border: 1px dashed red; box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;拖放（Drag 和 drop）&lt;/h2&gt; &lt;!-- 左边元素框 --&gt; &lt;div id="left"&gt; &lt;label draggable="true"&gt;index1&lt;/label&gt; &lt;label draggable="true"&gt;index2&lt;/label&gt; &lt;label draggable="true"&gt;index3&lt;/label&gt; &lt;label draggable="true"&gt;index4&lt;/label&gt; &lt;label draggable="true"&gt;index5&lt;/label&gt; &lt;label draggable="true"&gt;index6&lt;/label&gt; &lt;label draggable="true"&gt;index7&lt;/label&gt; &lt;/div&gt; &lt;!-- 右边元素框 --&gt; &lt;div id="right"&gt;&lt;/div&gt; &lt;script&gt; var moveItem = document.getElementsByTagName('label'); for (let i = 0; i &lt; moveItem.length; i++) &#123; //动态设置label元素id moveItem[i].setAttribute('id', 'label' + i); moveItem[i].ondragstart = function (ev) &#123; //dataTransfer.setData() 方法设置被拖数据的数据类型和值 ev.dataTransfer.setData("id", this.id); &#125;; &#125; document.getElementById('right').ondragover = function (ev) &#123; ev.preventDefault(); //阻止向上冒泡 &#125; document.getElementById('right').ondragenter = function (ev) &#123; ev.target.classList.add('over') console.log(this) &#125; document.getElementById('right').ondragleave = function (ev) &#123; ev.target.classList.remove('over') &#125; document.getElementById('right').ondrop = function (ev) &#123; ev.preventDefault(); ev.target.classList.remove('over') var id = ev.dataTransfer.getData('id'); var elem = document.getElementById(id); //当前拖动的元素 var toElem = ev.toElement.id; //放置位置 if (toElem == 'right') &#123; //如果为container,元素放置在末尾 this.appendChild(elem); &#125; else &#123; //如果为container里的元素，则插入该元素之前 this.insertBefore(elem, document.getElementById(toElem)); &#125; &#125; document.getElementById('left').ondragover = function (ev) &#123; ev.preventDefault(); //阻止向上冒泡 &#125; document.getElementById('left').ondragenter = function (ev) &#123; ev.target.classList.add('over') &#125; document.getElementById('left').ondragleave = function (ev) &#123; ev.target.classList.remove('over') &#125; document.getElementById('left').ondrop = function (ev) &#123; ev.preventDefault(); ev.target.classList.remove('over') var id = ev.dataTransfer.getData('id'); var elem = document.getElementById(id); var toElem = ev.toElement.id; if (toElem == 'left') &#123; //如果为container,元素放置在末尾 this.appendChild(elem); &#125; else &#123; //如果为container里的元素，则插入该元素之前 this.insertBefore(elem, document.getElementById(toElem)); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[过渡、变形和动画]]></title>
    <url>%2Fposts%2F540576d8%2F</url>
    <content type="text"><![CDATA[过渡过渡相关属性 transition-property：要过渡的CSS属性的名字（如background-color、text-shadow或者all，all会过渡所有可以过渡的属性）transition-duration：定义过渡效果持续的时间（用秒进行定义，例如.3s、2s或1.5s）transition-timing-function：定义过渡期间的速度变化（例如ease、linear、ease-in、ease-out、ease-in-out或者cubic-bezier，默认为ease）transition-delay：可选，用于定义过渡开始前的延迟时间。相反，将值设置为一个负数，可以让过渡效果立即开始，但过渡旅程会在半路结束（同样是用秒进行定义，例如.3s、2s或1.5s） 123456.style &#123; transition-property: all; transition-duration: 1s; transition-timing-function: ease; transition-delay: 0s;&#125; 过渡的简写语法我们可以把这些独自的属性组合成一个简写版： 123.style &#123; transition: all 1s ease 0s;&#125; 需要注意的是，当使用简写语法的时候，第一个和时间相关的值会被应用给transition-duration，而第二个则会被应用到transition-delay上。 尽量只定义那些你真的需要过渡的属性。定义成all是十分方便，但是如果你只需要过渡透明度，那么就把transition-property设成opacity，否则你会加重浏览器的负担 在不同时间段内过渡不同属性当一条规则要实现多个属性过渡时，这些属性不必步调一致 1234.style &#123; transition-property: border, color, text-shadow; transition-duration: 2s, 3s, 8s;&#125; 此处我们首先指定要过渡的属性，然后在分别为它们指定不同的过渡时间，不同过渡之间用逗号分隔 变形虽然两个英文单词发音相似，但变形和过渡完全不同。可以这么理解：过渡是从一种状态平滑转换到另一种状态，而变形则定义了元素将会变成什么样子。 变形原点元素的默认变形原点为正中心，即元素X轴的50%和Y轴的50%处。 你可以使用transform-origin来改变变形原点的位置。如果给它传递数值，则代表需要相对于正中心的偏移量。如果给它传递百分值，则表示要将变形原点移动到对应轴的对应百分比处。 如何变形 CSS的变形是通过transform属性实现的，下面列表中的内容具体的形变种类scale()：用来对元素进行缩放。如果给定一个值，则X轴和Y轴同时按照这个值进行缩放。如果给定两个值，则分别对应X轴和Y轴的缩放系数。如果还有第三个值，那这个值对应Z轴的缩放系数。当值为负数时，首先在对应方向上将元素镜像，然后在进行缩放。translate()：用来移动元素。用法与scale()相同，如果使用百分值，那么是相对于元素自身的百分比。rotate()：使元素围绕变形原点进行旋转。如果角度为正，那么顺时针方向旋转。反之则逆时针方向。skew()：沿X轴和Y轴对元素进行斜切。对X轴进行斜切时，以变形原点为中心让X轴顺时针旋转。对Y轴进行斜切时，以变形原点为中心让Y轴逆时针旋转。matrix()：允许你以像素精度来控制变形效果。以后理解更深刻的时候再回来整理。 perspectiveperspective属性指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三位元素比正常大，反之则小。 动画首先，我们创建一个关键帧规则 123456@keyframes pulse &#123; 100% &#123; text-shadow: 0 0 5px #bbb; box-shadow: 0 0 3px 4px #bbb; &#125;&#125; 如你所见，在@keyframes关键词后我们定义了一个新的关键帧规则，并且给这个动画命了名。 我们这里只定义了一个简单的关键帧选择器：100%。然而，你也可以设置多个关键帧选择器（用百分比定义）。你可以把它们想像成时间轴上的点。例如，10%的时候背景变成蓝色，30%的时候背景变成紫色，60%的时候让元素变得透明，等等。 在支持的浏览器中，from代表0%，to代表100%。 如果定义了负值或者大于100%的关键帧，它会被忽略。 与过渡的transition相对应，动画使用animation属性。它也是一个缩写属性，当然你也可以不采用缩写形式而使用下面例子中的形式，可选值已用|分隔表示 12345678910.animation-properties &#123; animation-name: pulse; animation-duration: 1.5s; animation-timing-function: ease | ease-in | ease-out | ease-in-out | linear | step-start | step-end; animation-iteration-count: infinite | n; animation-play-state: running | paused; animation-delay: 0s; animation-fill-mode: none | forwards | backwards | both; animation-direction: normal | reverse | alternate | alternaterverse;&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;style&gt; #container &#123; width: 200px; height: 200px; position: relative; background: green; &#125; #item &#123; width: 20px; height: 20px; border-radius: 10px; position: absolute; left: 0; right: 0; margin: auto; background: red; animation-name: bounce; animation-duration: 1.5s; animation-timing-function: linear; animation-iteration-count: infinite; &#125; @keyframes bounce &#123; 0% &#123; top: 0; &#125; 50% &#123; top: 100px; &#125; 100% &#123; top: 180px; &#125; &#125; &lt;/style&gt; &lt;div id="container"&gt; &lt;div id="item"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2Fposts%2Ff2cac40a%2F</url>
    <content type="text"><![CDATA[二叉堆什么是二叉堆只要满足下面的结构性质和堆序性质的，就是二叉堆 结构性质二叉堆是一颗被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入。这样的树称为完全二叉树。 容易证明，一颗高为h的完全二叉树有$2^h$到$2^{h+1} - 1$个节点。这意味着，完全二叉树的高是$\lfloor logN \rfloor$，显然它是$O(logN)$ 一个重要的观察发现，因为完全二叉树这么有规律，所以它可以用一个数组表示 该数组索引为0的位置是空的，元素是从索引为1的位置开始放入的。这样的话，对于数组中的任意位置$i$上的元素，其左儿子在位置$2i$上，右儿子在左儿子后的单元$2i+1$中，它的父亲则在位置$\lfloor i/2 \rfloor$上。 堆序性质使操作被快速执行的性质是堆序性质。由于我们想要能够快速地找出最小/大元，因此最小/大元应该在根上。 最小/大堆 二叉堆分为最小堆和最大堆最小堆：在最小堆中，对于每一个节点X，X的父亲中的关键字小于（或等于）X中的关键字，根节点除外（它没有父亲）最大堆：在最大堆中，对于每一个节点X，X的父亲中的关键字大于（或等于）X中的关键字，根节点除外（它没有父亲） 二叉堆的操作下面的操作，均以最小堆为例 insert为了将一个元素X插入到堆中，我们必须在下一个可用位置创建一个空穴，否则该堆将不是完全二叉树了。如果X可以放在该空穴中而并不破坏堆的序，那么插入完成。否则，我们把空穴的副节点上的元素移入该空穴中，这样，空穴就朝着根的方向上冒一步。继续该过程直到X能被放入空穴中位置。这种一般的策略叫作上滤。 时间复杂度（最坏）：$O(logN)$ deleteMin当删除一个最小元时，要在根节点建立一个空穴。由于现在的堆少了一个元素，因此堆中最后一个元素X必须移动到该堆的某个地方。如果X可以被放到空穴中，那么deleteMin就完成。否则我们将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层。重复该步骤直到X可以被放入空穴中。因此，我们的做法是将X置入沿着从根节点开始包含最小儿子的一条路径上的一个正确的位置。这种一般的策略叫作下滤。 时间复杂度（最坏）：$O(logN)$ decreaseKeydecreaseKey(p, △)操作降低在位置p处的项的值，降值的幅度为正的量△。由于这可能破坏堆序性质，因此必须通过上滤堆堆进行调整。 increaseKeyincreaseKey(p, △)操作增加在位置p处的项的值，增值的幅度为正的量△。这可以用下滤来完成。 removeremove(p)操作删除堆中位置p上的节点。该操作通过首先执行decreaseKey(p, ∞)然后再执行deleteMin来完成 buildHeap有时二叉堆是由一些项的一个初始集合构造而得的，当然可以使用连续的insert操作来完成堆的构建，但是这样的话最坏情况下的时间复杂度为$O(NlogN)$，这并不是最优的方案。 最优方案步骤：将这些项构成的集合直接转换为一个无序的完全二叉树从完全二叉树的最后一个非叶子节点开始往前遍历，依次进行下滤策略时间复杂度（最坏）：$O(N)$ 123456789101112131415161718192021222324252627282930313233343536373839let list = [90, 84, 83, 88, 87, 61, 50, 70, 60, 80]function buildHeap (array) &#123; let heap = []; heap.size = array.length; for (let i = 0; i &lt; array.length; i++) &#123; heap[i + 1] = array[i]; &#125; let currentIndex = Math.floor(heap.size / 2) while (currentIndex &gt; 0) &#123; percolateDown(heap, currentIndex); currentIndex--; &#125; return heap&#125;function percolateDown (heap, currentIndex) &#123; let leftSonIndex = 2 * currentIndex, rightSonIndex = 2 * currentIndex + 1, minValueIndex = currentIndex; if (leftSonIndex &lt;= heap.size &amp;&amp; heap[leftSonIndex] &lt; heap[currentIndex]) &#123; minValueIndex = leftSonIndex; &#125; if (rightSonIndex &lt;= heap.size &amp;&amp; heap[rightSonIndex] &lt; heap[minValueIndex]) &#123; minValueIndex = rightSonIndex; &#125; if (currentIndex !== minValueIndex) &#123; [heap[currentIndex], heap[minValueIndex]] = [heap[minValueIndex], heap[currentIndex]]; percolateDown(heap, minValueIndex); &#125;&#125;console.log(buildHeap(list)) $d$堆$d$堆是二叉堆的简单推广，它恰像一个二叉树，只是所有的节点都有$d$个儿子（因此，二叉堆是2堆）。 $d$堆要比二叉堆浅得多，它将insert操作的运行时间改进为$O(log_dN)$。然而，对于大的$d$，deleteMin操作费时得多，因为虽然树是浅了，但是$d$个儿子中的最小者是必须要找出的，如果使用标准的算法，这会花费$d-1$次比较，于是将操作的用时提高到$O(dlog_dN)$。如果$d$是常数，那么当然两者的运行时间都是$O(logN)$。最后，有证据显示，在实践中4堆可以胜过二叉堆。 左式堆左式堆像二叉堆那样也具有结构性和有序性。事实上，和所有使用的堆一样，左式堆具有相同的堆序性质。左式堆与二叉堆的区别主要体现在结构性上。 结构性质我们把任意节点X的零路径长npl(X)定义为从X到一个不具有两个儿子的节点的最短路径长。因此，具有0或1个儿子的节点的npl = 0，而空节点的npl = -1。 任意节点的零路径长比它的诸儿子节点的零路径长的最小值多1。这个结论也适用少于两个儿子的节点。 左式堆的结构性质是：对于每一个节点X，左儿子的零路径长至少与右儿子的零路径长一样。对于堆中的每一个节点X，左儿子的零路径长大于等于右儿子的零路径长《数据结构与算法分析》中有证明，在右路径上有$r$个节点的左式堆必然至少有$2^r-1$个节点 左式堆操作merge这里我要介绍的是递归进行合并的方法。当要合并两个堆时，如果有一个是空的，则直接返回另一个堆。否则，为了合并这两个堆，可比较它们的根。首先，递归地将具有较大的根植的堆与具有较小的根植的堆的右子堆合并，然后判断左子堆和新的右子堆的零路径长，如果不满足左式堆的结构性，那么交换左子堆与右子堆的位置。 insertinsert可以看作是merge的一种特殊情况，就是把插入看作是单节点堆与一个更大的堆的merge deleteMindeleteMin也可以看作是merge的一种特殊情况，首先将根节点移除，然后对两个儿子进行merge操作]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[格式化上下文]]></title>
    <url>%2Fposts%2F451e216f%2F</url>
    <content type="text"><![CDATA[格式化上下文（Formatting context）是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 BFCBFC形成条件 块级格式化上下文（Block formatting context，简称BFC）是一个独立的渲染区域，它规定了内部block-level box如何布局，并且内部block-level box的布局丝毫不受BFC外部区域的影响。下面是形成BFC的条件，满足任意一条即可根元素，即&lt;html&gt;。float的值不为none。overflow的不值为visible。display的值为table-cell、table-caption、inline-block、flex、inline-flex之一。position的值为absolute或fixed。 BFC布局规则 内部block-level box会在垂直方向，一个接一个地放置。属于同一个BFC的两个相邻block-level box会发生垂直外边距重叠，而属于不同BFC的相邻block-level box则不会发生垂直外边距重叠。每个盒模型的margin-box的左边，与包含块的border-box的左边相接触（对于从左往右的格式化，否则相反）。BFC的区域不会与浮动元素重叠。BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，外面的元素也影响不到容器里面的子元素。计算BFC的高度时，浮动元素也参与计算。关于垂直外边距重叠，如果两个外边距都是正数，那么取最大值。如果两个外边距都是负数，那么取两者中绝对值大的那个。如果两个外边距一正一负，那么取两者的和。 BFC作用 通过触发block-level box形成BFC，阻止它与在它之前的浮动元素发生重叠，此时如果宽度允许，它们会并排显示在同一行。如果一个父元素内部拥有浮动子元素，通过将父元素设置成BFC，可以让父元素包含浮动子元素。两个相邻的block-level box之间会发生垂直外边距重叠，通过将其中一个用BFC包裹，则可以避免垂直外边距重叠的发生（有歧义，请看后面的解释）。 关于第3点作用，是有歧义的，请看下方图片。通过图片可以看出，就算不用BFC包裹，而用普通的block-level box包裹，也会有同样的效果 IFCIFC形成条件行级格式化上下文（Inline formatting context，简称IFC）用来规定了内部inline-level box如何布局。与BFC的形成条件不同，只要一个block-level box内仅包含inline-level box时，这个外部的block-level box就会变成一个IFC IFC布局规则 子元素水平方向横向排列，并且垂直方向起点为元素顶部。子元素只会计算横向样式空间，垂直方向样式空间不会被计算。在垂直方向上，子元素的对齐规则由vertical-align决定。能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。行框的高度是由内部的元素决定的。行框一般左右边紧贴IFC，但浮动元素会优点排列。行框的高度由行高计算规则来决定，同一个IFC下不同行框的高度可能会不同。当一个行框内包含的多个子元素的总宽度不够时，它们的水平渲染规则由text-align决定。当一个子元素的宽度超过行框时，该子元素会被分割成多分，分布在多个行框内。如果该子元素设置了不允许折行，那么超出的部分会溢出行框。]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[盒模型]]></title>
    <url>%2Fposts%2F165da8b7%2F</url>
    <content type="text"><![CDATA[理解盒模型 盒模型由四个部分组成：内容区、内边距、边框、外边距盒模型中有四种盒子：content-box、padding-box、border-box、margin-box 盒模型和元素的大小 盒模型的大小和元素的大小不是一回事盒模型的大小是外边距+边框+内边距+内容区元素的大小取决于box-sizing属性，它有两个值：content-box（默认）：此时元素的width和height属性设置的是内容区的宽度和高度border-box：此时元素的width和height属性设置的是边框+内边距+内容区的宽度和高度块级元素在没有设置width时，它的盒模型会始终填满其父元素的宽度。 盒模型种类 根据盒模型的不同，它们参与不同的格式化上下文block-level box：display属性为block、list-item、tableinline-level box：display属性为inline、inline-block、inline-tablerun-in box：display属性为run-in margin和padding的注意事项 margin的top和bottom对非替换内联元素无效，例如：&lt;span&gt;和&lt;code&gt;margin和padding的属性值如果用百分比设置，那么都是相对于该元素包含块的宽度margin的属性值如果是auto，那么对应的外边距会自动占据包含块空间的所有可用空间 border-radiusborder-radius允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆 该属性是一个简写属性，是为了将border-top-left-radius、border-top-right-radius、border-bottom-right-radius和border-bottom-left-radius简写为一个属性 border-radius在设置椭圆形时，使用（/）分隔水平半轴和垂直半轴 123456789101112131415border-radius: 1em / 5em;/* 等价于： */border-top-left-radius: 1em 5em;border-top-right-radius: 1em 5em;border-bottom-right-radius: 1em 5em;border-bottom-left-radius: 1em 5em;/* ================================ */border-radius: 4px 3px 6px / 2px 4px;/* 等价于： */border-top-left-radius: 4px 2px;border-top-right-radius: 3px 4px;border-bottom-right-radius: 6px 2px;border-bottom-left-radius: 3px 4px; box-shadow box-shadow: inset &lt;offset-x&gt; &lt;offset-y&gt; &lt;blur-radius&gt; &lt;spread-radius&gt; &lt;color&gt;，需要特别注意的是，这些长度值需要指明单位！！！inset（可选）：不使用inset则阴影在边框外，使用inset则阴影在边框内&lt;offset-x&gt;（必选）：水平偏移量&lt;offset-y&gt;（必选）：垂直偏移量&lt;blur-radius&gt;（可选）：该值越大，阴影面积越大，阴影就越大越淡。不能为负值。默认为0，此时阴影边缘锐利&lt;spread-radius&gt;（可选）：取正值时，阴影扩大。取负值时，阴影缩小。默认为0，此时阴影与元素同样大&lt;color&gt;（可选）：颜色。默认颜色由浏览器决定如果给出了第三个长度值，则它被解释为&lt;blur-radius&gt;。如果给出了第四个长度值，则它被解释为&lt;spread-radius&gt;如果想设置多个阴影，则不同阴影规则之间需要使用逗号分隔。越靠前的阴影规则，对应的阴影越接近显示的表层如果元素同时设置了border-radius，那么阴影也会有圆角效果]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2Fposts%2F7b216a3b%2F</url>
    <content type="text"><![CDATA[树的基本概念一棵树是一些节点的集合，这个集合可以是空集；若不是空集，则树由称做根（root）的节点$r$及 0 或多个非空的（子）树$T_1,T_2, ···,T_k$组成，这些子树中每一颗的根都被来自根$r$的一条有向的边所连接。每一颗子树的根叫作根$r$的儿子，而$r$是每一颗子树的根的父亲 下图中，节点 A 是根。节点 F 有一个父亲 A 并且有儿子 K、L 和 M。每一个节点可以有任意多个儿子，也可能是零个儿子。没有儿子的节点称为树叶，下图中的树叶是 B、C、H、I、P、Q、K、L、M 和 N。具有相同父亲的节点为兄弟。因此，K、L 和 M 都是兄弟。 从节点$n_1$到$n_k$的路径定义为节点$n_1, n_2, ···, n_k$的一个序列，使得对于$1 \leq i \leq k$的节点$n_i$是$n$$i+1$的父亲。这条路径的长是该路径上边的条数，即$k - 1$。从每一个节点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个节点恰好存在一条路径 对任意节点$n_i$，$n_i$的深度为从根到$n_i$的唯一路径的长。因此，根的深度为 0。节点$n_i$的高是从$n_i$到一片树叶的最长路径的长。因此所有树叶的高都是 0。一棵树的高等于它的根的高。上图中的树，E 的深度为 1 而高为 2；F 的深度为 1 而高也是 1；该树的高为 3。一棵树的深度等于其最深的树叶的深度，该深度总是等于这棵树的高 二叉树二叉树的种类 二叉树：是一种特殊的树，它每个节点最多只能有两个儿子完美二叉树：高为 h，且节点数为$2^{h+1} - 1$的二叉树。也就是说除了最后一层无任何子节点之外，每一层上的所有节点都有两个儿子完全二叉树：从根节点到倒数第二层满足完美二叉树，最后一层没有完全填满，其叶子节点都靠左对齐。一颗高为 h 的完全二叉树有$2^h$到$2^{h+1} - 1$个节点。这意味着，完全二叉树的高是$\lfloor logN \rfloor$，显然它是$O(logN)$完满二叉树：对于任意节点，要不就是拥有两个儿子，要不就是一个儿子都没有堆：特殊的完全二叉树，后续文章会详细介绍二叉查找树：使二叉树成为二叉查找树的性质是，对于树中的每个节点 X，它的左子树中所有项的值均小于 X 中的项，而它的右子树中所有项的值均大于 X 中的项AVL 树：带有平衡条件的二叉查找树 二叉树的遍历 先序遍历：首先处理根节点，然后再处理它的左儿子和右儿子中序遍历：首先处理左儿子，然后处理根节点，最后处理右儿子后序遍历：首先处理左儿子，然后处理右儿子，最后处理根节点层序遍历：按照从上到下、从左到右的顺序处理节点 先序遍历递归12345678function preOrderTraverse(node) &#123; if (node) &#123; console.log(node.val); preOrderTraverse(node.left); preOrderTraverse(node.right); &#125;&#125; 非递归1234567891011121314151617function preOrderTraverse(node) &#123; const stack = []; let cur = node; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; console.log(cur.val); stack.push(cur); cur = cur.left; &#125; if (stack.length &gt; 0) &#123; cur = stack.pop().right; &#125; &#125;&#125; 中序遍历递归123456789function middleOrderTraverse(node) &#123; if (node) &#123; middleOrderTraverse(node.left); console.log(node.val); middleOrderTraverse(node.right); &#125;&#125; 非递归1234567891011121314151617function middleOrderTraverse(node) &#123; const stack = []; let cur = node; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; stack.push(cur); cur = cur.left; &#125; if (stack.length &gt; 0) &#123; const topNode = stack.pop(); console.log(topNode.val); cur = topNode.right; &#125; &#125;&#125; 后序遍历递归12345678function postOrderTraverse(node) &#123; if (node) &#123; postOrderTraverse(node.left); postOrderTraverse(node.right); console.log(node.val); &#125;&#125; 非递归12345678910111213141516171819202122232425function postOrderTraverse(node) &#123; const stack = []; let cur = node; let lastHandled = null; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; stack.push(cur); cur = cur.left; &#125; if (stack.length &gt; 0) &#123; const topNode = stack[stack.length - 1]; if (topNode.right &amp;&amp; topNode.right !== lastHandled) &#123; cur = topNode.right; &#125; else &#123; console.log(topNode.val); lastHandled = topNode; stack.pop(); &#125; &#125; &#125;&#125; 层序遍历1234567891011121314151617181920function levelOrderTraverse(node) &#123; if (!node) &#123; return; &#125; const queue = [node]; while (queue.length &gt; 0) &#123; const prevLevelNode = queue.shift(); console.log(prevLevelNode.value); if (prevLevelNode.left) &#123; queue.push(prevLevelNode.left); &#125; if (prevLevelNode.right) &#123; queue.push(prevLevelNode.right); &#125; &#125;&#125; 二叉查找树 二叉查找树与普通的二叉树相比，有如下特点：所有节点彼此互异，即不存在相同的节点对于树中的任意节点 X，它的左子树中所有项的值均小于 X 中的项，而它的右子树中所有项的值均大于 X 中的项 下面是实现一个二叉查找树的代码： 从二叉查找树中移除元素是这部分的难点，首先定位到要移除元素所在节点，然后进行如下 3 种操作：如果当前节点为树叶，那么直接删除该树叶如果当前节点拥有一个子树，那么用该子树的根节点替换当前节点如果当前节点拥有两个子树，那么找出右子树中的最小节点并递归的删除该最小节点，然后将这个最小节点的值赋给当前节点的值（也可以采用相反的方式，去寻找左子树中的最大节点） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149class BinarySearchTree &#123; constructor(newValue) &#123; this.value = newValue; this.left = null; this.right = null; this.isNode = true; &#125; static makeTree(array) &#123; let tree = new BinarySearchTree(array[0]); array.slice(1).forEach((item) =&gt; &#123; tree.insert(item); &#125;); return tree; &#125; insert(newNode, currentNode = this) &#123; if (!newNode.isNode) &#123; newNode = new BinarySearchTree(newNode); &#125; if (newNode.value &lt; currentNode.value) &#123; if (currentNode.left) &#123; currentNode.insert(newNode, currentNode.left); &#125; else &#123; currentNode.left = newNode; &#125; &#125; if (newNode.value &gt; currentNode.value) &#123; if (currentNode.right) &#123; currentNode.insert(newNode, currentNode.right); &#125; else &#123; currentNode.right = newNode; &#125; &#125; if (newNode.value === currentNode.value) &#123; console.log(`$&#123;newNode.value&#125; already exists`); &#125; &#125; contains(inputValue, currentNode = this) &#123; if (inputValue &lt; currentNode.value) &#123; if (currentNode.left) &#123; return currentNode.contains(inputValue, currentNode.left); &#125; else &#123; return false; &#125; &#125; if (inputValue &gt; currentNode.value) &#123; if (currentNode.right) &#123; return currentNode.contains(inputValue, currentNode.right); &#125; else &#123; return false; &#125; &#125; if (inputValue === currentNode.value) &#123; return true; &#125; &#125; findMin(currentNode = this) &#123; if (currentNode.left) &#123; return currentNode.findMin(currentNode.left); &#125; else &#123; return currentNode.value; &#125; &#125; findMax(currentNode = this) &#123; if (currentNode.right) &#123; return currentNode.findMin(currentNode.right); &#125; else &#123; return currentNode.value; &#125; &#125; // preNode和where参数完全是为了删除树叶准备的 remove(inputValue, currentNode = this, preNode = null, where = "") &#123; if (inputValue &lt; currentNode.value) &#123; if (currentNode.left) &#123; currentNode.remove(inputValue, currentNode.left, currentNode, "left"); &#125; else &#123; console.log(`$&#123;inputValue&#125; does not exist`); &#125; &#125; if (inputValue &gt; currentNode.value) &#123; if (currentNode.right) &#123; currentNode.remove(inputValue, currentNode.right, currentNode, "right"); &#125; else &#123; console.log(`$&#123;inputValue&#125; does not exist`); &#125; &#125; if (inputValue === currentNode.value) &#123; if (!currentNode.left &amp;&amp; !currentNode.right) &#123; preNode[where] = null; return; &#125; if (!currentNode.left) &#123; currentNode = currentNode.right; return; &#125; else if (!currentNode.right) &#123; currentNode = currentNode.left; return; &#125; if (currentNode.left &amp;&amp; currentNode.right) &#123; let minValue = currentNode.right.findMin(); currentNode.remove(minValue, currentNode.right, currentNode, "right"); currentNode.value = minValue; return; &#125; &#125; &#125;&#125;let array = [6, 2, 8, 7, 1, 4, 3, 5], tree = BinarySearchTree.makeTree(array);function preOrderTraverse(node, result = "") &#123; result += node.value + " "; if (node.left) &#123; result = preOrderTraverse(node.left, result); &#125; if (node.right) &#123; result = preOrderTraverse(node.right, result); &#125; return result;&#125;console.log(preOrderTraverse(tree)); // 6 2 1 4 3 5 8 7tree.remove(4);console.log(preOrderTraverse(tree)); // 6 2 1 5 3 8 7tree.insert(4);console.log(preOrderTraverse(tree)); // 6 2 1 5 3 4 8 7tree.remove(41); // 41 does not existconsole.log(preOrderTraverse(tree)); // 6 2 1 5 3 4 8 7 AVL 树基本概念 AVL 树是带有平衡条件的二叉查找树平衡条件为每个节点的左子树和右子树的高度最多差 1（空树的高度定义为-1） 如果要对一个 AVL 树进行插入操作，需要更新通向根节点路径上那些节点的所有平衡信息，而插入操作隐含着困难的原因在于，插入一个节点可能破坏 AVL 树的平衡特性。如果发生这种情况，那么可以通过旋转来恢复 AVL 树的平衡 在一次插入之后，从插入点到根节点的路径上寻找其中深度最深（或高度最小）的不平衡节点，称该节点为 A，造成不平衡的插入分为下面四种情况：对 A 的左儿子的左子树进行一次插入对 A 的左儿子的右子树进行一次插入对 A 的右儿子的左子树进行一次插入对 A 的右儿子的右子树进行一次插入删除操作会出现的情况与插入类似，不单独介绍了。 情况 1 和情况 4 是关于 A 点的镜像对称，使用单旋转来处理，原理如下图所示 情况 2 和情况 3 也是关于点的镜像对称，使用双旋转来处理，原理如下图所示，因为子树 B 和 C 中有一颗比 D 深两层，但是我们不能肯定是哪一颗，所以图中 B 和 C 都被画成比 D 低 1.5 层 实现 我实现二叉查找树和 AVL 树的代码书写思路不同，最主要的区别是插入和删除操作是否有返回值。普通二叉树没有利用返回值，而 AVL 树的插入和删除操作都会返回新的 AVL 树 🌲！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229class AVLTree &#123; constructor(newValue) &#123; this.value = newValue; this.left = null; this.right = null; this.height = 0; this.isNode = true; &#125; static makeTree(array) &#123; let tree = new AVLTree(array[0]); array.slice(1).forEach((item) =&gt; &#123; tree = tree.insert(item); &#125;); return tree; &#125; insert(newNode, currentNode = this) &#123; if (!newNode.isNode) &#123; newNode = new AVLTree(newNode); &#125; if (newNode.value &lt; currentNode.value) &#123; if (currentNode.left) &#123; currentNode.left = currentNode.insert(newNode, currentNode.left); &#125; else &#123; currentNode.left = newNode; &#125; &#125; if (newNode.value &gt; currentNode.value) &#123; if (currentNode.right) &#123; currentNode.right = currentNode.insert(newNode, currentNode.right); &#125; else &#123; currentNode.right = newNode; &#125; &#125; if (newNode.value === currentNode.value) &#123; console.log(`$&#123;newNode.value&#125; already exists`); &#125; currentNode = currentNode.balanceTree(currentNode); return currentNode; &#125; // 只要树的结构发生改变就要触发这个函数 // 负责保持树的平衡和更新节点的高度信息 balanceTree(currentNode) &#123; function getTreeHeight(currentNode) &#123; if (!currentNode) &#123; return -1; &#125; else &#123; return currentNode.height; &#125; &#125; function rotateWithLeftChild(currentNode) &#123; let nextNode = currentNode.left; currentNode.left = nextNode.right; nextNode.right = currentNode; return nextNode; &#125; function rotateWithRightChild(currentNode) &#123; let nextNode = currentNode.right; currentNode.right = nextNode.left; nextNode.left = currentNode; return nextNode; &#125; function doubleWithLeftChild(currentNode) &#123; currentNode.left = rotateWithRightChild(currentNode.left); currentNode = rotateWithLeftChild(currentNode); return currentNode; &#125; function doubleWithRightChild(currentNode) &#123; currentNode.right = rotateWithLeftChild(currentNode.right); currentNode = rotateWithRightChild(currentNode); return currentNode; &#125; if ( getTreeHeight(currentNode.left) - getTreeHeight(currentNode.right) &gt; 1 ) &#123; if ( getTreeHeight(currentNode.left.left) &gt;= getTreeHeight(currentNode.left.right) ) &#123; currentNode = rotateWithLeftChild(currentNode); &#125; else &#123; currentNode = doubleWithLeftChild(currentNode); &#125; &#125; if ( getTreeHeight(currentNode.right) - getTreeHeight(currentNode.left) &gt; 1 ) &#123; if ( getTreeHeight(currentNode.right.right) &gt;= getTreeHeight(currentNode.right.left) ) &#123; currentNode = rotateWithRightChild(currentNode); &#125; else &#123; currentNode = doubleWithRightChild(currentNode); &#125; &#125; function updateHeight(currentNode) &#123; currentNode.height = Math.max( getTreeHeight(currentNode.left), getTreeHeight(currentNode.right) ) + 1; &#125; if (currentNode.left) &#123; updateHeight(currentNode.left); &#125; if (currentNode.right) &#123; updateHeight(currentNode.right); &#125; updateHeight(currentNode); return currentNode; &#125; remove(inputValue, currentNode = this) &#123; if (inputValue &lt; currentNode.value) &#123; if (currentNode.left) &#123; currentNode.left = currentNode.remove( inputValue, currentNode.left, currentNode, "left" ); &#125; else &#123; console.log(`$&#123;inputValue&#125; does not exist`); &#125; &#125; if (inputValue &gt; currentNode.value) &#123; if (currentNode.right) &#123; currentNode.right = currentNode.remove( inputValue, currentNode.right, currentNode, "right" ); &#125; else &#123; console.log(`$&#123;inputValue&#125; does not exist`); &#125; &#125; if (inputValue === currentNode.value) &#123; switch (true) &#123; case !currentNode.left &amp;&amp; !currentNode.right: currentNode = null; break; case !currentNode.left: currentNode = currentNode.right; break; case !currentNode.right: currentNode = currentNode.left; break; case currentNode.left &amp;&amp; currentNode.right: let minValue = currentNode.right.findMin(); currentNode = currentNode.remove( minValue, currentNode.right, currentNode, "right" ); currentNode.value = minValue; break; default: break; &#125; &#125; if (currentNode) &#123; currentNode = currentNode.balanceTree(currentNode); &#125; return currentNode; &#125;&#125;function preOrderTraverse(node, result = "") &#123; result += node.value + " "; if (node.left) &#123; result = preOrderTraverse(node.left, result); &#125; if (node.right) &#123; result = preOrderTraverse(node.right, result); &#125; return result;&#125;let array = [1, 2, 3, 4, 5, 6, 7, 16, 15], tree = AVLTree.makeTree(array);console.log(preOrderTraverse(tree)); // 4 2 1 3 6 5 15 7 16tree = tree.insert(14);console.log(preOrderTraverse(tree)); // 4 2 1 3 7 6 5 15 14 16tree = tree.remove(6);console.log(preOrderTraverse(tree)); // 4 2 1 3 7 5 15 14 16tree = tree.remove(5);console.log(preOrderTraverse(tree)); // 4 2 1 3 15 7 14 16 B 树 阶为 $M$ 的 B 树是一颗具有下列特性的 $M$ 叉树：数据全部存储在叶节点上；非叶节点最多可以存储 $M-1$ 个关键字，以指示搜索的方向。关键字 $i$ 代表子树 $i+1$ 中最小的关键字；树的根如果有子节点，则子节点个数一定在 2 和 $M$ 之间；除根外，所有非叶节点的子节点个数在 $\lceil M/2 \rceil$ 和 $M$ 之间；所有树叶的深度相同，并且每片树叶上存储的数据个数在 $\lceil L/2 \rceil$ 和 $L$ 之间。$L = 节点可容纳数据个数 = 节点容量/数据大小$ 树的练习判断二叉树是否平衡12345678910111213141516171819202122232425262728293031323334function isAVL (root) &#123; const stack = []; let cur = root; let lastHandled; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; stack.push(cur); cur = cur.left; &#125; if (stack.length &gt; 0) &#123; const topNode = stack[stack.length - 1]; if (topNode.right &amp;&amp; topNode.right !== lastHandled) &#123; cur = topNode.right; &#125; else &#123; const leftSonHeight = topNode.left ? topNode.left.height : -1; const rightSonHeight = topNode.right ? topNode.right.height : -1; if (Math.abs(leftSonHeight - rightSonHeight) &gt; 1) &#123; return false; &#125; &#123; topNode.height = Math.max(leftSonHeight, rightSonHeight) + 1; &#125; lastHandled = topNode; stack.pop(); &#125; &#125; &#125; return true;&#125;; 判断二叉树是否对称12345678910111213141516171819202122232425262728293031323334353637383940414243444546function isSymmetric (root) &#123; let queue = [root]; while (queue.length &gt; 0) &#123; const preLevelNodes = queue.slice(); queue = []; let isAllEmpty = true; preLevelNodes.forEach(item =&gt; &#123; if (!item) &#123; queue.push(null, null); &#125; else &#123; queue.push(item.left, item.right); if (item.left || item.right) &#123; isAllEmpty = false; &#125; &#125; &#125;); if (isAllEmpty) &#123; queue = []; &#125; // 如果想优化，可以将下面过程融合到上面到遍历过程中去 const len = queue.length; for (let i = 0; i &lt; len / 2; i++) &#123; // 两个都是空节点 if (!queue[i] &amp;&amp; !queue[len -i - 1]) &#123; continue; &#125; // 一个空节点，一个非空节点 if (!queue[i] || !queue[len -i - 1]) &#123; return false; &#125; // 两个都非空，但是值不相同 if (queue[i].val !== queue[len - i - 1].val) &#123; return false; &#125; &#125; &#125; return true;&#125;; 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function buildTree (preOrder, middleOrder) &#123; if (preOrder.length === 0 || middleOrder.length === 0) &#123; return null &#125; const root = &#123; val: preOrder[0], left: null, right: null, preOrder: preOrder, middleOrder: middleOrder, &#125;; const stack = []; let cur = root; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; const curPreOrder = cur.preOrder; const curMiddleOrder = cur.middleOrder; const splitIndex = curMiddleOrder.indexOf(cur.val); if (splitIndex === 0) &#123; cur.left = null; &#125; else &#123; cur.left = &#123; val: curPreOrder[1], preOrder: curPreOrder.slice(1, splitIndex + 1), middleOrder: curMiddleOrder.slice(0, splitIndex) &#125; &#125; stack.push(cur); cur = cur.left; &#125; if (stack.length &gt; 0) &#123; const topNode = stack.pop(); const curPreOrder = topNode.preOrder; const curMiddleOrder = topNode.middleOrder; const splitIndex = curMiddleOrder.indexOf(topNode.val); if (splitIndex &gt;= curPreOrder.length - 1) &#123; topNode.right = null; &#125; else &#123; topNode.right = &#123; val: curPreOrder[splitIndex + 1], preOrder: curPreOrder.slice(splitIndex + 1), middleOrder: curMiddleOrder.slice(splitIndex + 1), &#125; &#125; cur = topNode.right; &#125; &#125; return root&#125;; 二叉树的最近公共祖先1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function lowestCommonAncestor (root, p, q) &#123; if (!root) &#123; return null &#125; const stack = []; let cur = root; let lastHandled = null; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; stack.push(cur); cur = cur.left; &#125; if (stack.length &gt; 0) &#123; const topNode = stack[stack.length - 1]; if (topNode.right &amp;&amp; lastHandled !== topNode.right) &#123; cur = topNode.right; &#125; else &#123; if (topNode.val === p.val) &#123; topNode.isPRoot = true; &#125; if (topNode.val === q.val) &#123; topNode.isQRoot = true; &#125; if (topNode.left) &#123; if (topNode.left.isPRoot) &#123; topNode.isPRoot = true; &#125; if (topNode.left.isQRoot) &#123; topNode.isQRoot = true; &#125; &#125; if (topNode.right) &#123; if (topNode.right.isPRoot) &#123; topNode.isPRoot = true; &#125; if (topNode.right.isQRoot) &#123; topNode.isQRoot = true; &#125; &#125; if (topNode.isPRoot &amp;&amp; topNode.isQRoot) &#123; return topNode; &#125; lastHandled = topNode; stack.pop(); &#125; &#125; &#125; return null&#125;; 二叉搜索树转换为双向链表双向链表应按照从小到大顺序排列。 123456789101112131415161718192021222324252627282930313233343536373839function treeToDoublyList (root) &#123; if (!root) &#123; return null; &#125; const stack = []; let head; let prev; let cur = root; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; stack.push(cur); cur = cur.left; &#125; if (stack.length &gt; 0) &#123; const topNode = stack.pop(); if (!head) &#123; head = topNode; prev = topNode; &#125; else &#123; prev.right = topNode; topNode.left = prev; prev = topNode; &#125; cur = topNode.right; &#125; &#125; head.left = prev; prev.right = head; return head;&#125;; 二叉树剪枝如果一个子树的所有节点值都为 0，则剪除这个子树。 1234567891011121314151617181920212223242526272829303132333435363738394041function pruneTree (root) &#123; const stack = []; let cur = root; let lastHandled; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; stack.push(cur); cur = cur.left; &#125; if (stack.length &gt; 0) &#123; const topNode = stack[stack.length - 1]; if (topNode.right &amp;&amp; topNode.right !== lastHandled) &#123; cur = topNode.right; &#125; else &#123; if (topNode.left &amp;&amp; topNode.left.canDelete) &#123; topNode.left = null; &#125; if (topNode.right &amp;&amp; topNode.right.canDelete) &#123; topNode.right = null; &#125; if (topNode.val === 0 &amp;&amp; !topNode.left &amp;&amp; !topNode.right) &#123; topNode.canDelete = true; &#125; lastHandled = topNode; stack.pop(); &#125; &#125; &#125; if (root.canDelete) &#123; return null; &#125; return root&#125;; 二叉树子树的判断输入两棵二叉树 A 和 B，判断 B 是不是 A 的子树。B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。约定空树不是任意一个树的子树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function isValid (val) &#123; return typeof val === 'number';&#125;function buildArrayWithTree (tree) &#123; if (!tree) &#123; return []; &#125; const array = [tree.val]; let queue = [tree]; while (queue.length &gt; 0) &#123; const preLevelNodes = queue.slice(); queue = []; preLevelNodes.forEach(item =&gt; &#123; if (item) &#123; if (item.left) &#123; array.push(item.left.val); queue.push(item.left); &#125; else &#123; array.push(null); &#125; if (item.right) &#123; array.push(item.right.val); queue.push(item.right); &#125; else &#123; array.push(null); &#125; &#125; &#125;) &#125; return array;&#125;var isSubStructure = function (A, B) &#123; if (!A || !B) &#123; return false; &#125; const basicArray = buildArrayWithTree(B); const stack = []; let cur = A; while (cur || stack.length &gt; 0) &#123; while (cur) &#123; stack.push(cur); if (cur.val === B.val) &#123; const curArray = buildArrayWithTree(cur); const isSame = basicArray.every((val, i) =&gt; &#123; if (!isValid(val)) &#123; return true; &#125; return val === curArray[i]; &#125;) if (isSame) &#123; return true; &#125; &#125; cur = cur.left; &#125; if (stack.length &gt; 0) &#123; cur = stack.pop().right; &#125; &#125; return false;&#125; 二叉树任务调度]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[可编程的CSS]]></title>
    <url>%2Fposts%2F6abf3348%2F</url>
    <content type="text"><![CDATA[自定义属性 CSS的自定义属性（也叫做变量）是通过前缀--定义的区分大小写同一个变量可以在多个选择器内声明。读取的时候，优先级最高的声明生效，这与CSS的“层叠”规则是一致的var(&lt;custom-property-name&gt;, &lt;declaration-value&gt;?)用于读取变量。&lt;custom-property-name&gt;为变量名称，&lt;declaration-value&gt;为默认值声明变量的时候可以使用var() 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;CSS自定义属性&lt;/title&gt; &lt;style type="text/css"&gt; :root &#123; --first-color: red; --temporary-color: white; --second-color: var(--temporary-color); &#125; #firstParagraph &#123; background-color: var(--first-color); color: var(--second-color) &#125; #secondParagraph &#123; background-color: var(--second-color); color: var(--first-color) &#125; #container &#123; --first-color: green; &#125; #thirdParagraph &#123; background-color: var(--first-color); color: var(--second-color) &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="firstParagraph"&gt;This paragraph should have a red background and white text.&lt;/p&gt; &lt;p id="secondParagraph"&gt;This paragraph should have a white background and red text.&lt;/p&gt; &lt;div id="container"&gt; &lt;p id="thirdParagraph"&gt;This paragraph should have a green background and white text.&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; calc在CSS中使用calc()可是实现加、减、乘、除。 123width: calc(100% - 20px);--custom-height: calc(60% + 20px);height: calc(var(--custom-height) * 1.5); 通过JavaScript访问自定义属性 可以通过getComputedStyle().getPropertyValue()来访问在CSS中定义的变量变量是可继承的不允许修改变量值，否则会抛出错误 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;CSS自定义属性&lt;/title&gt; &lt;style type="text/css"&gt; :root &#123; --first-color: red; --second-color: white; &#125; #myDiv &#123; --first-color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv" style="width: 10px"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; let div = document.getElementById('myDiv') let computedStyle = document.defaultView.getComputedStyle(div, null) console.log(computedStyle['--first-color']) // undefined console.log(computedStyle.getPropertyValue('--first-color')) // green console.log(computedStyle.getPropertyValue('--second-color')) // white &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2Fposts%2Fcd65786b%2F</url>
    <content type="text"><![CDATA[基本概念 排序算法可以分为以下两种类型：比较类非线性时间排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破$O(nlogn)$非比较类线性时间排序：不通过比较来决定元素间的相对次序，其时间复杂度最低可以为$O(n)$稳定性：如果排序前后两个相等元素的相对次序不变，则算法稳定；反之算法不稳定 冒泡排序 实现步骤（从小到大排序）：从最前面的两个元素开始，不断对相邻元素进行比较，根据情况决定是否交换相邻元素的位置，直到最后。这会将最大的元素“冒泡”到元素列的末尾位置。步骤1需要被重复执行n-1次。但是每一趟排序时，不是全部元素都需要进行比较的。例如，对于第m趟排序，此时元素列最后面的m个元素是已经完成排序了的，所以不需要对它们进行重复的比较。最坏时间复杂度：$O(n^2)$平均时间复杂度：$O(n^2)$最好时间复杂度：$O(n)$空间复杂度：$O(1)$稳定性：稳定 1234567891011121314151617let list = [84, 83, 88, 87, 61, 50, 70, 60, 80]function bubbleSort (array) &#123; console.log(array.join(' ')) let len = array.length for (let i = 0; i &lt; len - 1; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (array[j] &gt; array[j+1]) &#123; [array[j], array[j+1]] = [array[j+1], array[j]] &#125; &#125; console.log(array.join(' ')) &#125;&#125;bubbleSort(list) 选择排序 实现步骤（从小到大排序）：共需要进行n-1次循环。每次循环都会选定一个起点元素，例如，第一次循环是以第一个元素为起点。第m次循环是以第m个元素为起点。在每次循环中，找出本次循环中从起点元素开始到最后一个元素为止最小的元素，如果这个元素正是起点元素则什么都不做，否则交换起点元素与该最小元素的位置。最坏时间复杂度：$O(n^2)$平均时间复杂度：$O(n^2)$最好时间复杂度：$O(n^2)$空间复杂度：$O(1)$稳定性：不稳定 1234567891011121314151617181920let list = [84, 83, 88, 87, 61, 50, 70, 60, 80]function selectionSort (array) &#123; console.log(array.join(' ')) let len = array.length let mixIndex for (let i = 0; i &lt; len - 1; i++) &#123; mixIndex = i for (let j = i + 1; j &lt; len; j++) &#123; if (array[j] &lt; array[mixIndex]) &#123; mixIndex = j &#125; &#125; [array[mixIndex], array[i]] = [array[i], array[mixIndex]] console.log(array.join(' ')) &#125;&#125;selectionSort(list) 插入排序 实现步骤（从小到大排序）：共需要进行n-1次循环。每次循环都会选定一个待插入元素，例如，第一次循环是以第二个元素为待插入元素。第m次循环是以第m+1个元素为待插入元素。在每次循环中，不断将待插入元素与处于它前方的元素进行比较，找出适合它的位置并插入。最坏时间复杂度：$O(n^2)$平均时间复杂度：$O(n^2)$最好时间复杂度：$O(n)$空间复杂度：$O(1)$稳定性：稳定 12345678910111213141516171819let list = [84, 83, 88, 87, 61, 50, 70, 60, 80]function insertionSort (array) &#123; console.log(array.join(' ')) let len = array.length for (let i = 1; i &lt; len; i++) &#123; let unsortValue = array[i] let currentIndex = i - 1 while ((currentIndex &gt;= 0) &amp;&amp; (array[currentIndex] &gt; unsortValue)) &#123; array[currentIndex + 1] = array[currentIndex] currentIndex-- &#125; array[currentIndex + 1] = unsortValue console.log(array.join(' ')) &#125;&#125;insertionSort(list) 希尔排序 实现步骤（从小到大排序）：按照步长n/2 =&gt; n/4 =&gt; ··· =&gt; 1进行循环。每次循环中根据步长对元素列进行分组，然后对这些分组执行插入排序。最坏时间复杂度：$O(n^2)$平均时间复杂度：$O(n^{1.3})$最好时间复杂度：$O(n)$空间复杂度：$O(1)$稳定性：不稳定 12345678910111213141516171819202122let list = [84, 83, 88, 87, 61, 50, 70, 60, 80]function shellSort (array) &#123; console.log(array.join(' ')) let len = array.length for (let gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123; // 内部为插入排序 for (let i = gap; i &lt; len; i++) &#123; let unsortValue = array[i] let currentIndex = i - gap while ((currentIndex &gt;= 0) &amp;&amp; (array[currentIndex] &gt; unsortValue)) &#123; array[currentIndex + gap] = array[currentIndex] currentIndex = currentIndex - gap &#125; array[currentIndex + gap] = unsortValue &#125; console.log(array.join(' ')) &#125;&#125;shellSort(list) 归并排序 实现步骤（从小到大排序）：不断地将元素列分成两个部分，然后对这两个部分递归执行归并排序。当元素列只有1个元素时，停止递归。对于被划分的两个部分，需要按照顺序将它们合并为一个整体。最坏时间复杂度：$O(nlogn)$平均时间复杂度：$O(nlogn)$最好时间复杂度：$O(nlogn)$空间复杂度：$O(n)$稳定性：稳定 123456789101112131415161718192021222324252627282930313233343536373839let list = [84, 83, 88, 87, 61, 50, 70, 60, 80]function mergeSort (array) &#123; let len = array.length if (len &lt; 2) &#123; return array &#125; else &#123; let middle = Math.floor(len / 2), left = array.slice(0, middle), right = array.slice(middle) return merge(mergeSort(left), mergeSort(right)) &#125;&#125;function merge (left, right) &#123; let result = [] while ((left.length &gt; 0) &amp;&amp; (right.length &gt; 0)) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; while (left.length) &#123; result.push(left.shift()) &#125; while (right.length) &#123; result.push(right.shift()) &#125; return result&#125;mergeSort(list) 快速排序 实现步骤（从小到大排序）：通过三数中值分割法，从元素列中选出最左侧，中间和最右侧的三个元素，并排序。从步骤1中排序后的三个元素中选择中间元素作为枢纽元素，并交换枢纽元素和元素列倒数第二个元素的位置。选择i = left + 1, j = right - 2。不断执行i++操作，直到i所处元素大于等于枢纽元素为止。不断执行j--操作，直到j所处元素小于等于枢纽元素为止。如果i &lt; j，那么交换这两个位置上的元素，然后重复执行步骤4、5。如果i &gt;= j，那么此刻位置i上的元素一定是大于等于枢纽元素的，此时交换位置i上的元素和枢纽元素的位置。交换之后，枢纽元素左侧的元素均小于等于它，而它右侧的元素均大于等于它。不断对被枢纽元素分割开来的两个子元素列执行步骤1至步骤7，直到排序完成。最坏时间复杂度：$O(n^2)$平均时间复杂度：$O(nlgn)$最好时间复杂度：$O(nlgn)$空间复杂度：$O(lgn)$ 至 $O(n)$ 之间稳定性：不稳定 需要注意array[i]=array[j]=pivot的情况，不要陷入死循环。为什么当所遇元素与枢纽元素相等时，也要让i和j停下来，并交换位置？这样可以确保被枢纽元素分割开来的两部分尽量均衡，减少插入排序算法总的时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667let list = [84, 83, 88, 87, 61, 50, 70, 60, 80]function quickSort (array, left, right) &#123; var left = typeof left !== 'number' ? 0 : left, right = typeof right !== 'number' ? array.length - 1 : right if (left === right) &#123; return &#125; if (left + 1 === right) &#123; if (array[left] &lt;= array[right]) &#123; return &#125; else &#123; [array[left], array[right]] = [array[right], array[left]] return &#125; &#125; let pivot = median3(array, left, right), i = left + 1, j = right - 2 while (i &lt; j) &#123; while (array[i] &lt; pivot) &#123; i++ &#125; while (pivot &lt; array[j]) &#123; j-- &#125; if (i &lt; j) &#123; if (array[i] === array[j]) &#123; i++ &#125; else &#123; [array[i], array[j]] = [array[j], array[i]] &#125; &#125; if (i &gt;= j) &#123; break &#125; &#125; [array[i], array[right - 1]] = [array[right - 1], array[i]] quickSort(array, left, i - 1) quickSort(array, i + 1, right)&#125;function median3 (array, left, right) &#123; let center = Math.floor((left + right) / 2) if (array[center] &lt; array[left]) &#123; [array[left], array[center]] = [array[center], array[left]] &#125; if (array[right] &lt; array[left]) &#123; [array[left], array[right]] = [array[right], array[left]] &#125; if (array[right] &lt; array[center]) &#123; [array[center], array[right]] = [array[right], array[center]] &#125; [array[center], array[right - 1]] = [array[right - 1], array[center]] return array[right - 1]&#125;quickSort(list) 堆排序 实现步骤（从小到大排序）：首先将元素列转换为最大堆形式的数组。数组中的最大元素总在 A[1] 中，把它与 A[heap.size] 进行互换，同时从堆中去掉最后一个结点（这一操作可以通过减少 heap.size 来实现）。步骤 2 之后，最大堆的剩余结点中，原来根的孩子结点仍然是最大堆，而新的根节点可能会违背最大堆的性质。为了维护最大堆的性质，我们要做的就是通过下滤操作使其符合最大堆的性质。重复步骤 2、3，直到 heap.size = 1。最坏时间复杂度：$O(nlgn)$平均时间复杂度：$O(nlgn)$最好时间复杂度：$O(nlgn)$空间复杂度：$O(1)$稳定性：不稳定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let list = [90, 84, 83, 88, 87, 61, 50, 70, 60, 80]function heapSort (array) &#123; let heap = buildHeap(array); for (let i = heap.size; i &gt; 1; i--) &#123; [heap[i], heap[1]] = [heap[1], heap[i]]; heap.size--; percolateDown(heap, 1); &#125; return heap.slice(1)&#125;function buildHeap (array) &#123; let heap = []; heap.size = array.length; for (let i = 0; i &lt; array.length; i++) &#123; heap[i + 1] = array[i]; &#125; let currentIndex = Math.floor(heap.size / 2) while (currentIndex &gt; 0) &#123; percolateDown(heap, currentIndex); currentIndex--; &#125; return heap&#125;function percolateDown (heap, currentIndex) &#123; let leftSonIndex = 2 * currentIndex, rightSonIndex = 2 * currentIndex + 1, maxValueIndex = currentIndex; if (leftSonIndex &lt;= heap.size &amp;&amp; heap[leftSonIndex] &gt; heap[currentIndex]) &#123; maxValueIndex = leftSonIndex; &#125; if (rightSonIndex &lt;= heap.size &amp;&amp; heap[rightSonIndex] &gt; heap[maxValueIndex]) &#123; maxValueIndex = rightSonIndex; &#125; if (currentIndex !== maxValueIndex) &#123; [heap[currentIndex], heap[maxValueIndex]] = [heap[maxValueIndex], heap[currentIndex]]; percolateDown(heap, maxValueIndex); &#125;&#125;console.log(heapSort(list)) // [ 50, 60, 61, 70, 80, 83, 84, 87, 88, 90 ] 计数排序 实现步骤（从小到大排序）：假设元素列中的元素均处于 $[0, k]$ 区间内，$k$ 为某个整数。准备一个长度为 $k+1$ 的数组 temp，索引为 $i$ 处记录着元素列中值为 $i$ 的元素的个数。调整数组 temp，使得索引为 $i$ 处记录着元素列中值小于等于 $i$ 的元素的个数。准备一个长度为 $n$ 的数组 res 用于存储排序后的元素列，然后从后至前的迭代待排序的元素列，根据 temp 确定每次迭代的元素应该处于哪个位置，同时对 temp 进行适当的修改。时间复杂度：$\Theta(n+k)$空间复杂度：$O(n+k)$稳定性：稳定 1234567891011121314151617181920212223242526272829303132let list = [2, 5, 3, 0, 2, 3, 0, 3];function countingSort (array) &#123; let temp = []; array.forEach(item =&gt; &#123; if (typeof temp[item] === 'number') &#123; temp[item] = temp[item] + 1; &#125; else &#123; temp[item] = 1; &#125; &#125;) for (let i = 0; i &lt; temp.length; i++) &#123; let cur = typeof temp[i] === 'number' ? temp[i] : 0; if (i === 0) &#123; temp[i] = cur; &#125; else &#123; temp[i] = cur + temp[i - 1]; &#125; &#125; let res = []; for (let i = array.length - 1; i &gt;= 0; i--) &#123; let value = array[i]; res[temp[value] - 1] = value; temp[value] = temp[value] - 1; &#125; return res&#125;console.log(countingSort(list)); // [ 0, 0, 2, 2, 3, 3, 3, 5 ] 桶排序 实现步骤（从小到大排序）：假设元素列中的元素均处于 $[0, 1）$ 区间内。准备一个长度为 10 的数组 temp。假设元素的值为 $x$，则将它放入 temp 数组索引为 $\lfloor 10x \rfloor$ 的位置。对数组 temp 下的每个“桶”进行排序，然后将排序后的“桶”拼接在一起。时间复杂度：需要考虑每个桶内排序所消耗的时间空间复杂度：$O(n+k)$稳定性：稳定 12345678910111213141516171819202122232425262728293031323334let list = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]function bucketSort (array) &#123; let temp = Array.from(Array(10), () =&gt; []); array.forEach(item =&gt; &#123; let index = Math.floor(item * 10); temp[index].push(item); &#125;) temp = temp.map(item =&gt; &#123; if (temp.length &gt; 0) &#123; insertionSort(item) &#125; return item &#125;) return [].concat(...temp)&#125;function insertionSort (array) &#123; let len = array.length for (let i = 1; i &lt; len; i++) &#123; let unsortValue = array[i] let currentIndex = i - 1 while ((currentIndex &gt;= 0) &amp;&amp; (array[currentIndex] &gt; unsortValue)) &#123; array[currentIndex + 1] = array[currentIndex] currentIndex-- &#125; array[currentIndex + 1] = unsortValue &#125;&#125;console.log(bucketSort(list)) // [ 0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94 ] 基数排序 实现步骤（从小到大排序）：从最低有效位开始，依次根据当前位的关键字对元素列使用稳定排序算法进行排序。时间复杂度：给定 $n$ 个 $d$ 位数，其中每一个数位有 $k$ 个可能的取值。如果使用的稳定排序方法耗时 $\Theta(n+k)$，那么它就可以在 $\Theta(d(n+k))$ 时间内将这些数排好序。给定一个 $b$ 位数和任何正整数 $r \leq b$，如果使用稳定排序算法对数据取值区间为 $[0, k]$ 的输入进行排序耗时 $\Theta(n+k)$，那么它就可以在 $\Theta((b/r)(n+2^r))$ 时间内将这些数排好序。空间复杂度：由过程中使用的稳定排序算法决定稳定性：稳定 1234567891011121314151617181920212223242526272829303132333435363738394041424344let list = [329, 457, 657, 839, 436, 720, 355, 11, 20, 4];function radixSort (array, d) &#123; array = array.map(item =&gt; &#123; let str = String(item), len = str.length; return '0'.repeat(d - len) + str &#125;) for (let i = d - 1; i &gt;= 0; i--) &#123; let temp = []; array.forEach(item =&gt; &#123; if (typeof temp[item[i]] === 'number') &#123; temp[item[i]] = temp[item[i]] + 1; &#125; else &#123; temp[item[i]] = 1; &#125; &#125;) for (let j = 0; j &lt; temp.length; j++) &#123; let cur = typeof temp[j] === 'number' ? temp[j] : 0; if (j === 0) &#123; temp[j] = cur; &#125; else &#123; temp[j] = cur + temp[j - 1]; &#125; &#125; let res = []; for (let j = array.length - 1; j &gt;= 0; j--) &#123; let value = array[j], singleValue = array[j][i]; res[temp[singleValue] - 1] = value; temp[singleValue] = temp[singleValue] - 1; &#125; array = res; &#125; return array.map(item =&gt; parseInt(item))&#125;console.log(radixSort(list, 3)); // [ 4, 11, 20, 329, 355, 436, 457, 657, 720, 839 ]]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对docker数据持久化的理解]]></title>
    <url>%2Fposts%2F9d0d99dd%2F</url>
    <content type="text"><![CDATA[背景项目需要读取本地的一个文件，采用的方式是挂载本地目录作为volume。但是在将这个项目部署到远端服务器时，项目image可以直接拉取，而项目所需文件的迁移就成了问题 解决方案 创建一个专门用于COPY数据的image，起名为data-image:1.0接着就可以远程访问服务器，创建docker-compose.yml文件，通过挂载volume的方式实现数据共享到此为止就可以拉取镜像、启动服务了 1234# DockerfileFROM alpineCOPY ./data /usr/src/data 12345678910111213141516# docker-compose.ymlversion: '3'services: project: image: project-image volumes: - project-data:/usr/src/data data-container: image: data-image:1.0 volumes: - project-data:/usr/src/datavolumes: project-data: 总结 只有volume可以做到数据持久化，image内的数据是无法被更改的当项目启动后对依赖文件的改动会被记录在project-data中，而两个image中/usr/src/data目录下的内容会一直保持它们最开始的状态启动服务后，project-data会被挂载到两个container上，实现数据的共享，这个时候两个container中/usr/src/data目录下的内容与project-data同步如果删除了project-data，则对依赖文件的改动会丢失]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML标签]]></title>
    <url>%2Fposts%2F500cdacf%2F</url>
    <content type="text"><![CDATA[HTML标签大全太多了，整理一会之后果断放弃，MDN上的介绍 HTML模板1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="renderer" content="webkit" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt; &lt;meta name="description" content="简介" /&gt; &lt;meta name="keywords" content="关键字" /&gt; &lt;meta name="author" content="作者" /&gt; &lt;title&gt;题目&lt;/title&gt; &lt;link rel="apple-touch-icon" href="/apple-touch-icon.png" /&gt; &lt;link rel="icon" href="/favicon.ico" /&gt; &lt;link rel="stylesheet" href="style.css" type="text/css" /&gt; &lt;style type="text/css"&gt; /* CSS内部样式表 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里放内容 --&gt; &lt;script type="text/javascript" src="example.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; a标签 &lt;a&gt;标签代表一个超链接，它有如下属性：download：这个属性用于指示浏览器去下载href所指向的资源而不是进行页面跳转。如果给download属性设置一个值，这个值将是对应资源被保存成本地文件过程中的默认名称。href：URL。hreflang：用于指定链接资源的人类语言ping：包含一个以空格分隔的 URL 列表，当跟随超链接时，将由浏览器发送带有正文的 PING 的 POST 请求，通常用于跟踪。rel：该属性执行了目标对象到链接对象的关系。该值是空格分隔的列表类型值。target：该属性指定在何处显示链接的资源。它的值包括：_self、_blank、_parent和_top。type：该属性指定在一个 MIME type 链接目标的形式的媒体查询。其仅提供建议，并没有内置的功能。&lt;a&gt;标签还有四个伪类：link：具有href属性。visited：被访问过。hover：鼠标悬浮。active：鼠标点击瞬间。 下面展示一个使用download属性的例子。 1&lt;a download="国旗" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALYAAAB5CAMAAACjkCtXAAAAe1BMVEX/AAD////XsbH0RETe2dnToqLi7e3wVVX80Rb80xb81Rb82Bf/MQX/JQT8xhX/FwL8yxX+VQn/Ogb83Rf8whT9nBD+TAj9jw/9lQ/9rhL9uBP8uxT+bgv9ohDGv7/SuLj9hA3+XQj9eAn+fw39qBL+Qwf+ZQv2OzvmbW2v1N+9AAACiklEQVR4nO3ZCW+bMByHYdjpg8PcEMhKUpL2+3/CORs9osUGofFzUP6vlKpqFfTINTZOPd//9WVTPf3wfd/z/e/epvpJbGDERkZsZMRGRmxkxEb2YOxkFc3slrLzVTSzW8QOgpIlQbCWaUaL2D0XnMsqXAs13bJJEkZSOZ3dy9ixGMRhJdGslrH73uuKlUSzmmbHN36Wji9nTbKT9pb7UxO/XqdJdp+drBeIq/9umtEku8mO1guEuYv1e4qtl7q95e1VUbCi6OETZYp9YDy3bCtpoTeeAX93TrGfBVel7QIqixzsllPsvWDCNrnPUZLbJ/8qGdjp+HePW82ux+/TG8N6TL3gbtipEoypdqgqxvTk7usmV4zJAe8zZBjtQ5RxLoSU7OKWUug7L2ucboxXGed2zwT7nIgcH2iuMt+S5S7jH+isdnkq+CfbSnKM3txiZ10E8VkXwHJ0i8HhQeZmdvY4vXlkvkDsZHmxsmu9kPDLgGfm2/H+HqUCxZlQjdBfTUNaNQ1vmuquHqWOeofkZz3mnCvDQ3dYSS4cHOEt7HgnRH7hdkzTTBdQKnIwSyzskxTt30Hu9GZjeH/Xlrvn9XimLOwiG97m7CnPzrff340vcGZ2HNUfd9qptZ1x8FlG+/pGc3JAN/Zgn297idNHq8XsYYMfXSaHkvXJ2d0D1jL2KWec8Xol04yWTpJGSpezZCE7zAflYHN8byG7q7xgv7l/gvzZikKHO9CjbTduIzYyYiMjNjJiIyM2MmIjIzYyYiMjNjJiIyM2MmIjIzYyYiMjNjJiIyM2MmIjIzYyYiMjNjJiIyM2MmIjIzYyYiMjNjJiIyM2MmIje2e/fN1SryP728Ya2Vtso+zffNMqoOoYARcAAAAASUVORK5CYII="&gt;下载图片&lt;/a&gt; input标签 &lt;input&gt;标签用于接受来自用户的数据。它有如下属性：autocomplete：一个字符串，描述输入应提供的任何类型的自动完成功能。自动完成的典型实现只是回忆在同一输入字段中输入的先前值，但可以存在更复杂的自动完成形式。例如，浏览器可以与设备的联系人列表集成，以在电子邮件输入字段中自动完成电子邮件地址。不过当type属性值为button、file等时，&lt;input&gt;不会返回文本或数值数据，此时autocomplete属性将被忽略。autofocusdisabledform：该属性值为一个&lt;form&gt;的id，用于指示该&lt;input&gt;是属于它的。如果缺失，则该&lt;input&gt;属于最近的&lt;form&gt;或者不属于任何&lt;form&gt;。list：该属性值为一个&lt;datalist&gt;的id，&lt;datalist&gt;用于为该&lt;input&gt;提供建议列表。name：该&lt;input&gt;的名称，与表单数据一起提交。readonlyrequiredtabindex：该&lt;input&gt;在当前文档的 Tab 导航顺序中的位置。type：该&lt;input&gt;的类型。包括：button、checkbox、color、date、datetime-local、email、file、hidden、image、month、number、password、radio、range、reset、search、submit、tel、text、time、url、week。value：该&lt;input&gt;的当前值。 meta标签&lt;meta&gt;标签中包含那些不能被&lt;base&gt;、&lt;link&gt;、&lt;script&gt;、&lt;style&gt;和&lt;title&gt;标签所表示的内容。并且&lt;meta&gt;标签一次只干一件事，如果想利用&lt;meta&gt;标签设置多个内容，那就多写几个&lt;meta&gt;标签。它有如下属性： charset：该属性表明了页面的编码方式，通常为UTF-8。content：该属性值对应于http-equiv属性或name属性的值。http-equiv：该属性定义 HTTP 的一些首部字段，对应的首部字段值在content属性中。content-security-policy：定义页面的内容安全策略，内容策略主要指定允许的服务器源和脚本端点，这有助于防止 XSS 攻击。refresh：如果content属性值是一个正整数，则该正数代表页面重载的时间间隔（秒）。如果content属性值是一个正整数，并且后面跟着;url=和一个合法的 URL，则页面将在指定秒数后进行跳转。name：该属性定义能定义如下内容，同样的，这些内容的值在content属性中。author：定义作者。description：定义页面的描述信息。在你收藏一个页面时，描述信息就是来自于这里的。generator：生成页面的软件的标识符。keywords：用,分隔的关键词。referrer：控制所有从页面发出的 HTTP 请求的Referer首部字段。下面所述的页面的源包含协议、域名和端口。no-referrer：不发送Referer首部字段。origin：发送页面的源。no-referrer-when-downgradeorigin-when-cross-origin：对于与页面同源的请求发送页面完整的 URL，与页面不同源的请求只发送页面的源。same-origin：对于与页面同源的请求发送页面的源，与页面不同源的请求不发送Referer首部字段。strict-originstrict-origin-when-cross-originunsafe-URL：发送页面完整的 URL。theme-color：建议客户端应该用来使用的主题颜色。color-scheme：指定一个或多个主题颜色。normal[light | dark]+only lightcreator：定义网页作者，即一个组织或者机构的名称。googlebotpublisher：定义网页发布者。robotsslurpviewport：专门用于为移动端设备定义视口的大小。widthheightinitial-scalemaximum-scaleminimum-scaleuser-scalable]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[媒体查询]]></title>
    <url>%2Fposts%2Fd62e352c%2F</url>
    <content type="text"><![CDATA[媒体类型 all：所有媒体braile：盲文触觉设备embossed：盲文打印机handheld：手持设备print：打印预览或打印机projection：项目演示screen：彩屏设备speech：听觉类似的媒体tty：不适用像素的设备，如电传打字机tv：电视 媒体特性 以下特性，除scan和grid外，都可以加上min或max前缀以指定范围width：视口宽度height：视口高度device-width：渲染表面的宽度（可以认为是设备屏幕的宽度）device-height：渲染表面的高度（可以认为是设备屏幕的高度）orientation：设备方向是水平还是垂直aspect-ratio：视口的宽高比。如16:9的宽屏显示器可以写成aspect-ratio: 16/9color：颜色组分的位深。如min-color: 16表示设备至少支持16位深color-index：设备颜色查找表中的条目数，值必须是数值，且不能为负monochrome：单色帧缓冲中表示每个像素的位数，值必须是数值（整数），且不能为负resolution：屏幕或打印分辨率。如min-resolution: 300dpi，也可以接受每厘米多少点，如min-resolution: 118dpcmscan：针对电视的逐行扫描（progressive）和隔行扫描（interlace）grid：设备基于栅格还是位图 媒体查询方式link标签的media属性在&lt;link&gt;标签的media属性中指定媒体查询是CSS2的方式 1&lt;link rel="stylesheet" type="text/css" media="screen" href="screenstyles.css" /&gt; @media@media是在样式表中使用的媒体查询方式 1@media screen &#123; ... &#125; @import@import可以根据媒体查询将其他样式表加载到当前样式表中 1@import url("phone.css") screen 媒体查询语法 and：类似于逻辑与,：类似于逻辑或not：用于对整个媒体查询取反only：指定某种特定的媒体类型，用来对那些不支持媒体特性但支持媒体类型的设备隐藏样式表 1234567891011121314151617/* 当设备是彩屏设备并且视口最小宽度大于等于400px时生效 */@media screen and (min-width: 400px) &#123; ... &#125;/* 当设备垂直或者视口最小宽度大于等于400px时生效 */@media (orientation: portrait), (min-width: 400px) &#123; ... &#125;/* 当视口最小宽度小于400px时生效 */@media not all and (min-width: 400px) &#123; ... &#125;/* 等价于 */@media not (all and (min-width: 400px)) &#123; ... &#125;/* 而不是 */@media (not all) and (min-width: 400px) &#123; ... &#125;@media only screen and (min-width: 400px) &#123; ... &#125;]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字体和文本]]></title>
    <url>%2Fposts%2F9e9287fd%2F</url>
    <content type="text"><![CDATA[字体是“文字的不同体式”或者“字的形体结构”。对于英文而言，每种字体都是由一组具有独特样式的字母、数字和符号组成的。 文本就是一组字或字符，比如章标题、段落正文等等，跟使用什么字体无关。 字体属性 网页中的字体有三个来源：用户机器中安装的字体；保存在第三方网站上的字体；保存在你的Web服务器上的字体。 font-familyfont-family用于设定元素中的文本使用什么字体，它是可以继承的属性，因此它的值会遗传给所有后代元素。一般来说，应该给整个页面设定一种主字体，然后只对那些需要使用不同字体的元素再应用font-family。要为整个页面指定字体，可以设定&lt;body&gt;元素的font-family属性。 1body &#123; font-family: verdana, sans-serif; &#125; 用户机器上的字体是随操作系统一起安装的，可以由本地应用共享。每种操作系统自带的字体不多，而且用户随时会安装或删除字体，因此我们永远也不敢保证一定能使用某种字体来显示网页。为此，在指定文本的字体时，需要多列出几种后背字体，以防第一种字体无效。这个字体的列表也叫字体栈。 font-size font-size属性是可继承的设定字体大小时可以使用：绝对单位：px相对单位：百分比、em、rem关键字：x-small、medium、x-large等如果你给某个元素设定了相对字体大小，则该元素的字体大小要相对于最近的“被设定过字体大小”的祖先元素来确定。rem单位比较特殊，它只是相对于&lt;html&gt;根元素 font-style font-style设定字体是斜体还是正体，它的值有：italic（斜体）、oblique（正体）和normal font-weight font-weight设定字体粗细，它的值可以是：100、200…900，或者lighter、normal、bold或bolder font-variant font-variant的值只能是：small-caps和normal。small-caps会让小写英文字母变为小型大写字母 font font是字体的简写属性使用font时必须声明font-size和font-family的值使用font时必须按照如下顺序：font-weight、font-style、font-variant不分先后然后是font-size最后是font-family实际上，在设定font-size属性的同时，可以顺便设定line-height的值，如12px/1.5 文本属性text-indent text-indent属性设定行内盒子相对于包含元素的起点。默认情况下，这个起点就是包含元素的左上角text-indent的值可正、可负text-indent属性是可以被继承的，它继承的是经过计算之后的绝对值 letter-spacing letter-spacing属性用于调整字符间距，为负值时缩小间距。无论设定字体大小时使用的是什么单位，设定字符间距一定要用相对单位，以便字符间距跟随字体大小同比例变化 word-spacing word-spacing属性用于调整单词间距 text-decoration text-decoration属性的值：underline、overline、line-through、blink、none text-align text-align属性的值：left、right、center、justifycenter值也可以用来在较大的元素中居中较小的固定宽度的元素或图片 line-height line-height属性用于指定文本的行高如果line-height的值是不包含单位的数值，那么行高就是数值 * 字体大小 text-transform text-transform属性的值：none、uppercase、lowercase、capitalize vertical-align vertical-align属性的值：sub、super、top、middle、bottom或任意长度值 word-break word-break属性的值：normal、break-all、keep-all、break-word text-overflow text-overflow属性的值：clip、ellipsis、&lt;string&gt;text-overflow属性只对那些在块级元素溢出的内容有效 123456789101112131415161718192021/* Overflow behavior at line end Right end if ltr, left end if rtl */text-overflow: clip;text-overflow: ellipsis;text-overflow: "…";text-overflow: fade;text-overflow: fade(10px);text-overflow: fade(5%);/* Overflow behavior at left end | at right end Directionality has no influence */text-overflow: clip ellipsis;text-overflow: "…" "…";text-overflow: fade clip;text-overflow: fade(10px) fade(10px);text-overflow: fade(5%) fade(5%);/* Global values */text-overflow: inherit;text-overflow: initial;text-overflow: unset; white-space white-space属性的值：normal、nowrap、pre、pre-wrap、pre-linewhite-space属性只对那些在块级元素溢出的内容有效 text-shadow text-shadow: &lt;offset-x&gt; &lt;offset-y&gt; &lt;blue-radius&gt; &lt;color&gt;：&lt;offset-x&gt;（必选）：阴影水平偏移量&lt;offset-y&gt;（必选））：阴影垂直偏移量&lt;blue-radius&gt;（可选）：该值越大，阴影面积越大，阴影就越大越淡。不能为负值。默认为0，此时阴影边缘锐利&lt;color&gt;（可选）：颜色。默认颜色由浏览器决定如果想设置多个阴影，则不同阴影规则之间需要使用逗号分隔 文字版式具体的文字版式设计可以看《CSS权威指南》的4.4节]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[背景]]></title>
    <url>%2Fposts%2F28d95575%2F</url>
    <content type="text"><![CDATA[背景结构图 background-color通过这个属性可以指定盒模型的背景颜色。 background-image格式为：background-image: url(图片路径/图片文件名)。 background-repeat该属性用于定义背景图片的重复方式。 background-position该属性用于定义背景图片的位置，该属性的值可以是：关键字、百分比、绝对或相对单位的数值，也可以将关键字与百分比或数值配合使用。 关键字包括：top、right、bottom、left和center。 background-size该属性用于定义背景图片的大小。 background-attachment该属性用于定义背景图片是否随元素滚动而移动。这个属性的默认值是scroll，即背景图片随元素移动。如果把它的值改为fixed，那么背景图片不会随元素滚动而移动。 background-clip该属性用于定义背景图片的覆盖范围。 background-origin该属性用于定义背景图片的起点位置。 background background属性是有关背景的简写属性，这里需要注意的是，当background-position和background-size同时出现时，应写为background-position/background-size。且如果想指定background-size，则必须指定background-position，否则背景图片不会呈现。 多背景图片直接上例子： 123456#background-demo &#123;background: url(images/demo1.png) 20px -10px no-repeat, url(images/demo2.png) 145px 0px no-repeat, url(images/demo3.png) 14px -30px no-repeat, #ffbd75;&#125; 在background中先定义的背景图片显示在上方，或者说更接近前景。所以demo1.png显示在最上方，demo3.png在最下方。 背景渐变background-image属性除了可以指定背景图片外，还可以定义背景的渐变效果。 linear-gradient linear-gradient使用步骤：确定渐变方向：渐变方向有两种定义方式：关键字和角度。当未指定渐变方向时，默认为to bottom，也叫作180deg；在渐变方向的不同位置处，定义渐变点：渐变点的个数不能少于两个。如果为同一个渐变点设定两种颜色，会得到突变效果。 首先通过下图理解渐变方向。 然后就可以上例子了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id="outer"&gt; &lt;div id="a"&gt;a&lt;/div&gt; &lt;div id="b"&gt;b&lt;/div&gt; &lt;div id="c"&gt;c&lt;/div&gt; &lt;div id="d"&gt;d&lt;/div&gt; &lt;div id="e"&gt;e&lt;/div&gt; &lt;div id="f"&gt;f&lt;/div&gt;&lt;/div&gt; &lt;style type="text/css"&gt;#outer &#123; display: flex; width: 700px; align-items: center; flex-wrap: wrap; justify-content: space-between; color: white; font-size: 30px;&#125;div &#123; margin-top: 40px; width: 200px; height: 200px;&#125;#a &#123; background-image: linear-gradient(red, blue);&#125;#b &#123; background-image: linear-gradient(to bottom right, red, blue);&#125;#c &#123; background-image: linear-gradient(90deg, red, blue);&#125;#d &#123; background-image: linear-gradient(red 20%, yellow 50%, blue 80%);&#125;#e &#123; background-image: linear-gradient(red 30%, blue 30%);&#125;#f &#123; background-image: linear-gradient(45deg, red 30%, blue 30%);&#125;&lt;/style&gt; radial-gradient linear-gradient时需要设置渐变方向。而使用radial-gradient时则需要设置渐变的形状、大小和位置：形状：circle或ellipse（默认）；大小：closest-side：渐变从圆形（或椭圆形）中心开始，到距离中心最近的边终止；closest-corner：渐变从圆形（或椭圆形）中心开始，到距离中心最近的角终止；farthest-side：渐变从圆形（或椭圆形）中心开始，到距离中心最远的边终止；farthest-corner：渐变从圆形（或椭圆形）中心开始，到距离中心最远的角终止；12rem：会生成一个直径为12rem的圆；40px 30px：会生成一个X方向宽40像素、Y方向高30像素的椭圆形。位置：使用at定义渐变中心的位置，例如at center或at top 100px right。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id="outer"&gt; &lt;div id="a"&gt;a&lt;/div&gt; &lt;div id="b"&gt;b&lt;/div&gt; &lt;div id="c"&gt;c&lt;/div&gt; &lt;div id="d"&gt;d&lt;/div&gt; &lt;div id="e"&gt;e&lt;/div&gt; &lt;div id="f"&gt;f&lt;/div&gt;&lt;/div&gt; &lt;style type="text/css"&gt;#outer &#123; display: flex; width: 700px; align-items: center; flex-wrap: wrap; justify-content: space-between; color: white; font-size: 30px;&#125;div &#123; margin-top: 40px; width: 200px; height: 200px;&#125;#a &#123; background-image: radial-gradient(red, blue);&#125;#b &#123; background-image: radial-gradient(closest-side, red 50%, blue 50%);&#125;#c &#123; background-image: radial-gradient(closest-corner, red 50%, blue 50%);&#125;#d &#123; background-image: radial-gradient(circle closest-side at top 45px left 45px, red 20%, yellow 20%, blue 50%);&#125;#e &#123; background-image: radial-gradient(ellipse 200px 100px at bottom left , red 20%, yellow 50%, blue 80%);&#125;#f &#123; background-image: radial-gradient(circle closest-corner at 100%, red, red 50%, yellow 75%, blue 75%);&#125;&lt;/style&gt; 重复渐变规则相同，就是在前面加上repeating-前缀]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2Fposts%2Fee1ff2c0%2F</url>
    <content type="text"><![CDATA[浮动float的初衷首先介绍引入float属性的初衷：为了实现文字环绕图片的效果，就像下面的例子： 12345&lt;div style="width: 500px; border: 1px solid black;"&gt; &lt;img src="https://mdn.mozillademos.org/files/13340/butterfly.jpg" alt="A pretty butterfly with red, white, and brown coloring, sitting on a large leaf" style="float: left"&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.&lt;/p&gt;&lt;/div&gt; 利用float布局 在此之后，人们开始利用float属性进行布局，不过需要了解如下内容：一定要为浮动元素设置宽度。当前一个元素非浮动，后一个元素浮动时，浮动元素在原水平位置向左或向右浮动。当前一个元素浮动，后一个元素也浮动时，后一个元素会在宽度允许的条件下与前一个元素挤在同一行。如果两个元素都是向左浮动，且前一个元素宽度过大导致两个元素无法放置在同一行，这个时候如果给后一个浮动元素设置适当的负的左边距，那么它会浮动上去与前一个元素发生重叠（默认后一个元素在上方）。当前一个元素浮动，后一个元素非浮动时，如果后一个元素不是BFC，则会发生重叠。如果后一个元素是BFC，则不会发生重叠。 围住浮动元素浮动元素脱离了文档流，其父元素也看不到它了，因而也不会包围它。 123456&lt;div style="width: 500px; border: 1px solid black;"&gt; &lt;img src="https://mdn.mozillademos.org/files/13340/butterfly.jpg" alt="A pretty butterfly with red, white, and brown coloring, sitting on a large leaf" style="float: left"&gt; &lt;p&gt;It is fun to float.&lt;/p&gt;&lt;/div&gt;&lt;footer style="width: 500px; border: 1px solid black;"&gt;Here is the footer element runs across the bottom of the page.&lt;/footer&gt; 这个效果明显不是我们实际想要的，为了解决这个问题，介绍下面几种让父元素围住子元素的方法。 下面几种方案的效果都是一致的，如下所示： 利用overflow123456&lt;div style="width: 500px; border: 1px solid black; overflow: hidden;"&gt; &lt;img src="https://mdn.mozillademos.org/files/13340/butterfly.jpg" alt="A pretty butterfly with red, white, and brown coloring, sitting on a large leaf" style="float: left"&gt; &lt;p&gt;It is fun to float.&lt;/p&gt;&lt;/div&gt;&lt;footer style="width: 500px; border: 1px solid black;"&gt;Here is the footer element runs across the bottom of the page.&lt;/footer&gt; 同时浮动父元素123456&lt;div style="width: 500px; border: 1px solid black; float: left;"&gt; &lt;img src="https://mdn.mozillademos.org/files/13340/butterfly.jpg" alt="A pretty butterfly with red, white, and brown coloring, sitting on a large leaf" style="float: left"&gt; &lt;p&gt;It is fun to float.&lt;/p&gt;&lt;/div&gt;&lt;footer style="width: 500px; border: 1px solid black;"&gt;Here is the footer element runs across the bottom of the page.&lt;/footer&gt; 利用clear clear属性的值分别为：left、right和both；clear属性指定一个元素是否必须移动（清除浮动后）到它之前的浮动元素下方。 12345678910111213141516&lt;div style="width: 500px; border: 1px solid black;"&gt; &lt;img src="https://mdn.mozillademos.org/files/13340/butterfly.jpg" alt="A pretty butterfly with red, white, and brown coloring, sitting on a large leaf" style="float: left"&gt; &lt;p&gt;It is fun to float.&lt;/p&gt;&lt;/div&gt;&lt;footer style="width: 500px; border: 1px solid black;"&gt;Here is the footer element runs across the bottom of the page.&lt;/footer&gt;&lt;style type="text/css"&gt;div::after &#123; content: '.'; display: block; height: 0; visibility: hidden; clear: both;&#125;&lt;/style&gt; 定位 position属性有四个可选值：static、relative、absolute、fixed和sticky，默认值为static只有当position属性为relative、absolute、fixed或sticky时，top、right、bottom和left才会其作用。top、right、bottom和left是根据盒模型进行设置的。如果使用百分比值设置top、right、bottom和left，则是相对于最近的块级祖先元素的宽高来计算的。 静态定位123456789101112131415&lt;p&gt;First Paragraph&lt;/p&gt;&lt;p&gt;Second Paragraph&lt;/p&gt;&lt;p id="specialpara"&gt;Third Paragraph (with ID)&lt;/p&gt;&lt;p&gt;Fourth Paragraph&lt;/p&gt;&lt;style type="text/css"&gt;p &#123; border: 1px solid black; width: 200px;&#125;p#specialpara &#123; position: static&#125;&lt;/style&gt; 相对定位 相对定位是元素相对于它原来在文档流中的位置定位；可以使用top、right、bottom和left来调整元素的位置；相对定位的元素仍然处于文档流中，它原来的位置会被保留。 1234567891011121314151617&lt;p&gt;First Paragraph&lt;/p&gt;&lt;p&gt;Second Paragraph&lt;/p&gt;&lt;p id="specialpara"&gt;Third Paragraph (with ID)&lt;/p&gt;&lt;p&gt;Fourth Paragraph&lt;/p&gt;&lt;style type="text/css"&gt;p &#123; border: 1px solid black; width: 200px;&#125;p#specialpara &#123; position: relative; top: 25px; left: 30px;&#125;&lt;/style&gt; 绝对定位 绝对定位会将元素从文档流中拿出来，它是相对于定位上下文进行定位的；可以使用top、right、bottom和left来调整元素的位置；绝对定位默认的定位上下文是&lt;body&gt;元素；如果绝对定位的祖先元素中有position属性值不为static的元素，那么绝对定位就以其为定位上下文。 1234567891011121314151617&lt;p&gt;First Paragraph&lt;/p&gt;&lt;p&gt;Second Paragraph&lt;/p&gt;&lt;p id="specialpara"&gt;Third Paragraph (with ID)&lt;/p&gt;&lt;p&gt;Fourth Paragraph&lt;/p&gt;&lt;style type="text/css"&gt;p &#123; border: 1px solid black; width: 200px;&#125;p#specialpara &#123; position: absolute; top: 25px; left: 30px;&#125;&lt;/style&gt; 固定定位 固定定位会将元素从文档流中拿出来，它是根据视口（浏览器窗口或手持设备的屏幕）进行定位的，所以在页面滚动时，它的位置也不会改变；可以使用top、right、bottom和left来调整元素的位置。 123456789101112131415161718192021222324&lt;p&gt;First Paragraph&lt;/p&gt;&lt;p&gt;Second Paragraph&lt;/p&gt;&lt;p id="specialpara"&gt;Third Paragraph (with ID)&lt;/p&gt;&lt;p&gt;Fourth Paragraph&lt;/p&gt;&lt;p&gt;Fifth Paragraph&lt;/p&gt;&lt;p&gt;Sixth Paragraph&lt;/p&gt;&lt;p&gt;Seven Paragraph&lt;/p&gt;&lt;p&gt;Eighth Paragraph&lt;/p&gt;&lt;p&gt;Ninth Paragraph&lt;/p&gt;&lt;p&gt;Tenth Paragraph&lt;/p&gt;&lt;style type="text/css"&gt;p &#123; border: 1px solid black; width: 200px;&#125;p#specialpara &#123; position: fixed; top: 25px; left: 30px;&#125;&lt;/style&gt; 粘性定位 粘性定位没有脱离正常的文档流。它可以看作是相对定位和固定定位的结合。必须使用top、right、bottom或left来设定一个阀值。当距离没有达到阀值时显示效果与相对定位相同。当距离在阀值范围之内时，显示效果与固定定位相同。粘性元素被最近的块级祖先元素限制着，即当块级祖先元素消失在BFC范围时，粘性元素也会随之消失。 这里我理解的还不够透彻，就不写demo了，想看效果可以去MDN flex布局Flexbox是一种布局方式，我们称之为弹性布局。设置了display: flex的元素被称为容器（flex container），而它的子元素则称之为项目（flex item）。对于容器和项目，它们各自有着不同的CSS属性。 容器的属性flex-directionFlexbox中有两根轴：主轴和交叉轴。这两个轴代表什么取决容器上的flex-direction属性，它共有四个可供选择的值：row（默认）、row-reverse、column和column-reverse。 justify-contentjustify-content属性用于定义项目在主轴上的对齐方式。 align-itemsalign-items属性用于定义项目在交叉轴上的对齐方式。 align-contentalign-content属性用于定义多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用。 flex-wrapflex-wrap属性用于定义当主轴上项目过多时，是否允许折行。 flex-flowflex-flow属性是flex-direction和flex-wrap的简写形式。 项目的属性orderorder属性用于定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-growflex-grow属性用于定义项目的放大比例，默认为0，即就算存在剩余空间，也不放大。 flex-shrinkflex-shrink属性用于定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basisflex-basis属性用于定义项目在未放大或缩小前，占据的主轴空间大小，默认为auto，即项目本来的大小。 flex-basis设置的是元素的border-box，而不是content-box。 flexflex属性是flex-grow、flex-shrink和flex-basis的简写形式。 align-selfalign-self属性允许单个项目有与其他项目不一样的对其方式。可覆盖容器的align-items属性。 column布局CSS多列布局扩展块布局模式，以便更容易地定义多列文本 根据定义来看多列布局是为了定义文本的布局方式的，但实际上多列布局也可以应用于其他类型的元素上。看下面的例子，多列布局竟然能将元素以这种方式截断！ 术业有专攻，还是将多列布局用于文本布局吧column-count：设置列数column-width：设置期望最小列宽column-gap：设置列之间的缝隙大小CSS3多列规范需要列高平衡：即浏览器自动设置最大列高，因此每列中的内容高度大致相同。除此之外，也允许通过height或max-height属性来限制列高，在生成新的一列之前每一列都会仅允许增加到这个高度 display属性 none：完全移除元素；inline：将元素变为行内元素，它的height和weight将不会起作用；block：将元素变为块级元素；inline-block：将元素变成具有height和weight的行内元素；list-item：元素表现得像是&lt;li&gt;一样；table：元素表现得像是&lt;table&gt;一样；flex：将元素变为flex container，其子元素变为flex item；inline-flex：将元素变为行内flex container；grid：将元素变为grid container。 元素层叠 元素层叠是相对的；z-index属性只有当对应元素的postion属性不为static时才有效。 下面的例子有助于理解元素层叠是相对的。 1234567891011121314151617181920212223242526272829&lt;div id="outer"&gt; &lt;div id="a"&gt;&lt;/div&gt; &lt;div id="b"&gt;&lt;/div&gt;&lt;/div&gt; &lt;style type="text/css"&gt;#outer &#123; width: 200px; height: 200px; background: black; position: relative; z-index: -100;&#125;#a &#123; width: 100px; height: 100px; background: red; position: relative; z-index: -1000;&#125;#b &#123; width: 100px; height: 100px; background: blue;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[volume的备份及还原]]></title>
    <url>%2Fposts%2Fe113cc4a%2F</url>
    <content type="text"><![CDATA[现在Docker中有一个名为registry-data的volume，我想备份它。 思路如下：创建一个文件夹，路径如下/d/Docker/backup，backup就是我保存备份的文件夹；运行一个临时的容器，它需要做以下工作：将想要备份的registry-data挂载到容器上；将第一步创建的文件夹，挂载到容器上；通过命令压缩registry-data，而后保存到第一步创建的文件夹中。 运行如下命令，将会生成registry-data20190509.tar压缩文件，并将其保存在backup文件夹中。 1docker run --rm -v registry-data:/source -v /d/Docker/backup:/backup alpine sh -c "cd /source &amp;&amp; tar cvf /backup/registry-data20190509.tar ." 如果想将备份还原成volume，只需运行下面的命令即可： 1docker run --rm -v another-registry-data:/source -v /d/Docker/backup:/backup alpine sh -c "cd /source &amp;&amp; tar xvf /backup/registry-data20190509.tar ." 这样就会利用备份的压缩文件，为我们生成一个名为another-registry-data的volume。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue+node+python+docker实战]]></title>
    <url>%2Fposts%2F96fb2f92%2F</url>
    <content type="text"><![CDATA[Docker基础概念Docker中文文档Docker英文文档 系统架构注意事项 系统中各组成部分介绍：vue-client：使用vue开发的前端界面；node-serve：使用hapi开发的基础服务器，主要负责系统内数据的增删改查；node-worker：基于node的消息队列消费者；python-serve：使用flask开发的算法服务端，主要负责系统内算法的运行；mysql：数据库；phpmyadmin：数据库UI；rabbitmq：消息队列服务器。上面介绍的组成部分，除了mysql和phpmyadmin不需要利用Dockerfile构建镜像外，其余全需要。马上就会讲解它们的Dockerfile，不过需要注意的是，请将所有镜像全部构建完成后，再利用docker-compose来启动所有容器。否则只单独启动像node-worker这样的容器，是不会成功的，因为它依赖于rabbitmq。 vue-client1234567# Dockerfile文件FROM nginxCOPY ./dist /appCOPY ./nginx.conf /etc/nginx/nginx.confEXPOSE 80 1234567891011121314151617181920212223242526272829303132333435363738394041424344# nginx.conf文件user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root /app; index index.html; try_files $uri $uri/ /index.html; &#125; location /api &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://node-serve:8000; proxy_connect_timeout 600s; proxy_send_timeout 600s; proxy_read_timeout 600s; send_timeout 600s; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; &#125;&#125; 在项目根目录下依次运行如下命令：npm run build：这会将项目打包到根目录下的dist文件夹；docker build -t vue-client:20190509_1 .：构建一个名称为vue-client:20190509_1的镜像。 node-serve12345678910111213141516# Dockerfile文件FROM node:10.15.1-alpineWORKDIR /appCOPY . .RUN npm install --registry=https://registry.npm.taobao.org &amp;&amp; \ apk add --no-cache tzdata &amp;&amp; \ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \ echo "Asia/Shanghai" &gt; /etc/timezone &amp;&amp; \ apk del tzdataEXPOSE 8000CMD ["npm", "start", "-s"] 1234567# .dockerignore文件npm-debug.lognode_modules.vscodetypingspackage-lock.json 在项目根目录下运行docker build -t node-serve:20190509_1 .构建一个名称为node-serve:20190509_1的镜像。 node-worker123456789101112131415# Dockerfile文件FROM node:10.15.1-alpineWORKDIR /appCOPY . .RUN npm install --registry=https://registry.npm.taobao.org &amp;&amp; \ npm install -g pm2 --registry=https://registry.npm.taobao.org &amp;&amp; \ apk add --no-cache tzdata &amp;&amp; \ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \ echo "Asia/Shanghai" &gt; /etc/timezone &amp;&amp; \ apk del tzdataCMD ["pm2", "start", "ecosystem.config.js", "--no-daemon"] 12345# .dockerignore文件.vscode/node_modules/.git/.gitignore 在项目根目录下运行docker build -t node-worker:20190509_1 .构建一个名称为node-worker:20190509_1的镜像。 python-serve12345678910111213# Dockerfile文件FROM python:3.7.2WORKDIR /usr/src/appCOPY . .RUN pip install -U pip &amp;&amp; \ pip install -r requirements.txtEXPOSE 5000CMD ["gunicorn", "-c", "gunicorn.conf", "run:app"] 12345# .dockerignore文件__pycache__.vscode/.git/.gitignore 在项目根目录下运行docker build -t python-serve:20190509_1 .构建一个名称为python-serve:20190509_1的镜像。 rabbitmqrabbitmq的根目录下只有一个文件，就是Dockerfile文件。 123456789# Dockerfile文件FROM rabbitmq:3-management-alpineRUN rabbitmq-plugins enable rabbitmq_stomp &amp;&amp; \ rabbitmq-plugins enable rabbitmq_web_stomp &amp;&amp; \ rabbitmq-plugins enable --offline rabbitmq_managementEXPOSE 15672EXPOSE 15674 在项目根目录下运行docker build -t rabbitmq:stomp .构建一个名称为rabbitmq:stomp的镜像。 docker-compose实例创建一个文件夹用于存放docker-compose.yml文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384version: '3'services: vue-client: image: vue-client:20190509_1 ports: - "8888:80" depends_on: - node-serve - node-worker - python-serve networks: - app-net node-serve: image: node-serve:20190509_1 ports: - "8000:8000" depends_on: - mysql networks: - app-net node-worker: image: node-worker:20190509_1 depends_on: - python-serve networks: - app-net python-serve: image: python-serve:20190509_1 ports: - "5000:5000" depends_on: - mysql - rabbitmq networks: - app-net mysql: image: mysql:5.6 restart: always ports: - "3306:3306" environment: MYSQL_ROOT_PASSWORD: yourpassword command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci volumes: - mysql-data:/var/lib/mysql networks: - app-net phpmyadmin: image: phpmyadmin/phpmyadmin:latest restart: always ports: - "8001:80" environment: MYSQL_ROOT_PASSWORD: yourpassword PMA_HOST: mysql depends_on: - mysql networks: - app-net rabbitmq: image: rabbitmq:stomp restart: always ports: - "15672:15672" - "15674:15674" environment: RABBITMQ_DEFAULT_USER: yourname RABBITMQ_DEFAULT_PASS: yourpassword RABBITMQ_ERLANG_COOKIE: yourpassword networks: - app-netnetworks: app-net:volumes: mysql-data: 命令介绍：docker-compose build：构建（重新构建）服务容器；docker-compose up -d：后台自动（重新）创建服务和关联服务相关容器；docker-compose down：停止容器、移除容器和网络。遇到的坑：depends_on：解决容器的依赖、启动先后问题，但是不会等到所依赖的容器完全启动之后，再启动后续容器。所以如果在docker-compose up -d后，发现node-worker部分没有正常工作的话，你在保证rabbitmq完全启动后，重启下node-worker就可以了。这里有其他的解决办法，比如利用wait-for-it脚本等，我简单的试了一下，有些小问题，为了项目进度，暂时搁置，相关资料戳这里。 portainer运行如下命令就可以启动一个docker的可视化管理工具。 1docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer-data:/data portainer/portainer]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[选择器]]></title>
    <url>%2Fposts%2F7c8269b4%2F</url>
    <content type="text"><![CDATA[选择器种类标签选择器123456789&lt;div&gt; &lt;span&gt;选择器&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt;span &#123; color: red;&#125;&lt;/style&gt; 类选择器123456789&lt;div&gt; &lt;span class="my-span"&gt;选择器&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt;.my-span &#123; color: red;&#125;&lt;/style&gt; id选择器123456789&lt;div&gt; &lt;span id="my-span"&gt;选择器&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt;#my-span &#123; color: red;&#125;&lt;/style&gt; 通用选择器1234567891011&lt;div&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;p&gt;p&lt;/p&gt; &lt;span&gt;span&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt;* &#123; color: red;&#125;&lt;/style&gt; 属性选择器 假设元素内设置了data-attr=&quot;value1 value2 value3&quot;，下面介绍对它使用属性选择器的几种方式：[data-attr]：根据属性名称；[data-attr=&quot;value1 value2 value3&quot;]：根据属性名和属性值；[data-attr^=&quot;val&quot;]：以……开头；[data-attr*=&quot;value2&quot;]：包含……；[data-attr$=&quot;3&quot;]：以……结尾。 12345678910111213141516171819202122232425&lt;div&gt; &lt;span data-attr="value1 value2 value3"&gt;选择器&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt;[data-attr] &#123; color: red;&#125;[data-attr="value1 value2 value3"] &#123; color: red;&#125;[data-attr^="val"] &#123; color: red;&#125;[data-attr*="value2"] &#123; color: red;&#125;[data-attr$="3"] &#123; color: red;&#125;&lt;/style&gt; 选择器使用规则 选择器的组合使用：div, span：同时选择&lt;div&gt;和&lt;span&gt;元素；div.classValue：选择class属性值包含classValue的&lt;div&gt;元素；div#idValue：选择id属性值为idValue的&lt;div&gt;元素；div[data-attr]：选择具有data-attr属性的&lt;div&gt;元素；div.class1.class2：选择class属性值同时包含class1和class2的&lt;div&gt;元素。根据结构来使用选择器：selector1 selector2：当selector2是selector1的后代元素时，选择selector2；selector1 &gt; selector2：当selector2是selector1的子元素时，选择selector2；selector1 + selector2：当selector2是selector1的同胞元素，且selector2紧跟着selector1时，选择selector2；selector1 ~ selector2：当selector2是selector1的同胞元素，且selector2位于selector1后面时，选择selector2；selector1 * selector2：当selector2是selector1的后代元素，且selector2不是selector1的子元素时，选择selector2。 伪类和伪元素MDN上伪类和伪元素的总结 伪类用于给已经存在于文档树中的元素添加不存在的类，并为其添加样式；伪元素用于创建文档树中不存在的元素，并为其添加样式。 样式层叠样式来源 以下就是浏览器层叠各个来源样式的顺序：浏览器默认样式表用户样式表作者链接样式表（按照它们链接到页面的先后顺序）作者嵌入样式作者行内样式 特指度 100：ID选择器。10：类选择器、伪类选择器和属性选择器。1：标签选择器和伪元素。 层叠规则 带有!import的优先级最高（开挂一样的存在）。行内样式优先级仅次于!import。抛开!import和行内样式，其他情况下，特指度大的优先级高。当特指度相同时，嵌入样式表 &gt; 链接样式表 &gt; 用户样式表 &gt; 浏览器默认样式表。当特指度相同时，则后出现的优先级高。]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[运算符优先级]]></title>
    <url>%2Fposts%2F9393c5c%2F</url>
    <content type="text"><![CDATA[请移步 MDN。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强制类型转换]]></title>
    <url>%2Fposts%2F1750eb3e%2F</url>
    <content type="text"><![CDATA[强制类型转换规则引用类型转换为基本类型 调用自身的 valueOf() 方法，如果返回基本类型的值，则转换成功。如果 valueOf() 方法返回的还是引用类型值，则改为调用自身的 toString() 方法。如果 toString() 方法返回基本类型的值，则转换成功。如果 toString() 方法返回的是引用类型值，抛出错误。需要注意的是，数组的默认 toString() 方法经过了重新定义，会将所有单元字符串化以后再用 &quot;,&quot; 连接起来。 转换为字符串 null：&quot;null&quot;。undefined：&quot;undefined&quot;。布尔值：&quot;true&quot; 或 &quot;false&quot;。数值：通常直接转换为字符串即可，但是对于极小或极大的数值，会使用指数形式。引用类型值：返回自身的 toString() 方法的返回值。 1234567891011121314151617181920// "null"console.log(String(null)) // "undefined"console.log(String(undefined)) // "false"console.log(String(false)) // "123"console.log(String(123)) // "1.23e+21"console.log(String(123 * 10000000000000000000)) // "[object Object]"console.log(String(&#123;a: 1&#125;)) // "1,2,3"console.log(String([1, 2, 3])) 转换为数值 null：0。undefined：NaN。布尔值：0 或 1。字符串：十进制数值或 NaN。引用类型值：先将引用类型值转换为基本类型值，然后再将该基本类型值转换为数值。 12345678910111213141516171819202122232425262728293031323334353637// 0console.log(Number(null)) // NaNconsole.log(Number(undefined)) // 0console.log(Number(false)) // 123console.log(Number('123')) // NaNconsole.log(Number('123abc')) // NaNconsole.log(Number(&#123;a: 1&#125;)) // NaNconsole.log(Number([1, 2, 3])) var obj = &#123; valueOf () &#123; return 42 &#125;&#125;var array = [1, 2, 3]array.valueOf = function () &#123; return 123&#125;// 42console.log(Number(obj)) // 123console.log(Number(array)) 转换为布尔值 在将值转换为布尔值时，除了下述 5 种情况，其他所有情况都会转换为 true：nullundefinedfalse+0、-0 或 NaN&quot;&quot; 显示强制类型转换 一元运算符 +、-、++ 和 -- 都会调用 Number() 将其他类型转换为数值，或将日期对象转换为对应的毫秒数。注意不要混淆 +、++、+ +，-、--、- -。一元运算符 ~ 会先将值强制类型转换为 32 位数值，然后执行按位非操作，可以将 ~x 等价于 -(x+1)。但是 ~-1 的结果是 0 而不是 -0，因为 ~ 是字位操作而非数学运算。将值转换为布尔值时，可以使用 ! 运算符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var a = '1'var b = +avar c = -avar d = - -avar e = --a// 1console.log(b) // -1console.log(c) // 1console.log(d) // 0console.log(e) var f = new Date()// 1557055687256console.log(+f) // ==============================var x = -42// 41console.log(~x) // ==============================var a = '0'var b = []var c = &#123;&#125;var d = ''var e = 0var f = nullvar g// trueconsole.log(!!a) // trueconsole.log(!!b) // trueconsole.log(!!c) // falseconsole.log(!!d) // falseconsole.log(!!e) // falseconsole.log(!!f) // falseconsole.log(!!g) 隐式强制类型转换 + 和 - 作为一元运算符和作为多元运算符时具有不同的含义，别混淆了！ + 运算符+ 运算符既能用于数值加法，也能用于字符串拼接。JavaScript 怎样来判断我们要执行的是哪个操作？ 如果操作数中有字符串，进行字符串拼接操作。如果操作数中有引用类型值，首先将引用类型值转换为基本类型值，然后进行后续操作。其他情况全都进行数值加法。 - 运算符与 + 运算符不同，- 运算符会只会执行减法运算。所以它会先将非数值类型的数据转换为数值，然后进行减法运算。 12345var a = '12'var b = 1// 11console.log(a-b) 宽松相等和严格相等 == 允许在相等比较中进行强制类型转换，而 === 不允许。NaN 不等于 NaN。+0 严格等于 -0。!= 与 !== 分别类似于 == 与 ===。 下面主要介绍 == 是如何进行强制类型转换的。 字符串和数值 首先将字符串转换为数值类型，然后进行比较。 12345var a = 42var b = '42'// trueconsole.log(a == b) 其他类型和布尔类型 首先将布尔类型的值转换为数值类型，然后进行比较。 12345678var a = '42'var b = true// falseconsole.log(a == b) // trueconsole.log('1' == true) null 和 undefined 在 == 中 null 和 undefined 相等（它们也与其自身相等），除此之外其他情况都不相等。 1234567891011121314151617181920212223242526272829var a = nullvar b// trueconsole.log(a == b) // trueconsole.log(a == null) // trueconsole.log(b == null) // falseconsole.log(a == false) // falseconsole.log(b == false) // falseconsole.log(a == '') // falseconsole.log(b == '') // falseconsole.log(a == 0) // falseconsole.log(a == 0) 引用类型和基本类型 首先将引用类型转换为基本类型，然后进行比较。 12345var a = 42var b = [42]// trueconsole.log(a == b) 引用类型和引用类型这种情况就是判断两个变量的引用是否相同]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax 与 Comet]]></title>
    <url>%2Fposts%2F5ffed448%2F</url>
    <content type="text"><![CDATA[Ajax 是 Asynchronous JavaScript + XML 的简写，这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。 Ajax 技术的核心是 XMLHttpRequest 对象（简称 XHR），XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口。 XHR 对象XHR 属性 readyState（只读）：代表XHR对象的当前状态。0：未初始化。尚未调用 open() 方法。1：启动。已经调用 open() 方法，但尚未调用 send() 方法。2：发送。已经调用 send()方法，但尚未接收到响应。3：接收。已经接收到部分响应数据。4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。onreadystatechange：它是 XHR 对象的一个方法，只要 readyState 属性值发生变化，就会调用该方法。必须在调用 open() 方法之前为 onreadystatechange 赋值才能确保跨浏览器兼容性。并且在这个事件处理程序中最好不要使用 this 对象，否则可能会出问题。response（只读）：返回响应的主体部分。主体部分内容的格式由 responseType 属性决定。responseText（只读）：返回响应的主体内容的字符串形式。responseType：通过这个属性指定期望的 response 的类型。该属性的默认值为 text。responseURL（只读）：返回响应的序列化URL，如果 URL 为空则返回空字符串。如果URL有锚点，则位于 # 后面的内容会被删除。如果 URL 有重定向， responseURL 的值会是经过多次重定向后的最终URL。responseXML（只读）：如果响应的内容类型是 &quot;text/xml&quot; 或 &quot;application/xml&quot;，这个属性中将保存包含着响应数据的 XML DOM 文档。status（只读）：HTTP 状态码。statusText（只读）：HTTP 状态码对应的描述信息。timeout：设置请求超时的毫秒数。超时后会触发 ontimeout 事件处理程序。upload（只读）：该属性专门用于上传文件，可用于显示上传进度。它返回的是一个 XMLHttpRequestUpload 对象，该对象也拥有 loadstart、progress、error、abort、load、loadend 和 timeout 事件。withCredentials：该属性为布尔值，它指示了是否该使用类似 cookies，authorization headers 或者 TLS 客户端证书这一类资格证书来创建一个跨站点访问控制请求。在同一个站点下使用 withCredentials 属性是无效的。默认值为 false。 XHR方法 open(method, url, async, user, password)：初始化一个 XHR 对象。method：一个字符串，用于表示要发送的请求类型，比如：&quot;get&quot;、&quot;post&quot;。url：请求的 URL。async（可选）：一个布尔值，用于表示是否发送是异步请求，默认为 true。user（可选）：用户名，默认为 null。password（可选）：密码，默认为 null。send(body)：在 send() 之后，通过调用该发送请求。body 参数是请求主体要发送的数据，如果不需要通过请求主体发送数据，则传入 null。abort()：终止已经发送的请求。当调用该方法时，被终止的 XHR 对象的 readyState 值变为 0，status 值也变为 0。getResponseHeader(headerName)：用于获取对应首部字段的值。getAllResponseHeaders()：用于获取所有的首部字段内容。各个首部字段被 CRLF 分隔，如果无首部字段，则返回 null。setRequestHeader(header，value)：设置首部字段。必须在调用 open() 之后，调用 send() 之前使用该方法才有效。overrideMimeType(mimeType)：重写响应的MIME类型。必须在调用 send() 之前使用该方法才有效。 XHR事件 需要在调用 open() 之前注册事件处理程序的事件：loadstart：在接收到响应数据的第一个字节时触发。progress：在接收响应期间持续不断地触发。error：在请求发生错误时触发。abort：在因为调用 abort() 方法而终止连接时触发。load：在接收到完整的响应数据时触发。loadend：在通信完成或者触发 error、abort 或 load 事件后触发。需要在调用 open() 之后，调用 send() 之前注册事件处理程序的事件：timeout：在请求超时时触发。 demodemo 用于展示如何利用 XHR 发送请求，并没有进行什么特殊配置。 123456var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; // do something&#125;xhr.open('get', 'example.txt')xhr.send(null) 跨域通过 XHR 实现 Ajax 通信的一个主要限制，来源于跨域安全策略（同源策略）。默认情况下，使用 XHR 对象发送请求的 URL 域名必须和当前页面完全一致。完全一致的意思是，域名要相同（www.example.com 和 example.com 不同），协议要相同（http 和 https不同），端口号也要相同。有的浏览器比较宽松，允许端口不同，大多数浏览器都会严格遵守这个限制。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。 就算是域名和域名对应的 IP 之间发起请求，也算作跨域。 CORSCORS（Cross-Origin Resource Sharing，跨域资源共享）是 W3C 的一个工作草案，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 比如一个简单的使用 GET 或 POST 发送的请求，它没有自定义的头部，而主体内容是 text/plain。在发送该请求时，需要给它附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是 Origin 头部的一个示例： 1Origin: http://www.nczonline.net 如果服务器认为这个请求可以接收，就在响应的 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 &quot;*&quot;）。例如： 1Access-Control-Allow-Origin: http://www.nczonline.net 如果响应没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。 现代浏览器都通过 XMLHttpRequest 对象对象实现了对CORS的源生支持，在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。 跨域 XHR 对象也有一些限制，但为了安全这些限制是必需的。以下就是这些限制：不能使用 setRequestHeader() 设置自定义头部。默认不能发送和接收 cookie，但是可以通过 XHR 对象的 withCredentials 来发送带凭据的跨域请求。调用 getAllResponseHeaders() 方法总会返回空字符串。由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对 URL，在访问远程资源时再使用绝对 URL。这样做能消除歧义，避免出现限制访问头部或本地 cookie 信息等问题。 Preflight request参考资料：前端 | 浅谈preflight request 想象一个场景，我们发送一个 POST 跨域请求，服务器收到请求后对数据库进行了相应的操作并返回响应，但是由于浏览器的跨域限制，导致我们收到的是请求失败的结果。这种情况就是明明用户请求的操作成功了，但是用户不知道他成功了。 预检请求（Preflight request）就是为了解决上述问题的。某些情况下浏览器在发送跨域请求之前会先发送一个相应的预检请求，从而获知服务器是否允许该跨域请求。如果允许，就发送跨域请求。如果不允许，则阻止发送跨域请求。 触发预检请求的条件：如果请求方法不是 GET、HEAD 或 POST，那么将发送预检请求。如果人为设置了对 CORS 安全的首部字段集合之外的首部字段，那么将发送预检请求。对 CORS 安全的首部字段集合包含：AcceptAccept-LanguageContent-LanguageContent-TypeDPRDownlinkSave-DataViewport-WidthWidth如果请求头的 Content-Type 的值不是 application/x-www-form-urlencoded、multipart/form-data、text/plain 之一的话，那么将发送预检请求。预检请求使用的是 OPTIONS 方法，发送下列头部：Origin：源信息。Access-Control-Allow-Method：跨域请求使用的方法。Access-Control-Allow-Headers（可选）：跨域请求会额外发送的头部字段，这些头部字段用逗号分隔。预检请求的响应会包含如下头部字段：Access-Control-Allow-Origin：源信息。Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔。Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔。Access-Control-Max-Age（可选）：应该将这个预检请求缓存多长时间（以秒表示），也就是说在这个时间范围内，不会再发送相同的预检请求。 带凭据的请求默认情况下，跨域请求不提供凭据（cookie、HTTP 认证及客户端 SSL 证明等）。通过将 withCredentials 属性设置为 true，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的 HTTP 头部来响应： 1Access-Control-Allow-Credentials: true 如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript（于是，responseText 中将是空字符串，status 的值为 0，而且会调用 onerror() 事件处理程序）。另外，服务器还可以在预检请求的响应中发送这个 HTTP 头部，表示允许源发送带凭据的请求。 其他跨域技术图像 Ping图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。通过图像 Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时候接收到的。来看下面的例子： 12345var img = new Image()img.onload = img.onerror = function () &#123; alert('Done!')&#125;img.src = 'http://www.example.com/test?name=Nicholas' 图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数。图像 Ping 有两个主要缺点，一是只能发送 GET 请求，二是无法访问服务器的响应文本。因此，图像 Ping 只能用于浏览器与服务器的单向通信。 JSONPJSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写，是应用 JSON 的一种方法。JSONP 看起来与 JSON 差不多，只不过是被包含在函数调用中的 JSON，就像下面这样： 1handleResponse(&#123; "name": "Nicholas" &#125;) JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，回调函数一般是在请求中通过 callback 查询字段指定的。而数据就是传入回调函数中的 JSON 数据。下面是一个典型的 JSONP 请求： 1http://aadonkeyz.com/example.js?callback=handleResponse JSONP 的原理很简单，它是通过动态 &lt;script&gt; 元素来发送请求的，然后将收到的响应内容（JSONP 格式）当作是 JavaScript 代码处理。 请看下面的例子： 123456789101112function handleResponse(response) &#123; // do something&#125;var script = document.createElement('script')script.src = 'http://aadonkeyz.com/example.js?callback=handleResponse'document.body.insertBefore(script, document.body.firstChild)// 收到 JSONP 为 'handleResponse(&#123; "name": "Nicholas" &#125;)' 时，则等价于下面// &lt;script&gt;// handleResponse(&#123; "name": "Nicholas" &#125;)// &lt;/script&gt; 这个例子的执行顺序为：浏览器通过 &lt;script&gt; 标签发送请求。服务器收到请求后，发现这个是 JSONP 的请求，根据请求的 callback 查询字段获取回调函数的名称，然后准备要返回的 JSON 数据，最后以 JSONP 的格式结合回调函数名称和 JSON 数据。浏览器接收到 JSONP 格式的响应，开始执行代码，即 handleResponse({ &quot;name&quot;: &quot;Nicholas&quot; })。 与图像 Ping相比，JSONP 非常简单易用并且能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过它也有自己的缺点： 首先，JSONP 是从其他域中加载代码执行，如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃 JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的 Web 服务时，一定要保证它安全可靠。 其次，要确定 JSONP 请求是否失败并不容易。但是 HTML5 给 &lt;script&gt; 标签新增了一个 onerror 事件处理程序，现在来说这个应该不算缺点了吧…… 服务器推送技术ComteComte 是 Alex Russell 发明的一个词儿，指的是一种更高级的 Ajax 技术（经常也有人称为“服务器推送”）。Ajax 是一种从页面向服务器请求数据的技术，而 Comte 则是一种服务器向页面推送数据的技术。Comte 能够让信息近乎实时地被推送到页面上。 有两种实现 Comte 的方式：长轮询和流。 短轮询是浏览器定时向服务器发送请求，查看是否有更新的数据。长轮询是在页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的链接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。 第二种流行的 Comet 实现是 HTTP 流。流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个 HTTP 连接。具体来说，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。在浏览器中，通过注册 onreadystatechange 事件处理程序及检测 readyState 的值，就可以利用 XHR 对象实现 HTTP 流。随着不断从服务器接收数据，readyState 的值会周期性地变为 3，而浏览器将接收的所有数据均保存在 responseText 属性中。 使用 XHR 对象实现 HTTP 流的典型代码如下所示： 12345678910111213141516171819202122232425262728293031function createStreamingClient(url, progress, finished) &#123; var xhr = new XMLHttpRequest() var received = 0 xhr.onreadystatechange = function () &#123; var result if (xhr.readyState === 3) &#123; result = xhr.responseText.substring(received) received += result.length progress(result) &#125; else if (xhr.readyState === 4) &#123; finished(xhr.responseText) &#125; &#125; xhr.open('get', url) xhr.send(null) return xhr&#125;var client = createStreamingClient( 'http://demo.com', function (data) &#123; alert('Received: ' + data) &#125;, function (data) &#123; alert('Done!') &#125;) SSE 使用 SSE 可以跨域。 SSE（Server-Sent Events，服务器发送事件）是围绕只读 Comet 交互推出的 API。SSE API 用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME 类型必须是 text/event-stream，而且是浏览器中的 JavaScript API 能解析格式输出。SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。 SSE 的 JavaScript API与其他传递消息的JavaScript API很相似。要预订新的事件流，首先要创建一个新的EventSource对象实例，并传进一个入口点： 123var source = new EventSource(url)// 或者var source = new EventSource(url, &#123; withCredentials: true &#125;) 上面的 url 可以与当前网页同域，也可以跨域。跨域时，可以指定第二个参数。withCredentials 是一个布尔值，表示是否一起发送 cookie。 默认情况下，EventSource 对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着 SSE 适合长轮询和 HTTP 流。如果想强制立即断开连接并且不再重新连接，可以调用 close() 方法。 1source.close() EventSource 的实例有一个 readyState 属性值为 0 表示正连接到服务器。值为 1 表示打开了连接。值为 2 表示关闭了连接。另外，还有以下三个事件：open：在建立连接时触发。message：在从服务器接收到新事件时触发。error：在无法建立连接时触发。服务器发回的数据已字符串形式保存在 event.data 中。 所谓的服务器事件会通过一个持久的 HTTP 响应发送，这个响应的 MIME 类型为 text/event-stream。响应数据的格式是纯文本，最简单的情况是每个数据项都带有前缀 data:，例如： 123456data: foodata: bardata: foodata bar 对以上响应而言，事件流中的第一个 message 事件返回的 event.data 值为 &quot;foo&quot;，第二个 message 事件返回的 event.data 值为 &quot;bar&quot;，第三个 message 事件返回的 event.data 值为 &quot;foo\nbar&quot;（注意中间的换行符）。对于多个连续的以 data: 开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有在包含 data: 的数据行后面有空格时，才会触发 message 事件，因此在服务器上生成事件流时不能忘了多添加这一行。 通过 id: 前缀可以给特定的事件指定一个关联的 ID，这个 ID 行位于 data: 行前面或后面皆可： 12data: fooid: 1 设置了 ID 后，EventSource 对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为 Last-Event-ID 的特殊 HTTP 头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。 Web SocketsWeb Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 Web Sockets 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 Web Sockets 协议。也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持 Web Sockets 协议的专门服务器才能正常工作。 由于 Web Sockets 使用了自定义的协议，所以 URL 模式也略有不同。未加密得到连接不再是 http:// 而是 ws://。加密的连接也不是 https:// 而是 wss://。在使用 Web Sockets URL 时，必须带着这个模式，因为将来还有可能支持其他模式。 要创建 Web Sockets，先实例一个 WebSocket 对象并传入要连接的URL： 1var socket = new WebSocket('ws://www.example.com/server.php') 必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接（不存在跨域问题）。实例化了 WebSocket 对象后，浏览器就会马上尝试创建连接。 与 XHR 类似，WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示：WebSocket.OPENING(0)：正在建立连接。WebSocket.OPEN(1)：已经建立连接。WebSocket.CLOSING(2)：正在关闭连接。WebSocket.CLOSE(3)：已经关闭连接。WebSocket 没有 readystatechange 事件。 要关闭 Web Sockets 连接，可以在任何时候调用 close() 方法。 1socket.close() 调用了 close() 方法之后，readyState 属性的值立即变为 2，而在关闭连接后就会变成 3。 Web Sockets 打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用 send() 方法并传入任意字符串，例如： 12var socket = new WebSocket('ws://www.example.com/server.php')socket.send('Hello World!') 当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。这个 message 事件与其他传递消息的协议类似，也是把返回的数据保存在 event.data 属性中。 123socket.onmessage = function () &#123; console.log(event.data)&#125; 在使用 Web Sockets 连接发送和接收数据时，需要注意传递的数据只能是纯文本数据。WebSocket 对象还有其他三个事件，在连接生命周期的不同阶段触发，分别是 open、error 和 close。WebSocket 对象不支持 DOM2 级事件侦听器，因此必须使用 DOM0 级语法分别注册每个事件处理程序。 12345678910111213var socket = new WebSocket('ws://www.example.com/server.php')socket.onopen = function () &#123; alert('Connection established.')&#125;socket.onerror = function () &#123; alert('Connection error.')&#125;socket.onclose = function () &#123; alert('Connection closed.')&#125; 在这三个事件中，只要 close 事件的 event 对象有额外的信息。这个事件的事件对象有三个额外属性：wasClean、code 和 reason。其中，wasClean 是一个布尔值，表示连接是否已经明确地关闭。code 是服务器返回的数值状态码。而 reason 是一个字符串，包含服务器发回的消息。 SSE 与 Web Sockets面对某个具体的用例，在考虑是使用 SSE 还是使用 Web Sockets 时，可以考虑如下几个因素。首先，你是否有自由度建立和维护 Web Sockets 服务器？因为 Web Sockets 协议不同于 HTTP，所以现有服务器不能用于 Web Sockets 通信。SSE 倒是通过常规 HTTP 通信，因此现有服务器就可以满足需求。 第二个要考虑的问题是到底需不需要双向通信。如果用例只需读取服务器数据，那么 SSE 比较容易实现。如果用例必须双向通信，那么 Web Sockets 显然更好。别忘了，在不能选择 Web Sockets 的情况下，组合 XHR 和 SSE 也是能实现双向通信的。]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2Fposts%2Ffdc54b8c%2F</url>
    <content type="text"><![CDATA[语法关于 JSON，最重要的是理解它是一个数据格式，不是一种编程语言。虽然具有相同的语法形式，但 JSON 并不从属于 JavaScript。而且，并不是只有 JavaScript 才使用 JSON，毕竟 JSON 只是一种数据格式。 JSON 的语法可以表示以下三种类型的值：简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。对象：对象作为一种复杂数据类型，表示的是一组有序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。数组：数组也是一种复杂数据类型，表示一组有序的值的列表。可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。JSON中的字符串必须使用双引号。 举个简单的例子： 1234567891011121314&#123; "name": "json demo", "number": 1, "array": [ 1, 2, &#123; "name": "obj" &#125; ], "obj": &#123; "name": "whatever" &#125;&#125; JSON.stringify JSON.stringify() 接受三个参数：value：需要被转换为JSON字符串的值。replacer（可选）：该参数可以是一个数组或者过滤器函数。当该参数为数组时，这个数组相当于是一个白名单，不在白名单中的属性将被过滤掉。当该参数为函数时，这个函数接收两个参数：属性（键）名和属性值。这个函数的返回值就相当于对应的属性被序列化后的结果，但是如果函数返回了 undefined，那么对应属性将被过滤掉。space（可选）：该参数可以是数值或字符串。当为数值时，这个数值表示序列化结果的缩进空格数。当为字符串时，这个字符串会替换空格，被用作缩进字符。注意事项：如果 value 中出现循环引用会抛出错误。如果 value 是对象，且没有传入 replacer 参数，那么如果它的某一个属性值是JSON所不支持的，比如 undefined，那么这个属性会被自动过滤掉。如果 value 是对象，且 replacer 是数组，那么该数组相当于一个白名单，不在白名单中的属性将被过滤掉。如果 value 是对象，且 replacer 是函数，那么这个函数接收两个参数：属性（键）名和属性值。这个函数的返回值就相当于对应的属性被序列化后的结果，如果函数返回了 undefined，那么对应属性将被过滤掉。如果 value 是数组，且没有传入 replacer 参数，那么如果它的某一项是JSON所不支持的，比如 undefined，那么这个项会被转换为 null。如果 value 是数组，且 replacer 也是数组，那么没有 replacer 没有什么作用，跟没传递 replacer 效果是一样的。如果 value 是数组，且 replacer 是函数，那么这个函数接收两个参数：字符串形式的索引和每一项的值。这个函数的返回值就相当于对应的项被序列化后的结果，如果函数返回了 undefined，那么对应项会被转换为null。replacer 是个十分有意思的函数，它接收到的第一个键会是空字符串 &#39;&#39;，而接收到的第一个值会是 value。之后如果 value 是对象或者数组，它才开始在 value中进行迭代。有时候 JSON.stringify() 还是不能满足对某些对象进行自定义序列化的需求，这种情况下，就可以在对象中定义 toJson() 方法。当 JSON.stringify() 接收的第一个参数包含 toJson() 方法时，会先调用其 toJson() 方法，然后再对该方法的返回值进行序列化，即实际上的操作是 JSON.stringify(value.toJson())。。 下面的例子来自MDN 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// '&#123;&#125;'JSON.stringify(&#123;&#125;) // 'true'JSON.stringify(true) // '"foo"'JSON.stringify('foo') // '[1,"false",false]'JSON.stringify([1, 'false', false]) // '[null,null,null]'JSON.stringify([NaN, null, Infinity]) // '&#123;"x":5&#125;'JSON.stringify(&#123; x: 5 &#125;) // '"2006-01-02T15:04:05.000Z"'JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)) // '&#123;"x":5,"y":6&#125;'JSON.stringify(&#123; x: 5, y: 6 &#125;)// '[3,"false",false]'JSON.stringify([new Number(3), new String('false'), new Boolean(false)])// String-keyed array elements are not enumerable and make no sense in JSONlet a = ['foo', 'bar']// a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]a['baz'] = 'quux' // '["foo","bar"]'JSON.stringify(a) // '&#123;"x":[10,null,null,null]&#125;' JSON.stringify(&#123; x: [10, undefined, function()&#123;&#125;, Symbol('')] &#125;) // Standard data structures// '[&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;]'JSON.stringify([new Set([1]), new Map([[1, 2]]), new WeakSet([&#123;a: 1&#125;]), new WeakMap([[&#123;a: 1&#125;, 2]])])// TypedArray// '[&#123;"0":1&#125;,&#123;"0":1&#125;,&#123;"0":1&#125;]'JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])])// '[&#123;"0":1&#125;,&#123;"0":1&#125;,&#123;"0":1&#125;,&#123;"0":1&#125;]'JSON.stringify([new Uint8Array([1]), new Uint8ClampedArray([1]), new Uint16Array([1]), new Uint32Array([1])])// '[&#123;"0":1&#125;,&#123;"0":1&#125;]'JSON.stringify([new Float32Array([1]), new Float64Array([1])]) // toJSON()// '11'JSON.stringify(&#123; x: 5, y: 6, toJSON()&#123; return this.x + this.y &#125; &#125;)// Symbols:// '&#123;&#125;'JSON.stringify(&#123; x: undefined, y: Object, z: Symbol('') &#125;)// '&#123;&#125;'JSON.stringify(&#123; [Symbol('foo')]: 'foo' &#125;)// '&#123;&#125;'JSON.stringify(&#123; [Symbol.for('foo')]: 'foo' &#125;, [Symbol.for('foo')])// undefinedJSON.stringify(&#123; [Symbol.for('foo')]: 'foo' &#125;, function(k, v) &#123; if (typeof k === 'symbol') &#123; return 'a symbol' &#125;&#125;)// Non-enumerable properties:// '&#123;"y":"y"&#125;'JSON.stringify( Object.create(null, &#123; x: &#123; value: 'x', enumerable: false &#125;, y: &#123; value: 'y', enumerable: true &#125; &#125;) )// 这里是空字符串''// &#123; '1': 1, '2': 2, '3': &#123; '4': 4, '5': &#123; '6': 6 &#125; &#125; &#125;// ========// 1// 1// ========// 2// 2// ========// 3// &#123; '4': 4, '5': &#123; '6': 6 &#125; &#125;// ========// 4// 4// ========// 5// &#123; '6': 6 &#125;// ========// 6// 6// ========JSON.stringify(&#123;"1": 1, "2": 2, "3": &#123;"4": 4, "5": &#123;"6": 6&#125;&#125;&#125;, (key, value) =&gt; &#123; console.log(key) console.log(value) console.log('========') return value&#125;)// [ 1, null, 3 ]JSON.stringify([1,2,3], (key, value) =&gt; &#123; if (key !== '1') &#123; return value &#125;&#125;) JSON.parse JSON.parse() 接受两个参数：text：需要被转换为JSON字符串的值。receiver（可选）：该参数是一个函数，这个函数也接受键值对，并且返回一个值。如果返回值是 undefined，则表示要从对象中删除相应的属性，或者在数组中将对应的项变成 &lt;empty&gt;。关于这个函数是怎么迭代的，请看下面的例子。 例子来自 MDN 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// &#123;&#125;JSON.parse('&#123;&#125;') // trueJSON.parse('true') // "foo"JSON.parse('"foo"') // [1, 5, "false"]JSON.parse('[1, 5, "false"]') // nullJSON.parse('null') // &#123; p: 10 &#125;JSON.parse('&#123;"p": 5&#125;', (key, value) =&gt; typeof value === 'number' ? value * 2 // return value * 2 for numbers : value // return everything else unchanged)// 1// 1// ========// 2// 2// ========// 4// 4// ========// 6// 6// ========// 5// &#123; '6': 6 &#125;// ========// 3// &#123; '4': 4, '5': &#123; '6': 6 &#125; &#125;// ========// 这里是空字符串''// &#123; '1': 1, '2': 2, '3': &#123; '4': 4, '5': &#123; '6': 6 &#125; &#125; &#125;// ========JSON.parse('&#123;"1": 1, "2": 2, "3": &#123;"4": 4, "5": &#123;"6": 6&#125;&#125;&#125;', (key, value) =&gt; &#123; console.log(key) console.log(value) console.log('========') return value&#125;)// [ 1, &lt;1 empty item&gt;, 3, 4 ]JSON.parse('[1,2,3,4]', (key, value) =&gt; &#123; if (key !== '1') &#123; return value &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2Fposts%2F9c2b83ad%2F</url>
    <content type="text"><![CDATA[JavaScript 与 HTML 之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间，比如：点击按钮、拖动鼠标等。 事件流事件冒泡事件冒泡是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的 HTML 页面为例： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;Click Me&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如果你单击了页面中的 &lt;div&gt; 元素，那么这个 click 事件会按照如下顺序传播 事件捕获事件捕获的顺序与事件冒泡的顺序正好相反，以前面的HTML页面为例，它的顺序为： 事件流DOM2 级事件规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。还是以前面的HTML页面为例，它的顺序如下所示： 在 DOM 事件流中，实际的目标在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从 document 到 &lt;html&gt; 再到 &lt;body&gt; 后就停止了。下一个阶段是“处于目标”阶段，于是事件在 &lt;div&gt; 上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 多数支持 DOM 事件流的浏览器都实现了一种特定的行为：即使DOM2 级事件规范明确要求捕获阶段不会涉及事件目标，但 IE9、Safari、Chrome、Firefox 和 Opera9.5 及更高版本都会在捕获阶段触发事件对象上的事件。结果就是有两个机会在目标对象上面操作事件。 事件处理程序事件就是用户或浏览器自身执行的某种动作。诸如 click、load 和 mouseover，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字就是在事件名前面加上 &quot;on&quot;，因此 click 事件的事件处理程序就是 onclick，load 事件的事件处理程序就是 onload。为事件注册处理程序的方式有好几种，下面一一进行介绍。 HTML 事件处理程序某个元素支持的每种事件，都拥有一个与相应事件处理程序同名的 HTML 特性，可以通过这个特性来注册事件处理程序。下面以 onclick 事件为例： 1234// test.jsfunction showAnother (that) &#123; alert(that.value)&#125; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 直接在HTML中指定具体动作 --&gt; &lt;input type="button" value="1" onclick="alert(this.value)" /&gt; &lt;!-- 调用在&lt;script&gt;标签内定义的函数 --&gt; &lt;input type="button" value="2" onclick="showMessage(this, event)" /&gt; &lt;!-- 调用外部js文件中定义的函数 --&gt; &lt;input type="button" value="3" onclick="showAnother(this)" /&gt; &lt;script type="text/javascript" src="./test.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function showMessage (that, event) &#123; alert(that.value) console.log(that) console.log(event) &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在 HTML 中注册事件处理程序，会创建一个封装着元素属性值的函数。这个函数中有一个局部变量 event，也就是事件对象（后面将会讨论这个概念），通过 event 变量可以直接访问事件对象。并且在这个函数内部，this 值等于事件的目标元素。所以你可以将 event 和 this 当做参数，传递给要调用的函数。关于这一点，你可以查看上面例子中 showMessage() 函数打印的内容来验证。 HTML 事件处理程序的缺点：如果用户在页面解析 showMessage() 和 showAnother() 之前就点击了对应的按钮，会抛出错误。可以使用 onclick=&quot;try {showMessage()} catch(ex) {}&quot; 的形式来解决这个问题。事件处理程序的作用域链在不同的浏览器中会有不同的结果。HTML 和 JS 代码紧密耦合。 DOM0 级事件处理程序 使用 DOM0 级方法只能在元素上注册一个事件处理程序。对于相同的事件，DOM0 级事件处理程序与 HTML 事件处理程序事件处理程序无法共存。使用 DOM0 级方法注册的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行，所以此时函数中的 this 指向元素自身。在注册事件处理程序时，不推荐使用 箭头函数，因为它会造成 this 的丢失。 在添加的事件处理程序函数内部，可以直接通过 event 变量访问事件对象。也可以通过给程序处理函数定义参数或者使用 arguments 来访问事件对象，在下面有例子。 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。你可以通过将事件处理程序属性的值设置为 null 来删除添加的事件处理程序。 来看一个例子： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="myButton" type="button" value="1" /&gt; &lt;script type="text/javascript"&gt; var button = document.getElementById('myButton') button.onclick = function (e) &#123; console.log(this) console.log(event) // true console.log(event === e) // true console.log(event === arguments[0]) // 删除添加的事件处理程序 button.onclick = null &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这个例子中的按钮，只有第一次点击时会打印内容，之后就没有任何反应，因为事件处理程序在第一次触发之后，就被删除了。 DOM2 级事件处理程序DOM2 级事件定义了两个方法，addEventListener() 和 removeEventListener()，分别用于注册和删除事件处理程序，所有 DOM 节点都包含这两个方法。 使用 addEventListener() 可以在同一个元素上注册多个事件处理程序，触发的顺序为添加顺序。关于 this 和 event 的使用规则，与 DOM0 级事件处理程序一致。 首先介绍 addEventListener() 方法，它的参数如下：type：表示监听事件类型的字符串，需要注意的是没有 on 前缀。listener：作为事件处理程序的函数。options（可选）：一个对象。其属性如下：capture：一个布尔值，默认为 false。当值为 true 时，listener 会在事件捕获阶段时被调用。once：一个布尔值，默认为 false。当值为 true 时，listener 会在其被调用之后自动移除。passive：一个布尔值，默认为 false。当值为 true 时，listener 内部不允许调用 event.preventDefault()，否则会抛出错误。useCapture（可选）：一个布尔值，默认为 false。当值为 true 时，listener 会在事件捕获阶段时被调用。对于 options 和 useCapture 参数，它们都是该方法的第三个参数，options 是新标准，而 useCapture 是老标准。接着介绍 removeEventListener() 方法，它的参数如下：type：表示监听事件类型的字符串，需要注意的是没有 on 前缀。listener：作为事件处理程序的函数。options（可选）：一个对象。其属性如下：capture：一个布尔值，默认为 false。当值为 true 时，表示要移除的 listener 是注册在事件捕获阶段的。useCapture（可选）：一个布尔值，默认为 false。当值为 true 时，表示要移除的 listener 是注册在事件捕获阶段的。如果一个事件处理程序一共注册了两次，一次在事件捕获阶段，一次在事件冒泡阶段，那么这两次注册需要分别移除，两者不会互相干扰。 下面的例子用于观察 options.capture 和 useCapture 的效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;style&gt; #outer, #inner &#123; display: block; width: 500px; height: 500px; text-decoration: none; &#125; #outer&#123; border: 1px solid red; color: red; &#125; #inner&#123; border: 1px solid green; color: green; width: 250px; height: 250px; margin: 125px auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="outer"&gt; outer, capture &amp; none-capture &lt;div id="inner"&gt; inner &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var outer = document.getElementById('outer') var inner = document.getElementById('inner') function captureListener1 () &#123; console.log('outer, capture1') outer.removeEventListener('click', captureListener1, true) &#125; function captureListener2 () &#123; console.log('outer, capture2') &#125; function noneCaptureListener () &#123; console.log('outer, none-capture') &#125; function innerListener () &#123; console.log('inner') &#125; outer.addEventListener('click', captureListener1, &#123; capture: true &#125;) outer.addEventListener('click', captureListener2, true) outer.addEventListener('click', noneCaptureListener) inner.addEventListener('click', innerListener) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上例中 captureListener1 和 captureListener2 都是注册在 outer 的捕获阶段，而 noneCaptureListener 和 innerListener 分别注册在 outer 和 inner 的冒泡阶段。并且 captureListener1 会在第一次调用后被移除。请多点击几次 inner 框，查看打印的结果。 事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。这里只介绍 DOM 中的事件对象，忽略 IE 的。 无论注册事件处理程序时使用的是 DOM0 级还是 DOM2 级方法，兼容 DOM 的浏览器都会将一个 event 对象传入到事件处理程序中，这样就可以直接在函数内部访问到 event 对象了。 event 对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。下面简单的对事件对象的属性和方法进行了介绍，如果想查看详细信息，去移步 MDN。 属性：bubbles（只读）：表明事件是否会冒泡。cancelBubble：通过将该属性设置为 true 可阻止事件继续冒泡。cancelable（只读）：表明是否可以取消事件的默认行为。currentTarget（只读）：事件处理程序注册在哪个元素上，currentTarget 就指向哪个元素。defaultPrevented（只读）：表明是否已经调用了 preventDefault() 方法。eventPhase（只读）：表明处于事件流的哪个阶段。1 表示捕获阶段，2 表示处于目标，3 表示冒泡阶段。target（只读）：触发事件的那个元素，也就是事件流在“处于目标”阶段时的那个目标元素。timeStamp（只读）：表明事件对象的创建时间。type（只读）：表明事件对象的类型。isTrusted（只读）：当事件是由用户触发的时（比如点击鼠标），该属性值为 true。当事件是由脚本触发时，该属性值为 false。方法：preventDefault()：取消事件的默认行为。该方法只有在 cancelable 属性为 true 时才会起作用。stopImmediatePropagation()：取消事件的进一步捕获或冒泡，同时阻止其后的所有事件处理程序被调用。stopPropagation()：取消事件的进一步捕获或冒泡，但是不会阻止注册在当前 currentTarget 上的事件处理程序被调用。 事件类型 下面我只简单的介绍一下我认为比较常用的事件，如果你想比较全面的了解这里，点击下面的链接！MDN，只有你想不到，没有找不到 内存和性能在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。 事件委托对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。 移除事件处理程序每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。如前所述，可以采用事件委托技术，限制建立的连接数量。另外，在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的“空事件处理程序”，也是造成 Web 应用程序内存与性能问题的主要原因。 在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的 DOM 操作，例如使用 removeChild() 方法，但更多地是发生在使用 innerHTML 替换页面中某一部分的时候。如果带有事件处理程序的元素被 innerHTML 删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。所以如果你知道某个元素即将被移除，那么最好在此之前手工移除事件处理程序。 另一种情况，就是卸载页面的时候。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。每次加载完页面在卸载页面时（可能是在两个页面间来回切换，也可能是单击了“刷新”按钮），内存中滞留的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。因此最好的做法就是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2Fposts%2Fee93c80b%2F</url>
    <content type="text"><![CDATA[DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API。DOM 描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。 节点层次DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的 HTML 为例： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 可以将这个简单的 HTML 文档表示为如下层次结构： 文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即 &lt;html&gt; 元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终都是 &lt;html&gt; 元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。 每一段标记都可以通过树中的一个节点来表示。HTML 元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型有继承自一个基类型。 NodeList 与 HTMLCollection NodeList 是节点集合，是一个类数组对象。有两种类型的 NodeList：Live NodeList：它会随着 DOM 的变化而自动更新。Static NodeList：无论 DOM 如何变化，它的值都不变。可以理解为当生成 Static NodeList 时，对那一时刻的 NodeList 作了一次浅拷贝。HTMLCollection 是元素集合，是一个类数组对象。HTMLCollection 是动态的，会随着 DOM 的变化而变化。 Node 类型DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。这个 Node 接口在 JavaScript 中是作为 Node 类型实现的。除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。 每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型有 Node 类型中定义的下列 12 个数值常量来表示，任何节点类型必居其一：Node.ELEMENT_NODE: 1。Node.ATTRIBUTE_NODE: 2。Node.TEXT_NODE: 3。Node.CDATA_SECTION_NODE: 4。Node.ENTITY_REFERENCE_NODE: 5。Node.ENTITY_NODE: 6。Node.PROCESSING_INSTRUCTION_NODE: 7。Node.COMMENT_NODE: 8。Node.DOCUMENT_NODE: 9。Node.DOCUMENT_TYPE_NODE: 10。Node.DOCUMENT_FRAGMENT_NODE: 11。Node.NOTATION_NODE: 12。 通过比较上面这些常量，可以很容易地确定节点的类型，例如： 1234// 在IE中无效if (someNode.nodeType === Node.ELEMENT_NODE) &#123; console.log('Node is an element')&#125; 为了确保跨浏览器兼容，最好还是将 nodeType 属性与数字值进行比较，如下所示： 1234// 适用于所有浏览器if (someNode.nodeType === 1) &#123; console.log('Node is an element')&#125; Node 的属性 文档中所有的节点之间都存在这样或那样的关系，节点间的各种关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。每个节点都有如下属性，用于记录彼此之间的关系：childNodes：该属性可以看作一个保存着所有子节点的有序列表，它是一个 Live NodeList 对象。firstChild：指向 childNodes 列表的第一个节点，如果不存在，则为 null。lastChild：指向 childNodes 列表的最后一个节点，如果不存在，则为 null。parentNode：该属性指向文档中的父节点。previousSibling：指向上一个同胞节点，如果不存在，则为 null。nextSibling：指向下一个同胞节点，如果不存在，则为 null。ownerDocument：指向表示整个文档的文档节点。children：该属性可以看作一个保存着所有子元素的有序列表，它是一个 HTMLCollection 对象。childElementCount：返回子元素的个数。firstElementChild：指向第一个子元素。lastElementChild：指向最后一个子元素。previousElementSibling：指向前一个同辈元素。nextElementSibling：指向后一个同辈元素。 Node 的方法 因为节点的关系属性都是只读的，所以 DOM 提供了一些操作子节点的方法，：appendChild()：该方法接受单个参数：要新增的节点。操作成功后返回新增的节点。该操作会将新增的节点添加到 childNodes 列表的末尾。添加节点后，childNodes 中相关节点的关系会自动更新。insertBefore()：该方法接受两个参数：要插入的节点和作为参照的节点。操作成功后返回插入的节点。如果第二个参数是 null，则会将要插入的节点添加到 childNodes 列表的末尾。如果省略第二个参数，会抛出错误。replaceChild()：该方法接受两个参数：要插入的节点和要替换的节点。操作成功后返回被替换的节点。removeChild()：该方法接受单个参数：要移除的节点。操作成功后返回被移除的节点。cloneNode()：该方法接受一个布尔值参数，表示是否执行深复制。在参数为 true 时，执行深复制，也就是复制节点及其整个子节点树。在参数为 false 时，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。需要注意的是，该方法不会复制添加到 DOM 节点中的 JavaScript 属性，例如事件处理程序等。importNode()：该方法接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。normalize()：该方法唯一的作用是处理文档树中的文本节点。由于解析器的实现或 DOM 操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它。如果找到相邻的文本节点，则将它们合并为一个文本节点。注意事项：任何一个 DOM 节点不能同时出现在文档中的多个位置上，所以当使用 appendChild()、insertBefore() 或 replaceChild() 方法并且传入的第一个参数为文档树中已经存在的节点时，该节点会从原位置转移到对应的新位置。如果调用 appendChild() 时传入的节点属于不同的文档，则会抛出错误。每个节点都有一个 ownerDocument 属性，表示所属的文档。 Document 类型JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。Document 节点具有下列特征： nodeType 的值为 9。nodeName 的值为 &quot;#document&quot;。nodeValue 的值为 null。parentNode 的值为 null。ownerDocument 的值为 null。其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。 document 的属性 documentElement：该属性指向 HTML 页面中的 &lt;html&gt; 元素。body：该属性指向 HTML 页面中的 &lt;body&gt; 元素。doctype：该属性指向 &lt;!DOCTYPE&gt; 标签，但是不同浏览器对该属性的支持差别很大。title：通过该属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。URL：该属性保存着页面完整的URL。domain：该属性保存着页面的域名。referrer：该属性保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下，该属性值可能会包含空字符串。anchors：该属性保存着文档中所有带 name 特性的 &lt;a&gt; 元素，是一个 HTMLCollection 对象。applets：该属性保存着文档中所有的 &lt;applet&gt; 元素，是一个 HTMLCollection 对象，因为不再推荐使用 &lt;applet&gt; 元素，所以这个集合已经不建议使用了。forms：该属性保存着文档中所有的 &lt;form&gt; 元素，是一个 HTMLCollection 对象，与 document.getElementsByTagName(&#39;form&#39;) 得到的结果相同。images：该属性保存着文档中所有的 &lt;img&gt; 元素，是一个 HTMLCollection 对象，与 document.getElementsByTagName(&#39;img&#39;) 得到的结果相同。links：该属性保存着文档中所有带 href 特性的 &lt;a&gt; 元素，是一个 HTMLCollection 对象。关于 domain 属性，可以将低级域改为高级域，但是不能将高级域改为低级域。 12345// 成功document.domain = 'wrox.com'// 抛出错误！document.domain = 'p2p.wrox.com' Element 类型除了 Document 类型之外，Element 类型就要算是 Web 编程中最常用的类型了。Element 类型用于表现 XML 或 HTML 元素，提供了对元素签名、子节点及特性的访问。Element 节点具有以下特征： nodeType 的值为 1。nodeName 的值为元素的标签名。nodeValue 的值为 null。parentNode 可能是 Document 或 Element。其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。 要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性。这两个属性会返回相同的值。以下面的元素为例： 1&lt;div id="myDiv"&gt;&lt;/div&gt; 可以像下面这样获得这个元素及其标签名： 1234567var div = document.getElementById('myDiv')// DIVconsole.log(div.tagName) // trueconsole.log(div.tagName === div.nodeName) 这里的元素标签名是 div，它拥有一个值为 myDiv 的 ID。可是，div.tagName 实际上输出的是 &quot;DIV&quot; 而非 &quot;div&quot;。在 HTML 中，标签名始终都是以全部大写表示。而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在 HTML 还是 XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式，如下面的例子所示： 123if (element.tagName.toLowerCase === 'div') &#123; // 在此执行某些操作&#125; HTML 元素的属性所有 HTML 元素都是由 HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement 类型直接继承自 Element 并添加了一些属性。添加的这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。 id：元素在文档中的唯一标识符。title：有关元素的附加说明信息，一般通过工具提示条显示出来。lang：元素内容的语言代码，很少使用。dir：语言的方向，值为 ltr 或 rtl，也很少使用。className：与元素的 class 特性对应，即为元素指定的 CSS 类。没有将这个属性命名为 class，是因为 class 是 ECMAScript 的保留字。 上述这些属性都可以用来取得或修改相应的特性值。以下面的HTML元素为例： 1&lt;div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"&gt;&lt;/div&gt; 元素中指定的所有信息，都可以通过下列 JavaScript 代码取得： 12345678910111213141516var div = document.getElementById('myDiv')// myDivconsole.log(div.id) // bdconsole.log(div.className) // Body textconsole.log(div.title) // enconsole.log(div.lang) // ltrconsole.log(div.dir) 当然，像下面这样通过为每个属性赋予新的值，也可以修改对应的每个特性： 12345div.id = "someOtherId"div.className = 'ft'div.title = 'Some other text'div.lang = 'fr'div.dir = 'rtl' 操作特性每个元素都有一或多个特性，这些特性的用途是给出相应元素或内容的附加信息。操作特性的 DOM 方法主要有三个：getAttribute()、setAttribute() 和 removeAttribute()。关于这三个方法的用法就不详细介绍了，下面介绍下使用它们时的注意事项： 传递给三个方法的特性名必须与实际的特性名相同，但是不区分大小写。例如，如果想要得到 class 特性值，应传入 class 而不是 className，后者只有在通过对象属性访问特性时才用。根据 HTML5 规范，自定义特性应该加上 data- 前缀以便验证。用户自定义特性，只能通过这三个方法来操作，无法通过对象属性形式来操作。有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过 getAttribute() 方法返回的值并不相同。它们分别是：style 特性和像 onclick 这样的事件处理程序。它们的属性值分别为对象和函数，但是通过 getAttribute() 方法返回的都是是字符串。在使用 setAttribute() 为元素设置属性时，无论你传递的是什么类型的值，它都会将该值转换为字符串在设置到元素的属性上。所以对于一些特殊的属性，比如 &lt;input&gt; 标签上的 check 属性，只要出现了，无论你给它传递任何属性值（哪怕是空字符串也不行），它的属性值就是 true。只有使用 removeAttribute() 移除 check 属性，才会让该属性值变为 false。所以有的属性最好不要使用 setAttribute() 来设置。 下面的例子展示了公认特性与自定义特性的区别： 12&lt;div id="myDiv" data-special="aadonkeyz"&gt;&lt;/div&gt;&lt;input id="myInput"&gt;&lt;/input&gt; 1234567891011121314151617181920212223242526272829303132333435363738var div = document.getElementById('myDiv')// myDivconsole.log(div.id) // myDivconsole.log(div.getAttribute('id')) // undefinedconsole.log(div['data-special']) // aadonkeyzconsole.log(div.getAttribute('data-special')) div.setAttribute('class', 'myClass')// myClassconsole.log(div.className) div['data-other'] = 'other'// otherconsole.log(div['data-other'])// nullconsole.log(div.getAttribute('data-other'))div.setAttribute('data-other', 'other')// other console.log(div.getAttribute('data-other')) let input = document.getElementById('myInput')input.setAttribute('checked', '')// trueconsole.log(input.checked)input.setAttribute('checked', false)// trueconsole.log(input.checked)input.removeAttribute('checked')// falseconsole.log(input.checked) attributesElement 类型是使用 attributes 属性的唯一一个 DOM 节点类型。attributes 属性中包含一个 NamedNodeMap 类数组对象，它是一个“动态”的集合。 attributes 属性中包含一系列 Attr 节点，每个节点的 nodeName 就是特性的名称，而节点的 nodeValue 就是特性值。getNamedItem(name)：返回 nodeName 属性等于 name 的节点。removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点。setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引。item(pos)：返回位于数字 pos 位置处的节点。 下面简单的演示一下 getNamedItem() 方法的几种使用方式： 12345678// 直接使用var id = element.attributes.getNamedItem('id').nodeValue// 后台自动调用 getNamedItem() 方法var id = element.attributes['id'].nodeValue// 先取得特性节点，然后修改它的 nodeValueelement.attributes['id'].nodeValue = 'someOtherId' 一般来说，由于 attributes 属性上的方法不够方便，开发人员更多的会使用 getAttribute()、setAttribute() 和 removeAttribute() 方法。不过当你想要遍历元素的特性时，attributes 属性倒是可以派上用场。在需要将 DOM 结构序列化为 XML 或 HTML 字符串时，多数都会涉及遍历元素特性。以下代码展示了如何迭代元素的每一个特性，然后将它们构造成 name=&#39;value&#39; name=&#39;value&#39; 这样的字符串格式。 123456789101112131415function outputAttributes (element) &#123; var pairs = new Array(); var attrName; var attrValue; var i; var len; for (i = 0, len = element.attributes.length; i &lt; len; i++) &#123; attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; pairs.push(attrName + '="' + attrValue + '"'); &#125; return pairs.join(' ');&#125; 关于以上代码的运行结果，以下是两点必要的说明：针对 attributes 中包含的特性，不同浏览器返回的顺序不同。这些特性在 XML 或 HTML 代码中出现的先后顺序，不一定与它们出现在 attributes 中的顺序一致。IE7 及更早的版本会返回 HTML 元素中所有可能的特性，包括没有指定的特性。换句话说，返回 100 多个特性的情况会很常见。 针对 IE7 及更早版本中存在的问题，可以对上面的函数加以改进，让它只返回指定的特性。每个特性节点都有一个名为 specified 的属性，这个属性的值如果为 true，则意味着要么是在 HTML 中指定了相应特性，要么是通过 setAttribute() 方法设置了该特性。在 IE 中，所有未设置过的特性的该属性值都为 false，而在其他浏览器中根本不会为这类特性生成对应的特性节点（因此，在这些浏览器中，任何特性节点的 specified 值始终为 true）。改进后的代码如下所示： 123456789101112131415161718function outputAttributes (element) &#123; var pairs = new Array(); var attrName; var attrValue; var i; var len; for (i = 0, len = element.attributes.length; i &lt; len; i++) &#123; attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; if (element.attributes[i].specified) &#123; pairs.push(attrName + '="' + attrValue + '"'); &#125; &#125; return pairs.join(' ');&#125; 创建元素使用 document.createElement() 方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在 HTML 文档中不区分大小写，而在 XML（包括 XHTML）文档中，则是区分大小写的。在使用该方法创建新元素的同时，也为新元素设置了 ownerDocument 属性。例如，使用以下代码可以创建一个 &lt;div&gt; 元素： 1var div = document.createElement('div') 在 IE 中，可以以另一种方式使用 document.createElement()，即为这个方法传入完整的元素标签，也可以包含属性，如下面的例子所示： 1var div = document.createElement('&lt;div id="myNewDiv" class="box"&gt;&lt;/div&gt;') 这种方式有助于避开在 IE7 及更早版本中动态创建元素的某些问题。建议只在需要避开 IE7 及更早版本中存在的问题时，才使用这种方式！ 查找元素 只能在 document 上调用的方法：getElementById()：输入要取得的元素 ID。如果没找到，返回 null。如果有多个则返回第一个。注意，这里的 ID 必须与页面中元素的 id 特性严格匹配，包括大小写。getElementsByName()：输入取得元素的 name 特性值。返回一个 Live NodeList 对象。既能在 document 上调用，也能在 HTMLElement 上调用的方法：getElementsByTagName()：输入要取得元素的标签名。返回一个 HTMLCollection 对象。如果想要取得文档中的所有元素，可以向该方法传入 &quot;*&quot;。getElementsByClassName()：输入要取得元素的类。返回一个 HTMLCollection 对象。querySelector()：输入要取得元素的 css selector。如果没找到，返回 null。如果有多个则返回第一个。如果输入的 css selector 不合法，会抛出错误。querySelectorAll()：输入要取得元素的 css selector。返回一个 Static NodeList 对象。如果输入的 css selector 不合法，会抛出错误。 样式CSSStyleDeclaration CSSStyleDeclaration 对象代表一个 CSS 声明块。通过以下三种方式都能够访问到各自的 CSSStyleDeclaration 对象：HTMLElement.style：行内样式。CSSStyleSheet：样式表。window.getComputedStyle：只读的计算样式。CSSStyleDeclaration 对象上有如下属性和方法：cssTextlengthparentRulegetPropertyPriority()getPropertyValue()removeProperty()setProperty() 行内样式任何支持 style 特性的 HTML 元素在 JavaScript 中都有一个对应的 style 属性，其中保存着一个 CSSStyleDeclaration 对象。该对象包含通过 HTML 的 style 特性指定的所有样式信息，但不包含外部样式表或嵌入样式表层叠而来的样式。对于使用短划线的 CSS 属性名，必须将其转换成驼峰大小写形式，才能通过 JavaScript 来访问。 由于 float 是 JavaScript 的保留字，因此不能用于属性名。DOM2 级规范规定样式对象上相应的属性名应该是 cssFloat.Firefox、Safari、Opera 和 Chrome 都支持这个属性，而 IE 支持的则是 styleFloat。在标准模式下，所有度量值都必须指定一个度量单位。在混杂模式下，可以将 style.width 设置为 &quot;20&quot;，浏览器会假设它是 &quot;20px&quot;。但在标准模式下，将 style.width 设置为 &quot;20&quot; 会导致被忽略。在实践中，最好始终都指定度量单位。如果没有为元素设置 style 特性，那么 style 对象中可能会包含一些默认的值，但这些值并不能准确地反映该元素的样式信息。例如，在 style 特性中没有定义 width，而通过样式表来定义了 width 的话，默认值就不能准确地反映样式信息了。 1&lt;div id="myDiv" style="width: 10px; font-size: 1px;"&gt;&lt;/div&gt; 123456789var div = document.getElementById('myDiv')// 10pxconsole.log(div.style.width)// 1pxconsole.log(div.style.fontSize) div.style.height = '20px' 计算样式window.getComputedStyle(element [, pseudoElt]) 方法会解析一个元素的样式，然后返回一个包含元素所有 CSS 属性值的对象。所有计算样式都是只读的，试图修改会抛出错误。 1&lt;div id="myDiv" style="width: 10px; font-size: 1px;"&gt;&lt;/div&gt; 123456var div = document.getElementById('myDiv')var computedStyle = window.getComputedStyle(div)// 10pxconsole.log(computedStyle.width) 样式表局限性 如果样式已经通过行内样式的方式定义了，那么怎么操作样式表也修改不了对应的样式！ CSSRuleCSSRule 对象表示样式表中的每一条规则。实际上，CSSRule 是一个供其他多种类型继承的基类型，其中最常见的就是 CSSStyleRule 类型，表示样式信息。CSSStyleRule 对象包含下列属性： cssText：返回整条规则对应的文本。parentRule：如果当前规则是导入的规则，这个属性引用就是导入的规则，否则这个值为 null。parentStyleSheet：当前规则所属的样式表。selectorText：返回当前规则的选择符文本。style：一个 CSSStyleDeclaration 对象，可以通过它设置和取得规则中特定的样式值。type：表示规则类型的常量值。 样式表的属性和方法CSSStyleSheet 类型表示的是样式表，包括通过 &lt;link&gt; 元素包含的样式表和在 &lt;style&gt; 元素中定义的样式表。CSSStyleSheet 继承自 StyleSheet，后者可以作为一个基础接口来定义非 CSS 样式表。 从 StyleSheet 接口继承而来的属性如下，其中除了 disable 属性，其他属性均为只读属性：disabled：表示样式是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为 true 可以禁用样式表。href：如果样式表是通过 &lt;link&gt; 包含的，则是样式表的 URL，否则为 null。media：当前样式表支持的所有媒体类型的集合。与所有 DOM 集合一样，这个集合也有一个 length 属性和一个 item() 方法，也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在 HTML 中通过 &lt;link&gt; 或 &lt;style&gt; 引入的（在 XML 中可能是通过指令引入的）。如果当前样式表是其他样式表通过 @import 导入的，则这个属性值为 null。parentStyleSheet：在当前样式表是通过 @import 导入的情况下，这个属性是一个指向导入它的样式表的指针。title：ownerNode 中 title 属性的值。type：表示样式表类型的字符串。对 CSS 样式表而言，这个字符串是 &quot;type/css&quot;。CSSStyleSheet 类型还支持下列属性和方法：cssRules：样式表中包含的样式规则的集合，集合中的每一项都是一个 CSSRule 对象。IE 不支持这个属性，但有一个类似的 rules 属性。ownerRules：如果样式表是通过 @import 导入的，这个属性就是一个指针，指向表示导入的规则，否则为 null。deleteRule(index)：删除 cssRules 集合中指定位置的规则。insertRule(rule, index)：向 cssRules 集合中指定的位置插入 rule 字符串。 获取样式表应用于文档的所有样式表是通过 document.styleSheets 集合来表示的。通过这个集合的 length 属性可以获知文档中样式表的数量，而通过方括号语法或 item() 方法可以访问每一个样式表。来看一个例子： 12345var sheet = nullfor (var i = 0, len = document.styleSheets.length; i &lt; len; i++) &#123; sheet = document.styleSheets[i] console.log(sheet)&#125; DOM 为 &lt;link&gt; 或 &lt;style&gt; 元素定义了一个 sheet 属性，通过它可以直接取得对应的样式表。除了 IE，其他浏览器都支持这个属性，IE 支持的是 styleSheet 属性。 1234567function getStyleSheet (element) &#123; return element.sheet || element.styleSheet&#125;// 取得第一个&lt;link&gt;元素引入的样式表var link = document.getElementByTagName('link')[0]var sheet = getStyleSheet(link) 使用样式表前面已经介绍足够多的准备知识了，现在直接举一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;style id="mySheet"&gt; #myDiv &#123; border: 1px solid red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var sheet = document.getElementById('mySheet').sheet // 取得规则列表 var rules = sheet.cssRules || sheet.rules // 取得第一条规则 var rule = rules[0] // #myDiv &#123; border: 1px solid red; &#125; console.log(rule.cssText) // null console.log(rule.parentRule) // #myDiv console.log(rule.selectorText) // 1 console.log(rule.type) // 1px solid red console.log(rule.style.border) // 改变第一条规则中的内容 rule.style.border = '1px solid black' rule.style.width = '20%' // 创建第二条规则，并放到样式表最前面 sheet.insertRule('body &#123;background: silver&#125;', 0) // 删除旧的规则 sheet.deleteRule(1) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 元素大小偏移量 首先要介绍的属性涉及偏移量，包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。通过下列属性可以取得元素的偏移量：offsetParent：该属性指向最近的包含该元素的定位元素。如果外层没有定位元素，则返回最近的 &lt;td&gt;、&lt;th&gt;、&lt;table&gt; 或者 &lt;body&gt;。如果元素的 style.display 为 none，则 offsetParent 返回 null。offsetLeft：元素的左外边框至 offsetParent 的左内边框之间的像素距离。offsetTop：元素的上外边距至 offsetParent 的上内边框之间的像素距离。offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。 offsetLeft 和 offsetTop 的值都是相对于最近的定位元素，也就是 offsetParent。所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性。如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。 要想知道某个元素在页面上的偏移量，将这个元素的 offsetLeft 和 offsetTop 与其 offsetParent 的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。以下两个函数就可以用于分别取得元素的左和上偏移量 1234567891011121314151617181920212223function getElementLeft (element) &#123; var actualLeft = element.offsetLeft var current = element.offsetParent while (current !== null ) &#123; actualLeft += current.offsetLeft current = current.offsetParent &#125; return actualLeft&#125;function getElementTop (element) &#123; var actualTop = element.offsetTop var current = element.offsetParent while (current !== null ) &#123; actualTop += current.offsetTop current = current.offsetParent &#125; return actualTop&#125; 客户区 元素的客户区大小，指的是元素内容及其内边距所占据的空间大小。有关客户区大小的属性有两个：clientWidth：元素内容区宽度加上左右内边距宽度。clientHeight：元素内容区高度加上上下内边距高度。clientLeft：元素左边框的厚度。clientTop：元素上边框的厚度。 滚动 滚动大小指的是包含滚动内容的元素的大小。有些元素（例如 &lt;html&gt; 元素），即使没有执行任何代码也能自动添加滚动条。但另外一些元素，则需要通过 CSS 的 overflow 属性进行设置才能滚动。以下是与滚动大小相关的属性：scrollHeight：在没有滚动条的情况下，元素内容区高度加上上下内边距高度。scrollWidth：在没有滚动条的情况下，元素内容区宽度加上左右内边距宽度。scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 getBoundingClientRect通过 Element.getBoundingClientRect() 的形式调用该方法，会返回一个对象，用于指示目标元素在页面中相对于视口的位置信息和目标元素的大小信息，该对象包含 top、right、bottom、left、width、height、x 和 y。其中不同浏览器对 width、height、x 和 y属性的支持程度不一样。 bottom 和 right 的含义与绝对定位中的不同，请看下图。当计算边界矩形时，会考虑视口区域（或其他可滚动元素）内的滚动操作，也就是说，当滚动位置发生了改变，top、 right、 bottom 和 left 属性值就会立即随之发生改变。 对于不支持 Element.getBoundingClientRect() 方法的浏览器，可以通过其他手段取得相同的信息。一般来说，right 和 left 的差值与 offsetWidth 的值相等，而 bottom 和 top 的差值与 offsetHeight 的值相等。polyfill 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142function getElementLeft (element) &#123; var actualLeft = element.offsetLeft var current = element.offsetParent while (current !== null ) &#123; actualLeft += current.offsetLeft current = current.offsetParent &#125; return actualLeft&#125;function getElementTop (element) &#123; var actualTop = element.offsetTop var current = element.offsetParent while (current !== null ) &#123; actualTop += current.offsetTop current = current.offsetParent &#125; return actualTop&#125;function getBoundingClientRect (element) &#123; if (element.getBoundingClientRect) &#123; return element.getBoundingClientRect() &#125; else &#123; var scrollTop = document.documentElement.scrollTop var scrollLeft = document.documentElement.scrollLeft var actualTop = getElementTop(element) var actualLeft = getElementLeft(element) return &#123; top: actualTop - scrollTop, bottom: actualTop - scrollTop + element.offsetHeight, left: actualLeft - scrollLeft, right: actualLeft - scrollLeft + element.offsetWidth &#125; &#125;&#125;]]></content>
      <categories>
        <category>FE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CommonJS]]></title>
    <url>%2Fposts%2Fb3fe2fad%2F</url>
    <content type="text"><![CDATA[CommonJs模块规范CommonJs是 Node 的规范，是一直沿用至今的一个模块规范,。虽然ES6提出了新的模块规范，但目前为止 Node 无法直接兼容ES6，我们按照ES6的模块规范来书写代码，但是实际上它们最终会被编译为CommonJs规范对应的代码来执行。 需要记住，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了function (exports, require, module, __filename, __dirname) {\n，而在尾部添加了\n}。所以一个正常的JavaScript文件会被包装成如下的样子： 1234function (exports, require, module, __filename, __dirname) &#123; // .js文件的内容 // ......&#125; 模块文件5个变量的含义：exports：一个对象，用来挂载当前模块中要导出的内容；require：一个用来引入其他模块的函数；module：一个代表模块自身的对象；__filename：当前模块文件的绝对路径；__dirname：当前模块文件所在目录的绝对路径。注意千万不要重写这些变量，否则会导致它们与模块文件之间的联系被切断。 下面的例子是我创建了一个名为test.js的文件并用node运行得到的： 1234567891011121314// test.js文件console.log(exports) // &#123;&#125;console.log(typeof require) // functionconsole.log(__filename) // D:\Others\test.jsconsole.log(__dirname) // D:\Othersconsole.log(module) // Module &#123; // id: '.', // exports: &#123;&#125;, // parent: null, // filename: 'D:\\Others\\test.js', // loaded: false, // children: [], // paths: [ 'D:\\Others\\node_modules', 'D:\\node_modules' ] // &#125; 现在我创建了两个文件a.js和b.js，在a.js中演示exports的使用，在b.js中演示require的使用。 12345678// a.jslet name = 'a.js'let sayName = function () &#123; console.log(`my name is $&#123;name&#125;`)&#125;exports.sayName = sayName 1234// b.jsvar moduleA = require('./a.js')moduleA.sayName() // my name is a.js 在a.js文件中，通过将函数sayName()挂载到exports对象上，来导出sayName()。而在b.js文件中，通过require()函数获取了a.js文件中要导出内容组成的对象。 我们已经知道了Node会将每个模块文件包装为一个函数，而exports对象实际上是通过形参的方式传入的，直接赋值形参会改变形参的引用。所以为了防止无意间重写exports，推荐使用module.exports来替代它。下面演示下初学者容易犯的错误，和推荐的用法： 123456789101112// a1.jslet name = 'a1.js'let sayName = function () &#123; console.log(`my name is $&#123;name&#125;`)&#125;// 错误用法exports = &#123; name, sayName&#125; 1234567891011// a2.jslet name = 'a2.js'let sayName = function () &#123; console.log(`my name is $&#123;name&#125;`)&#125;// 推荐用法module.exports = &#123; name, sayName&#125; 1234567// b.jsvar moduleA1 = require('./a1.js')var moduleA2 = require('./a2.js')moduleA1.sayName() // TypeError: moduleA.sayName is not a functionmoduleA2.sayName() // my name is a2.js 模块加载机制CommonJS模块的重要特性是加载时执行，即模块文件内的代码会在被require()的时候，就会全部执行。当执行完成后，module.exports对象就代表着被加载的模块文件要导出的内容。 有两点需要注意：var moduleA = require(&#39;./a.js&#39;)中的moduleA，是由a.js文件中的module.exports经过一次浅拷贝得到的；同一个模块文件，也许会被多次加载，但是只会执行一次。 浅拷贝的操作类似于clone函数： 123456789function clone(obj) &#123; let newObj = &#123;&#125; for (let key in ) &#123; newObj[key] = obj[key] &#125; return newObj&#125; 在明白上面说述内容后，请观察一个例子： 12345678910111213141516171819202122// a.jslet count = 0let obj = &#123; num: 0&#125;let show = function () &#123; console.log(`count is: $&#123;count&#125;`) console.log(`obj.num is: $&#123;obj.num&#125;`)&#125;let change = function () &#123; count++ obj.num++&#125;module.exports = &#123; count, obj, show, change&#125; 1234567891011121314// b.jsvar moduleA = require('./a.js')console.log(moduleA.count) // 0console.log(moduleA.obj.num) // 0moduleA.show() // count is: 0 // obj.num is: 0moduleA.change()console.log(moduleA.count) // 0console.log(moduleA.obj.num) // 1moduleA.show() // count is: 1 // obj.num is: 1 通过change()函数同时改变了count和obj.num的值。在a.js文件中，count和obj.num的值均变为1，而在b.js文件中moduleA.count的值还是为0没有变化，moduleA.obj.num的值则变为1。如果你没看懂，你可能需要看这里。 模块循环require()在CommonJs中如果出现模块“循环require()”，只会输出已经执行的部分，还未执行的部分不会输出。下面贴出官方文档里面的例子。 1234567891011// a.jsconsole.log('a starting')exports.done = falseconst b = require('./b.js')console.log('in a, b.done = %j', b.done)exports.done = trueconsole.log('a done') 1234567891011// b.jsconsole.log('b starting')exports.done = falseconst a = require('./a.js')console.log('in b, a.done = %j', a.done)exports.done = trueconsole.log('b done') 1234567// main.jsconsole.log('main starting')const a = require('./a.js')const b = require('./b.js')console.log('in main, a.done = %j, b.done = %j', a.done, b.done) 123456789依次输出：main startinga startingb startingin b, a.done = falseb donein a, b.done = truea donein main, a.done = true, b.done = true When main.js loads a.js, then a.js in turn loads b.js. At that point, b.js tries to load a.js. In order to prevent an infinite loop, an unfinished copy of the a.js exports object is returned to the b.js module. b.js then finishes loading, and its exports object is provided to the a.js module.]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[import 与 export]]></title>
    <url>%2Fposts%2F588c1481%2F</url>
    <content type="text"><![CDATA[何为模块？ 模块是使用不同方式加载的 JS 文件（与 JS 原先的脚本加载方式相对）。这种不同模式很有必要，因为它与脚本（script）有大大不同的语义：模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式。在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域内部存在。模块顶级作用域的 this 值为 undefined。模块不允许在代码中使用HTML风格的注释。对于需要让模块外部代码访问的内容，模块必须导出它们。允许模块从其他模块导入绑定。 CommonJS 是在 ES6 之前的模块规范，至今仍然被广泛使用。点击这里了解 CommonJS！ 导出ES6 的导出有两种形式：命名导出和默认导出。 命名导出命名导出要求导出的内容必须有自己的标识符，这就意味着不能使用这种方式来导出匿名函数或匿名类。 你可以将 export 放置在任意变量、函数或类声明之前，从模块中将它们公开出去，就像这样： 12345678910111213141516export var color = 'red'export let name = 'Nicholas'export const magicNumber = 7export function sum(num1, num2) &#123; return num1 + num1&#125;export class Rectangle &#123; constructor (length, width) &#123; this.length = length this.width = width &#125;&#125; 或者使用花括号包裹想要导出内容的标识符，一起将它们导出。在使用这种方式的时候，允许你对导出的内容进行重命名： 123456789function multiply (num1, num2) &#123; return num1 * num2&#125;function sum (num1, num2) &#123; return num1 + num2&#125;export &#123; multiply, sum as add &#125; 默认导出模块的默认值是使用 default 关键字所指定的单个变量、函数或类，而你在每个模块中最多只能设置一个默认导出，将 default 关键字用于多个导出会是语法错误。 使用 default 可以导出匿名函数或匿名类，实际上默认导出并不在乎导出内容的标识符，就算导出的内容原本是有标识符的，在其他模块中引入时，也会忽略它原本的标识符。 以下三种用法都是正确的： 123export default function (num1, num2) &#123; return num1 + num2&#125; 12345function sum (num1, num2) &#123; return num1 + num2&#125;export default sum 12345function sum (num1, num2) &#123; return num1 + num2&#125;export &#123; sum as default &#125; 使用 default 导出的内容必须是已经声明过或正在声明的，否则会抛出错误： 12// ReferenceError: sum is not definedexport default sum = function () &#123;&#125; 导入导入的语法创建了 a.js 文件用于导出，b.js 文件用于导入： 1234567891011121314// a.jsexport var count = 0export var color = 'red'export function multiply (num1, num2) &#123; return num1 * num2&#125;export function sum (num1, num2) &#123; return num1 + num2&#125;var num = 666export default num 1234567891011121314151617181920212223242526272829303132333435363738394041// b.jsimport &#123; count &#125; from './a.js'import &#123; sum as add, multiply &#125; from './a.js'// 0console.log(count) // [Function: sum]console.log(add) // [Function: multiply]console.log(multiply) import * as moduleA from './a.js'// &#123;// multiply: [Function: multiply],// sum: [Function: sum],// count: 0,// color: 'red',// default: 666// &#125;console.log(moduleA) import default1 from './a.js'// 666console.log(default1) import &#123; default as default2 &#125; from './a.js'//666console.log(default2) import default3, &#123; color &#125; from './a.js'// 666console.log(default3) // redconsole.log(color) 根据上面例子，总结以下几点注意事项：在使用 import 引入一个模块的内容时，除了默认导出，其他导出均需要根据标识符来进行匹配。默认导出是一个特立独行的存在，它在原模块中的标识符是被忽略的。比如上面例子中的 moduleA 对象不包含 num 属性，但是包含 default 属性。 只读绑定ES6 的 import 语句为变量、函数与类创建了只读绑定，不允许修改这个只读绑定的值，否则会抛出错误。 其实只要不是重写这个导入的变量，其他任何操作都是可以的，比如修改对象的属性。 12345678910// a.jsexport var name = 'Nicholas'export var obj = &#123; a: 1&#125;export function setName (newName) &#123; name = newName&#125; 123456789101112131415161718// b.jsimport &#123; name, obj, setName &#125; from './a.js'// Nicholasconsole.log(name) setName('Greg')// Gregconsole.log(name) obj.a = 2// &#123;a: 2&#125;console.log(obj) // SyntaxError: "name" is read-onlyname = 'Nicholas' 调用 setName(&#39;Greg&#39;) 会回到导出 setName() 的模块内部，并在那里执行，从而将 a.js 文件内的 name 设置为 &#39;Greg&#39;，注意这个变化会自动反映到 b.js 文件内所导入的 name 绑定上。 模块的实例化与缓存 无论你对同一个模块使用了多少次 import 语句，该模块都只会被执行一次。在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 import 所引用。 123456// a.jsimport * as b from './b.js'import * as c from './c.js'// a.js: b change c.objconsole.log(`a.js: $&#123;c.obj.b&#125;`); 1234// b.jsimport * as c from './c.js'c.obj.b = 'b change c.obj' 12// c.jsexport let obj = &#123;&#125;; 绑定的再导出也许有时你会想将当前模块已导入的内容重新再导出，你可以这样做： 12import &#123; sum &#125; from './example.js'export &#123; sum &#125; 此方法能奏效，但还可以使用单个语句来完成相同的任务： 1export &#123; sum &#125; from './example.js' 这种形式的 export 会进入指定模块查看 sum 的定义，随后将其导出。当然，你也可以选择一个值用不同名称导出： 1export &#123; sum as add &#125; from './example.js' 若你想将来自另一个模块的所有值完全导出，可以使用星号（*）模式： 1export * from './example.js' 使用完全导出，就可以导出目标模块的默认值及所有具名导出，但这可能影响你从当前模块所能导出的值。例如，假设 example.js 具有一个默认导出，当你使用这种语法时，你就无法为当前模块另外再定义一个默认导出。 无绑定的导入有些模块也许没有进行任何导出，相反只是修改全局作用域的对象。尽管这种模块的顶级变量、函数或类最终并不会自动被加入全局作用域，但这并不意味着该模块无法访问全局作用域。诸如 Array 与 Object 之类的内置对象的共享定义在模块内部可访问的，并且对于这些对象的修改会反映到其他模块中。 例如，若你想为所有数组添加一个 pushAll() 方法，你可以像下面这样定义一个模块文件 a.js： 1234567891011// a.js// 没有导出与导入的模块Array.prototype.pushAll = function(items) &#123; // items 必须是一个数组 if (!Array.isArray(items)) &#123; throw new TypeError('Argument must be an array.') &#125; // 使用内置的 push() 与扩展运算符 return this.push(...items)&#125; 这是一个有效的模块，尽管此处没有任何导出与导入。此代码可以作为模块或脚本来使用。由于它没有导出任何东西，你可以使用简化的导入语法来执行此模块的代码，而无须导入任何绑定： 12345678910// b.jsimport './a.js'let colors = ['red', 'green', 'blue']let items = []items.pushAll(colors)// [ 'red', 'green', 'blue' ]console.log(items) 此代码导入并执行了包含 pushAll() 的模块，于是 pushAll() 就被添加到数组的原型上。这意味着现在 pushAll() 在当前模块内的所有数组上都可用。 import/export 的限制import 与 export 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部。例如，以下代码会抛出错误： 1234function tryImport () &#123; // SyntaxError: 'import' and 'export' may only appear at the top level import flag from './a.js' &#125; 123456let flag = trueif (flag) &#123; // SyntaxError: 'import' and 'export' may only appear at the top level export flag &#125; 模块的循环引用ES6 根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 12345678910// even.jsimport &#123; odd &#125; from './odd.js'export var counter = 0export function even(n) &#123; counter++ return n == 0 || odd(n - 1)&#125; 123456// odd.jsimport &#123; even &#125; from './even'export function odd(n) &#123; return n != 0 &amp;&amp; even(n - 1)&#125; 1234567891011121314// main.jsimport * as m from './even.js'// trueconsole.log(m.even(10)) // 6console.log(m.counter) // trueconsole.log(m.even(20)) // 17console.log(m.counter) 调用 m.even(10) 时，参数 n 从 10 变为 0 的过程中，even() 一共会执行 6 次，所以 counter 等于 6。调用 m.even(20) 时，参数 n 从 20 变为 0，even() 一共会执行 11 次，加上前面的 6 次，所以变量 counter 等于 17。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Reflect 与 Proxy]]></title>
    <url>%2Fposts%2F27777a89%2F</url>
    <content type="text"><![CDATA[ES6 让开发者能进一步接近 JS 引擎的能力，这些能力原先只存在于内置对象上。语言通过代理暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变 JS 引擎的底层操作。 代理与反射是什么？Proxy 对象用于在目标对象上定义一些基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 语法：let proxy = new Proxy(target, handler)。target 与 handler 参数都是必填项。target：用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。handler：一个包含特定方法的对象，这些特定的方法又叫做陷阱函数。陷阱函数：用来拦截 target 对象上的特定操作、并用自定义行为替代这些特定操作的默认行为。陷阱函数内部的 this 指向 handler。 观察下面的例子： 123456789101112131415161718192021222324let targetObj = &#123;name: 'target object'&#125;let handlerObj = &#123; // get陷阱函数，用于拦截对象的属性访问操作 get () &#123; return 'change the underlying operation' &#125;&#125;let proxyObj = new Proxy(targetObj, handlerObj)// target objectconsole.log(targetObj.name)// change the underlying operationconsole.log(proxyObj.name)// undefinedconsole.log(targetObj.notExist) // change the underlying operationconsole.log(proxyObj.notExist) 上面的例子中，proxyObj 是通过 Proxy 对 targetObj 进行了包装得到的代理对象，在对 proxyObj 的属性进行访问时，调用的是 handlerObj 中的 get 方法，因为陷阱函数 get 的存在，拦截了所有对 proxy 属性进行访问的操作。 Reflect 对象是一个内置的对象，它是给底层操作提供默认行为的方法的集合。每个陷阱函数都可以在 Reflect 对象上找到与之对应的同名方法，这个方法也叫做反射接口，陷阱函数与反射接口之间是一一对应的，并且它们接收的参数是相同的。 另外需要注意的是，Reflect 不是一个函数对象，因此它不可以被当作构造器使用。 每个陷阱函数都可以重写 JS 对象的一个特定默认行为，允许你拦截并修改它。如果你仍然需要使用原先的默认行为，则可使用 Reflect 的对应反射接口。 下面表格中列出了陷阱函数、对应的操作和对应的默认行为： 代理陷阱 对应操作 默认行为 get 读取一个属性的值 Reflect.get() set 写入一个属性的值 Reflect.set() has in运算符 Reflect.has() deleteProperty delete运算符 Reflect.deleteProperty() getPrototypeOf Object.getPrototypeOf() Reflect.getPrototypeOf() setPrototypeOf Object.setPrototypeOf() Reflect.setPrototypeOf() isExtensible Object.isExtensible() Reflect.isExtensible() preventExtensions Object.preventExtensions() Reflect.preventExtensions() getOwnPropertyDescriptor Object.getOwnPropertyDescriptor() Reflect.getOwnPropertyDescriptor() defineProperty Object.defineProperty() Reflect.defineProperty() ownKeys Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols() Reflect.ownKeys() apply 调用一个函数 Reflect.apply() construct 使用new调用一个函数 Reflect.construct() get handler.get()/Reflect.get() 的参数：trapTarget：目标对象。key：目标属性的键。receiver：最初被调用的对象（通常是代理对象，但也可能是以代理对象为原型的其他对象）。handler.get() 的返回值：可以返回任何值。handler.get()的限制：如果目标属性是目标对象的自有属性、不可写且不可配置，那么返回值必须与该目标属性的值相同，否则会抛出错误。如果目标属性是目标对象的自有属性、不可配置且没有定义 getter，那么返回值必须为 undefined ，否则会抛出错误。 set handler.set()/Reflect.set() 的参数：trapTarget：目标对象。key：目标属性的键。value：目标属性的值。receiver：最初被调用的对象（通常是代理对象，但也可能是以代理对象为原型的其他对象）。handler.set()的返回值：会自动将返回值转换为对应的布尔值，true 代表操作成功，false 代表操作失败。在严格模式下，如果返回 false，会抛出错误。handler.set()的限制：如果目标属性是不可写且不可配置的，那么不允许改变它的值，否则会抛出错误。如果目标属性是不可配置，并且没有定义 setter，那么不允许设置它的值，否则会抛出错误。关于上面两个限制，是对象自己的限制，跟 handler.set() 没啥关系。 has handler.has()/Reflect.has() 的参数：trapTarget：目标对象。key：目标属性的键。handler.has() 的返回值：会自动将返回值转换为对应的布尔值。handler.has() 的限制：如果目标属性是目标对象的自有属性，且是不可配置的，那么不允许返回 false，否则会抛出错误。如果目标属性是目标对象的自有属性，且目标对象是不可扩展的，那么不允许返回 false，否则会抛出错误。 deleteProperty handler.deleteProperty()/Reflect.deleteProperty() 的参数：trapTarget：目标对象。key：目标属性的键。handler.deleteProperty() 的返回值：会自动将返回值转换为对应的布尔值，true 代表操作成功，false 代表操作失败。在严格模式下，如果返回 false，会抛出错误。handler.deleteProperty() 的限制：如果目标属性是目标对象的自有属性，且是不可配置的，那么不允许删除该属性，否则会返回 false。 Object 与R eflect的区别Object 对象和 Reflect 对象上存在着一些同名方法，比如 getPrototypeOf()、setPrototypeOf()、isExtensible 等等。它们不仅名称相同，功能也大致相同，这会让人产生疑惑，会有一种“既然有了 Object，何必又出现 Reflect”的感觉。 Reflect 对象上的方法属于底层方法、是对 JS 语言内部方法进行封装（并附加了一些输入验证）后得到的。而 Object 对象上的方法属于高级方法，它们会在调用 JS 语言内部方法之前添加一些步骤、并检查返回值。。 getPrototypeOf handler.getPrototypeOf()/Reflect.getPrototypeOf() 的参数：trapTarget：目标对象。handler.getPrototypeOf() 的返回值：返回值必须是一个对象或者 null，否则会抛出错误。handler.getPrototypeOf() 的限制：如果目标对象是不可扩展的，那么返回值必须是目标对象的原型（即 Object.getPrototypeOf(target)），否则会抛出错误。 Object.getPrototypeOf 与 Reflect.getPrototypeOf 的区别：Object.getPrototypeOfReflect.getPrototypeOf接收的参数不是对象时，会先将其转换为对象接收的参数不是对象时，会抛出错误 setPrototypeOf handler.setPrototypeOf()/Reflect.setPrototypeOf() 的参数：trapTarget：目标对象。proto：需要被用作原型的对象。handler.setPrototypeOf() 的返回值：会自动将返回值转换为对应的布尔值，true 代表操作成功，false 代表操作失败;如果返回 false，会导致 Object.setPrototypeOf() 抛出错误。handler.setPrototypeOf() 的限制：如果目标对象是不可扩展的，那么必须保证传入的 proto 参数就是目标对象的原型（即 Object.getPrototypeOf(target)），否则会抛出错误。 Object.setPrototype 与 Reflect.setPrototype 的区别：Object.setPrototypeReflect.setPrototype接收的第一个参数不是对象时，会先将其转换为对象接收的第一个参数不是对象时，会抛出错误操作成功会将接收的第一个参数作为自身的返回值，操作失败会抛出错误操作成功返回 true，操作失败返回 false isExtensible handler.isExtensible()/Reflect.isExtensible() 的参数：trapTarget：目标对象。handler.isExtensible() 的返回值：会自动将返回值转换为对应的布尔值。handler.isExtensible() 的限制：返回值必须与 Object.isExtensible(target) 的值相同，否则会抛出错误。 Object.isExtensible 与 Reflect.isExtensible 的区别：Object.isExtensibleReflect.isExtensible接收的参数不是对象时，会返回 false接收的参数不是对象时，会抛出错误 preventExtensions handler.preventExtensions()/Reflect.preventExtensions() 的参数：trapTarget：目标对象。handler.preventExtensions() 的返回值：会自动将返回值转换为对应的布尔值，true 代表操作成功，false 代表操作失败。如果返回 false，会抛出错误。handler.preventExtensions() 的限制：只有当Object.isExtensible(target) 的值为 false 时，才允许返回 true，否则会抛出错误。 Object.preventExtensions 与 Reflect.preventExtensions 的区别：Object.preventExtensionsReflect.preventExtensions总是将接收的参数作为自身的返回值，即使该参数不是一个对象接收的参数不是对象时，会抛出错误。参数是一个对象时，会在操作成功时返回 true，失败时返回 false getOwnPropertyDescriptor handler.getOwnPropertyDescriptor()/Reflect.getOwnPropertyDescriptor() 的参数：trapTarget：目标对象。key：目标属性的键。handler.getOwnPropertyDescriptor() 的返回值：返回值必须是一个对象或者 undefined，否则会抛出错误。如果返回一个对象，会忽略对象中的其他属性，只保留 configurable、enumerable、writable、value、get 或 set。如果返回一个对象，其中数据属性与访问器属性不能同时存在，否则会抛出错误。如果返回一个对象，默认 { value: undefined, writable: false, enumerable: false, configurable: false }。handler.getOwnPropertyDescriptor() 的限制：如果目标属性是目标对象的自有属性，且是不可配置的，那么返回值必须与 Object.getOwnPropertyDescriptor(target) 相同，否则会抛出错误。如果目标属性是目标对象的自有属性，且是可配置的，那么只允许返回 undefined 或者 configurable 属性为 true 的对象，否则会抛出错误。如果目标属性是目标对象的自有属性，且目标对象是不可扩展的，那么不允许返回 undefined，否则会抛出错误（注意目标属性是否可配置，然后结合上面两条规则，取交集）。如果目标属性不是目标对象的自有属性，且目标对象是不可扩展的，那么必须返回 undefined，否则会抛出错误。如果目标属性不是目标对象的自有属性，那么只可以返回 undefined 或者 configurable 属性为 true 的对象，否则会抛出错误。 Object.getOwnPropertyDescriptor 与 Reflect.getOwnPropertyDescriptor 的区别：Object.getOwnPropertyDescriptorReflect.getOwnPropertyDescriptor接收的第一个参数不是对象时，会先将其转换为对象接收的第一个参数不是对象时，会抛出错误 defineProperty handler.defineProperty()/Reflect.defineProperty() 的参数：trapTarget：目标对象。key：目标属性的键。descriptor：为该属性准备的描述符对象。handler.defineProperty() 的返回值：会自动将返回值转换为对应的布尔值，true 代表操作成功，false 代表操作失败。如果返回 false，会导致 Object.defineProperty() 抛出错误。handler.defineProperty() 的限制：如果目标对象不可扩展，那么不允许添加属性，否则会抛出错误。如果目标属性是目标对象的自有属性，且是不可配置，那么不允许修改其描述符，否则会抛出错误。 Object.defineProperty 与 Reflect.defineProperty 的区别：Object.definePropertyReflect.defineProperty总是返回接收到的第一个参数成功时返回 true，失败时返回 false ownKeys handler.ownKeys()/Reflect.ownKeys() 的参数：trapTarget：目标对象。handler.ownKeys() 的返回值：会自动将返回值转换为一个数组（用内部的 CreateListFromArrayLike 方法），所以如果返回的是基本类型值，会抛出错误。这个数组的元素必须是字符串类型或者符号类型，否则会抛出错误。handler.ownKeys() 的限制：Object.keys(proxy) 的结果是对 Object.keys(target) 与返回的数组取交集。Object.getOwnPropertyNames(proxy) 会将返回的数组中所有符号类型的键过滤。Object.getOwnPropertySymbols(proxy) 会将返回的数组中所有字符串类型的键过滤。如果目标对象中包含不可配置的属性，那么返回的数组中必须包含该属性的键，否则会抛出错误。如果目标对象不可扩展，那么返回的数组必须包含目标对象的所有自有属性，且不能包含多余的内容，否则会抛出错误。 apply handler.apply()/Reflect.apply() 的参数：trapTarget：目标对象（被执行的函数）。thisArg：调用过程中函数内部的 this 值。argumentsList：被传递给函数的参数数组。handler.apply() 的返回值：可以返回任何值。handler.apply() 的限制：trapTarget 参数必须是一个函数，否则会抛出错误。 construct handler.construct()/Reflect.construct() 的参数：trapTarget：目标对象（被执行的函数）。argumentsList：被传递给函数的参数数组。newTarget（可选参数）：new.target 的值。handler.construct() 的返回值：返回值必须是一个对象，否则会抛出错误。handler.construct() 的限制：trapTarget 参数必须是一个函数，否则会抛出错误。 关于 newTarget 参数，请看下面例子。 12345678910111213141516171819202122232425262728function target () &#123; console.log(new.target)&#125;let proxy = new Proxy(target, &#123; construct (trapTarget, argumentsList, newTarget) &#123; console.log(newTarget) return &#123;&#125; &#125;&#125;)// [Function: target]new target()// [Function: target]Reflect.construct(target, [])// [Function: a]Reflect.construct(target, [], function a () &#123;&#125;)// [Function: target]new proxy() // [Function: target]Reflect.construct(proxy, []) // [Function: b]Reflect.construct(proxy, [], function b () &#123;&#125;) 调用构造器而无须使用 new假设 Numbers 函数是硬编码的，无法被修改，一直该代码依赖于 new.target，而你想要在调用函数时避免这个检查。在“必须使用 new”这一限制已经确定的情况下，你可以使用 apply 陷阱函数来规避它： 1234567891011121314151617181920function Numbers(...values) &#123; if (typeof new.target === 'undefined') &#123; throw new TypeError('This function must be called with new.') &#125; this.values = values&#125;let NumbersProxy = new Proxy(Numbers, &#123; apply: function (trapTarget, thisArg, argumentsList) &#123; // 下面两种方式都是可以的 // return Reflect.construct(trapTarget, argumentsList) return new trapTarget(...argumentsList) &#125;&#125;)let instance = NumbersProxy(1, 2, 3, 4)// [ 1, 2, 3, 4 ]console.log(instance.values) 重写抽象基础类的构造器在抽象基础类的构造器中，new.target 被要求不能是构造器自身的。但是通过 construct 陷阱函数，我们可以规避这个限制： 1234567891011121314151617181920class AbstractNumbers &#123; constructor (...values) &#123; if (new.target === AbstractNumbers) &#123; throw new TypeError('This function must be inherited from.') &#125; this.values = values &#125;&#125;let AbstractNumbersProxy = new Proxy(AbstractNumbers, &#123; construct: function (trapTarget, argumentsList) &#123; return Reflect.construct(trapTarget, argumentsList, function () &#123;&#125;) &#125;&#125;)let instance = new AbstractNumbersProxy(1, 2, 3, 4)// [ 1, 2, 3, 4 ]console.log(instance.values) 可被撤销的代理在被创建之后，代理通常就不能再从目标对象上被解绑，但有的情况下你可能想撤销一个代理以便让它不能再被使用。当你想通过公共接口向外提供一个安全的对象，并且要求随时都能切断对某些功能的访问，这种情况下被撤销的代理就会非常有用。 你可以使用 Proxy.revocable() 方法来创建一个可被撤销的代理，该方法接受的参数与 Proxy 构造器的相同：一个目标对象、一个代理处理器，而返回值是包含下列属性的一个对象：proxy：可被撤销的代理对象。revoke：用于撤销代理的函数。 当 revoke() 函数被调用后，就不能再对该 proxy 对象进行更多操作，任何与该代理对象交互的意图都会触发代理的陷阱函数，从而抛出一个错误。例如： 12345678910111213let target = &#123; name: 'target'&#125;let &#123; proxy, revoke &#125; = Proxy.revocable(target, &#123;&#125;)// targetconsole.log(proxy.name) revoke()// TypeError: Cannot perform 'get' on a proxy that has been revokedconsole.log(proxy.name) 实现MyArray类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970function toUint32 (value) &#123; return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32)&#125;function isArrayIndex (key) &#123; let numericKey = toUint32(key) return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1)&#125;class MyArray &#123; constructor (length=0) &#123; this.length = length return new Proxy(this, &#123; set (trapTarget, key, value) &#123; let currentLength = Reflect.get(trapTarget, 'length') // 特殊情况 if (isArrayIndex(key)) &#123; let numericKey = Number(key) if (numericKey &gt;= currentLength) &#123; Reflect.set(trapTarget, 'length', numericKey + 1) &#125; &#125; else if (key === 'length') &#123; if (value &lt; currentLength) &#123; for (let index = currentLength - 1; index &gt;= value; index--) &#123; Reflect.deleteProperty(trapTarget, index) &#125; &#125; &#125; // 无论键的类型是什么，都要执行这行代码 return Reflect.set(trapTarget, key, value) &#125; &#125;) &#125;&#125;let colors = new MyArray(3)// trueconsole.log(colors instanceof MyArray) // 3console.log(colors.length) colors[0] = 'red'colors[1] = 'green'colors[2] = 'blue'colors[3] = 'black'// 4console.log(colors.length) colors.length = 2// 2console.log(colors.length) // undefinedconsole.log(colors[3]) // undefinedconsole.log(colors[2]) // greenconsole.log(colors[1]) // redconsole.log(colors[0]) 将代理对象作为原型使用在使用代理对象作为原型时，仅当操作的默认行为会按惯例追踪达到原型时，代理陷阱才会被调用，这就限制了代理对象作为原型时的能力。考虑这个例子： 123456789101112131415161718let target = &#123;&#125;let proxy = new Proxy(target, &#123; // 永远不会被调用 defineProperty(trapTarget, name, descriptor) &#123; return false &#125;&#125;)let newTarget = Object.create(proxy)Object.defineProperty(newTarget, 'name', &#123; value: 'newTarget'&#125;)// newTargetconsole.log(newTarget.name) // trueconsole.log(newTarget.hasOwnProperty('name')) 尽管在把代理对象作为原型时会受到严重限制，但仍然存在几个很有用的陷阱函数。 在原型上使用 get 陷阱函数当使用代理作为原型时，只有在对象不存在指定名称的自有属性时，才会触发原型上的 get 陷阱函数。 1234567891011121314151617let target = &#123;&#125;let proxy = new Proxy(target, &#123; get (trapTarget, key, receiver) &#123; throw new ReferenceError(`$&#123;key&#125; doesn't exist`) &#125;&#125;)let thing = Object.create(proxy)thing.name = 'thing'// 没有触发 get 陷阱函数// thingconsole.log(thing.name) // 触发了 get 陷阱函数// ReferenceError: unknow doesn't existconsole.log(thing.unknow) 这个例子中 trapTarget 与 receiver 是不同的对象，这对理解本例是非常重要的。trapTarget 为 target，receiver 为 thing。 在原型上使用 set 陷阱函数当使用代理作为原型时，只有在对象不存在指定名称的自有属性时，才会触发原型上的 set 陷阱函数。 12345678910111213141516171819202122let target = &#123;&#125;let proxy = new Proxy(target, &#123; set (trapTarget, key, value, receiver) &#123; return Reflect.set(trapTarget, key, value, receiver) &#125;&#125;)let thing = Object.create(proxy)// 触发了 set 陷阱函数thing.name = 'thing'// thingconsole.log(thing.name) // trueconsole.log(thing.hasOwnProperty('name')) // 没有触发 set 陷阱函数thing.name = 'boo'// booconsole.log(thing.name) 在原型上使用 has 陷阱函数当使用代理作为原型时，只有在对象不存在指定名称的自有属性时，才会触发原型上的 has 陷阱函数。 1234567891011121314151617let target = &#123;&#125;let proxy = new Proxy(target, &#123; has (trapTarget, key) &#123; return Reflect.has(trapTarget, key) &#125;&#125;)let thing = Object.create(proxy)// 触发了 has 陷阱函数// falseconsole.log('name' in thing) thing.name = 'thing'// 没有触发 has 陷阱函数// trueconsole.log('name' in thing) 将代理作为类的原型类不能直接被修改为将代理用作自身的原型，因为它们的 prototype 属性是不可写入的。然而你可以使用一点变通手段，利用继承来创建一个把代理作为自身原型的类。 123456789101112131415161718function Super () &#123;&#125;let proxy = new Proxy(&#123;&#125;, &#123;&#125;)Super.prototype = proxyclass Sub extends Super &#123;&#125;let instance = new Sub()let instanceProto = Object.getPrototypeOf(instance)let secondLevelProto = Object.getPrototypeOf(instanceProto)// trueconsole.log(instanceProto === Sub.prototype)// trueconsole.log(secondLevelProto === proxy)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2Fposts%2F9a3eeeca%2F</url>
    <content type="text"><![CDATA[Promises/A+本来想仔细描述一下 Promises 的各种特性的，但由于翻译水平有限，最后觉得还是直接查看 Promises/A+ 的规范更精确。 所以，请先移步 Promises/A+。 规范中提到“then may be called multiple times on the same promise”，它的意思是同一个 Promise 实例上可以挂载多个 then，而不是同一个 then 被调用多次。规范中说的 object 是指 Object.prototype.toString.call(value) 返回值为 &quot;[object Object]&quot; 的数据，而不是广义上的 Object 的实例。与 resolve() 的复杂规则不同。调用 reject(reason) 时，不论传给它的值是什么，它都会将 Promise 实例的状态置为 rejected，将 Promise 实例的值设置为 reason。 Promises/A+ 的补充说明 在根据 Promises/A+ 实现 Promise 时，各种引擎又添加了如下规则：如果在 Promise 构造器中抛出了一个错误，则会 reject(err)。规范中的 resolve 和 reject 函数，既可以在 Promise 构造器中的使用，也可以单独使用，如 Promise.resolve() 和 Promise.reject()。这样做的相当于直接创建了一个 fulfilled 或 rejected 状态的 Promise 实例，跳过了前序的 pending 状态。这样做的好处是可以很方便的将 thenable 类型数据转换为标准的 Promise 实例。可能是为了实现方便，如果传递给 resolve 的是一个 Promise 实例，它会原封不动的将该 Promise 实例返回。Promise.prototype.catch(onRejected) 等价于 Promise.prototype.then(null, onRejected)。Promise.prototype.finally(onFinally) 中的 onFinally() 不接受任何参数，它会在 Promise 实例被决议且 execution context stack 为空时被调用，但它会原封不动的将调用它的那个 Promise 实例作为返回值。它是 ES8 中引入中，所以可能会存在一些兼容性问题。与 Promise.prototype.then 一样，同一个 Promise 实例上也可以挂在多个 Promise.prototype.catch 和 Promise.prototype.finally。 基础用法如下，详细的可以参考 MDN。 123456789const promise = new Promise(function (resolve, reject) &#123; // some code if (/* 异步操作成功 */) &#123; resolve('success'); &#125; else &#123; reject('fail'); &#125;&#125;); thenable 在按照规范实现 Promise 的同时，也实现了许多额外的方法，如 Promise.all、Promise.race 等。这些方法同样兼容 thenable。 全局的 Promise 拒绝处理Promise 最有争议的方面之一就是：当一个 Promise 实例被拒绝时若缺少拒绝处理函数，就会静默失败。有人认为这是规范中最大的缺陷，因为这是 JS 语言所有组成部分中唯一不让错误清晰可见的。 由于 Promise 的本质，判断一个 Promise 实例的拒绝是否已被处理并不直观。例如，研究以下示例： 123456789let rejected = Promise.reject(42)// 在此刻 rejected 不会被处理// 一段时间后……rejected.catch(function (reason) &#123; // 现在 rejected 已经被处理了 console.log(reason)&#125;) 无论 Promise 实例是否已被决议，你都可以在任何时候调用 then() 或 catch() 并使它们正确工作，这导致很难准确知道一个 Promise 实例何时会被处理。 虽然下个版本的 ES 可能会处理此问题，不过 Node 与浏览器已经实施了变更来解决开发者的这个痛点。这些变更不是 ES6 规范的一部分，但却是使用 Promise 时的宝贵工具。 Node 的拒绝处理在 Node 中，process 对象上存在两个关联到 Promise 实例的拒绝处理的事件： unhandledRejection：当一个 Promise 实例被拒绝、而在事件循环本轮次中没有任何拒绝处理函数被调用时，该事件就会被触发。rejectionHandled：当一个 Promise 实例被拒绝、并从事件循环的下一个轮次开始才有拒绝处理函数被调用时，该事件就会被触发。 这两个事件旨在共同帮助识别已被拒绝但未曾被处理的 Promise 实例。 unhandledRejection 事件处理函数接受的参数是拒绝原因（常常是一个错误对象）以及被拒绝的 Promise。以下代码展示了 unhandledRejection的应用： 1234567891011let rejectedprocess.on('unhandledRejection', function (reason, promise) &#123; // Explosion! console.log(reason.message) // true console.log(rejected === promise) &#125;)rejected = Promise.reject(new Error('Explosion!')) rejectionHandled 事件处理函数则只有一个参数，即已被拒绝的 Promise 实例。例如： 12345678910111213141516let rejectedprocess.on('rejectionHandled', function (promise) &#123; // true console.log(rejected === promise) &#125;)rejected = Promise.reject(new Error('Explosion!'))// 延迟添加拒绝处理函数setTimeout(function() &#123; rejected.catch(function (reason) &#123; // Explosion! console.log(reason.message) &#125;)&#125;, 1000) 此处的 rejectionHandled 事件在拒绝处理函数最终被调用时触发。若在 rejected 被创建后直接将拒绝处理函数附加到它上面，那么此事件就不会被触发。因为立即附加的拒绝处理函数在 rejected 被创建的事件循环的同一个轮次内就会被调用，这样 rejectionHandled 就不会起作用。 为了正确追踪潜在的未被处理的拒绝，使用 unhandledRejection 与 rejectionHandled 事件就能保持包含这些 Promise 实例的一个列表，之后等待一段时间再检查此列表。例如： 1234567891011121314151617181920let possiblyUnhandledRejections = new Map()// 当一个拒绝未被处理，将其添加到 mapprocess.on('unhandledRejection', function (reason, promise) &#123; possiblyUnhandledRejections.set(promise, reason)&#125;)process.on('rejectionHandled', function (promise) &#123; possiblyUnhandledRejections.delete(promise)&#125;)setInterval(function () &#123; possiblyUnhandledRejections.forEach(function (reason, promise) &#123; console.log(reason.message ? reason.message : reason) // 做点事来处理这些拒绝 handleRejection(promise, reason) &#125;) possiblyUnhandledRejections.clear()&#125;, 60000) 浏览器的拒绝处理浏览器同样能触发两个事件，来帮助识别未处理的拒绝。这两个事件会被 window 对象触发，并完全等效于 Node 的相关事件： unhandledrejection：当一个 Promise 实例被拒绝、而在事件循环的本轮次中没有任何拒绝处理函数被调用时，该事件就会被触发。rejectionhandled：当一个 Promise 实例被拒绝、并从事件循环的下一个轮次开始才有拒绝处理函数被调用时，该事件就会被触发。 Node 的实现会传递分离的参数给事件处理函数，而浏览器的两个事件处理函数则只会接收到包含下列属性的一个对象： type：事件的名称（unhandledrejection 或 rejectionhandled）。promise：被拒绝的 Promise 实例。reason：Promise 实例的值，即 reason。 除了事件处理函数接收的参数有所区别外，浏览器的事件处理函数用法可以仿照 Node。 手写一个 Promise/A+ Implementations should not set arbitrary limits on the depth of thenable chains, and assume that beyond that arbitrary limit the recursion will be infinite. Only true cycles should lead to a TypeError; if an infinite chain of distinct thenables is encountered, recursing forever is the correct behavior. 可以使用 promises-aplus-tests 进行测试npm install promises-aplus-tests -g将下面代码保存至 test.jspromises-aplus-tests test.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221function privateFulfill (promise, value) &#123; // 2.2.2.3 it must not be called more than once if (promise.status !== MyPromise.PENDING) &#123; return promise; &#125; promise.status = MyPromise.FULFILLED; promise.value = value; promise.onFulfilledCallbacks.forEach(item =&gt; &#123; item(value); &#125;); return promise;&#125;function privateReject (promise, reason) &#123; // 2.2.3.3 it must not be called more than once if (promise.status !== MyPromise.PENDING) &#123; return promise; &#125; promise.status = MyPromise.REJECTED; promise.reason = reason; promise.onRejectedCallbacks.forEach(item =&gt; &#123; item(reason); &#125;); return promise;&#125;function resolveEngine (promise, x) &#123; // 2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason if (promise === x) &#123; return privateReject(promise, new TypeError('2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason')); &#125; // 2.3.2 If x is a promise, adopt its state if (x instanceof MyPromise) &#123; // 2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected. // 2.3.2.2 If/when x is fulfilled, fulfill promise with the same value. // 2.3.2.3 If/when x is rejected, reject promise with the same reason. if (x.status === MyPromise.PENDING) &#123; x.then( (value) =&gt; &#123; privateFulfill(promise, value); &#125;, (reason) =&gt; &#123; privateReject(promise, reason); &#125; ); return promise; &#125; // 2.3.2.2 If/when x is fulfilled, fulfill promise with the same value. if (x.status === MyPromise.FULFILLED) &#123; return privateFulfill(promise, x.value); &#125; // 2.3.2.3 If/when x is rejected, reject promise with the same reason. if (x.status === MyPromise.REJECTED) &#123; return privateReject(promise, x.reason); &#125; &#125; if (Object.prototype.toString.call(x) === '[object Object]' || typeof x === 'function') &#123; // 2.3.3 Otherwise, if x is an object or function try &#123; // 2.3.3.1 Let then be x.then const then = x.then; if (typeof then === 'function') &#123; // 2.3.3.3 If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise var called = false; try &#123; then.call( x, (y) =&gt; &#123; if (called) &#123; return; &#125; called = true; MyPromise.resolve.call(promise, y); &#125;, (r) =&gt; &#123; if (called) &#123; return; &#125; called = true; MyPromise.reject.call(promise, r); &#125;, ) &#125; catch (err) &#123; if (called) &#123; return; &#125; MyPromise.reject.call(promise, err); &#125; return promise; &#125; else &#123; // 2.3.3.4 If then is not a function, fulfill promise with x return privateFulfill(promise, x); &#125; &#125; catch (err) &#123; // 2.3.3.2 If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason return privateReject(promise, err); &#125; &#125; else &#123; // 2.3.4 If x is not an object or function, fulfill promise with x return privateFulfill(promise, x); &#125;&#125;class MyPromise &#123; static PENDING = 'pending'; static FULFILLED = 'fulfilled'; static REJECTED = 'rejected'; static resolve (value) &#123; if (this === MyPromise) &#123; return resolveEngine(new MyPromise(), value); &#125; else if (this instanceof MyPromise) &#123; return resolveEngine(this, value); &#125; else &#123; return new TypeError('this is not an instance of MyPromise') &#125; &#125; static reject (reason) &#123; if (this === MyPromise) &#123; return privateReject(new MyPromise(), reason); &#125; else if (this instanceof MyPromise) &#123; return privateReject(this, reason); &#125; else &#123; return new TypeError('this is not an instance of MyPromise') &#125; &#125; constructor (executor) &#123; this.status = MyPromise.PENDING; this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; if (typeof executor === 'function') &#123; try &#123; executor(MyPromise.resolve.bind(this), MyPromise.reject.bind(this)); &#125; catch (err) &#123; privateReject(this, err); &#125; &#125; &#125; then (onFulfilled, onRejected) &#123; // 2.2.7 then must return a promise // promise2 = promise1.then(onFulfilled, onRejected) return new MyPromise((resolve, reject) =&gt; &#123; // 2.2.1 Both onFulfilled and onRejected are optional arguments // 2.2.2 If onFulfilled is a function // 2.2.3 If onRejected is a function // 2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code // 2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value) const fulfillCallback = () =&gt; &#123; setTimeout(() =&gt; &#123; if (typeof onFulfilled === 'function') &#123; try &#123; // 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x) resolve(onFulfilled(this.value)); &#125; catch (err) &#123; // 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason reject(err); &#125; &#125; else &#123; // 2.2.7.3 If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1 resolve(this.value); &#125; &#125;) &#125;; const rejectCallback = () =&gt; &#123; setTimeout(() =&gt; &#123; if (typeof onRejected === 'function') &#123; try &#123; // 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x) resolve(onRejected(this.reason)) &#125; catch (err) &#123; // 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason reject(err); &#125; &#125; else &#123; // 2.2.7.4 If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1 reject(this.reason); &#125; &#125;) &#125;; // 2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code // 2.2.6 then may be called multiple times on the same promise. if (this.status === MyPromise.PENDING) &#123; this.onFulfilledCallbacks.push(fulfillCallback); this.onRejectedCallbacks.push(rejectCallback); &#125; else if (this.status === MyPromise.FULFILLED) &#123; setTimeout(fulfillCallback); &#125; else if (this.status === MyPromise.REJECTED) &#123; setTimeout(rejectCallback); &#125; &#125;) &#125; catch (onRejected) &#123; this.then(undefined, onRejected); &#125;&#125;// for promises-aplus-testsMyPromise.deferred = () =&gt; &#123; var result = &#123;&#125;; result.promise = new MyPromise(function (resolve, reject) &#123; result.resolve = resolve; result.reject = reject; &#125;); return result;&#125;module.exports = MyPromise;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Class]]></title>
    <url>%2Fposts%2Fe1a12c4d%2F</url>
    <content type="text"><![CDATA[类的声明基本的类声明类声明以 class 关键字开始，其后是类的名称。剩余部分的语法看起来就像对象字面量中的方法简写，并且在方法之间不需要使用逗号。作为范例，此处有个简单的类声明： 类语法中，必须使用对象方法简写的形式来定义构造器、原型方法、访问器属性和静态方法等。不允许使用 =、: 和箭头函数来定义。 12345678910111213141516171819202122232425262728class PersonClass &#123; // 等价于 PersonType 构造器 constructor (name) &#123; this.name = name &#125; // 等价于 PersonType.prototype.sayName sayName () &#123; console.log(this.name) &#125;&#125;let person = new PersonClass('Nicholas')// Nicholasperson.sayName() // trueconsole.log(person instanceof PersonClass) // trueconsole.log(person instanceof Object) // functionconsole.log(typeof PersonClass) // functionconsole.log(typeof PersonClass.prototype.sayName) 类声明允许你在其中使用特殊的 constructor 方法名称直接定义一个构造器，而不需要先定义一个函数再把它当做构造器使用。由于类的方法使用了简写语法，于是就不再需要使用 function 关键字。constructor 之外的方法名称则没有特别的含义，因此可以随你高兴自由添加方法。 自有属性：该属性出现在实例上而不是原型上，只能在类的构造器或方法内部进行创建。在本例中，name 就是一个自有属性。建议应在构造器函数内创建所有可能出现的自有属性，这样在类中声明变量就会被限制在单一位置（有助于代码检查）。 为何要使用类的语法 类声明不会被提升，这与函数定义不同。类声明的行为与 let 相似，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。类的所有方法都是不可枚举的。类的所有方法内部都没有 [[Construct]]，因此使用 new 来调用它们会抛出错误。调用类构造器时不使用 new，会抛出错误。在类的内部不允许重写类名，在类的外部则可以。 这样看来，上例中的 PersonClass 声明实际上就直接等价于以下未使用类语法的代码： 12345678910111213141516171819202122232425262728let PersonClass = (function () &#123; 'use strict' const PersonClass = function (name) &#123; // 确认函数被调用时使用了 new if (typeof new.target === 'undefined') &#123; throw new Error('Constructor must be called with new.') &#125; this.name = name &#125; Object.defineProperty(PersonClass.prototype, 'sayName', &#123; value: function () &#123; // 确认函数被调用时没有使用 new if (typeof new.target !== 'undefined') &#123; throw new Error('Method cannot be called with new.') &#125; console.log(this.name) &#125;, enumerable: false, writable: true, configurable: true &#125;) return PersonClass&#125;)() 首先要注意这里有两个 PersonClass 声明：一个在外部作用域的 let 声明，一个在 IIFE 内部的 const 声明。这就是为何类的方法不能对类名进行重写、而类外部的代码则被允许。构造器函数检查了 new.target，以保证被调用时使用了 new，否则就抛出错误。接下来，sayName() 方法被定义为不可枚举，并且此方法也检查了 new.target，它则要保证在被调用时没有使用 new。最后一步是将构造器函数返回出去。 类表达式类与函数有相似之处，即它们都有两种形式：声明与表达式。函数声明与类声明都以适当的关键字为起始（分别是 function 与 class），随后是标识符（即函数名或类名）。函数具有一种表达式形式，无须在 function 后面使用标识符。类似的，类也有不需要标识符的表达式形式。类表达式被设计用于变量声明，或可作为参数传递给函数。 基本的类表达式1234567891011121314151617181920212223242526let PersonClass = class &#123; constructor (name) &#123; this.name = name &#125; sayName () &#123; console.log(this.name) &#125;&#125;let person = new PersonClass('Nicholas')// Nicholasperson.sayName() // trueconsole.log(person instanceof PersonClass) // trueconsole.log(person instanceof Object) // functionconsole.log(typeof PersonClass) // functionconsole.log(typeof PersonClass.prototype.sayName) 具名类表达式上面的例子使用了一个匿名的类表达式，不过就像函数表达式那样，你也可以为类表达式命名。为此需要在 class 关键字后添加标识符，就像这样： 123456789101112131415let PersonClass = class PersonClass2 &#123; constructor (name) &#123; this.name = name &#125; sayName () &#123; console.log(this.name) &#125;&#125;// functionconsole.log(typeof PersonClass) // undefinedconsole.log(typeof PersonClass2) 与命名函数表达式相似，类表达式的标识符 PersonClass2 只在类定义内部存在，在外部则不存在。 作为一级公民的类ES6 延续了传统，让类成为一级公民，这就使得类可以被多种方式所使用。例如，类可以作为参数传入函数，也可以立即调用类构造器。 123456789101112let person = new class &#123; constructor (name) &#123; this.name = name &#125; sayName () &#123; console.log(this.name) &#125;&#125;('Nicholas')// Nicholasperson.sayName() 访问器属性自有属性需要在类构造器中创建，而类还允许你在原型上定义访问器属性。例如： 123456789101112131415161718192021222324class CustomHTMLElement &#123; constructor (element) &#123; this.element = element &#125; get html () &#123; return this.element.innerHTML &#125; set html (value) &#123; this.element.innerHTML = value &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, 'html')// trueconsole.log('get' in descriptor) // trueconsole.log('set' in descriptor) // falseconsole.log(descriptor.enumerable) 需计算的成员名类方法与类访问器属性也都能使用需计算的名称。语法相同于对象字面量中的需计算名称。例如： 1234567891011121314151617181920212223242526272829303132let methodName = 'sayName'class PersonClass &#123; constructor (name) &#123; this.name = name &#125; [methodName] () &#123; console.log(this.name) &#125;&#125;let me = new PersonClass('Nicholas')// Nicholasme.sayName() let propertyName = 'html'class CustomHTMLElement &#123; constructor (element) &#123; this.element = element &#125; get [propertyName] () &#123; return this.element.innerHTML &#125; set [propertyName] (value) &#123; this.element.innerHTML = value &#125;&#125; 生成器方法在类语法中，允许将任何方法变为一个生成器。因此可以使用 Symbol.iterator 来定义生成器方法，从而定义出类的默认迭代器。 1234567891011121314151617class Collection &#123; constructor () &#123; this.items = [] &#125; *[Symbol.iterator] () &#123; yield *this.items &#125;&#125;var collection = new Collection()collection.items.push(1, 2, 3)for (let x of collection) &#123; // 依次输出 1, 2, 3 console.log(x) &#125; 静态成员直接在构造器上添加额外方法来模拟静态成员，这在 ES5 及更早版本中是另一个通用的模式。例如： 123456789101112131415function PersonClass (name) &#123; this.name = name&#125;// 静态方法PersonClass.create = function (name) &#123; return new PersonClass(name)&#125;// 实例方法PersonClass.prototype.sayName = function () &#123; console.log(this.name)&#125;var person = PersonClass.create('Nicholas') 在其他变成语言中，PersonClass.create() 会被认定为一个静态方法，它的数据不依赖 PersonClass 的任何实例。ES6 的类简化了静态成员的创建，只要在方法与访问器属性的名称前添加正式的 static 标注。作为一个例子，此处有个与上例等价的类： 12345678910111213141516class PersonClass &#123; constructor (name) &#123; this.name = name &#125; sayName () &#123; console.log(this.name) &#125; // 等价于 PersonType.create static create (name) &#123; return new PersonClass(name) &#125;&#125;let person = PersonClass.create('Nicholas') 类中的任何方法与访问器属性上都可以使用 static 关键字，唯一的限制是不能将它用于 constructor 方法。 使用派生类进行继承ES6 之前，实现自定义类型的继承是个繁琐的过程。类的出现让继承工作变得更轻易，使用熟悉的 extends 关键字来指定当前类所需要继承的函数即可。生成的类的原型会被自动调整，而你还能调用 super() 方法来访问基类的构造器。此处有个例子： 12345678910111213141516171819202122232425262728class Rectangle &#123; constructor (length, width) &#123; this.length = length this.width = width &#125; getArea () &#123; return this.length * this.width &#125;&#125;class Square extends Rectangle &#123; constructor (length) &#123; // 与 Rectangle.call(this, length, length) 相同 super(length, length) &#125;&#125;var square = new Square(3)// 9console.log(square.getArea()) // trueconsole.log(square instanceof Square) // trueconsole.log(square instanceof Rectangle) 此次 Square 类使用了 extends 关键字继承了 Rectangle。Square 构造器使用了 super() 配合指定参数调用了 Rectangle 的构造器。 继承了其他类的类被称为派生类。如果派生类指定了构造器，就需要使用 super()，否则会造成错误。若你选择不使用构造器，super() 方法会被自动调用，并会使用创建新实例时提供的所有参数。例如，下列两个类是完全相同的： 12345678910class Square extends Rectangle &#123; // 没有构造器&#125;// 等价于：class Square extends Rectangle &#123; constructor (...args) &#123; super(...args) &#125;&#125; 此例中的第二个类展示了与所有派生类默认构造器等价的写法，所有的参数都按顺序传递给了基类的构造器。在当前需求下，这种做法并不完全准确，因为 Square 构造器只需要单个参数，因此最好手动定义构造器。 使用 super() 时需要牢记以下几点：你只能在派生类中使用 super()。若尝试在非派生的类或函数中使用它，就会抛出错误。在构造器中，你必须在访问 this 之前调用 super()。由于 super() 负责初始化 this，因此试图先访问 this 自然就会造成错误（具体原因看本文的继承内置对象部分）。唯一能避免调用 super() 的办法，是从派生类的构造器中返回一个对象。 屏蔽类方法派生类中的方法总是会屏蔽基类的同名方法。例如，你可以将 getArea() 方法添加到 Square 类，以便重定义它的功能： 123456789101112131415161718192021class Rectangle &#123; constructor (length, width) &#123; this.length = length this.width = width &#125; getArea () &#123; return this.length * this.width &#125;&#125;class Square extends Rectangle &#123; constructor (length) &#123; super(length, length) &#125; // 重写并屏蔽 Rectangle.prototype.getArea() getArea () &#123; return this.length * this.length &#125;&#125; 由于 getArea() 已经被定义为 Square 的一部分，Rectangle.prototype.getArea() 方法就不能在 Square 的任何实例上被调用。当然，你总是可以使用 super.getArea() 方法来调用基类中的同名方法，就像这样： 123456789101112131415161718192021class Rectangle &#123; constructor (length, width) &#123; this.length = length this.width = width &#125; getArea () &#123; return this.length * this.width &#125;&#125;class Square extends Rectangle &#123; constructor (length) &#123; super(length, length) &#125; // 重写、屏蔽并调用了 Rectangle.prototype.getArea() getArea () &#123; return super.getArea() &#125;&#125; 用这种方式使用 super，其效果等同于在对象的简写方法中使用 super。 继承静态成员如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。 1234567891011121314151617181920212223242526272829303132class Rectangle &#123; constructor (length, width) &#123; this.length = length this.width = width &#125; getArea () &#123; return this.length * this.width &#125; static create (length, width) &#123; return new Rectangle(length, width) &#125;&#125;class Square extends Rectangle &#123; constructor (length) &#123; // 与 Rectangle.call(this, length, length) 相同 super(length, length) &#125;&#125;var rect = Square.create(3, 4)// trueconsole.log(rect instanceof Rectangle) // 12console.log(rect.getArea()) // falseconsole.log(rect instanceof Square) 在此代码中，一个新的静态方法 create() 被添加到 Rectangle 类中。通过继承，该方法会以 Square.create() 的形式存在，并且其行为方式与 Rectangle.create() 一样。 从表达式中派生类在 ES6 中派生类的最强大能力，或许就是能够从表达式中派生类。只要一个表达式能够返回一个具有 [[Construct]] 属性以及原型的函数，你就可以对其使用 extends。例如： 12345678910111213141516171819202122function Rectangle (length, width) &#123; this.length = length this.width = width&#125;Rectangle.prototype.getArea = function () &#123; return this.length * this.width&#125;class Square extends Rectangle &#123; constructor (length) &#123; super(length, length) &#125;&#125;var x = new Square(3)// 9console.log(x.getArea()) // trueconsole.log(x instanceof Rectangle) Rectangle 被定义为 ES5 风格的构造器，而 Square 则是一个类。由于 Rectangle 具有 [[Construct]] 以及原型，Square 类就能直接继承它。 extends 可以被用于继承 null，这好像违反了前面的说法，把这个当作特殊情况吧！ extends 后面能接受任意类型的表达式，这带来了巨大可能性，例如动态地决定所要继承的类： 1234567891011121314151617181920212223242526function Rectangle (length, width) &#123; this.length = length this.width = width&#125;Rectangle.prototype.getArea = function () &#123; return this.length * this.width&#125;function getBase () &#123; return Rectangle&#125;class Square extends getBase() &#123; constructor(length) &#123; super(length, length) &#125;&#125;var x = new Square(3)// 9console.log(x.getArea()) // trueconsole.log(x instanceof Rectangle) 继承内置对象几乎从 JS 数组出现那天开始，开发者就想通过继承机制来创建他们自己的特殊数组类型。在 ES5 及早期版本中，这是不可能做到的。试图使用传统继承并不能产生功能正确的代码，例如： 123456789101112131415161718192021222324252627282930313233343536// 内置数组的行为var colors = []colors[0] = 'red'// 1console.log(colors.length) colors.length = 0// undefinedconsole.log(colors[0]) // 在 ES5 中尝试继承数组function MyArray () &#123; Array.apply(this, arguments)&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;)var colors = new MyArray()colors[0] = 'red'// 0console.log(colors.length) colors.length = 0// 'red'console.log(colors[0]) MyArray 实例上的 length 属性以及数值属性，其行为与内置数组并不一致，因为这些功能并未被涵盖在 Array.apply() 或数组原型中。 在 ES6 中的类，其设计目的之一就是允许从内置对象上进行继承。为了达成这个目的，类的继承模型与 ES5 或更早版本的传统继承模型有轻微差异： 在 ES5 的传统继承中，this 的值会先被派生类（例如 MyArray）创建，随后基类构造器（例如：Array.apply() 方法）才被调用。这意味着 this 一开始就是 MyArray 的实例，之后才使用了 Array 的附加属性对其进行了装饰。在 ES6 基于类的继承中，this 的值会先被基类（Array）创建，随后才被派生类的构造器（MyArray）所修改。结果是 this 初始就拥有作为基类的内置对象的所有功能，并能正确接收与之关联的所有功能。 以下范例实际展示了基于类的特殊数组： 1234567891011121314class MyArray extends Array &#123; // 空代码块&#125;var colors = new MyArray()colors[0] = 'red'// 1console.log(colors.length) colors.length = 0// undefinedconsole.log(colors[0]) MyArray 直接继承了 Array，因此工作方式与正规数组一致。与数值索引属性的互动更新了 length 属性，而操纵 length 属性也能更新索引属性。这意味着你既能适当地继承 Array 来创建你自己的派生类数组，也同样能继承其他的内置对象。 Symbol.species属性继承内置对象一个有趣的方面是：任意能返回内置对象实例的方法，在派生类上却会自动返回派生类的实例。因此，若你拥有一个继承了 Array 的派生类 MyArray，诸如 slice() 之类的方法都会返回 MyArray 的实例。例如： 123456789101112class MyArray extends Array &#123; // 空代码块&#125;let items = new MyArray(1, 2, 3, 4)let subitems = items.slice(1, 3)// trueconsole.log(items instanceof MyArray) // trueconsole.log(subitems instanceof MyArray) Symbol.species 知名符号被用于定义一个能返回函数的静态访问器属性。每当类实例的方法（构造器除外）必须创建一个实例时，Symbol.species 返回的函数就会被用为新实例的构造器。 1234567891011121314class MyClass &#123; static get [Symbol.species] () &#123; // 静态成员为类构造器的方法，因此这个 this 指向 MyClass return this &#125; constructor (value) &#123; this.value = value &#125; clone () &#123; return new this.constructor[Symbol.species](this.value) &#125;&#125; 在此例中，Symbol.species 知名符号被用于定义 MyClass 的一个静态访问器属性。注意此处只有个 get 函数而没有set 函数，这是因为修改类的 species 是不允许的。 Array 使用了 Symbol.species 来指定方法所使用的的类，让其返回值为一个数组。在 Array 派生类中，你可以决定这些继承方法应返回何种类型的对象，正如： 1234567891011121314151617class MyArray extends Array &#123; static get [Symbol.species] () &#123; return Array &#125;&#125;let items = new MyArray(1, 2, 3, 4)let subitems = items.slice(1, 3)// trueconsole.log(items instanceof MyArray) // trueconsole.log(subitems instanceof Array) // falseconsole.log(subitems instanceof MyArray) 在类构造器中使用 new.target在类的构造器中可以使用 new.target 来判断类是被如何调用的。 1234567891011121314151617class Rectangle &#123; constructor (length, width) &#123; console.log(new.target === Rectangle) this.length = length this.width = width &#125;&#125;class Square extends Rectangle &#123; constructor (length) &#123; super(length, length) &#125;&#125;// new.target 就是 Square// falsevar obj = new Square(3) Square 调用了 Rectangle构造器，因此当 Rectangle 构造器被调用时，new.target 等于 Square。这很重要，因为构造器能根据如何被调用而有不同行为，并且这给了更改这种行为的能力。例如，你可以使用 new.target 来创建一个抽象基类（一个不能被实例化的类），如下： 123456789101112131415161718192021222324// 静态的基类class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('This class cannot be instantiated directly.') &#125; &#125;&#125;class Rectangle extends Shape&#123; constructor (length, width) &#123; super() this.length = length this.width = width &#125;&#125;var x = new Rectangle(3, 4)// trueconsole.log(x instanceof Shape) // Error: This class cannot be instantiated directly.var y = new Shape() 此例中的 Shape 类构造器会在 new.target 为 Shape 的时候抛出错误，意味着 new Shape() 永远都会抛出错误。然而，你依然可以将 Shape 用作一个基类，正如 Rectangle 所做的那样。super() 的调用执行了 Shape 构造器，而且 new.target 的值等于 Rectangle，因此该构造器能够无错误地继续执行。 由于调用类时不能缺少 new，于是 new.target 属性在类构造器内部就绝不会是 undefined。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器与生成器]]></title>
    <url>%2Fposts%2F990a6acc%2F</url>
    <content type="text"><![CDATA[许多编程语言都将迭代数据的方式从使用 for 循环转变到使用迭代器对象，for 循环需要初始化变量以便追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。迭代器使操作集合变得更简单，JS 语言的很多新成分中都有迭代器的身影，如 for-of 和扩展运算符。 何为迭代器？迭代器是被设计专用于迭代的对象，带有特定接口。所有迭代器对象都拥有 next() 方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的 value，以及一个布尔类型的 done，其值为 true 时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了 next() 方法，迭代器就会返回相应的下一个值。 若你在最后一个值返回后再调用 next()，所返回的 done 属性值会是 true，并且 value 属性值会是迭代器自身的返回值（return value，即使用 return 语句明确返回的值）。该“返回值”不是原数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用 undefined。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。 记住这些后，在 ES5 中创建一个迭代器就相当简单了： 12345678910111213141516171819202122232425262728293031323334function createIterator (items) &#123; var i = 0 // 返回一个迭代器 return &#123; next () &#123; var done = (i &gt;= items.length) var value = !done ? items[i++] : undefined return &#123; done, value &#125; &#125; &#125;&#125;var iterator = createIterator([1, 2, 3])// &#123; done: false, value: 1 &#125;console.log(iterator.next()) // &#123; done: false, value: 2 &#125;console.log(iterator.next()) // &#123; done: false, value: 3 &#125;console.log(iterator.next()) // &#123; done: true, value: undefined &#125;console.log(iterator.next()) // 之后的所有调用// &#123; done: true, value: undefined &#125;console.log(iterator.next()) 正如此例演示，根据迭代器的规则来书写一个迭代器，是有一点复杂的。为此，ES6 提供了生成器，让创建迭代器对象变得更简单。 何为生成器？生成器是能返回一个迭代器的函数。生成器由放在 function 关键字之后的一个星号（*）来表示，并能使用新的 yield 关键字。将星号紧跟在 function 关键字之后，或是在中间留出空格，都是没问题的，正如下例： 1234567891011121314151617181920212223242526function *createIterator () &#123; yield 1 yield 2 yield 3 return 4&#125;// 生成器能像正规函数那样被调用，但会返回一个迭代器var iterator = createIterator()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 2, done: false &#125;console.log(iterator.next()) // &#123; value: 3, done: false &#125;console.log(iterator.next()) // &#123; value: 4, done: true &#125;console.log(iterator.next()) // 之后的所有调用// &#123; value: undefined, done: true &#125;console.log(iterator.next()) 生成器函数最有意思的方面可能就是它们会在每个 yield 语句后停止执行。例如，此代码中 yield 1 执行后，该函数将不会再执行任何操作，直到迭代器的 next() 方法被调用，此时才继续执行 yield 2。 yield 关键字可以和值或是表达式一起使用，因此你可以通过生成器给迭代器添加项目，而不是机械化地将项目一个个列出。 12345678910111213141516171819202122232425function *createIterator (items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i] &#125; return 'returnValue'&#125;var iterator = createIterator([1, 2, 3])// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 2, done: false &#125;console.log(iterator.next()) // &#123; value: 3, done: false &#125;console.log(iterator.next()) // &#123; value: 'returnValue', done: true &#125;console.log(iterator.next()) // 之后的所有调用// &#123; value: undefined, done: true &#125;console.log(iterator.next()) yield 关键字只能用在生成器内部，用于其他任意位置都是语法错误，即使在生成器内部的函数中也不行！ 例如下面的写法就是错误的： 123456function *createIterator (items) &#123; items.forEach(function (item) &#123; // 语法错误 yield item + 1 &#125;)&#125; 尽管 yield 严格位于 createIterator() 内部，此代码仍然有语法错误，因为 yield 无法穿越函数边界。从这点上来说，yield 与 return 非常相似，在一个被嵌套的函数中无法将值返回给包含它的函数。 生成器函数表达式你可以使用函数表达式来创建一个生成器，只要在 function 关键字与圆括号之间使用一个星号（*）即可。例如： 12345let createIterator = function * (items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i] &#125;&#125; 不能将箭头函数创建为生成器。 生成器对象方法由于生成器就是函数，因此也可以被添加到对象中。 12345678910111213141516var o = &#123; createIterator: function * (items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i] &#125; &#125;&#125;// 使用 ES6 的方法简写形式也是可以的var o = &#123; *createIterator (items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i] &#125; &#125;&#125; 可迭代对象和Symbol.iterator 首先要记住迭代器是一个对象，是一个带有特定接口、专门用来迭代的对象生成器是一个用于生成迭代器的函数只要具有 Symbol.iterator 方法的对象，就是可迭代对象Symbol.iterator 知名符号定义了为指定对象返回迭代器的函数，换句话说，Symbol.iterator 方法是可迭代对象的生成器方法生成器创建的所有迭代器都是可迭代对象，因为生成器默认就会为 Symbol.iterator 属性赋值 在 ES6 中，所有的集合对象（数组、Set和Map）以及字符串都是可迭代对象，因此它们都被指定了默认的迭代器。 for-of循环for-of 首先会调用可迭代对象的 Symbol.iterator 来生成迭代器，然后在循环中调用迭代器的 next() 方法，并将迭代器的 value 值存储在一个变量上，循环过程会持续到迭代器的 done 属性变为 true 为止。 访问默认迭代器你可以使用 Symbol.iterator 来访问对象上的默认迭代器，就像这样： 1234567891011121314let values = [1, 2, 3]let iterator = values[Symbol.iterator]()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 2, done: false &#125;console.log(iterator.next()) // &#123; value: 3, done: false &#125;console.log(iterator.next()) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) 既然 Symbol.iterator 指定了默认迭代器，你就可以使用它来检测一个对象是否能进行迭代，正如下例： 123456789101112131415161718192021function isIterable (object) &#123; return typeof object[Symbol.iterator] === 'function'&#125;// trueconsole.log(isIterable([1, 2, 3])) // trueconsole.log(isIterable('hello')) // trueconsole.log(isIterable(new Map())) // trueconsole.log(isIterable(new Set())) // falseconsole.log(isIterable(new WeakMap())) // falseconsole.log(isIterable(new WeakSet())) 这个 isIterable() 函数仅仅查看对象是否存在一个类型为函数的默认迭代器。for-of 循环在执行之前会做类似的检查。 创建可迭代对象开发者自定义对象默认情况下不是可迭代对象，但你可以创建一个包含生成器的 Symbol.iterator 属性，让它们成为可迭代对象。例如： 123456789101112131415let collection = &#123; items: [], *[Symbol.iterator] () &#123; for (let item of this.items) &#123; yield item &#125; &#125;&#125;collection.items.push(1, 2, 3)for (let x of collection) &#123; // 依次打印 1, 2, 3 console.log(x) &#125; 内置的迭代器集合的迭代器ES6 具有三种集合对象类型：数组、Map 和 Set。这三种类型都拥有如下迭代器，有助于探索它们的内容： entries()：返回一个包含键值对的迭代器。values()：返回一个包含集合中的值的迭代器。keys()：返回一个包含集合中的键的迭代器。 entriesentries() 迭代器会在每次 next() 被调用时返回一个双项数组，此数组代表了集合中每个元素的键与值：对于数组来说，第一项是数值索引。对于 Set，第一项也是值。对于 Map，第一项就是键。 记住，第一项是键，第二项才是值，别用混了…… 1234567891011121314151617181920212223242526let colors = [ 'red', 'green', 'blue' ]let tracking = new Set([1234, 5678, 9012])let data = new Map()data.set('title', 'Understanding ES6')data.set('format', 'ebook')for (let entry of colors.entries()) &#123; console.log(entry)&#125;// [ 0, 'red' ]// [ 1, 'green' ]// [ 2, 'blue' ]for (let entry of tracking.entries()) &#123; console.log(entry)&#125;// [ 1234, 1234 ]// [ 5678, 5678 ]// [ 9012, 9012 ]for (let entry of data.entries()) &#123; console.log(entry)&#125;// [ 'title', 'Understanding ES6' ]// [ 'format', 'ebook' ] valuesvalues() 迭代器仅仅能返回存储在集合内的值。 1234567891011121314151617181920212223242526let colors = [ 'red', 'green', 'blue' ]let tracking = new Set([1234, 5678, 9012])let data = new Map()data.set('title', 'Understanding ES6')data.set('format', 'ebook')for (let value of colors.values()) &#123; console.log(value)&#125;// red// green// bluefor (let value of tracking.values()) &#123; console.log(value)&#125;// 1234// 5678// 9012for (let value of data.values()) &#123; console.log(value)&#125;// Understanding ES6// ebook keyskeys() 迭代器能返回集合中的每一个键。对于数组来说，它只返回了数值类型的键，永不返回数组的其他自有属性。Set 的键与值时相同的，因此它的 keys() 与 values() 返回了相同的迭代器。对于 Map，keys() 迭代器返回了每个不重复的键。 1234567891011121314151617181920212223242526let colors = [ 'red', 'green', 'blue' ]let tracking = new Set([1234, 5678, 9012])let data = new Map()data.set('title', 'Understanding ES6')data.set('format', 'ebook')for (let key of colors.keys()) &#123; console.log(key)&#125;// 0// 1// 2for (let key of tracking.keys()) &#123; console.log(key)&#125;// 1234// 5678// 9012for (let key of data.keys()) &#123; console.log(key)&#125;// title// format 集合类型的默认迭代器当 for-of 循环没有显示指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。values() 方法是数组与 Set 的默认迭代器，而 entries() 方法则是 Map 的默认迭代器。 Map 默认迭代器的行为有助于在 for-of 循环中使用解构，正如此例： 123456789let data = new Map()data.set('title', 'Understanding ES6')data.set('format', 'ebook')// 与使用 data.entries() 相同for (let [key, value] of data) &#123; console.log(key + '=' + value)&#125; 字符串和 NodeList需要记住，可以对字符串和 NodeList 使用 for-of循环！ 扩展运算符与非数组的可迭代对象扩展运算符能作用于所有可迭代对象，并且会使用默认迭代器来判断需要使用哪些值。所有的值都从迭代器中被读取出来并插入数组，遵循迭代器返回值的顺序。 12345678910let mySet = new Set([1, 2, 3, 3, 3, 4, 5])let myMap = new Map([ ['name', 'Nicholas'], ['age', 25] ])let array1 = [...mySet]let array2 = [...myMap]// [ 1, 2, 3, 4, 5 ]console.log(array1) // [ [ 'name', 'Nicholas' ], [ 'age', 25 ] ]console.log(array2) 迭代器高级功能传递参数给迭代器你可以通过 next() 方法向迭代器传递参数。当一个参数被传递给 next() 方法时，该参数就会成为生成器内部 yield 语句的值。此处有个基本范例： 1234567891011121314151617181920212223function *createIterator () &#123; let first = yield 1 // 4 + 2 let second = yield first + 2 // 5 + 3 yield second + 3 &#125;let iterator = createIterator()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 6, done: false &#125;console.log(iterator.next(4)) // &#123; value: 8, done: false &#125;console.log(iterator.next(5)) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) 对于 next() 的首次调用是一个特殊情况，传给它的任意参数都会被忽略。由于传递给 next() 的参数会成为 yield 语句的值，该 yield 语句指的是上次生成器中断执行处的语句。而 next() 方法第一次被调用时，生成器函数才刚刚开始执行，没有所谓的“上一次中断处的 yield 语句”可供赋值。因此在第一次调用 next() 时，不存在任何向其传递参数的理由。 在第二次调用 next() 时，4 作为参数被传递进去，这个 4 最终被赋值给了生成器函数内部的 first 变量。在包含赋值操作的第一个 yield 语句中，表达式右侧在第一次调用 next() 时被计算，而表达式左侧则在第二次调用 next() 方法、并在生成器函数继续执行前被计算。由于第二次调用 next() 传入了 4，这个值就被赋给了 first 变量，之后生成器继续执行。 第二个 yield 使用了第一个 yield 的结果并加上了 2，也就是返回了一个 6。当 next() 被第三次调用时，传入了参数 5。这个值被赋给了 second 变量，并随后用在了第三个 yield 语句中，返回了 8。 在迭代器中抛出错误能传递给迭代器的不仅是数据，还可以是错误条件。迭代器可以选择实现一个 throw() 方法，用于指示迭代器应在恢复执行时抛出一个错误。这是对异步编程来说很重要的一个能力，同时也会增加生成器内部的灵活度，能够既模仿返回一个值，又模仿抛出错误。你可以传递一个错误对象给 throw() 方法，当迭代器继续进行处理时应当抛出此错误。例如： 如果你不使用 throw() 传递一个错误给迭代器，而是通过 next() 传递一个错误给迭代器，那么迭代器内部不会抛出错误！ 1234567891011121314151617181920function *createIterator () &#123; let first = yield 1 // yield 4 + 2 ，然后抛出错误 let second = yield first + 2 // 永不会被执行 yield second + 3 &#125;let iterator = createIterator()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 6, done: false &#125;console.log(iterator.next(4)) // 从生成器中抛出了错误console.log(iterator.throw(new Error('Boom'))) 了解这些之后，你就可以在生成器内部使用一个 try-catch 块来捕捉这种错误： 12345678910111213141516171819202122232425262728function *createIterator () &#123; let first = yield 1 let second try &#123; // yield 4 + 2 ，然后抛出错误 second = yield first + 2 &#125; catch (ex) &#123; // 当出错时，给变量另外赋值 second = 6 &#125; yield second + 3&#125;let iterator = createIterator()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 6, done: false &#125;console.log(iterator.next(4)) // &#123; value: 9, done: false &#125;console.log(iterator.throw(new Error('Boom'))) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) 本例使用一个 try-catch 块包裹了第二个 yield 语句。尽管这个 yield 自身的执行不会出错，但在对 second 变量赋值之前，错误就在此时被抛出，于是 catch 部分捕捉错误并将这个变量赋值为 6，然后再继续执行到下一个 yield 处并返回了 9。 要注意一件有趣的事情发生了：throw() 方法就像 next() 方法一样返回了一个结果对象。由于错误在生成器内部被捕捉，代码继续执行到下一个 yield 处并返回了下一个值，也就是 9。 将 next() 与 throw() 都当作迭代器的指令，会有助于思考。next() 方法指示迭代器继续执行，而 throw() 方法则指示迭代器通过抛出一个错误继续执行。 生成器的 return由于生成器是函数，你可以在它内部使用 return 语句，既可以让生成器早一点退出执行，也可以指定在 next() 方法最后一次调用时的返回值。在生成器内，return 表明所有的处理已完成，因此 done 属性会被设为 true，而如果提供了返回值，就会被用于 value 字段。此处有个例子，单纯使用 return 让生成器更早返回： 1234567891011121314function *createIterator () &#123; yield 1 return yield 2 yield 3&#125;let iterator = createIterator()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) 你也可以指定一个返回值，会被用于最终返回的结果对象中的 value 字段。例如： 123456789101112131415function *createIterator () &#123; yield 1 return 42&#125;let iterator = createIterator()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 42, done: true &#125;console.log(iterator.next()) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) 扩展运算符与 for-of 循环会忽略 return 语句所指定的任意值。一旦它们看到 done 的值为 true，它们就会停止操作而不会读取对应的 value 值。 生成器委托在某些情况下，将两个迭代器的值合并一起会更有用。生成器可以用星号（*）配合 yield 这一特殊形式来委托其他的迭代器。正如生成器的定义，星号出现在何处是不重要的，只要落在 yield 关键字与生成器函数名之间即可。此处有个范例： 1234567891011121314151617181920212223242526272829303132333435function *createNumberIterator () &#123; yield 1 yield 2&#125;function *createColorIterator () &#123; yield 'red' yield 'green'&#125;function *createCombinedIterator () &#123; yield *createNumberIterator() yield *createColorIterator() yield true&#125;var iterator = createCombinedIterator()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 2, done: false &#125;console.log(iterator.next()) // &#123; value: 'red', done: false &#125;console.log(iterator.next()) // &#123; value: 'green', done: false &#125;console.log(iterator.next()) // &#123; value: true, done: false &#125;console.log(iterator.next()) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) 此例中的 createCombinedIterator() 生成器依次委托了 createNumberIterator() 与 createColorIterator()。返回的迭代器从外部看来就是一个单一的迭代器，用于产生所有的值。每次对 next() 的调用都会委托给合适的生成器，直到使用 createNumberIterator() 与 createColorIterator() 创建的迭代器全部清空为止。然后最终的 yield 会被执行以返回true。 生成器委托也能让你进一步使用生成器的返回值。这是访问这些返回值的最简单方式，并且在执行复杂任务时会非常有用。例如： 123456789101112131415161718192021222324252627282930313233343536function *createNumberIterator () &#123; yield 1 yield 2 return 3&#125;function *createRepeatingIterator (count) &#123; for (let i = 0; i &lt; count; i++) &#123; yield 'repeat' &#125;&#125;function *createCombinedIterator () &#123; let result = yield *createNumberIterator() yield *createRepeatingIterator(result)&#125;var iterator = createCombinedIterator()// &#123; value: 1, done: false &#125;console.log(iterator.next()) // &#123; value: 2, done: false &#125;console.log(iterator.next()) // &#123; value: 'repeat', done: false &#125;console.log(iterator.next()) // &#123; value: 'repeat', done: false &#125;console.log(iterator.next()) // &#123; value: 'repeat', done: false &#125;console.log(iterator.next()) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) 注意观察，第三次调用 next() 方法时,代码在 createNumberIterator() 内的 return 语句处并没有停止执行，而是直接运行到 createCombinedIterator() 内的下一个 yield 处才停止执行的。 此处 createCombinedIterator() 生成器委托了 createNumberIterator() 并将它的返回值赋值给了 result 变量。由于 createNumberIterator() 包含 return 3 语句，该返回值就是 3。result 变量接下来会作为参数传递给 createRepeatingIterator() 生成器，指示同一个字符串需要被重复几次。 你也可以直接在字符串上使用 yield *，字符串的默认迭代器会被使用。 1234567891011121314151617181920212223function *createCombinedIterator () &#123; yield * 'hello'&#125;var iterator = createCombinedIterator()// &#123; value: 'h', done: false &#125;console.log(iterator.next()) // &#123; value: 'e', done: false &#125;console.log(iterator.next()) // &#123; value: 'l', done: false &#125;console.log(iterator.next()) // &#123; value: 'l', done: false &#125;console.log(iterator.next()) // &#123; value: 'o', done: false &#125;console.log(iterator.next()) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) 异步任务运行执行异步操作的传统方式是调用一个包含回调的函数。例如，在 Node 中从磁盘读取一个文件： 12345678910let fs = require('fs')fs.readFile('config.json', function (err, contents) &#123; if (err) &#123; throw err &#125; doSomethingWith(contents) console.log('Done')&#125;) 当你拥有数量少而有限的任务需要完成时，这么做很有效。然而当你需要嵌套回调函数，或者要按顺序处理一系列的异步任务时，传统方式就会非常麻烦。在这种场合下，生成器与 yield 会很有用。 一个简单的任务运行器由于 yield 能停止运行，并在重新运行前等待 next() 方法被调用，你就可以在没有回调函数的情况下实现异步调用。首先，你需要一个能够调用生成器并启动迭代器的函数，就像这样： 12345678910111213141516171819function run (taskDef) &#123; // 创建迭代器，让它在别处可用 let task = taskDef() // 启动任务 let result = task.next() // 递归使用函数来保持对 next() 的调用 function step () &#123; // 如果还有更多要做的 if (!result.done) &#123; result = task.next() step() &#125; &#125; // 开始处理过程 step()&#125; 配合这个已实现的 run() 函数，你就可以运行一个包含多条 yield 语句的生成器，就像这样： 1234567run (function * () &#123; console.log(1) yield console.log(2) yield console.log(3)&#125;) 此例只是将三个数值输出到控制台，单纯用于表明对 next() 的所有调用都已被执行。然而，仅仅使用几次 yield 并不太有意义，下一步是要把值传进迭代器并获取返回数据。 带数据的任务运行传递数据给任务运行器最简单的方式，就是把 yield 返回的值传入下一次的 next() 调用。为此，你仅需传递 result.value，正如以下代码： 12345678910111213141516171819202122232425262728293031function run (taskDef) &#123; // 创建迭代器，让它在别处可用 let task = taskDef() // 启动任务 let result = task.next() // 递归使用函数来保持对 next() 的调用 function step () &#123; // 如果还有更多要做的 if (!result.done) &#123; result = task.next(result.value) step() &#125; &#125; // 开始处理过程 step()&#125;run (function * () &#123; let value = yield 1 // 1 console.log(value) value = yield value + 3 // 4 console.log(value) &#125;) 异步任务运行器下面的代码是一个使用生成器来运行异步任务的例子。 ps. 为了保持纯粹，这个例子中并没有使用 Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let fs = require('fs')function readFile (filename) &#123; return function (callback) &#123; // 这里是异步操作 fs.readFile(filename, callback) &#125;&#125;function run (taskDef) &#123; // 创建迭代器，让它在别处可用 let task = taskDef() // 启动任务 let result = task.next() // 递归使用函数来保持对 next() 的调用 function step () &#123; // 如果还有更多要做的 if (!result.done) &#123; if (typeof result.value === 'function') &#123; // 执行异步操作，并传递一个函数作为参数callback result.value(function (err, data) &#123; if (err) &#123; result = task.throw(err) return &#125; result = task.next(data) step() &#125;) &#125; else &#123; result = task.next(result.value) step() &#125; &#125; &#125; // 开始处理过程 step()&#125;run (function * () &#123; let contents = yield readFile('config.json') doSomethingWith(contents) console.log('Done')&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Set 与 Map]]></title>
    <url>%2Fposts%2Fd766545b%2F</url>
    <content type="text"><![CDATA[Set 是不包含重复值的列表。你一般不会像对待数组那样来访问 Set 中的某个项。相反更常见的是，只在 Set 中检查某个值是否存在。 Map 则是键与相对应的值的集合。因此，Map 中的每个项都存储了两块数据，通过指定所需读取的键即可检索对应的值。Map 常被用作缓存，存储数据以便此后快速检索。 ES5 中的 Set 与 Map在 ES5 中，开发者使用对象属性来模拟 Set 与 Map，就像这样： 12345678let set = Object.create(null)set.foo = true// 检查属性的存在性if (set.foo) &#123; // 一些操作&#125; 本例中的 set 变量是一个原型为 null 的对象，确保在此对象上没有继承属性。使用对象的属性作为需要检查的唯一值在 ES5 中是很常用的方法。当一个属性被添加到 set 对象时，它的值也被设为 true，因此条件判断语句就可以简单判断出该值是否存在。 使用对象模拟 Set 与模拟 Map 之间唯一真正的区别是所存储的值。例如：以下例子将对象作为 Map 使用： 123456789let map = Object.create(null)map.foo = 'bar'// 提取一个值let value = map.foo// barconsole.log(value) 此代码将字符串值 &quot;bar&quot; 存储在 foo 键上。与 Set 不同，Map 多数被用来提取数据，而不是仅检查键的存在性。 变通方法的问题尽管在简单情况下将对象作为 Set 与 Map 来使用都是可行的，但一旦接触到对象属性的局限性，此方式就会遇到更多麻烦。研究如下代码： 123456789101112131415161718let map = Object.create(null)let key1 = 5let key2 = '5'let key3 = &#123;&#125;let key4 = &#123;&#125;map[key1] = 'number'map[key3] = 'foo'// numberconsole.log(map[key2]) // fooconsole.log(map[key4]) // &#123; '5': 'number', '[object Object]': 'foo' &#125;console.log(map) 造成上面例子中问题的原因是对象属性只可以是字符串或符号类型，所以当你为对象定义属性时，如果属性名不是字符串或符号类型，那么它会调用属性名的 toString() 方法将属性名转换为字符串，然后再进行后续操作。所以 map[key1] === map[key2]、map[key3] === map[key4]。 ES6 的 SetES6 新增了 Set 类型，这是一种无重复值的有序列表。Set 允许对它包含的数据进行快速访问，从而增加了一个追踪离散值的更有效方式。 创建 Set 并添加项目Set 使用 new Set() 来创建，而调用 add() 方法就能向 Set 中添加项目，检查 size 属性还能查看其中包含有多少项。 1234567let set = new Set()set.add(5)set.add('5')// 2console.log(set.size) Set 不会使用强制类型转换来判断值是否重复。这意味着 Set 可以同时包含数值 5 与字符串 &quot;5&quot;，将它们都作为相对独立的项（在 Set 内部的比较使用了 Object.is() 方法来判断两个值是否相等，唯一的例外是+0与-0被判断为是相等的）。你还可以向 Set 添加多个对象，它们不会被合并为同一项： 123456789let set = new Set()let key1 = &#123;&#125;let key2 = &#123;&#125;set.add(key1)set.add(key2)// 2console.log(set.size) 由于 key1 与 key2 并不会被转换为字符串，所以它们在这个 Set 内部被认为是两个不同的项（记住：如果它们被转换为字符串，那么都会等于 &quot;[object Object]&quot;）。 如果 add() 方法用相同值进行了多次调用，那么在第一次之后的调用实际上会被忽略： 12345678910let set = new Set()set.add(5)set.add('5')// 重复了，该调用被忽略set.add(5)// 2console.log(set.size) 你可以使用数组来初始化一个 Set，并且 Set 构造器会确保不重复地使用这些值。 1234let set = new Set([1, 2, 3, 4, 5, 5, 5, 5])// 5console.log(set.size) Set 构造器实际上可以接收任意可迭代对象作为参数。能使用数组是因为它们默认就是可迭代的，Map 也是一样的。 你可以使用 has() 方法来检测某个值是否存在于 Set 中，就像这样： 12345678910let set = new Set()set.add(5)set.add('5')// trueconsole.log(set.has(5)) // falseconsole.log(set.has(6)) 移除值使用 delete() 方法可以移除 Set 中的某个值，使用 clear() 方法可以移除 Set 中的所有值。 12345678910111213let set = new Set()set.add(5)set.add('5')set.delete(5)// falseconsole.log(set.has(5)) set.clear()// 0console.log(set.size) Set 上的 forEach() 方法Set上 的 forEach() 方法类似于数组中的 forEach() 方法，它接收两个参数：要在每一项上运行的函数和（可选的）运行该函数时的 this 值。传入的函数会接收三个参数：Set 元素的值，Set 元素的值和目标 Set 自身。你没看错，第一个和第二个参数是完全相同的，这么设计的目的是为了保持所有对象上 forEach() 方法的统一。 将 Set 转换为数组使用扩展运算符可以很轻松的将 Set 转换为数组，用一个数组去重的例子来展示它是如何转换的： 123456789function eliminateDuplicates (array) &#123; return [...new Set(array)]&#125;let numbers = [ 1, 2, 3, 3, 3, 4, 5 ]let noDuplicates = eliminateDuplicates(numbers)// [ 1, 2, 3, 4, 5 ]console.log(noDuplicates) Weak Set由于 Set 类型存储对象引用的方式，它也可以被称为 Strong Set。对象存储在 Set 的一个实例中时，实际上相当于把对象存储在变量中。只要对 Set 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存。例如： 12345678910111213141516let set = new Set()let key = &#123;&#125;set.add(key)// 1console.log(set.size) // 取消原始引用key = null// 1console.log(set.size) // 重新获得原始引用key = [...set][0] 在本例中，将 key 设置为 null 清楚了对 key 对象的一个引用，但是另一个引用还存在于 set 内部。你仍然可以使用扩展运算符将 Set 转换为数组，然后访问数组的第一项，key 变量就取回了原先的对象。 为了缓解这个问题，ES6 也包含了 Weak Set，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收。 创建 Weak SetWeak Set 使用 WeakSet 构造器来创建，并包含 add() 方法、has() 方法以及 delete() 方法。以下例子使用了这三个方法： 123456789101112let set = new WeakSet()let key = &#123;&#125;set.add(key)// trueconsole.log(set.has(key)) set.delete(key)// falseconsole.log(set.has(key)) 使用 Weak Set 很像在使用正规的 Set。你可以在 Weak Set 上添加、移除或检查引用，也可以给构造器传入一个可迭代对象来初始化 Weak Set的值： 123456789let key1 = &#123;&#125;let key2 = &#123;&#125;let set = new WeakSet([key1, key2])// trueconsole.log(set.has(key1)) // trueconsole.log(set.has(key2)) 在本例中，一个数组被传给了 WeakSet 构造器。由于该数组包含了两个对象，这些对象就被添加到了 Weak Set 中。要记住若数组中包含了非对象的值，就会抛出错误，因为 WeakSet 构造器不接受基本类型的值。 Set 类型之间的关键差异Weak Set 与正规 Set 之间最大的区别是对象的弱引用。此处有个例子说明了这种差异： 12345678910let set = new WeakSet()let key = &#123;&#125;set.add(key)// trueconsole.log(set.has(key)) // 移除对于键的最后一个强引用，同时从Weak Set中移除key = null 当代码被执行后，Weak Set 中的 key 引用就不能再访问了。核实这一点是不可能的，因为需要把对于该对象的一个引用传递给 has() 方法（而只要存在其他引用，Weak Set 内部的弱引用就不会消失）。这会使得难以对 Weak Set 的引用特征进行测试，但 JS 引擎已经正确地将引用移除了，这一点你可以信任。 这些例子演示了 Weak Set 与正规 Set 的一些共有特征，但是它们还有一些关键的差异，即： 对于 WeakSet 的实例，若调用 add() 方法时传入非对象的参数，就会抛出错误（has() 或 delete() 则会在传入了非对象的参数时返回 false）。Weak Set 不可迭代，因此不能被用在 for-of 循环中。Weak Set 无法暴露出任何迭代器，因此没有任何编程手段可用于判断 Weak Set 的内容。Weak Set 没有 forEach() 方法。Weak Set 没有 clear() 方法。Weak Set 没有 size 属性。 ES6 的 MapES6 的 Map 类型是键值对的有序列表，而键和值都可以是任意类型。 创建 MapMap 对键的处理方式与 Set 对值的处理一样，采用的是 Object.is() 方法，而不会进行强制类型转换，唯一的例外是 +0 与 -0 被判断为是相等的。 你可以调用 set() 方法并给它传递一个键与一个关联的值，来给 Map 添加项。此后使用键名来调用 get() 方法便能提取对应的值。如果任意一个键不存在于Map中，则 get() 方法就会返回特殊值 undefined。例如： 123456789101112131415let map = new Map()let key1 = &#123;&#125;let key2 = &#123;&#125;map.set(key1, 5)map.set(key2, 42)// 5console.log(map.get(key1)) // 42console.log(map.get(key2)) // undefinedconsole.log(map.get(111)) 此代码使用了对象 key1 与 key2 作为 Map 的键，并存储了两个不同的值。由于这些键不会被强制转换成其他形式，每个对象就都被认为是唯一的。这允许你给对象关联额外数据，而无须修改对象自身。 与 Set 类似，你能将数组传递给 Map 构造器，以便使用数据来初始化一个 Map。该数组中的每一项也必须是数组，内部数组的首个项会作为键，第二项则为对应值。因此整个 Map 就被这些双项数组所填充。例如： 1234567let map = new Map([['name', 'Nicholas'], ['age', 25]])// Nicholasconsole.log(map.get('name')) // 25console.log(map.get('age')) 虽然有数组构成的数组看起来有点奇怪，但这对于准确表示键来说却是必要的。因为键允许是任意数据类型，将键存储在数组中，是确保它们在被添加到 Map 之前不会被强制转换为其他类型的唯一方法。 Map 的方法及属性 has(key)：判断指定的键是否存在于 Map 中。delete(key)：移除 Map 中的键以及对应的值。clear()：移除 Map 中所有的键与值。size：用于指示包含了多少个键值对。 Map 上的 forEach 方法Map 的 forEach() 方法类似于 Set 与数组上的 forEach() 方法，不过它是按照键值对被添加到 Map 中的顺序来迭代的。它接收两个参数：要在每一项上运行的函数和（可选的）运行该函数时的 this 值。传入的函数会接收三个参数：Map 项的值、该值所对应的的键和目标Map自身。 Weak Map使用Weak MapES6 的 WeakMap 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。WeakMap 的接口与 Map 的非常相似，都使用 set() 与 get() 方法来分别添加与提取数据。 类似于 Weak Set，它没有 size 属性，没有任何办法可以确定 Weak Map 是否为空。在其他引用被移除后，由于对键的引用不再有残留，也就无法调用 get() 方法来去取对应的值。Weak Map 已经切断了对于该值的访问，其所占的内存在垃圾回收器运行时便会被释放。 Weak Map 的初始化为了初始化 Weak Map，需要把一个由数组构成的数组传递给 WeakMap 构造器。就像正规 Map 那样，每个内部数组都应当有两个项，第一项是作为键的对象，第二项则是对应的值（任意类型）。例如： 123456789101112131415let key1 = &#123;&#125;let key2 = &#123;&#125;let map = new WeakMap([[key1, 'hello'], [key2, 42]])// trueconsole.log(map.has(key1)) // helloconsole.log(map.get(key1)) // trueconsole.log(map.has(key2)) // 42console.log(map.get(key2)) 对象 key1 与 key2 被用作 Weak Map 的键，get() 与 has() 方法则能访问他们。在传递给 WeakMap 构造器的参数中，若任意键值对使用了非对象的键，构造器就会抛出错误。 Weak Map 的方法Weak Map 只有两个附加方法能用来与键值对交互。has() 方法用于判断指定的键是否存在于 Map 中，而 delete() 方法则用于移除一个特定的键值对。clear() 方法不存在，这是因为没有必要对键进行枚举，并且枚举 Weak Map 也是不可能的，这与 Weak Set 相同。 对象的私有数据ES5 中的创建私有数据的方式： 1234567891011121314151617181920var Person = (function () &#123; var privateData = &#123;&#125; var privateId = 0 function Person (name) &#123; Object.defineProperty(this, '_id', &#123; value: privateId++ &#125;) privateData[this._id] = &#123; name: name &#125; &#125; Person.prototype.getName = function () &#123; return privateData[this._id].name &#125; return Person&#125;)() 此例用 IIFE 包裹了 Person 的定义，其中含有两个私有属性：privateData 和 privateId。privateData 对象存储了每个实例的私有信息，而 privateId 则被用于为每个实例产生一个唯一ID。当 Person 构造器被调用时，一个不可枚举、不可配置、不可写入的 _id 属性就被添加了。 接下来在 privateData 对象中建立了与实例ID对应的一个入口，其中存储着 name 的值。随后在 getName() 函数中，就能使用 this._id 作为 privateData 的键来提取该值。由于 privateData 无法从 IIFE 外部进行访问，实际的数据就是安全的，尽管 this._id 在 privateData 对象上依然是公开暴露的。 此方式的最大问题在于 privateData 中的数据永远不会消失，因为在对象实例被销毁时没有任何方法可以获知该数据，privateData 对象就将永远包含多余的数据。这个问题现在可以换用 Weak Map 来解决了，如下： 12345678910111213let Person = (function () &#123; let privateData = new WeakMap() function Person (name) &#123; privateData.set(this, &#123; name: name &#125;) &#125; Person.prototype.getName = function () &#123; return privateData.get(this).name &#125; return Person&#125;)() 此版本的 Person 范例使用了 Weak Map 而不是对象来保存私有数据。由于 Person 对象的实例本身能被作为键来使用，于是也就无须再记录单独的 ID。当 Person 构造器被调用时，将 this 作为键在 Weak Map 上建立了一个入口，而包含私有信息的对象成为了对应的值，其中只存放了 name 属性。通过将 this 传递给 privateData.get() 方法，以获取值对象并访问其 name 属性，getName() 函数便能提取私有信息。这种技术让私有信息能够保持私有状态，并且当与之关联的对象实例被销毁时，私有信息也会被同时销毁。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[符号与符号属性]]></title>
    <url>%2Fposts%2F67215a69%2F</url>
    <content type="text"><![CDATA[在 JS 已有的基本类型之外，ES6 引入了一种新的基本类型：符号（Symbol）。符号起初被设计用于创建对象私有成员，而这也是JS开发者期待已久的特性。 创建符号值符号没有字面量形式，这在JS的基本类型中是独一无二的。你可以使用全局 Symbol 函数来创建一个符号值，正如下面这个例子： 1234567let firstName = Symbol()let person = &#123;&#125;person[firstName] = 'Nicholas'// Nicholasconsole.log(person[firstName]) 此代码创建了一个符号类型的 firstName 变量，并将它作为 person 对象的一个属性，而每次访问该属性都要使用这个符号值。 由于符号值是基本类型的值，因此调用 new Symbol() 将会抛出错误。你可以通过 new Object(yourSymbol) 来创建一个符号实例，但尚不清楚这能有什么作用。 Symbol 函数还可以接受一个额外的参数用于描述符号值，该描述并不能用来访问对应属性，但它能用于调试，例如： 12345678910111213let firstName = Symbol('first name')let person = &#123;&#125;person[firstName] = 'Nicholas'// falseconsole.log('first name' in person)// Nicholasconsole.log(person[firstName])// Symbol(first name)console.log(firstName) 符号的描述信息被存储在内部属性 [[Description]] 中，当符号的 toString() 方法被显式或隐式调用时，该属性都会被读取。 由于符号是基本类型的值，你可以使用 typeof 运算符来判断一个变量是否为符号。ES6 扩充了 typeof 的功能以便让它在作用于符号值的时候能够返回 symbol。 使用符号值你可以在任意能使用“需计算属性名”的场合使用符号。此外还可以在 Object.defineProperty() 或 Object.defineProperties() 调用中使用它。 由于符号不存在字面量形式，所以如果以符号作为对象的属性名，就算该属性的 enumerable 被设置为 true，该属性也无法用 for-in 循环，并且不会显示在 Object.keys() 的结果中。但是你可以使用 in 操作符来判断该属性是否存在！ 123456789101112131415161718192021222324252627282930let firstName = Symbol('first name')let person = &#123; [firstName]: 'Nicholas', normalAttr: 1&#125;let desc = Object.getOwnPropertyDescriptor(person, firstName)// Nicholasconsole.log(desc.value)// trueconsole.log(desc.writable)// trueconsole.log(desc.enumerable)// trueconsole.log(desc.configurable)// trueconsole.log(firstName in person)// [ 'normalAttr' ]console.log(Object.keys(person)) // normalAttrfor (let key in person) &#123; console.log(key) &#125; 共享符号值你或许想在不同的代码段中使用相同的符号值，例如：假设在应用中需要在两个不同的对象类型中使用同一个符号属性，用来表示一个唯一标识符。跨越文件或代码来追踪符号值是很困难并且易错的，为此，ES6 提供了“全局符号注册表”供你在任意时间点进行访问。 若你想创建共享符号值，应使用 Symbol.for() 方法而不是 Symbol() 方法。Symbol.for() 方法仅接受单个字符串类型的参数，作为目标符号值的标识符，同时此参数也会成为该符号的描述信息。例如： 12345678910let uid = Symbol.for('uid')let object = &#123;&#125;object[uid] = 123456// 123456console.log(object[uid])// Symbol(uid)console.log(uid) Symbol.for() 方法首先会搜索全局符号注册表，看是否存在一个键值为 &quot;uid&quot; 的符号值。若是，该方法会返回这个已存在的符号值。否则，会创建一个新的符号值，并使用该键值将其记录到全局符号注册表中，然后返回这个新的符号值。这就意味着此后使用同一个键值去调用 Symbol.for() 方法都将返回同一个符号值，就像下面这个例子： 123456789101112131415161718192021let uid = Symbol.for('uid')let object = &#123; [uid]: 123456&#125;// 123456console.log(object[uid])// Symbol(uid)console.log(uid)let uid2 = Symbol.for('uid')// trueconsole.log(uid === uid2)// 123456console.log(object[uid2])// Symbol(uid)console.log(uid2) 共享符号值还有另一个独特用法，你可以使用 Symbol.keyFor() 方法在全局符号注册表中根据符号值检索出对应的键值，例如： 1234567891011121314let uid = Symbol.for('uid')// uidconsole.log(Symbol.keyFor(uid))let uid2 = Symbol.for('uid')// uidconsole.log(Symbol.keyFor(uid2))let uid3 = Symbol('uid')// undefinedconsole.log(Symbol.keyFor(uid3)) 注意：使用符号值 uid 与 uid2 都返回了键值 &quot;uid&quot;，而符号值 uid3 在全局符号注册表中并不存在，因此没有关联的键值，Symbol.keyFot() 只会返回 undefined。 符号值的转换类型转换是 JS 语言重要的一部分，能够非常灵活地将一种数据类型转换为另一种。然而符号类型在进行转换时非常不灵活，因为其他类型缺乏与符号值的合理等价，尤其是符号值无法被转换为字符串值或数值。因此将符号作为属性所达成的效果，是其他类型所无法替代的。 在之前的例子中使用了 console.log() 来展示符号值的输出，能这么做是由于自动调用了符号值的 String() 方法来产生输出。你也可以直接调用 String() 方法来获取相同的结果，例如： 12345let uid = Symbol.for('uid')let desc = String(uid)// Symbol(uid)console.log(desc) String() 方法调用了 uid.toString() 来获取符号的字符串描述信息。但若你想直接将符号转换为字符串，则会引发错误： 1234let uid = Symbol.for('uid')// 引发错误let desc = uid + '' 将uid与空字符串相连接，会首先要求把uid转换为一个字符串，而这会引发错误，从而阻止了转换行为。 相似地，你也不能将符号转换为数值，对符号使用所有数学运算符都会引发错误，例如： 1234let uid = Symbol.for('uid')// 引发错误let desc = uid / 1 此例试图把符号值除以 1，同样引发了错误。无论对符号使用哪种数学运算符都会导致错误，但使用逻辑运算符则不会，因为符号值在运算符中会被认为等价于 true。 检索符号属性只能使用 ES6 新增的 Object.getOwnPropertySymbols() 方法用来检索对象的符号属性。Object.keys() 和 Object.getOwnPropertyNames() 方法都不行。 使用知名符号暴露内部方法ES6 定义了“知名符号”来代表JS中一些公共行为，而这些行为此前被认为只能是内部操作。每一个知名符号都对应全局 Symbol 对象的一个属性，这些知名符号是： Symbol.hasInstance：供 instanceof 运算符使用的一个方法，用于判断对象继承关系。Symbol.isConcatSpreadable：一个布尔类型值，在集合对象作为参数传递给 Array.prototype.concat() 方法时，指示是否要将该集合的元素扁平化。Symbol.iterator：返回迭代器的一个方法。Symbol.match：供 String.prototype.match() 函数使用的一个方法，用于比较字符串。Symbol.replace：供 String.prototype.replace() 函数使用的一个方法，用于替换子字符串。Symbol.search：供 String.prototype.search() 函数使用的一个方法，用于定位子字符串。Symbol.species：用于产生派生对象的构造器。Symbol.split：供 String.prototype.split() 函数使用的一个方法，用于分割字符串。Symbol.toPrimitive：返回对象所对应的基本类型值的一个方法。Symbol.toStringTag：供 String.prototype.toString() 函数使用的一个方法，用于创建对象的描述信息。Symbol.unscopables：一个对象，该对象的属性指示了那些属性名不允许被包含在 with 语句中。 下面将介绍其中的一些知名符号。 Symbol.hasInstance每个函数都具有一个 Symbol.hasInstance 方法，用于判断指定对象是否为本函数的一个实例。这个方法定义在 Function.prototype 上，因此所有函数都继承了面对 instanceof 运算符时的默认行为。Symbol.hasInstance 属性自身是不可写入、不可配置、不可枚举的，从而保证它不会被错误地重写。 Symbol.hasInstance 方法只接受单个参数，即需要检测的值。如果该值是本函数的一个实例，则方法会返回 true。为了理解该方法是如何工作的，可研究下述代码： 123obj instanceof Array// 等价于Array[Symbol.hasInstance](obj) ES6 从本质上将 instanceof 运算符重定义为上述方法调用的简写语法，这样使用 instanceof 便会出发一次方法调用，实际上允许你改变该运算符的工作。 假设你想定义一个函数，使得任意对象都不会被判断为该函数的一个实例，你可以采用硬编码的方式来让该函数的 Symbol.hasInstance 方法始终返回 false，就像这样： 1234567891011121314function MyObject () &#123; // ...&#125;Object.defineProperty(MyObject, Symbol.hasInstance, &#123; value (v) &#123; return false &#125;&#125;)let obj = new MyObject()// falseconsole.log(obj instanceof MyObject) 上例中通过 Object.defineProperty() 方法在 MyObject 对象上设置了 Symbol.hasInstance 属性，从而屏蔽了原型上不可写入的 Symbol.hasInstance 属性。 Symbol.isConcatSpreadable首先请看下面数组 concat() 方法的例子： 123456789let colors1 = [ 'red', 'green' ]let colors2 = colors1.concat([ 'blue', 'black' ])let colors3 = colors1.concat([ 'blue', 'black' ], 'brown')// [ 'red', 'green', 'blue', 'black' ]console.log(colors2) // [ 'red', 'green', 'blue', 'black', 'brown' ]console.log(colors3) concat() 方法会区别对待自己接收到的参数，如果参数为数组类型，那么它会自动的将数组扁平化（即分离数组中的元素）。而其他非数组类型的参数无需如此处理。在 ES6 之前，没有任何手段可以改变这种行为。 Symbol.isConcatSpreadable 属性是一个布尔类型的属性，它默认情况下并不会作为任意常规对象的属性。它只出现在特定类型的对象上，用来标示该对象作为 concat() 参数时应如何工作。 成功使用这个属性的前提条件是拥有该属性的对象，要在两个方面与数组类似：拥有数值类型的键和拥有 length 属性。 当该属性为 true 时，将该属性所属对象传递给 concat() 方法时，将所属对象扁平化。当该属性为 false 时，所属对象不会被扁平化。请看下面的例子： 12345678910111213141516171819202122let obj1 = &#123; 0: 'hello', 1: 'world', length: 2, [Symbol.isConcatSpreadable]: true&#125;let messages1 = [ 'hi' ].concat(obj1)// [ 'hi', 'hello', 'world' ]console.log(messages1) let obj2 = &#123; 0: 'hello', length: 2, [Symbol.isConcatSpreadable]: false&#125;let messages2 = [ 'hi' ].concat(obj2)// [ 'hi', &#123; '0': 'hello', length: 2, [Symbol.isConcatSpreadable]: false &#125; ]console.log(messages2) Symbol.match、Symbol.replace、Symbol.search 与 Symbol.split在 JS 中，字符串与正则表达式有着密切的联系，尤其是字符串具有几个可以接受正则表达式作为参数的方法：match、replace、search和split方法。 在 ES6 之前这些方法的实现细节对开发者是隐藏的，使得开发者无法将自定义对象模拟成正则表达式（并将它们传递给字符串的这些方法）。而 ES6 定义了 4 个符号以及对应的方法，将原生行为外包到内置的 RegExp 对象上。 Symbol.match：此函数接受一个字符串参数，并返回一个包含匹配结果的数组。若匹配失败，则返回 null。Symbol.replace：此函数接受一个字符串参数与一个替换用的字符串，并返回替换后的结果字符串。Symbol.search：此函数接受一个字符串参数，并返回匹配结果的数值索引。若匹配失败，则返回 -1。Symbol.split：此函数接受一个字符串参数，并返回一个用匹配值分割而成的字符串数组。 在对象上定义这些属性，允许你创建能过进行模式匹配的对象，而无需使用这则表达式，并且允许在任何需要正则表达式的方法中使用该对象。这里有一个例子，展示了这些符号的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 有效等价于/^.&#123;10&#125;$/let hasLengthOf10 = &#123; [Symbol.match] (value) &#123; return value.length === 10 ? [value.substring(0, 10)] : null &#125;, [Symbol.replace] (value, replacement) &#123; return value.length === 10 ? replacement + value.substring(10) : value &#125;, [Symbol.search] (value) &#123; return value.length === 10 ? 0 : -1 &#125;, [Symbol.split] (value) &#123; return value.length === 10 ? [ '', '' ] : [value] &#125;&#125;// 11 characterslet message1 = 'Hello world'// 10 characterslet message2 = 'Hello John' let match1 = message1.match(hasLengthOf10)let match2 = message2.match(hasLengthOf10)// nullconsole.log(match1) // [ 'Hello John' ]console.log(match2) let replace1 = message1.replace(hasLengthOf10, 'Howdy!')let replace2 = message2.replace(hasLengthOf10, 'Howdy!')// Hello worldconsole.log(replace1) // Howdy!console.log(replace2) let search1 = message1.search(hasLengthOf10)let search2 = message2.search(hasLengthOf10)// -1console.log(search1) // 0console.log(search2) let split1 = message1.split(hasLengthOf10)let split2 = message2.split(hasLengthOf10)// [ 'Hello world' ]console.log(split1)// [ '', '' ]console.log(split2) Symbol.toPrimitiveSymbol.toPrimitive 方法被定义在所有常规类型的原型上，规定了在对象被转换为基本类型值的时候会发生什么。当需要转换时，Symbol.toPrimitive 会被调用，并按照规范传入一个提示性的字符串参数。该参数有 3 种可能：当参数值为 number 的时候，应当返回一个数值。当参数值为 string 的时候，应当返回一个字符串。而当参数为 default 的时候，对返回值类型没有特别要求。 对于大部分常规对象，“数值模式”依次会有下述行为： 调用 valueOf() 方法，如果方法返回值是一个基本类型值，那么返回它。否则，调用 toString() 方法，如果方法返回值是一个基本类型值，那么返回它。否则，抛出一个错误。 类似的，对于大部分常规对象，“字符串模式”依次会有下述行为： 调用 toString() 方法，如果方法返回值是一个基本类型值，那么返回它。否则，调用 valueOf() 方法，如果方法返回值是一个基本类型值，那么返回它。否则，抛出一个错误。 在多数情况下，常规对象的默认模式都等价于数值模式（只有 Date 类型例外，它默认使用字符串模式）。通过定义 Symbol.toPrimitive 方法，你可以重写这些默认的转换行为。 使用 Symbol.toPrimitive 属性并将一个函数赋值给它，便可以重写默认的转换行为，例如： 12345678910111213141516171819202122232425function Temperature (degrees) &#123; this.degrees = degrees&#125;Temperature.prototype[Symbol.toPrimitive] = function (hint) &#123; switch (hint) &#123; case 'string': return this.degrees + '\u00b0' case 'number': return this.degrees case 'default': return this.degrees + ' degrees' &#125;&#125;let freezing = new Temperature(32)// 32 degrees!console.log(freezing + '!') // 16console.log(freezing / 2) // 32°console.log(String(freezing)) Symbol.toStringTagJS 最有趣的课题之一是在多个不同的全局执行环境中使用，这种情况会在浏览器页面包含内联帧（iframe）的时候出现，此时页面与内联帧均拥有各自的全局执行环境。大多数情况下这并不是一个问题，使用一些轻量级的转换操作就能够在不同的运行环境之间传递数据。问题出现在想要识别目标对象到底是什么类型的时候，而此时该对象已经在环境之间经历了传递。 该问题的典型例子就是从内联帧向容器页面传递数组，或者反过来。在 ES6 术语中，内联帧与包含它的容器页面分别拥有一个不同的“域”，以作为 JS 的运行环境，每个“域”都拥有各自的全局作用域以及各自的全局对象拷贝。无论哪个“域”创建的数组都是正规的数组，但当它跨域进行传递时，使用 instanceof Array 进行检测却会得到 false 的结果，因为该数组是由另外一个“域”的数组构造器创建的，有别于当前“域”的数组构造器。 识别问题的变通解决方案变通的解决方案为 Object.prototype.toString.call()。 ES6 给出的答案ES6 通过 Symbol.toStringTag 重定义了相关行为，该符号是对象的一个属性，定义了 Object.prototype.toString.call() 被调用时应当返回什么值。 1234567891011121314151617181920212223function Person (name) &#123; this.name = name&#125;Person.prototype[Symbol.toStringTag] = 'Person'let me = new Person('Nicholas')// [object Person]console.log(me.toString()) // [object Person]console.log(Object.prototype.toString.call(me)) Person.prototype.toString = function () &#123; return this.name&#125;// Nicholasconsole.log(me.toString()) // [object Person]console.log(Object.prototype.toString.call(me)) Symbol.unscopables尽管将来的代码无疑会停用 with 语句，但 ES6 仍然在非严格模式中提供了对于 with 语句的支持，以便向下兼容。为此需要寻找方法让使用 with 语句的代码能够适当地继续工作。为了理解这个任务的复杂性，可研究如下代码： 1234567891011let values = [1, 2, 3]let colors = ['red', 'green', 'blue']let color = 'black'with (colors) &#123; push(color) push(...values)&#125;// [ 'red', 'green', 'blue', 'black', 1, 2, 3 ]console.log(colors) 在此例中，...values 引用了 with 语句之外的变量 values。 但ES6为数组添加了一个 values 方法（迭代器与生成器的知识），这意味着在 ES6 的环境中，with 语句内部的 values 并不会指向 with 语句之外的变量 values，而是会指向数组的 values 方法，从而会破坏代码的意图。这也是 Symbol.unscopables 符号出现的理由。 Symbol.unscopables 符号在 Array.prototype 上使用，以指定哪些属性不允许在 with 语句内被绑定。Symbol.unscopables 属性是一个对象，当提供该属性时，它的键就是用于忽略 with 语句绑定的标识符，键值为 true 代表屏蔽绑定。以下是数组的 Symbol.unscopables 属性的默认值： 12345678910// 默认内置在 ES6 中Array.prototype[Symbol.unscopables] = Object.assign(Object.create(null), &#123; copyWithin: true, entries: true, fill: true, find: true, findIndex: true, keys: true, values: true&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解构]]></title>
    <url>%2Fposts%2F2798ec73%2F</url>
    <content type="text"><![CDATA[对象解构在对象解构语法出现之前，如果你想将一个对象的多个属性值分别赋值给本地的多个变量，需要书写许多相似的代码。 123456789101112131415161718let obj = &#123; a: 1, b: 2, c: 3&#125;let a = obj.alet b = obj.blet c = obj.c// 1console.log(a)// 2console.log(b)// 3console.log(c) 对象解构是如何做的呢，它将需要被赋值的变量全都放入一个花括号内，然后在后面添加等号，并指定提供数据的对象。 12345678910111213141516let obj = &#123; a: 1, b: 2, c: 3&#125;let &#123; a, b, c &#125; = obj// 1console.log(a)// 2console.log(b)// 3console.log(c) 对象解构语法会自动根据等号左侧的变量名在右侧对象中查找同名属性，并将属性值赋给对应的变量。 当使用对象解构来配合 var、let 或 const 声明变量时，必须提供初始化器（即等号右侧的值）。下面的代码都会因为缺失初始化器而抛出错误： 12345678// 语法错误var &#123; type, name &#125;// 语法错误let &#123; type, name &#125;// 语法错误const &#123; type, name &#125; 解构赋值以上对象解构示例都用于变量声明。不过，也可以在赋值的时候使用解构。例如，你可能想在变量声明之后改变它们的值，如下所示： 123456789101112131415let node = &#123; type: 'Identifier', name: 'foo'&#125;let type = 'Literal'let name = 5// 使用解构来分配不同的值(&#123; type, name &#125; = node)// Identifierconsole.log(type)// fooconsole.log(name) 在本例中，type 与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 node 对象来更改这两个变量的值。注意你必须使用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符（即等号）左侧出现。圆括号标示了里面的花括号并不是块语句，而应该被解释为表达式，从而允许完成赋值操作。 解构赋值表达式的值为等号右侧的对象。所以在调用函数时如果使用解构赋值表达式的话，实际上传递的参数为等号右侧的对象。 12345678910111213141516171819let node = &#123; type: 'Identifier', name: 'foo'&#125;let type = 'Literal'let name = 5function outputInfo (obj) &#123; console.log(obj === node)&#125;// trueoutputInfo(&#123; type &#125; = node)// Identifierconsole.log(type)// 5console.log(name) 上面例子中的 outputInfo({ type } = node) 实际上做了两件事情： 将 node.type 赋值给为本地变量 type；将 node 对象作为参数传递给函数 outputInfo。 当解构赋值表达式的右侧计算结果为 null 或 undefined 时，会抛出错误。因为任何读取 null 或 undefined 的企图都会导致“运行时”错误。 默认值当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为 undefined。例如： 123456789101112131415let node = &#123; type: 'Identifier', name: 'foo'&#125;let &#123; type, name, value &#125; = node// Identifierconsole.log(type)// fooconsole.log(name)// undefinedconsole.log(value) 此代码定义了一个额外的本地变量 value，并试图对其赋值。然而，node 对象中不存在同名属性，因此 value 不出预料地被赋值为 undefined。 你可以选择性地定义一个默认值，以便在指定属性不存在时使用该值。若要这么做，需要在属性名后面添加一个等号并指定默认值，就像这样： 123456789101112131415let node = &#123; type: 'Identifier', name: 'foo'&#125;let &#123; type, name, value = true &#125; = node// Identifierconsole.log(type)// fooconsole.log(name)// trueconsole.log(value) 在此例中，变量 value 被指定了一个默认值 true，只有在 node 的对应属性缺失、或对应的属性值为 undefined 的情况下，该默认值才会被使用。 赋值给不同的本地变量名以上使用解构赋值的例子中，都是本地变量名称与对象属性同名的情况，那么如果名称不相同呢？ 123456789101112let node = &#123; type: 'Identifier', name: 'foo'&#125;let &#123; type: localType, name: localName &#125; = node// Identifierconsole.log(localType)// fooconsole.log(localName) 此代码使用了解构赋值来声明 localType 和 localName 变量，分别获得了 node.type 和 node.name 属性的值。 type: localType 这种语法表示要读取名为 type 的属性，并把他的值存储在变量 localType 中。该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，则是名称在右边，需要进行值读取的位置则被放在了左边。 你也可以给变量别名添加默认值，依然是在本地变量名称后添加等号与默认值，例如： 1234567891011let node = &#123; type: 'Identifier'&#125;let &#123; type: localType, name: localName = 'bar' &#125; = node// Identifierconsole.log(localType)// barconsole.log(localName) 嵌套的对象解构1234567891011121314151617181920212223let node = &#123; type: 'Identifier', name: 'foo', loc: &#123; start: &#123; line: 1, column: 1 &#125;, end: &#123; line: 1, column: 4 &#125; &#125;&#125;// 等价于let localStart = node.loc.startlet &#123; loc: &#123; start: localStart &#125;&#125; = node// 1console.log(localStart.line)// 1console.log(localStart.column) 数组解构数组解构的语法看起来与对象解构非常相似，只是将对象字面量换成了数组字面量。数组解构时，是根据变量的位置索引来进行的，例如： 1234567891011121314let colors = ['red', 'green', 'blue']let [firstColor, secondColor] = colors// redconsole.log(firstColor)// greenconsole.log(secondColor)let [, , thirdColor] = colors// blueconsole.log(thirdColor) 与对象解构相似，在使用 var、let 或 const 进行数组解构时，你必须提供初始化器。 解构赋值你可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号内，例如： 1234567891011let colors = ['red', 'green', 'blue']let firstColor = 'black'let secondColor = 'purple';[firstColor, secondColor] = colors// redconsole.log(firstColor)// greenconsole.log(secondColor) 使用数组解构来互换两个变量的值是非常轻松的。 12345678910let a = 1let b = 2;[a, b] = [b, a]// 2console.log(a)// 1console.log(b) 与对象解构赋值相同，若等号右侧的计算结果为 null 或 undefined，那么数组解构赋值表达式会抛出错误。 默认值数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为 undefined，那么该默认值就会被使用。例如： 123456789let colors = ['red']let [firstColor, secondColor = 'green'] = colors// redconsole.log(firstColor)// greenconsole.log(secondColor) 嵌套的解构123456789let colors = ['red', ['green', 'lightgreen'], 'blue']let [firstColor, [secondColor]] = colors// redconsole.log(firstColor)// greenconsole.log(secondColor) 剩余项我们以前介绍过函数的剩余参数，而数组解构有个类似的、名为剩余项的概念，它使用 ... 语法来将剩余的项目赋值给一个指定的变量，此处有个范例： 123456789let colors = ['red', 'green', 'blue']let [firstColor, ...restColors] = colors// redconsole.log(firstColor)// [ 'green', 'blue' ]console.log(restColors) 使用剩余项语法可以很方便地实现数组的克隆。 12345let colors = ['red', 'green', 'blue']let [...cloneColors] = colors// [ 'red', 'green', 'blue' ]console.log(cloneColors) 需要注意的是剩余项必须是数组解构模式中最后的部分，之后不能再有逗号，否则就是语法错误。 混合解构对象与数组解构能被用在一起，以创建更复杂的解构表达式。在对象与数组混合而成的结构中，能准确提取其中你想要的信息片段。例如： 1234567891011121314151617181920212223242526272829let node = &#123; type: 'Identifier', name: 'foo', loc: &#123; start: &#123; line: 1, column: 1 &#125;, end: &#123; line: 1, column: 4 &#125; &#125;, range: [0, 3]&#125;let &#123; loc: &#123; start &#125;, range: [stratIndex]&#125; = node// 1console.log(start.line)// 1console.log(start.column)// 0console.log(stratIndex) 参数解构解构还有一个特别有用的场景，即在传递函数参数时。当函数接收大量可选参数时，一个常用模式是创建一个 options 对象，其中包含了附加的参数，就像这样： 1234567891011121314151617// options 上的属性表示附加参数function setCookie (name, value, options) &#123; options = options || &#123;&#125; let secure = options.secure let path = options.path let domain = options.domain let expires = options.expires // 设置 cookie 的代码&#125;// 第三个参数映射到 optionssetCookie('type', 'js', &#123; secure: true, expires: 60000&#125;) 很多 JS 的库都包含了类似于此例的 setCookie() 函数。在此函数内，name 与 value 参数是必需的，而 secure、path、domain 与 expires 则不是。并且因为此处对于其余数据并没有顺序要求，将它们作为 options 对象的具名属性会更有效率，而无须列出一堆额外的具名参数。这种方法很有用，但无法仅通过查看函数定义就判断出函数所期望的输入，你必须阅读函数的代码。 参数解构提供了更清楚地标明函数期望输入的替代方案。它使用对象或数组解构的模式替代了具名参数。要看到其实际效果，请查看下例中重写版本的 setCookie() 函数： 12345678function setCookie (name, value, &#123; secure, path, domain, expires &#125;) &#123; // 设置cookie的代码&#125;setCookie('type', 'js', &#123; secure: true, expires: 60000&#125;) 此函数的行为类似上例，但此时第三个参数使用了解构来抽取必要的数据。现在对于 setCookie() 函数的使用者来说，解构参数之外的参数明显是必需的；而可选项目存在于额外的参数组中，这同样是非常明确的；同时，若使用了第三个参数，其中应当包含什么值当然也是极其明确的。解构参数在没有传递值的情况下类似于常规参数，它们会被设为 undefined。 解构的参数也是必需的12// 出错！setCookie('type', 'js') 调用时第三个参数缺失了，因此它不出预料地等于 undefined。这导致了一个错误，因为参数解构实际上只是解构声明的简写。当 setCookie() 函数被调用时，JS 引擎实际上是这么做的： 12345function setCookie (name, value, options) &#123; let &#123; secure, path, domain, expires &#125; = options // 设置cookie的代码&#125; 既然在赋值右侧的值为null或undefined时，解构会抛出错误，那么未向setCookie()函数传递第三个参数就同样会出错。 若你让解构的参数作为必选参数，那么上述行为并不会令人困扰。但若你要求它是可选的，可以给解构的参数提供默认值来处理这种行为，就像这样： 123function setCookie (name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123; // 设置cookie的代码&#125; 参数解构的默认值你可以为参数解构提供可解构的默认值，就像在解构赋值时所做的那样，只需在其中每个参数后面添加等号并指定默认值即可。例如： 12345678910function setCookie (name, value, &#123; secure = false, path = '/', domain = 'example.com', expires = new Date(Date.now() + 360000000) &#125; = &#123;&#125;) &#123; // 设置cookie的代码&#125; 此代码中参数解构给每个属性都提供了默认值，所以你可以避免检查指定属性是否已被传入（以便在未传入时使用正确的值）。而整个解构的参数同样有一个默认值，即一个空对象，令该参数成为可选参数。这么做使得函数声明看起来比平时要复杂一些，但却是为了确保每个参数都有可用的值而付出的微小代价。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2Fposts%2F9595c646%2F</url>
    <content type="text"><![CDATA[带参数默认值的函数ES6 中的参数默认值ES6 能更容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时使用。在函数声明中能指定任意一个参数的默认值，即使该参数排在未指定默认值的参数之前也是可以的。 只有在某个参数未传递，或明确传递 undefined 时，才会应用参数的默认值。null 值被认为是有效的。 12345678910111213141516function makeRequest(url, timeout = 2000, callback) &#123; // 函数的剩余部分&#125;// 使用默认的timeoutmakeRequest('/foo', undefined, function (body) &#123; doSomething(body)&#125;)// 使用默认的timeoutmakeRequest('/foo')// 不使用默认值makeRequest('/foo', null, function (body) &#123; doSomething(body)&#125;) 默认值表达式和暂时性死区参数默认值最有意思的特性或许就是默认值并不要求一定是基本类型的值。例如，你可以执行一个函数来产生参数的默认值： 12345678910111213function getValue () &#123; return 5&#125;function add (first, second = getValue()) &#123; return first + second&#125;// 2console.log(add(1, 1))// 6console.log(add(1)) 需要注意的是，仅在调用 add() 函数而未提供第二个参数时，getValue() 函数才会被调用，而在 getValue() 函数声明初次被解析时并不会进行调用。另外在书写代码时要小心，将函数调用作为参数的默认值时一定不要遗漏了括号，否则含义就变了。 参数默认值与 let 和 const 声明类似，都存在着暂时性死区。函数每个参数都会创建一个新的标识符绑定，它在初始化之前不允许被访问，否则会抛出错误。参数初始化会在函数被调用时进行，无论是给参数传递了一个值、还是使用了参数的默认值。 所以在为函数参数指定默认值时，后面的参数可以使用前面的参数，反过来则会抛出错误。 123456789101112131415161718192021222324// 后面参数使用前面参数function getValue (value) &#123; return value + 5&#125;function add1 (first, second = getValue(first)) &#123; return first + second&#125;// 2console.log(add1(1, 1)) // 7console.log(add1(1)) // 前面参数使用后面参数function add2 (first = second, second) &#123; return first + second&#125;// 2console.log(add2(1, 1)) // ReferenceError: second is not definedconsole.log(add2(undefined, 1)) 剩余参数剩余参数由三个点(…)与一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组，名称中的“剩余”也由此而来。需要注意的是，函数的 length 属性用于指示具名参数的数量，而剩余参数对其毫无影响。 123456789101112131415function pick (string, ...keys) &#123; console.log(pick.length) console.log(string) console.log(keys)&#125;// 1// undefined// []pick()// 1// 1// [2]pick(1, 2) 剩余参数的两个限制条件： 函数只能有一个剩余参数，并且它必须被放在最后。在对象访问器属性的 set 函数中，不能使用剩余参数。原因是对象的 set 被限定只能使用单个参数，而剩余参数按照定义是不限制参数数量的。 扩展运算符与剩余参数关联最密切的就是扩展运算符。剩余参数允许你把多个独立的参数合并到一个数组中。而扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数。 用扩展运算符传递参数，使得更容易将数组作为函数参数来使用，你会发现在大部分场景中扩展运算符都是 apply() 方法的合适替代品。并且扩展运算符可以与其他参数混用。 扩展运算符的使用没有位置和数量限制。 1234567891011let values = [25, 50, 75, 100]let others = [789, 234]// 100console.log(Math.max.apply(Math, values)) // 789console.log(Math.max(...values, ...others)) // 110console.log(Math.max(...values, 110)) ES6 的名称属性定义函数有各种各样的方式，在 JavaScript 中识别函数就变得很有挑战性。此外，匿名函数表达的流行使得调试有点困难，经常导致堆栈跟踪难以被阅读与解释。正因为此，ES6 给所有函数添加了 name 属性。 需要注意的是，函数的 name 属性值未必会关联到同名变量。name 属性是为了在调试时获得有用的相关信息，所以不能用 name 属性值去获取对函数的引用。 选择合适的名称ES6 中所有函数都有适当的 name 属性值。为了理解其实际运作，请看下例————它展示了一个函数与一个函数表达式，并将二者的 name 属性都打印出来： 123456789101112function doSomething () &#123; // ...&#125;var doAnotherThing = function () &#123; // ...&#125;// doSomethingconsole.log(doSomething.name) // doAnotherThingconsole.log(doAnotherThing.name) 在此代码中，由于是一个函数声明，doSomething() 就拥有一个值为 &quot;doSomething&quot; 的 name 属性。而匿名函数表达式 doAnotherThing() 的 name 属性值是 &quot;doAnotherThing&quot;，因为这是该函数所赋值的变量的名称。 名称属性的特殊情况虽然函数声明与函数表达式的名称易于查找，但 ES6 更进一步确保了所有函数都拥有合适的名称。为了表明这点，请参考如下程序： 1234567891011121314151617181920212223var doSomething = function doSomethingElse () &#123; // ...&#125;var person = &#123; get firstName () &#123; return 'Nicholas' &#125;, sayName: function () &#123; console.log(this.name) &#125;&#125;// doSomethingElseconsole.log(doSomething.name) // sayNameconsole.log(person.sayName.name) var descriptor = Object.getOwnPropertyDescriptor(person, 'firstName')// get firstNameconsole.log(descriptor.get.name) 本例中的 doSomething.name 的值是 &quot;doSomethingElse&quot;，因为该函数表达式自己拥有一个名称，并且此名称的优先级要高于赋值目标的变量名。person.sayName() 的 name 属性值是 &quot;sayName&quot;，正如对象字面量指定的那样。类似的， person.firstName 实际上是个访问器属性的 get 函数，因此它的名称是 &quot;get firstName&quot;，以标明它的特征。同样，访问器属性的 set 函数也会带有 set 前缀（ get 与 set 函数都必须用 Object.getOwnPropertyDescriptor() 来检索）。 函数名称还有另外两个特殊情况。使用 bind() 创建的函数会在名称属性值之前带有 &quot;bound&quot; 前缀。而使用 Function 构造器创建的函数，其名称属性则会有 &quot;anonymous&quot; 前缀，正如此例： 123456789var doSomething = function () &#123; // ...&#125;// bound doSomethingconsole.log(doSomething.bind().name)// anonymousconsole.log((new Function()).name) 明确函数的双重用途JavaScript 为函数提供了两个不同的内部方法：[[Call]] 和 [[Construct]]。当函数未使用 new 进行调用时，[[Call]] 方法会被执行，运行的是代码中显示的函数体。而当函数使用 new 进行调用时，[[Construct]] 方法则会被执行，负责创建一个新的对象，并且使用该对象作为 this 去执行函数体。 记住并不是所有函数都拥有 [[Construct]] 方法（比如箭头函数），因此不是所有函数都可以用 new 来调用。 在 ES5 中判断函数如何被调用在 ES5 中判断函数是不是使用了 new 来调用，最流行的方式是使用 instanceof，但是这个方式存在漏洞。 1234567891011121314151617function Person (name) &#123; if (this instanceof Person) &#123; this.name = name &#125; else &#123; throw new Error('you must use new with Person.') &#125;&#125;// 成功了var person = new Person('Nicholas') // 抛出错误var person = Person('Nicholas') // 本应抛出错误，但是用 call 方法更改 this 值，产生了欺骗// 成功了var notPerson = Person.call(person, 'Michael') new.target元属性为了解决上述问题，ES6 引入了 new.target 元属性。当函数的 [[Construct]] 方法被调用时，new.target 的值为一个指向该构造函数的引用。而当 [[Call]] 方法被调用时，new.target 的值为 undefined。 1234567891011121314151617function Person (name) &#123; if (new.target === Person) &#123; this.name = name &#125; else &#123; throw new Error('you must use new with Person.') &#125;&#125;function AnotherPerson (name) &#123; Person.call(this, name)&#125;// 成功了var person = new Person('Nicholas') // 抛出错误var person = new AnotherPerson('Nicholas') 箭头函数ES6 最有意思的一个新部分就是箭头函数。箭头函数正如名称所示那样使用一个“箭头”（=&gt;）来定义，但它的行为在很多重要方面与传统的 JavaScript 函数不同： 没有 this、super、arguments 和 new.target：箭头函数本身没有 this、super、arguments 和 new.target，如果在箭头函数中引用了这些变量，那这些变量也是外层作用域的，跟它没关系。不能被使用 new 调用：箭头函数没有 [[Construct]] 方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。没有原型：既然不能对箭头函数使用 new，那么它也不需要原型，也就是没有 prototype 属性。不允许重复的具名参数：箭头函数不允许拥有重复的具名参数，无论是否在严格模式下。而相对来说，传统函数只有在非严格模式下才禁止这种重复。不能用于创建生成器函数 箭头函数语法 没有花括号，就不允许有 return，否则会抛出错误。 12345678910111213141516171819202122232425262728293031323334353637383940414243var reflect = value =&gt; value// 等价于var reflect = function (value) &#123; return value&#125;// ========================================var sum = (num1, num2) =&gt; num1 + num2// 等价于var sum = function (num1, num2) &#123; return num1 + num2&#125;// ========================================var getTempItem = id =&gt; (&#123; id: id, name: 'Temp'&#125;)// 等价于var getTempItem = function (id) &#123; return &#123; id: id, name: 'Temp' &#125;&#125;// ========================================var getName = () =&gt; 'Nicholas'// 等价于var getName = function () &#123; return 'Nicholas'&#125;// ========================================var add = (num1, num2) =&gt; &#123; return num1 + num2&#125;// 等价于var add = function (num1, num2) &#123; return num1 + num2&#125;// ========================================var doNothing = () =&gt; &#123;&#125;// 等价于var doNothing = function () &#123;&#125; 创建立即调用函数表达式使用传统函数创建立即调用函数表达式时，(function(){/*函数体*/})() 与 (function(){/*函数体*/}()) 两种方式都是可行的。 但若使用箭头函数，只有 (()=&gt;{/*函数体*/})() 这一种方式可行，也就是说括号必须仅包裹箭头函数的定义。 没有 this 绑定JavaScript 最常见的错误领域之一就是在函数内的 this 绑定。请看下面的例子： 1234567891011121314var PageHandler = &#123; id: 123456, init: function () &#123; document.addEventListener('click', function (event) &#123; // 运行init时会抛出错误 this.doSomething(event.type) &#125;, false) &#125;, doSomething: function (type) &#123; console.log('Handling' + type + 'for' + this.id) &#125;&#125; 调用 this.doSomething() 会抛出错误的原因是 this 是对事件目标对象（在此案例中就是 document）的一个引用，而不是被绑定到 PageHandler 上。下面的代码将使用 bind() 方法修复这个问题。 1234567891011121314var PageHandler = &#123; id: 123456, init: function () &#123; document.addEventListener('click', (function (event) &#123; // 没有错误 this.doSomething(event.type) &#125;).bind(this), false) &#125;, doSomething: function (type) &#123; console.log('Handling' + type + 'for' + this.id) &#125;&#125; 现在此代码能像预期那样运行，但看起来有点奇怪。接着让我们看看使用箭头函数如何解决这个问题的。 12345678910111213var PageHandler = &#123; id: 123456, init: function () &#123; document.addEventListener('click', (event) =&gt; &#123; this.doSomething(event.type) &#125;, false) &#125;, doSomething: function (type) &#123; console.log('Handling' + type + 'for' + this.id) &#125;&#125; 因为箭头函数没有 this 绑定，意味着在箭头函数内部使用 this 值时，引擎是通过作用域链来确定的，而 JavaScript 中的作用域机制是词法作用域，所以这个箭头函数内部使用的 this 是 init() 方法的 this。因为箭头函数没有 this 绑定，所以对箭头函数使用 call()、apply() 或 bind() 方法时，函数内的 this 并不会受影响。永远要记住，this 是在函数调用时进行绑定的！ 12345678910111213141516171819let obj1 = &#123; a: 1, func: function showThisA () &#123; (() =&gt; &#123; console.log(this.a) &#125;)() &#125;&#125;let obj2 = &#123; a: 2, func: obj1.func&#125;// 1obj1.func() // 2obj2.func() 上面例子中箭头函数内使用的 this 是函数 showThisA 的 this，但是函数 showThisA 的 this 具体绑定到哪里是由它的调用方式决定的。 尾调用优化在 ES6 中对函数最有趣的改动或许就是一项引擎优化，它改变了尾部调用的系统。尾调用指的是调用函数的语句是另一个函数的最后语句，就像这样： 1234function doSomething () &#123; // 尾调用 return doSomethingElse() &#125; 在 ES5 引擎中实现的尾调用，其处理就像其他函数调用一样：一个新的栈帧被创建并推到调用栈之上，用于表示该次函数调用。这意味着之前每个栈帧都被保留在内存中，当调用栈太大时会出问题。 ES6 在严格模式下力图为特定尾调用减少调用栈的大小（非严格模式的尾调用则保持不变）。当满足以下条件时，尾调用优化会清除当前栈帧并在此利用它，而不是为尾调用创建新的栈帧： 尾调用的函数内部不能引用当前栈帧中的变量（意味着该函数不能是闭包）。进行尾调用的函数在尾调用返回结果后不能做额外操作。尾调用的结果作为当前函数的返回值。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[块级绑定]]></title>
    <url>%2Fposts%2F3432e35f%2F</url>
    <content type="text"><![CDATA[块级声明块指由花括号封闭的代码块。 块级声明包括 let 和 const 两种声明方式，首先介绍它们之间的共性特点： 块级作用域：块级声明的变量，无法在指定的块作用域外访问；禁止重复声明：如果一个标识符已经在代码块内部被定义，那么禁止在此代码块内部对同一个标识符进行块级声明，否则会抛出错误；暂时性死区：块级声明的变量不仅不会进行变量提升，在代码运行到声明处之前还会被存放在暂时性死区（TDZ）的区域内。如果在声明处之前试图访问变量会导致一个引用错误，即使是使用 typeof 运算符也是如此！ let 和 const 之间的差异在于，用 const 声明的变量会被认为是常量，意味着它们的值在被设置完成后就不能再被改变。如果使用 const 声明了一个对象，变量中保存的是对象的引用，所以只要不重写对象，其他的也都随意更改。 循环中的块级绑定开发者最需要使用变量的块级作用域的场景，或许就是在 for 循环内，也就是想让一次性的循环计数器只能在循环内部使用。例如，以下代码在 JavaScript 中并不罕见： 1234567for (var i = 0; i &lt; 10; i++) &#123; console.log(i)&#125;// i在此处仍然可被访问// 10console.log(i) 在其他默认使用块级作用域的语言中，这个例子能够按照预期工作，也就是只有 for 才能访问变量 i。然后在JavaScript中，循环结束后 i 仍然可被访问，因为 var 声明导致了变量提升。若像如下代码那样换为使用 let，则会看到逾期行为： 1234567for (let i = 0; i &lt; 10; i++) &#123; console.log(i)&#125;// i在此处不可访问，抛出错误// Uncaught ReferenceError: i is not definedconsole.log(i) 循环内的函数长期以来，var 的特点使得循环变量在循环作用域外仍然可被访问，于是在循环内部创建函数就变得很有问题。考虑如下代码： 12345678910var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func) &#123; // 输出数值 10 十次 func() &#125;) 为了修正上述问题，开发者在循环内使用立即调用函数表达式（IIFE），以便在每次迭代中强制创建变量的一个新副本，示例如下： 1234567891011121314var funcs = []for (var i = 0; i &lt; 10; i++) &#123; funcs.push((function (value) &#123; return function () &#123; console.log(value) &#125; &#125;(i)))&#125;funcs.forEach(function (func) &#123; // 从 0 到 9 依次输出 func() &#125;) 虽然解决了问题，但是这种写法相对繁琐。幸运的是，使用 let 与 const 的块级绑定可以在 ES6 中为你简化这个循环。 循环内的 let 声明let 声明通过有效模仿上例中的 IIFE 的作用而简化了循环。在每次迭代中，都会创建一个新的同名变量并对其进行初始化。这意味着你可以完全省略 IIFE 从而获得预期的结果，就像这样： 123456789101112var funcs = []for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125;funcs.forEach(function (func) &#123; // 从 0 到 9 依次输出 func() &#125;) 与使用 var 声明以及 IIFE 相比，这里代码能达到相同效果，但无疑更加简洁。在循环中 let 声明每次都创建了一个新的 i 变量，因此在循环内部创建的函数获得了各自的 i 副本，而每个 i 副本的值都在每次循环迭代声明变量的时候被确定了。这种方式在 for-in 和 for-of 循环中同样适用，如下所示： 1234567891011121314151617var funcs = []var object = &#123; a: true, b: true, c: true&#125;for (let key in object) &#123; funcs.push(function () &#123; console.log(key) &#125;)&#125;funcs.forEach(function (func) &#123; // 依次输出a、b、c func() &#125;) 本例中的 for-in 循环体现出了与 for 循环相同的行为。每次循环，一个新的 key 变量绑定就被创建，因此每个函数都能够拥有它自身的 key 变量副本，结果每个函数都输出了一个不同的值。 需要重点了解的是：let 声明在循环内部的行为是在规范中特别定义的，而与不提升变量声明的特征没有必然联系。事实上，在早期 let 的实现中并没有这种行为，它是后来才添加的。 循环内的 const 声明ES6规范没有明确禁止在循环中使用 const 声明，然而它会根据循环方式的不同而有不同行为。在常规的 for 循环中，你可以在初始化时使用 const，但循环会在你试图改变该变量的值时抛出错误。例如： 12345678var funcs = []// 在一次迭代后抛出错误for (const i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i) &#125;)&#125; 在此代码中，i 被声明为一个常量。循环的第一次迭代成功执行，此时 i 的值为0。在 i++ 执行时，一个错误会被抛出，因为该语句试图更改常量的值。因此，在循环中你只能使用 const 来声明一个不会被更改的变量。 而另一方面，const 变量在 for-in 或 for-of 循环中使用时，与 let 变量效果相同。因此下面代码不会导致出错： 123456789101112131415161718var funcs = []var object = &#123; a: true, b: true, c: true&#125;// 不会导致出错for (const key in object) &#123; funcs.push(function () &#123; console.log(key) &#125;)&#125;funcs.forEach(function (func) &#123; // 依次输出a、b、c func() &#125;) 这段代码与“循环内的 let 声明”小节的第二个例子几乎完全一样，唯一的区别是 key 的值在循环内不能被更改。const 能够在 for-in 与 for-of 循环内工作，是因为循环为每次迭代创建了一个新的变量绑定，而不是试图去修改已绑定的变量的值。 全局块级绑定let 与 const 不同于 var 的另一个方面是在全局作用域上的表现。当在全局作用域上使用 var 时，它会创建一个新的全局变量，并成为全局对象（在浏览器中是 window）的一个属性。这意味着使用 var 可能会无意覆盖一个已有的全局属性，就像这样： 12345678910// 在浏览器中var RegExp = 'hello'// helloconsole.log(window.RegExp) var ncz = 'hi'// hiconsole.log(window.ncz) 尽管全局的 RegExp 是定义在 window 上的，它仍然不能防止被 var 重写。这个例子声明了一个新的全局变量 RegExp 而覆盖了原有对象。类似地，ncz 定义为全局变量后就立即成为了 window 的一个属性。 然而若你在全局作用域上使用 let 或 const，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。这也就意味着你不能使用 let 或 const 来覆盖一个全局变量，你只能将其屏蔽。这里有个范例： 12345678910111213141516// 在浏览器中let RegExp = 'hello'// helloconsole.log(RegExp) // falseconsole.log(window.RegExp === RegExp) const ncz = 'hi'// hiconsole.log(ncz) // falseconsole.log('ncz' in window) 此代码的 let 声明创建了 RegExp 的一个绑定，并屏蔽了全局的 RegExp。这表示 window.RegExp 与 RegExp 是不同的，因此全局作用域没有被污染。同样，const 声明创建了 ncz 的一个绑定，但并未在全局对象上创建属性。当你不想在全局对象上创建属性时，这种特性会让 let 与 const 在全局作用域中更安全。 块级绑定新的最佳实践在默认情况下使用 const，并且只在知道变量值需要被更改的情况下才使用 let。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[this]]></title>
    <url>%2Fposts%2Fd213b25d%2F</url>
    <content type="text"><![CDATA[关于 this当一个函数被调用时，会创建一个活动记录（执行上下文、执行环境、context）。这个活动记录会包含函数在哪里被调用、函数的调用方法、传入的参数等信息。this 就是活动记录中的一个属性，会在函数执行的过程中用到。 this 是在运行时绑定的，它的绑定取决于函数调用时的各种方式。this 的绑定和函数的声明位置、函数的调用位置没有任何关系，只取决于函数的调用方式。 关于 this 是什么有很多说法：函数本身、函数作用域、函数的执行上下文等，这里有的说法是错误的，有的说法不够准确。我觉得就不要纠结 this 到底是什么东西了，this 就是 this，你只要知道它的绑定规则和用法，就 ok 了！ 绑定规则因为 this 的绑定取决于函数的调用方式，所以下面我们从函数的调用方式分析 this 的绑定规则。 默认绑定首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。 默认绑定是指当函数被调用时，是直接使用不带任何修饰的函数引用进行调用的，这种情况下，如果运行在非严格模式中，this 会绑定到全局对象上。如果运行在严格模式下，this 会绑定到 undefined 上。 1234567function foo () &#123; console.log(this.a)&#125;var a = 2// 2foo() 隐式绑定在调用函数的时候，如果以对象方法的形式进行调用，这个时候this就会绑定到这个方法所属的对象上。ps：如果对象的某个属性是函数，就称这个属性为对象的方法。 123456789101112131415161718function foo () &#123; console.log(this.a)&#125;var obj = &#123; a: 2, foo: foo&#125;// 2obj.foo() var obj2 = &#123; a: 42, obj: obj&#125;// 2obj2.obj.foo() 一定要区分开默认绑定和隐式绑定，下面的例子里包含了让人容易忽略的情况。再次强调 this 的绑定和函数的声明位置、函数的调用位置没有任何关系，只取决于函数的调用方式。 123456789101112131415161718192021222324function foo () &#123; console.log(this.a)&#125;var obj = &#123; a: 2, foo: foo, other: function () &#123; console.log(this.a) // 默认绑定 foo() &#125;&#125;var bar = obj.foovar a = 'oops, global'// 默认绑定// oops, globalbar() // 隐式绑定// 2// oops, globalobj.other() 显示绑定通过 apply() 和 call() 方法来调用函数时，this 的绑定为显示绑定，this 会绑定到传给 apply() 或 call() 方法的第一个参数上。 123456789function foo () &#123; console.log(this.a)&#125;var obj = &#123; a: 2&#125;// 2foo.call(obj) 如果传给 apply() 或 call() 方法的第一个参数为基本数据类型，那么这个基本类型值会被转换为对应的对象形式（new String()、 new Boolean()等）。 硬绑定是显示绑定的一个变种，硬绑定是使用 bind() 方法强制指定 this，该方法返回一个新的函数实例。 apply() 和 call() 是要指定函数运行时的 this 并运行函数，而 bind() 是返回一个 this 已经绑定完的函数实例。并且 bind() 是遵守就近原则的。如果用来指定 this 值的参数是基本数据类型，那么这个基本类型值会被转换为对应的基本包装类型（new String()、 new Boolean()等）。 123456function print () &#123; console.log(this.a + this.b);&#125;// 30print.bind(&#123;a: 10, b: 20&#125;).bind(&#123;a: 1, b: 2&#125;)(); new 绑定使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作： 创建一个全新的对象。这个新对象会被执行[[原型]]连接。这个新对象会绑定到函数调用的 this。如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 1234567function foo (a) &#123; this.a = a&#125;var bar = new foo(2)// 2console.log(bar.a) 优先级 new &gt; 显示 &gt; 隐式 &gt; 默认 bind 的 Polyfill下面的代码来源于MDN 1234567891011121314151617181920212223242526272829303132if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable') &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, // 利用闭包记住调用bind方法的函数 fNOP = function() &#123;&#125;, fBound = function() &#123; // fBound是要被返回的新函数 // 这个return里的this含义与外面的不同 // 这里this的绑定取决于函数的调用方式是new操作符调用还是其他方式调用 return fToBind.apply(this instanceof fBound ? this // 这里是new绑定的优先级高于显示绑定优先级的原因 : oThis, // 这里是bind方法可以进行柯里化的原因 // 这里的arguments是fBound函数的，与外面的那个不是同一个 aArgs.concat(Array.prototype.slice.call(arguments))) &#125; // 考虑到可能使用new，所以是要继承原型链 if (this.prototype) &#123; fNOP.prototype = this.prototype &#125; fBound.prototype = new fNOP() return fBound &#125;&#125; 意料之外的绑定被忽略的 this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。一般都是在函数并不关心 this 的情况下才会传入 null 或者 undefined 作为参数。 但是如果某个函数确实使用了 this，那么这种做法就会产生一些副作用（如修改全局对象）。 所以比较推荐的做法是传入 Object.create(null) 替代 null 和 undefined。 间接引用另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。 12345678910111213function foo () &#123; console.log(this.a)&#125;var a = 2var o = &#123; a: 3, foo: foo &#125;var p = &#123; a: 4 &#125;//3o.foo()// 2(p.foo = o.foo)() 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此 (p.foo = o.foo)() 等价于 foo()，所以会应用默认绑定。 软绑定软绑定的原理类似于硬绑定，直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839if (!Function.prototype.softBind) &#123; Function.prototype.softBind = function (obj) &#123; var fn = this var curried = [].slice.call(arguments, 1) var bound = function () &#123; return fn.apply( (!this || this === (window || global)) ? obj : this), curried.concat.apply(curried, arguments ) &#125; bound.prototype = Object.create(fn.prototype) return bound &#125;&#125;function foo () &#123; console.log(this.name)&#125;var obj = &#123; name: 'obj' &#125;var obj2 = &#123; name: 'obj2' &#125;var obj3 = &#123; name: 'obj3' &#125;var fooObj = foo.softBind(obj)// objfooObj() obj2.foo = foo.softBind(obj)// obj2obj2.foo() // obj3fooObj.call(obj3) // objsetTimeout(obj2.foo, 10) 可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会将 this 绑定到 obj。 箭头函数中的 thisES6 的箭头函数并不使用 function 关键字定义，而是使用被称为“胖箭头”的操作符 =&gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据词法作用域来决定 this。 123456789101112131415function foo () &#123; // 返回一个箭头函数 return (a) =&gt; &#123; // this继承自foo() console.log(this.a) &#125;&#125;var obj1 = &#123; a: 2 &#125;var obj2 = &#123; a: 3 &#125;var bar = foo.call(obj1)// 2bar.call(obj2) foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1，bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改 箭头函数可以像 bind() 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的this机制。 有关箭头函数的详细介绍点这里]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数&作用域&闭包]]></title>
    <url>%2Fposts%2Ff1587c53%2F</url>
    <content type="text"><![CDATA[函数的定义定义函数的两种常用方式为函数声明和函数表达式，他们有如下区别： 函数声明 函数函数表达式 会被提升 不会被提升 名称标识符会存在于所在的作用域中 名称标识符只能在这个函数的内部被访问，外部作用域则不行 作用域是什么引擎、编译器、作用域 引擎：从头到尾负责整个JavaScript程序的编译及执行过程。编译器：负责语法分析及代码生成。JavaScript的编译发生在代码执行前的几微秒（甚至更短！）的时间内。作用域：一套设计良好的、用来存储变量并能够根据名称方便地查找这些变量的规则。 以 var a = 2 为例，实际上引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。 首先，当遇到 var a 时编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中（也就是说在当前作用域中该变量是否已经存在）。如果是，编译器会忽略该声明，否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a;接下来，编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 a 的变量，如果是，引擎会使用这个变量。否则引擎会继续在外层作用域中查找该变量。 词法作用域和动态作用域词法作用域词法作用域是由你在写代码时将变量、块和函数写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的，不过存在例外）。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 12345678910111213function foo () &#123; console.log(a)&#125;function bar () &#123; var a = 3 foo()&#125;var a = 2// 2bar() 词法作用域查找只会查找一级标识符，例如如果代码中引用了 a.b.c，词法作用域查找只会试图查找 a 标识符，找到这个变量之后，它就不管了，后续的 b 和 c 标识符的查找被交给对象属性访问规则了。 eval() 和 with 的使用都会欺骗词法作用域，如果引擎在代码中发现了 eval() 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法确定 eval() 或 with 会带来什么样的影响。这样造成的结果就是引擎无法在编译阶段完成一些性能的优化从而造成性能下降。 动态作用域动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，动态作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时会输出 3。 12345678910111213function foo () &#123; console.log(a)&#125;function bar () &#123; var a = 3 foo()&#125;var a = 2// 3bar() 为什么会这样？因为当 foo() 无法找到 a 变量的引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。 需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。 执行环境、变量对象、作用域链当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。当引擎查找某个变量时，首先从当前作用域开始查找，如果可以找到则返回该变量。如果在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 那么引擎怎么知道当前作用域的外层作用域是谁，又该怎么找到它呢？答案是通过作用域链。 执行环境：每个块或函数都有自己的执行环境，执行环境中定义了在块或函数内部有权访问的其他数据，决定了它们各自的行为。全局执行环境是最外围的一个执行环境。变量对象：执行环境中定义的所有变量和函数都保存在这个对象中，我们在编程时无法访问这个对象。如果执行环境是一个函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量（函数的参数），即 arguments 对象（箭头函数没有 arguments 对象，而且不鼓励使用 arguments 对象）。（词法）作用域链：从当前执行环境的变量对象出发，将外层每一个执行环境的变量对象串联起来，保证对当前执行环境有权访问的所有数据的有序访问。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 LHS 和 RHS LHS：试图找到变量的容器本身，并对其进行赋值；RHS：找到该变量对应的值，并使用这个值。 将函数声明理解为先声明变量、再进行赋值并不合适。因为这样理解的话这个函数声明将需要进行LHS查询，但实际中并不是这样的。 为什么区分 LHS 和 RHS 是一件很重要的事情？因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。 如果 RHS 查询不到所需的变量，引擎就会抛出 ReferenceError 异常。 相比之下，当 LHS 查询不到变量时，如果在非严格模式下，就会在全局作用域中创建一个具有该名称的变量。但如果是在非严格模式下，就会抛出错误。 函数作用域和块作用域函数作用域函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。 根据作用域嵌套和作用域链的概念可以知晓，内部作用域可以访问外部作用域中的变量，但是反过来则不可以。 1234567891011var outter = '我在外面'function foo () &#123; var inner = '我在里面' console.log(outter)&#125;// 我在外面foo() // Uncaught ReferenceError: inner is not definedconsole.log(inner) 在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 1234567891011var a = 2function foo () &#123; var a = 3 console.log(a)&#125;// 3foo()// 2console.log(a) 虽然这种技术可以解决一些问题，但是也产生了一些副作用。首先必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域，其次必须显示地调用 foo()。下面介绍一种解决这两个问题的例子： 12345678910111213141516var a = 2;(function foo () &#123; var a = 3 // 3 console.log(a) // function console.log(typeof foo) &#125;)()// 2console.log(a) // Uncaught ReferenceError: foo is not definedconsole.log(foo) 首先，包装函数的声明是以圆括号开始的，尽管开上去这并不是一个很显眼的细节，但实际上确实非常重要的区别。函数会被当做函数表达式而不是一个标准的函数声明来处理。 上面的代码中使用了 IIFE：立即执行函数表达式。在一个函数表达式后面加上一对圆括号就表示要立即调用这个函数。 函数声明和函数表达式之间最重要的区别是它们的名称标识符会绑定在何处！函数声明的名称标识符会存在于所在的作用域中。而函数表达式的名称标识符只能在这个函数的内部被访问，外部作用域则不行。 12345678910// 实际的代码var foo = function bar () &#123; // ...&#125;// 等价于var foo = function () &#123; var bar = ...self... // ...&#125; 块作用域with用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。 try/catch非常少有人会注意到 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。例如： 1234567891011try &#123; // 执行一个非法操作来强制制造一个异常 undefined() &#125;catch (err) &#123; // 能够正常执行！ console.log(err) &#125;// ReferenceError: err not foundconsole.log(err) let 和 constES6 中引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中（通常是{…}内部）。 12345678910var foo = trueif (foo) &#123; let bar = 2 // 2 console.log(bar) &#125;// Uncaught ReferenceError: bar is not definedconsole.log(bar) const 和 let 的性质类似，主要的区别在于 const 是用来定义常量的。有关它们的详细特性后续就不在这里展开说了。 提升如何提升提升：包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。但是只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。 另外值得注意的是，每个作用域都会进行提升操作。 1234567891011121314// ========实际代码=========foo()function foo() &#123; console.log(a) var a = 2&#125;// =====编译器眼中的代码=====function foo() &#123; var a console.log(a) a = 2&#125;foo() 函数声明会被提升，但是函数表达式不会。 1234567891011121314151617181920212223242526272829/** * 提升前 */// TypeErrorfoo() // ReferenceErrorbar() var foo = function bar () &#123; // ...&#125;/** * 提升后 */var foo// TypeErrorfoo() // ReferenceErrorbar() foo = function () &#123; var bar = ...self... // ...&#125; 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。 12345678910111213141516171819202122232425262728293031/** * 提升前 */// 1foo () var foofunction foo () &#123; console.log(1)&#125;foo = function () &#123; console.log(2)&#125;/** * 提升后 */function foo () &#123; console.log(1)&#125;// 1foo () foo = function () &#123; console.log(2)&#125; 注意到，var foo 尽管出现在 function foo() 的声明之前，但是函数声明会首先被提升，所以 var foo 被当作重复的声明而忽略了。 如果有重复的函数声明，后面的会覆盖前面的，看下面例子： 1234567891011121314// 3foo() function foo () &#123; console.log(1)&#125;var foo = function () &#123; console.log(2)&#125;function foo () &#123; console.log(3)&#125; 闭包什么是闭包闭包：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 12345678910111213function foo () &#123; var a = 2 function bar () &#123; console.log(a) &#125; return bar&#125;var baz = foo()// 2// 这就是闭包的效果baz() 在 foo() 执行后，通常会将 foo() 的整个内部作用域都销毁，但是由于闭包的存在，foo() 的内部作用域被保存下来了。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。如果想要释放被闭包住的内存，需要解除对 bar 的引用，即执行 baz = null。 循环和闭包先运行下面的例子，观察结果： 1234567891011121314151617// 以每秒一次的频率输出五次 6for (var i = 1; i &lt;= 5; i++) &#123; (function () &#123; setTimeout(function timer () &#123; console.log(i) &#125;, i * 1000) &#125;)()&#125;// 以每秒一次的频率以此输出 1、2、3、4、5for (var i = 1; i &lt;= 5; i++) &#123; (function (j) &#123; setTimeout(function timer () &#123; console.log(j) &#125;, j * 1000) &#125;)(i)&#125; 我们通过下面的例子，详细解释闭包与循环的爱恨纠葛。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function createFunctions () &#123; var result = new Array() for (var i = 0; i &lt; 3; i++) &#123; result[i] = function () &#123; return i &#125; &#125; return result&#125;var array = createFunctions()// 3console.log(array[0]())// 3console.log(array[1]())// 3console.log(array[2]()) // 上面的等价形式function createFunctions () &#123; var result = new Array() var i = 0 result[i] = function () &#123; return i &#125; i = 1 result[i] = function () &#123; return i &#125; i = 2 result[i] = function () &#123; return i &#125; i = 3 return result&#125;var array = createFunctions()// 3console.log(array[0]())// 3console.log(array[1]()) // 3console.log(array[2]()) 内部函数中使用了 createFunctions 的活动对象的属性 i，而在真正调用内部函数时，这个 i 的值是 3，所以它们返回的都是 3。 实际上在 for 循环中使用 let 代替 var 就可以轻松解决这个问题，具体原因就先不赘述了。 1234567891011121314151617181920function createFunctions () &#123; var result = new Array() for (let i = 0; i &lt; 3; i++) &#123; result[i] = function () &#123; return i &#125; &#125; return result&#125;var array = createFunctions()// 0console.log(array[0]())// 1console.log(array[1]())// 2console.log(array[2]()) 私有变量严格来讲，JavaScript 中没有私有成员的概念，所有对象属性都是公开的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能再函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。 我们把有权访问私有变量和私有函数的公有方法成为特权方法。可以在构造函数中定义特权方法，基本模式如下： 12345678910111213function MyObject () &#123; // 私有变量和私有函数 var privateVariable = 10 function privateFunction () &#123; return false &#125; // 特权方法 this.publicMethod = function () &#123; privateVariable++ return privateFunction() &#125;&#125; 在创建 MyObject 的实例后，除了使用 publicMethod() 这一个途径外，没有任何办法可以直接访问 privateVariable 和 privateFunction()。 不过在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。构造函数的缺点是针对每一个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。 静态私有变量1234567891011121314(function () &#123; // 私有变量和私有函数 var privateVariable = 10 function privateFunction () &#123; return false &#125; // 构造函数 MyObject = function () &#123;&#125; MyObject.prototype.publicMethod = function () &#123; privateVariable++ return privateFunction() &#125;&#125;)() 这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式，函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明 MyObject 时用 var 关键字（记住：初始化未经声明的变量，在非严格模式下会创建一个全局变量，在严格模式下会抛出错误），这样 MyObject 就成了一个全局变量。而且特权方法是在原型上定义的，因此所有实例都能使用同一个函数。这个特权方法作为一个闭包，总是保存着对包含作用域的引用。 以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。 模块模式前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式则是为单例创建私有变量和特权方法。所谓单例，指的就是只有一个实例的对象。 123456789101112131415var singleton = function () &#123; var privateVariable = 10 function privateFunction () &#123; return false &#125; // 特权/公有方法和属性 return &#123; publicProperty: true, publicMethod: function () &#123; privateVariable++ return privateFunction() &#125; &#125;&#125;() 增强的模块模式这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。 12345678910111213141516171819var singleton = function () &#123; var privateVariable = 10 function privateFunction () &#123; return false &#125; // 创建对象 var object = new CustomType() // 添加特权/公有属性和方法 object.publicProperty = true object.publicMethod = function () &#123; privateVariable++ return privateFunction() &#125; // 返回这个对象 return object&#125;()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对象&原型&继承]]></title>
    <url>%2Fposts%2Fbb5d40f2%2F</url>
    <content type="text"><![CDATA[理解对象属性类型数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。 configurable：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，这个特性默认值为 true。enumerable：表示能否通过 for-in 循环返回属性。直接在对象上定义的属性，这个特性默认值为 true。writable：表示能否修改属性的值。直接在对象上定义的属性，这个特性默认值为 true。value：包含这个属性的数据值。读取属性值得时候，从这个位置读。写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。可以使用 Object.defineProperty(obj, prop, descriptor) 修改数据属性的特性：obj：数据属性所在的对象。prop：数据属性的名称，可以是字符串或符号。descriptor：描述符对象，可包含的属性有 configurable、enumerable、writable 和 value。如果通过 Object.defineProperty(obj, prop, descriptor) 定义一个新的数据属性，descriptor 中缺失的特性会被赋予 false 或 undefined。 12345678910111213var obj = &#123; test: 1 &#125;var desc = Object.getOwnPropertyDescriptor(obj, 'test')// &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;console.log(desc)Object.defineProperty(obj, 'demo', &#123; configurable: false&#125;)desc = Object.getOwnPropertyDescriptor(obj, 'demo')// &#123; value: undefined, writable: false, enumerable: false, configurable: false &#125;console.log(desc) 关于writable：当 writable 为 false 时，在非严格模式下通过赋值语句修改属性值，赋值操作将被忽略。在严格模式下则会抛出错误。但是如果通过 Object.defineProperty() 方法修改 value 特性则不会有任何问题。 123456789101112131415var obj = &#123; test: 1&#125;Object.defineProperty(obj, 'test', &#123; writable: false&#125;)obj.test = 2// &#123; test: 1 &#125;console.log(obj) Object.defineProperty(obj, 'test', &#123; value: 3&#125;)// &#123; test: 3 &#125;console.log(obj) 关于configurable：当 configurable 为 false 时，不允许删除属性，不允许修改属性的 enumerable、configurable，不可以将 writable 由 false 修改为 true，但是可以将 writable由 true 修改为 false，也可以修改属性的 value 特性。 当 writable 和 configurable 均为 false 时，不允许通过任何方式修改属性值，直接赋值或者通过 Object.defineProperty() 都不可以！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 下面的实验运行于非严格模式下 */var obj = &#123; test: 1 &#125;// 在 configurable 为 false 时尝试删除属性Object.defineProperty(obj, 'test', &#123; configurable: false&#125;)delete obj.test// &#123; test: 1 &#125;console.log(obj) var desc = Object.getOwnPropertyDescriptor(obj, 'test')// &#123; value: 1, writable: true, enumerable: true, configurable: false &#125;console.log(desc) // 在 configurable 为 false 时尝试修改 enumerable// Uncaught TypeError: Cannot redefine property: testObject.defineProperty(obj, 'test', &#123; enumerable: false&#125;)// 在 configurable 为 false 时尝试修改 configurable// Uncaught TypeError: Cannot redefine property: testObject.defineProperty(obj, 'test', &#123; configurable: true&#125;)// 在 configurable 为 false 时尝试修改 valueObject.defineProperty(obj, 'test', &#123; value: '此时 configurable 为 false'&#125;)// &#123; test: "此时 configurable 为 false" &#125;console.log(obj) // 在 configurable 为 false 时尝试将 writable 由 true 修改为 falseObject.defineProperty(obj, 'test', &#123; writable: false&#125;)var desc = Object.getOwnPropertyDescriptor(obj, 'test')// &#123; value: "此时 configurable 为 false", writable: false, enumerable: true, configurable: false &#125;console.log(desc) // 在 configurable 为 false 时尝试将 writable 由 false 修改为 true// Uncaught TypeError: Cannot redefine property: testObject.defineProperty(obj, 'test', &#123; writable: true&#125;)// 在 configurable 和 writable 均为 false时，尝试修改属性值obj.test = '直接赋值可以吗'// &#123;test: "此时configurable为false"&#125;console.log(obj) // Uncaught TypeError: Cannot redefine property: testObject.defineProperty(obj, 'test', &#123; value: '通过 Object.defineProperty 可以吗'&#125;) 访问器属性访问器属性不包含数据值。它们包含一对 get 和 set 函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 get 函数，这个函数负责返回有效的值。在写入访问器属性时，会调用 set 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。 configurable：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。直接在对象上定义的属性，它们的这个特性默认值为 true。enumerable：表示能否通过 for-in 循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为 true。get：在读取属性时调用的函数。默认值为 undefined。set：在写入属性时调用的函数。默认值为 undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 12345678910111213141516171819var book = &#123; _year: 2004, edition: 1&#125;Object.defineProperty(book, 'year', &#123; get: function () &#123; return _this.year &#125;, set: function (newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue this.edition += newValue - 2004 &#125; &#125;&#125;)book.year = 2005// &#123; _year: 2005, edition: 2 &#125;console.log(book) 不一定非要同时指定 get和 set。只指定 get 意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 get 函数的属性会抛出错误。而读取只指定 set 的属性会返回 undefined 可以通过 Object.defineProperty() 实现数据属性与访问器属性的转换，但是切记不能同时指定数据属性和访问器属性，这样会抛出错误！ 定义多个属性ES5 定义了一个 Object.defineProperties() 方法用来为对象定义多个属性。 1234567891011121314151617181920var book = &#123;&#125;Object.defineProperties(book, &#123; _year: &#123; value &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function () &#123; return _this.year &#125;, set: function (newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue this.edition += newValue - 2004 &#125; &#125; &#125;&#125;) 读取属性的特性使用 ES5 的 Object.getOwnPropertyDescriptor() 方法可以取得给定属性的描述符。该方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。这个方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用。 禁止扩展如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions()。如果想检测一个对象是否可以添加新属性，可以使用 Object.isExtensible()。 不可以添加新属性，但是删除旧属性还是可以的。 123456789101112131415var myObject = &#123; a: 2 &#125;Object.preventExtensions(myObject)// falseconsole.log(Object.isExtensible(myObject)) myObject.b = 3// undefinedconsole.log(myObject.b)delete myObject.a// undefinedconsole.log(myObject.a) 在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。 密封Object.seal() 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions() 并把所有现有属性标记为 configurable: false。 冻结Object.freeze() 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal() 并把所有“数据访问”属性标记为 writable: false。 创建对象工厂模式工厂模式就是调用函数返回一个包含特定属性和方法的对象，工厂模式的问题在于它没有解决对象识别的问题（即怎样知道一个对象的类型）。 123456789101112function createPerson (name, age) &#123; var o = &#123; name: name, age: age, sayName: function () &#123; console.log(this.name) &#125; &#125; return o&#125;var person1 = createPerson('Nicholas', 29)var person2 = createPerson('Greg', 27) 构造函数模式ES 中可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，下面使用构造函数模式重写工厂模式中的例子。 1234567891011121314function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var person1 = new Person('Nicholas', 29)var person2 = new Person('Greg', 27)// trueconsole.log(person1 instanceof Person) // trueconsole.log(person2 instanceof Person) 构造函数模式与工厂模式的区别： 没有显示地创建对象.直接将属性和方法赋给了 this 对象.没有 return 语句。 要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历一下 4 个步骤： 创建一个新对象（因为用了 new）。为新对象连接原型。将构造函数的作用域内的 this 绑定到这个新对象。执行构造函数的代码。返回新对象。 使用 new 创建新对象的时候，如果存在类的继承，那么在 ES5 和 ES6 中这个过程是有差别的。查看详情 构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那么它就可以作为构造函数。 构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍，但是有的方法是所有实例都应该共享的，没有创建多次的必要。 原型模式 我们创建的每一个函数都有一个 prototype（原型）属性，这个属性值是一个对象的引用，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 理解原型对象无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的引用。 1234567891011121314151617181920function Person () &#123;&#125;Person.prototype.name = 'Nicholas'Person.prototype.age = 29Person.prototype.job = 'Software Engineer'Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var person1 = new Person()// Nicholasperson1.sayName() var person2 = new Person()// Nicholasperson2.sayName() // trueconsole.log(person1.sayName === person2.sayName) 上图展示了 Person 构造函数、Person 的原型属性以及 Person 现有的两个实例之间的关系。注意 Person 的每个实例，person1 和 person2 都包含一个内部属性 [[Prototype]]，该属性仅仅指向了 Person.prototype。换句话说，对象实例与构造函数没有直接的关系。 isPrototypeOf()：用于测试一个对象是否存在于另一个对象的原型链上。hasOwnProperty()：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在，该方法是从 Object 继承而来的。Object.getPrototypeOf()：返回指定对象的原型（对象内部 [[Prototype]] 属性的值）。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例开始，如果在实例中找到了具有给定名字的属性，则返回该属性。如果没有找到，则沿着对象的原型链向上逐层查找具有给定名字的属性，如果找到了则返回这个属性的值。 属性设置和屏蔽当用赋值语句给实例对象设置已经在原型链上层存在的同名属性时，会有以下三种情况： 如果在原型链上层存在的同名属性没有被标记为只读，即 writable: true，那么会直接在实例中添加一个同名的新属性，它是屏蔽属性。如果在原型链上层存在的同名属性被标记为只读，即 writable: false，那么无法修改已有属性，也无法在实例对象上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。如果在非严格模式下，赋值语句会被忽略。如果在原型链上层存在的同名属性具有 set 描述符，那么一定会调用这个 set。实例对象上并不会添加新的属性，也不会重新定义这个 set。 但是 JS 这门语言很灵活，如果上述所说的存在于原型链上层的同名属性中保存的是某一个引用类型值的引用，那么你还是可以修改这个引用类型的值的（并没有违反规则，因为保存的引用并没有改变）！比如，这个属性保存的是某一个数组的引用，那么我就可以通过 push 方法去改变这个数组。 如果你无论如何也想要屏蔽原型链上层的属性，那么你可以使用 Object.defineProperty() 方法！ 有些情况下会隐式产生屏蔽，一定要当心。思考下面的代码： 1234567891011121314151617181920212223242526var anotherObject = &#123; a: 2 &#125;var myObject = Object.create(anotherObject)// 2anotherObject.a // 2myObject.a // trueanotherObject.hasOwnProperty('a') // falsemyObject.hasOwnProperty('a') // 隐式屏蔽！myObject.a++ // 2anotherObject.a // 3myObject.a // truemyObject.hasOwnProperty('a') 属性的获取有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。 在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 在使用 for-in 循环时返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包含存在于原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在 for-in 循环中返回。 要取得对象上所有可枚举的实例属性，可以使用 ES5 的 Object.keys() 方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 如果你想要得到所有实例属性，无论它是否可枚举，可以使用 Object.getOwnPropertyNames() 方法。 更简单的原型语法简单来说就是用对象字面量形式来重写 Person.prototype，但是这样会导致新原型对象的 constructor 属性指向 Object 而不是 Person，尽管此时 instanceof 操作符还能返回正确的结果，但是通过 constructor 已经无法确定对象的类型了，所以如果 constructor 属性比较重要的话，还需要用 Object.defineProperty() 方法定义 constructor 的数据属性。 1234567891011121314151617181920212223242526272829303132function Person () &#123;&#125;Person.prototype = &#123; name: 'Nicholas', age: 29, job: 'Software Engineer', sayName: function () &#123; console.log(this.name) &#125;&#125;var friend = new Person()// trueconsole.log(friend instanceof Object) // trueconsole.log(friend instanceof Person) // trueconsole.log(friend.constructor === Object) // falseconsole.log(friend.constructor === Person) Object.defineProperty(Person.prototype, 'constructor', &#123; enumerable: false, value: Person&#125;)// trueconsole.log(friend.constructor === Person) 原型的动态性由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来。即使是先创建了实例后修改原型也是如此。 12345678function Person () &#123;&#125;var friend = new Person ()Person.prototype.sayHi = function () &#123; console.log('hi')&#125;// hifriend.sayHi() 但是如果先创建了实例然后重写整个原型对象，那么情况就不一样了。具体的变化看图吧! 此时 instanceof 操作符已经不好使了！构造函数找不到最初的原型对象了！现有实例也找不到新的原型对象了！ 12345678910111213141516171819202122232425function Person () &#123;&#125;var friend = new Person()Person.prototype = &#123; name: 'Nicholas', age: 29, job: 'Software Engineer', sayName: function () &#123; console.log(this.name) &#125;&#125;Object.defineProperty(Person.prototype, 'constructor', &#123; enumerable: false, value: Person&#125;)// trueconsole.log(friend instanceof Object) // falseconsole.log(friend instanceof Person) // Uncaught TypeError: friend.sayName is not a functionfriend.sayName() 原型对象的问题原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型模式的最大问题。原型模式的最大问题是由其共享的本性所导致的（主要针对引用类型值的属性来说）。 组合使用构造函数模式和原型模式创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存，另外这种混成模式还支持向构造函数传递参数。 123456789101112131415161718192021222324252627function Person (name, age, job) &#123; this.name = name this.age = age this.job = job this.friends = ['Shelby', 'Court']&#125;Person.prototype = &#123; constructor: Person, sayName: function () &#123; console.log(this.name) &#125;&#125;var person1 = new Person('Nicholas', 29, 'Software Engineer')var person2 = new Person('Greg', 27, 'Doctor')person1.friends.push('Van')// ["Shelby", "Court", "Van"]console.log(person1.friends) // ["Shelby", "Court"]console.log(person2.friends) // falseconsole.log(person1.friends === person2.friends) // trueconsole.log(person1.sayName === person2.sayName) 动态原型模式动态原型模式把所有信息封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效来决定是否需要初始化原型。 123456789101112131415161718function Person (name, age, job) &#123; // 属性 this.name = name this.age = age this.job = job // 方法 if (typeof this.sayName !== 'function') &#123; Person.prototype.sayName = function () &#123; console.log(this.name) &#125; &#125;&#125;var friend = new Person('Nicholas', 29, 'Software Engineer')// Nicholasfriend.sayName() 在使用动态原型模式时，禁止使用对象字面量重写原型！ 寄生构造函数模式在前面几种模式都不适用的情况下，可以使用寄生构造函数模式，这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。 123456789101112131415function Person (name, age, job) &#123; var o = new Object() o.name = name o.age = age o.job = job o.sayName = function () &#123; console.log(this.name) &#125; return o&#125;var friend = new Person('Nicholas', 29, 'Software Engineer')// Nicholasfriend.sayName() 在这个例子中，Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。 关于寄生构造函数模式，有一点需要说明：返回的对象与构造函数或者与构造函数的原型属性之间没有关系。也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。 稳妥构造函数模式道格拉斯·克罗克福德发明了 JavaScript 中的稳妥对象这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与计生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this。二是不使用 new 操作符调用构造函数。 1234567891011121314151617function Person (name, age, job) &#123; // 创建要返回的对象 var o = new Object() // 可以在这里定义私有变量和函数 // 添加方法 o.sayName = function () &#123; console.log(name) &#125; return o&#125;var friend = Person('Nicholas', 29, 'Software Engineer')// Nicholasfriend.sayName() 小结 继承原型链12345678910111213141516171819function SuperType () &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property&#125;function SubType () &#123; this.subproperty = false&#125;SubType.prototype = new SuperType()SubType.prototype.getSubValue = function () &#123; return this.subproperty&#125;var instance = new SubType()// trueconsole.log(instance.getSuperValue()) 我觉得用文字解释这个原型链有点绕嘴，没有上图方便，就直接看下面的图片吧！ instanceof 操作符用于测试构造函数的 prototype 属性是否出现在对象的原型链中。isPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。在通过原型链实现继承时，不能使用对象字面量语法重写原型。 原型链的第一个问题类似于上面介绍的原型模式的问题，这里就不详细介绍了。它的第二个问题是在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 借用构造函数在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数的技术。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数（通过 call() 或 apply() 方法）。 12345678910111213141516171819function SuperType (name) &#123; this.name = name&#125;function SubType () &#123; // 继承了SuperType，同时还传递了参数 SuperType.call(this, 'Nicholas') // 实例属性 this.age = 29&#125;var instance = new SubType()// Nicholasconsole.log(instance.name) // 29console.log(instance.age) 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题-方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。 组合继承组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 123456789101112131415161718192021222324252627282930313233343536373839404142function SuperType (name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType (name, age) &#123; // 继承属性 SuperType.call(this, name) this.age = age&#125;// 继承方法SubType.prototype = new SuperType()SubType.prototype.sayAge = function () &#123; console.log(this.age)&#125;var instance1 = new SubType('Nicholas', 29)instance1.colors.push('black')// ["red", "blue", "green", "black"]console.log(instance1.colors) // Nicholasinstance1.sayName() // 29instance1.sayAge() var instance2 = new SubType('Greg', 27)// ["red", "blue", "green"]console.log(instance2.colors) // Greginstance2.sayName() // 27instance2.sayAge() 两个实例上的 colors 属性屏蔽了原型链上的同名属性。 原型式继承12345function object (o) &#123; function F () &#123;&#125; F.prototype = o return new F()&#125; 在 object() 函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质讲，object() 对传入其中的对象执行了一次浅复制。ES5 新增的 Object.create() 方法规范化了原型式继承。 寄生式继承寄生式继承是与原型式继承紧密相关的一种思路，寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 123456789101112131415161718192021222324252627function object (o) &#123; function F () &#123;&#125; F.prototype = o return new F()&#125;function createAnother (original) &#123; // 通过调用函数创建一个新对象 var clone = object(original) // 以某种方式来增强这个对象 clone.sayHi = function () &#123; console.log('hi') &#125; // 返回这个对象 return clone &#125;var person = &#123; name: 'Nicholas', friengd: ['Shelby', 'Court', 'Van']&#125;var anotherPerson = createAnother(person)// hianotherPerson.sayHi() 寄生组合式继承前面说过组合继承是 JavaScript 最常用的继承函数，不过它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。 1234567891011121314151617181920function SuperType (name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType (name, age) &#123; // 第二次调用SuperType() SuperType.call(this, name) this.age = age&#125;// 第一次调用SuperType()SubType.prototype = new SuperType() SubType.prototype.sayAge = function () &#123; console.log(this.age)&#125; 为了解决上述问题，我们使用寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 123456789101112131415161718192021222324252627282930313233343536function object (o) &#123; function F () &#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype (subType, superType) &#123; // 创建对象 var prototype = object(superType.prototype) // 增强对象 prototype.constructor = subType // 指定原型 subType.prototype = prototype &#125;function SuperType (name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType (name, age) &#123; SuperType.call(this, name) this.age = age&#125;inheritPrototype(SubType, SuperType)SubType.prototype.sayAge = function () &#123; console.log(this.age)&#125; 这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并因此避免了在 SubType.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用 instanceof 和 isPrototypeOf()。 小结]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[引用类型]]></title>
    <url>%2Fposts%2F71de0ab2%2F</url>
    <content type="text"><![CDATA[Object类型对象&amp;原型&amp;继承 Object Array类型Array RegExp类型RegExp Function类型函数&amp;作用域&amp;闭包 函数 Date类型通过 var now = new Date() 可以创建一个日期对象，在调用 Data 构造函数而不传参数时，新创建的对象自动获得当前日期和时间（当前日期和时间是浏览器从本机操作系统获取的时间，所以不一定准确！）。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 2017 年 1 月 1 日午夜起至该日期经过的毫秒数）。为了简化这一计算过程，ES提出了两个方法：Date.parse()和Date.UTC()。 Date.parse()：接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。但是它支持哪种日期格式并不一定。Date.UTC()：同样返回表示日期的毫秒数，但接收参数分别为年份、基于0的月份、月中的哪一天、小时、分钟、秒以及毫秒。这些参数中只有年和月是必需的。 其实，在使用 Date() 构造函数创建日期对象时，后台会根据传入的参数自动调用 Date.parse() 或 Date.UTC() 方法，所以根本不需要我们去主动的调用它们。ES5添加了 Date.now() 方法，返回表示调用这个方法时的日期和时间的毫秒数。在不兼容它的情况下可以使用 + new Date() 来达到相同的效果。 12345678910var now = new Date()now // 2020-10-17T04:56:29.512Znow.getFullYear() // 2020now.getMonth() // 0-11now.getDate() // 1-31now.getDay() // 0-6，0代表周日，6代表周六now.getHours() // 0-23now.getMinutes() // 0-59now.getSeconds() // 0-59now.getMilliseconds() // 0-999 基本包装类型ES提供了 3 个特殊的引用类型：Boolean、Number 和 String。这些类型与引用类型相似，但同时也具有与各自的基本类型相应的特殊行为，我们称它们为基本包装类型。 实际上，每当读取一个基本类型值的时候，后台会自动创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。 引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。 123456789101112131415161718192021// 创建了一个基本类型值并保存在s1中var s1 = 'some text' // 调用对应的基本包装类型s1.color = 'red' // undefined，因为基本包装类型的生存期已过console.log(s1.color) // stringconsole.log(typeof s1) // 显示的创建了String的实例对象并保存在s2中，实际上就是创建了一个引用类型值var s2 = new String('some text') s2.color = 'red'// String &#123;"some text", color: "red"&#125;console.log(s2) // objectconsole.log(typeof s2) 通过上面例子认识到通过 new 显示创建的就是一个引用类型值，它已经不能称之为基本包装类型了。换句话说，基本包装类型都是后台自己创建的，不存在显示创建的情况。在第六章会介绍，通过 new 显示创建的就是一个引用类型的实例对象。记住最好别用new将基本包装类型给实例化就行。 要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 12345678910111213var value = '25'// 转型函数var number = Number(value) // numberconsole.log(typeof number) // 构造函数var obj = new Number(value) // objectconsole.log(typeof obj) Boolean类型没啥说的。 Number类型 toFixed()：按照指定的小数位返回数值的字符串表示，银行家喜欢用这个方法，这个方法不是真正意义的四舍五入。toExponential()：返回以指数表示法表示的数值的字符串形式。toPrecision()：返回固定大小格式，也可能返回指数格式。 String类型字符方法charAt() 和 charCodeAt()方法都接收一个参数，即基于 0 的字符位置。charAt() 方法以单字符字符串的形式返回给定位置的那个字符，而 charCodeAt() 方法返回的是字符编码。 123456var string = 'hello world'// econsole.log(string.charAt(1)) // 101console.log(string.charCodeAt(1)) ES5 还定义了访问个别字符的方法，可以像数组那样使用索引来访问某个位置的字符。 1234var string = 'hello'// econsole.log(string[1]) 操作方法提取子字符串方法 slice()：类比于数组的slice()方法。substr()：第一个参数用于指定子字符串的开始位置，第二个参数用于指定返回的字符个数;substring()：类比于数组的slice()方法。 当传递负值作为参数时，slice() 方法会将传入的负值与字符串的长度相加。substr() 方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。substring() 方法会把所有负值参数都转换为0。 另外需要注意的是，substring() 方法会将参数中较小的数作为开始位置，将较大的数作为结束位置。即 string.substring(3, 0) 等价于 string.substring(0, 3)。 123456789101112131415var string = 'hello world'// rldconsole.log(string.slice(-3)) // hello world console.log(string.substring(-3)) // rld console.log(string.substr(-3)) // lo wconsole.log(string.slice(3, -4)) // hel console.log(string.substring(3, -4)) // ''console.log(string.substr(3, -4)) concat类比于数组的concat()方法。 trimES5 定义了这个方法，会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。 repeat该方法接收一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。 12345678// xxxconsole.log('x'.repeat(3)) // hellohelloconsole.log('hello'.repeat(2)) // abcabcabcabcconsole.log('abc'.repeat(4)) 位置方法indexOf(searchValue[, fromIndex]) 和 lastIndexOf(searchValue[, fromIndex]) 都是找到就返回索引，找不到就返回 -1。 大小写转换方法toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase() 方法。 模式匹配方法match match()：如果没有匹配成功就返回 null。如果匹配成功了，根据下面情况返回不同的内容。如果正则表达式使用了 g 标志，则返回所有匹配项组成的数组，该数组无特殊属性。如果正则表达式没有使用 g 标志，则仅返回第一个匹配项与捕获组组成的数组，该数组还含有3个特殊属性。index：匹配项在字符串中的索引。input：输入的字符串。group：一个捕获组或 undefined（如果没有定义命名捕获组）。 1234567var text = 'mom and dad and baby'// [ 'mom and dad and baby' ]console.log(text.match(/mom (and dad (and baby)?)?/g))// [ 'mom and dad and baby', 'and dad and baby', 'and baby', index: 0, input: 'mom and dad and baby', groups: undefined ]console.log(text.match(/mom (and dad (and baby)?)?/)) search search() 方法接收正则表达式作为参数，返回字符串中第一个匹配项的索引，如果没有找到匹配项则返回-1。 replace replace()：该方法接收两个参数，第一个参数可以是正则表达式或一个字符串，第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的办法就是提供正则表达式作为第一参数，并且要指定全局标志。第二个参数与正则表达式的捕获组有关。如果第二个参数是字符串如果第二个参数是函数 123456789101112131415var text = 'cat, bat, sat, fat'var result = text.replace('at', 'ond')// cond, bat, sat, fatconsole.log(result) result = text.replace(/at/g, 'ond')// cond, bond, sond, fondconsole.log(result) result = text.replace(/(.at)/g, 'word ($1)')// word (cat), word (bat), word (sat), word (fat)console.log(result) split split() 方法可以基于指定的分隔符将一个字符串分割成多个子字符串并将结果存放在一个数组中。分隔符可以是字符串，也可以是一个正则表达式。该方法有一个可选的第二参数，用于指定数组的大小。如果将空字符串作为分隔符传递给 split()，那么字符串会基于每一个 UTF-16 codeunit 进行划分。如果传递给 split() 的正则表达式中包含捕获组，那么捕获组会被保留下来 12345678910111213141516171819var colorText = 'red,blue,green,yellow'// [ 'red', 'blue', 'green', 'yellow' ]console.log(colorText.split(',')) // [ 'red', 'blue' ] console.log(colorText.split(',', 2)) // [ 'red', 'blue', 'green', 'yellow' ]console.log(colorText.split(/\,/)) // [ 'red', ',', 'blue', ',', 'green', ',', 'yellow' ]console.log(colorText.split(/(\,)/)) // [ '', ',', ',', ',', '' ]console.log(colorText.split(/[^\,]+/)) // [ '', 'red', ',', 'blue', ',', 'green', ',', 'yellow', '' ]console.log(colorText.split(/([^\,]+)/)) 识别子字符串的方法ES6新增了三个方法： includes(searchString[, fromIndex])：在给定文本出现在字符串的任意位置时返回 true，否则返回 false；startsWith(searchString[, fromIndex])：在给定文本出现在字符串起始处时返回 true，否则返回 false；endsWith(searchString[, length])：在给定文本出现在字符串结尾处时返回 true，否则返回 false。 详细 API 请移步 MDN，这里有 demo。 12345678910111213141516171819202122var msg = 'hello world!'// trueconsole.log(msg.startsWith('hello')) // falseconsole.log(msg.startsWith('o')) // trueconsole.log(msg.startsWith('o', 4)) // trueconsole.log(msg.endsWith('!')) // trueconsole.log(msg.endsWith('world!')) // trueconsole.log(msg.endsWith('o', 8)) // trueconsole.log(msg.includes('o'))// falseconsole.log(msg.includes('x'))// falseconsole.log(msg.includes('o', 8)) localeCompareMDN 上的介绍 fromCharCode该方法接收一个或多个字符编码，然后将它们转换成字符串。 模板字面量基本语法模板字面量的最简单语法，是使用反引号（`）来包裹普通字符串，而不是用双引号或单引号。若你想在字符串中包含反引号，只需要使用反斜杠（\）转义即可。 1234let message = `hello \` world`// hello ` worldconsole.log(message) 多行字符串ES6 的模板字面量使多行字符串更易创建，因为它不需要特殊的语法。只需在想要的位置包含换行即可，而且它会显示在结果中。 123456789let message = `Multilinestring`// Multiline// stringconsole.log(message) // 16console.log(message.length) 反斜杠之内的所有空白符都是字符串的一部分，因此需要留意缩进。 123456789let message = `Multiline string`// Multiline// stringconsole.log(message) // 30console.log(message.length) 如果让多行文本保持合适的缩进对你来说很重要，请考虑将多行模板字面量的第一行空置并在此后进行缩进，如下所示： 12345let html = `&lt;div&gt; &lt;h1&gt;Title&lt;/h1&gt;&lt;/div&gt;`.trim() 制造替换位此时模板字面量看上去仅仅是普通 JavaScript 字符串的升级版，但二者之间真正的区别在于前置的“替换位”。替换位允许你将任何有效的 JavaScript 表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分。 替换位由起始的 ${ 与结束的 } 来界定，之间允许放入任意的 JavaScript 表达式。例如： 1234567891011121314151617181920var name = 'Nicholas'var message = `hello, $&#123;name&#125;.`// hello, Nicholas.console.log(message) var count = 10var price = 0.25var message = `$&#123;count&#125; items cost $$&#123;(count * price).toFixed(2)&#125;.`// 10 items cost $2.50.console.log(message) var name = 'Nicholas'var message = `hello, $&#123; `my name is $&#123;name&#125;`&#125;.`// hello, my name is Nicholas.console.log(message) 标签化模板一个标签仅是一个函数，只不过这个函数的调用形式有些特别：tagName`模板字面量数据` 标签函数会将调用时接收的模板字面量数据中的非替换位提取出来保存为一个数组，这个数组将作为标签函数的第一个参数；数据中的每个替换位的解释值都将作为标签函数的参数传递进来。为了方便处理，一般在定义标签函数时使用剩余参数形式。 12345678910111213function passthru (literals, ...substitutions) &#123; // ["", " items cost $", ""] console.log(literals) // [10, "2.50"] console.log(substitutions) return '返回啥都行'&#125;var count = 10var price = 0.25var message = passthru`$&#123;count&#125; items cost $$&#123;(count * price).toFixed(2)&#125;` 注意观察上面的例子，literals 数组的第一个和最后一个元素均为空字符串，说明标签函数在对传入的模板字面量进行处理时，总是以非替换位形式的字符串作为数据的开始和结尾；如果模板字面量实际上是以替换位作为开始和结尾，那么会自动在开始和结尾处添加上空字符串！所以 literals 的长度总是比 substitutions 的长度多 1。 模板标签也能访问字符串的原始信息，主要指的是可以访问字符在转义之前的形式。获取原始字符串值的最简单方式是使用内置的 String.raw() 标签。不过我按照书中例子试验的时候，关于原始形式这里有些出入，详细的就不介绍了。 单体内置对象内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显示地实例化内置对象，因为它们已经实例化了。前面介绍的 Object、Array、String 等都是内置对象，除此之外还有两个单体内置对象：Global 和 Math。 Global对象Global (全局)对象可以说是 ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ES中的Global 对象在某种意义上是作为一个终极的“兜底儿的对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数。所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。 ES虽然没有指出如何直接访问 Global 对象,但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。 1234// 取得 Global 对象的方法var global = function () &#123; return this&#125; URI编码方法Gloabl对象的 encodeURI() 和 encodeURIComponent() 方法可以对URI进行编码，以便发送给浏览器 它们的主要区别在于，encodeURI() 不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号。而 encodeURIComponent() 则会对它发现的任何非标准字符串进行编码 与它们相对应的方法是 decodeURI() 和 decodeURIComponent() 1234567var uri = 'http://www.wrox.com/illegal value.html#start'// http://www.wrox.com/illegal%20value.html#startconsole.log(encodeURI(uri))// http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23startconsole.log(encodeURIComponent(uri)) Math对象属性和方法 属性：Math.E：自然对数的底数，即常量 e 的值。Math.LN10：10 的自然对数。Math.LN2：2 的自然对数。Math.LOG2E：以 2 为底 e 的对数。Math.LOG10E：以 10 为底 e 的对数。Math.PI：π 的值。Math.SQRT1_2：1/2 的平方根（即 2 的平方根的倒数）。Math.SQRT2：2 的平方根。方法：Math.abs(x)：返回x的绝对值。Math.pow(x, y)：返回 $x^y$。 min &amp;&amp; max123456var max = Math.max(3, 54, 32, 16)var min = Math.min(3, 54, 32, 16)console.log(max, min) // 54 3 var values = [1, 2, 3, 4, 5, 6, 7, 8]console.log(Math.max.apply(Math, values)) // 8 舍入方法 Math.ceil()：执行向上（大）舍入，即它总是将数值向上舍入为最接近的整数。Math.floor()：执行向下（小）舍入，即它总是将数值向下舍入为最接近的整数。Math.round()：执行标准舍入，即它总是将数值四舍五入为最接近的整数。Math.round() 在数值是负数且小数部分恰好是 0.5 时会出现例外，如 Math.round(-1.5) 的值为 -1. randomMath.random() 方法返回介于 0 和 1 之间的一个随机数，包括 0，但不包括 1。 123456789101112131415161718// 得到一个随机数，包括 min，不包括 maxfunction getRandomArbitrary (min, max) &#123; return Math.random() * (max - min) + min &#125;// 得到一个随机整数，包括 min，不包括 maxfunction getRandomInt (min, max) &#123; min = Math.ceil(min) max = Math.floor(max) return Math.floor(Math.random() * (max - min)) + min&#125;// 得到一个随机整数，包括 min 和 maxfunction getRandomIntInclusive (min, max) &#123; min = Math.ceil(min) max = Math.floor(max) return Math.floor(Math.random() * (max - min + 1)) + min&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基本概念]]></title>
    <url>%2Fposts%2F2c31c1a2%2F</url>
    <content type="text"><![CDATA[变量ECMAScript 的变量是松散类型的，可以用来保存任何类型的数据，换句话说，变量只是一个用于保存值得占位符而已，变量没有类型，数据才有类型！ 使用 var 声明变量，变量为声明该变量的作用域中的局部变量。即在全局作用域中声明的变量为全局变量，在局部作用域中声明的变量为局部变量。使用 var 声明的变量如果未初始化，则变量保存的值默认为 undefined。对没有声明的变量直接进行赋值操作（或者说是 LHS 操作），在非严格模式下，会创建一个全局变量。但是在严格模式下，会抛出错误。 数据类型JavaScript 的数据类型分为“基本数据类型”和“引用数据类型”两种。 基本数据类型：Undefined、Null、Boolean、Number、String 和 Symbol（ES6 提出）。引用数据类型：Object。 检测类型typeof 操作符对一个值使用 typeof 操作符，可能返回下列某个字符串（均为英文单词小写形式）： &quot;undefined&quot;: 如果这个值未定义。&quot;boolean&quot;: 如果这个值是布尔值。&quot;string&quot;: 如果这个值是字符串。&quot;number&quot;: 如果这个值是数值。&quot;symbol&quot;: 如果这个值是符号。&quot;function&quot;: 如果这个值是函数（其实函数属于对象的一种）。&quot;object&quot;: 如果这个值是对象或 null。 instanceof 操作符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 object instanceof constructor =&gt; true | false 《JavaScript 高级程序设计》中说：“根据规定，所有引用数据类型的值都是Object的实例。因此，在检测一个引用数据类型值和Object构造函数时，instanceof操作符始终会返回true。”随着版本的迭代，这个说法变得不准确了，有例外了！！！ 12var a = Object.create(null)console.log(a instanceof Object) // false Object.prototype.toString.call()返回一个表示类型的字符串，详情请看 MDN官网。 基本数据类型UndefinedUndefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。对未初始化的变量执行 typeof 操作会返回 undefined ，而对未声明的变量执行 typeof 操作同样会返回 undefined。 除了可以对未声明的变量执行 typeof 操作之外，在非严格模式下还可以对其进行 delete 操作。除了这两种情况之外，对未声明的变量进行任何其他操作，都会抛出错误。 NullNull 类型也只有一个值 - null。 1234typeof null === 'object' // truenull instanceof Object // falsenull == undefined // trueBoolean(null) === false // true BooleanBoolean 类型的字面值 true 和 false 是区分大小写的。也就是说，True 和 False 都不是 Boolean 值，只是标识符。 Number 八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。绝对值超过 Number.MAX_VALUE 的值会被自动转换为 infinity 或 -infinity。可以使用 isFinite() 函数来确定数值是否为无穷。如果不是无穷，则返回 true。NaN 与自身都不相等，可以使用 isNaN() 或 Number.isNaN() 确定数值是否为 NaN。在传入数据非数值时，isNaN() 会首先调用 Number() 将其转换为数值类型再进行判断，而 Number.isNaN() 则会直接返回 false。Number() 用于把任何类型数据转换为数值。parseInt() 和 parseFloat() 用于把字符串转换为数值。parseInt() 在转换字符串时比 Number() 好用，但是最好为 parseInt() 提供第二个参数（转换的基数2、8、10、16）。 String 任何字符串的长度都可以通过访问其 length 属性取得，包含双子节字符的可能不准确。字符串是不可变的，一旦创建就不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串然后再用新的替代。数值、布尔值、对象和字符串值都有 toString() 方法，并且数值的 toString() 方法可以接收一个参数（数值的基数），但是 null 和 undefined 没有。在不知道要转换值的类型时，可以使用 String() 方法。 引用数据类型ObjectECMAScript 中的对象其实就是一组数据和功能的集合，它的属性或方法是没有顺序之分的！！！ Object 类型是所有它的实例的基础，它所具有的任何属性和方法也同样存在于更具体的对象中。Object 的每个实例都具有下列属性和方法： constructorhasOwnProperty(propertyName)isPrototypeOf(object)propertyIsEnumerable(propertyName)toLocaleString()toString()valueOf() 复制变量值在将一个值赋给变量时，如果这个值是基本数据类型，则变量中保存的是这个值本身。如果这个值是引用数据类型，则变量中保存的只是该值的一个引用（通过引用，可以在内存中找到这个引用数据类型的值）！ 12345678910111213141516// ===================================================// 在从一个变量向另一个变量复制基本数据类型值和引用数据类型值的区别// ===================================================//复制基本数据类型值var a = 1var b = ab = 2console.log(a, b) // 1, 2// 复制引用数据类型值// c 和 d 中保存的都是指向内存中同一对象的引用var c = &#123; num: 1 &#125;var d = cd.num = 2console.log(c.num, d.num) //2, 2 传递参数ECMAScript 中所有函数的参数都是按值传递的。简单来说就是数据进行复制，然后传递给给函数作为参数。 语句for-in语句ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。 for-in 不能对 null 和 undefined 进行迭代。 switch语句可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），并且每个 case 的值不一定是常量，可以是变量，甚至是表达式。 switch对 case 进行匹配时，遵循的是 === 严格相等。 函数理解参数首先说明我的观点，不推荐使用 arguments ！！！ ECMAScript 中的函数参数是用一个数组来表示的，可以通过 arguments 对象来访问这个数组，arguments 是一个类数组对象。 关于 arguments 和 命名参数 之间是如何相互影响的，《JavaScript高级程序设计》与《深入理解ES6》的说法有些矛盾，我在谷歌浏览器中简单的试了一下，他们之间的同步关系好像是双向的。 没有重载ECMAScript 中的函数没有重载，如果声明了多个同名函数，后面的会覆盖前面的。 垃圾收集JavaScript 中的变量分为全局变量和局部变量，其中全局变量一直存在，不会被清除。 而局部变量只在函数执行的过程中存在，当函数执行结束后，局部变量会被自动清除。 当然如果存在闭包的话，局部变量被清除的时机需要取决于闭包。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo搭建个人博客]]></title>
    <url>%2Fposts%2Fd4a0c543%2F</url>
    <content type="text"><![CDATA[准备工作 Node安装及配置Git安装及配置阅读Hexo的文档 Hexo安装及博客初始化在Node安装成功之后，在命令行中使用npm命令安装Hexo，输入：npm install -g hexo-cli。 安装完成后我们自己创建一个空文件夹Blog作为博客的根目录，双击进入文件夹，之后按住shift键并点击鼠标右键，选择菜单中的“在此处打开Powershell窗口”，这样所有的命令行操作都是以Blog为根目录进行的，后文的所有命令行均是以Blog为根目录！ 在新打开的命令行窗口中依次输入：123hexo inithexo ghexo s 完成后就可以在浏览器中输入http://localhost:4000来查看我们的本地博客了。 主题更换我选择的是评价较好的Next主题，首先将主题下载到Blog/themes中，在Blog根目录启动命令行，输入： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 现在先简单的介绍下Blog下的themes文件夹和_config.yml文件，themes下保存的是博客的主题，每一种主题为一个文件夹，例如目前为止我们有两种主题landscape（自带的）和next。下面请仔细注意，每个主题文件夹下都有一个_config.yml文件，我们称之为主题配置文件，而Blog文件夹下的_config.yml称之为站点配置文件。 接下来打开站点配置文件，修改主题为next，保存。 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 也可以修改next的主题样式，当前版本的next有四种样式，我选择的是最后一个Gemini。 12345# Schemes# scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 除此之外有关于博客样式和功能菜单的配置，大部分都可以在这两个配置文件中发现，Next主题也提供了一份配置方面的文档。 都保存之后，连续执行三个命令： 123hexo cleanhexo ghexo s 接着刷新浏览器就可以观察到页面样式的变化。 博客的备份及部署到目前为止，已经成功用Hexo建立本地博客，接下来要先将本地博客文件备份至github中，然后再部署博客。 在开始前先介绍一下这部分的安排，打算创建两个分支master和root。 master：负责博客的部署，所以其中存放的是部署后生成的文件；root：负责存放博客的原始文件，并且要注意将root设置为默认分支。 首先在github上创建个人仓库，然后复制仓库的SSH，格式为git@github.com:username/repository_name.git，将username和repository_name分别换为你的github用户名和仓库名。 接着修改github账号的Setting中的Emails设置，取消下图中红线标记的功能。 然后通过下列指令将本地博客文件备份至github的root分支上： 123git init# 注意add后面有个“空格”和“.”git add . 备份过程中会遇到一个警告提示，原因是我们前面使用的主题Next也是一个Git仓库，所以在将Blog文件下所有文件加入Git缓存中时会警告我们子仓库不会被添加，解决方式为将这个Git子仓库以我们的本地文件夹形式加入到Git缓存中。 12345678git rm --cached themes/next -f# next后面的“/”表示添加的是文件夹，一定要加上git add themes/next/git commit -m "first commit to branch root"# 将本地master分支重命名为rootgit branch -m master rootgit remote add origin git@github.com:aadonkeyz/Blog.gitgit push -u origin root 最后一个指令输完可能会要求我们输入SSH秘钥的密码，如果要求验证，输入密码即可。 上面的操作已经成功将本地博客文件添加到仓库的root分支，接着打开站点配置文件进行如下修改：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:aadonkeyz/Blog.git branch: master 保存后开始通过命令行下载并保存一个名为hexo-deployer-git的插件，然后就可以将博客部署到github上了。 1234npm install hexo-deployer-git --savehexo cleanhexo ghexo d 目前已经将博客部署到master分支了，但是还要进行一些修改才可以，进入仓库的Setting中，找到Github Pages，将Source选择为master branch。 完成后会发现这部分会有所变化，多出一个链接，格式为https://username.github.io/仓库名/。 回到站点配置文件中将url改为刚刚的链接，root改为/仓库名/。 1234# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://aadonkeyz.github.io/Blog/root: /Blog/ 之后将新的修改备份至github并重新部署博客。 123456git add .git commit –m “change URL and Deploy of site config”git push -u origin roothexo cleanhexo ghexo d 大功告成，等待几秒后（github需要时间来完成更新），在浏览器中输入刚刚的url链接就可以查看我们部署在github上的博客啦！]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows下Node安装及配置]]></title>
    <url>%2Fposts%2Fee28a0bf%2F</url>
    <content type="text"><![CDATA[Node的安装首先附上Node的下载链接 安装过程中除了对安装位置进行修改外，其他的都选择默认项就可以，我的安装位置选择为D:\nodejs\，安装之后在命令行中分别输入node -v和npm -v会显示出对应的node及npm版本号。 刚刚安装完成之后，nodejs的目录如下所示。 Node路径修改接下来要修改npm安装全局模块的路径和缓存cache的路径，这样做是因为默认路径都在C盘，而我们并不想过多的占用C盘空间。 在修改路径前先在D:\nodejs\下创建node_global和node_cache文件夹。 然后在命令行中输入以下指令： 12npm config set prefix "D:\nodejs\node_global"npm config set cache "D:\nodejs\node_cache" 上面的指令为修改路径，现在让我们验证下路径修改是否成功：首先通过npm全局安装一个模块，如果这个模块被下载到我们指定的文件夹中，则说明修改成功。 1npm install express -g 检查D:\nodejs\node_global文件夹，在里面的node_modules中发现刚刚全局安装的express模块，说明上述对路径的修改已经成功。 Node环境变量修改因为我们刚刚修改了模块的全局安装路径，所以需要修改相应的环境变量以保证在Node使用过程中，可以找到正确的位置来引用模块，操作如下： 我的电脑 - 右键 - 属性 - 高级系统设置 - 高级 - 环境变量 在“系统变量”下新建NODE_PATH,输入：D:\nodejs\node_global\node_modules。 在“用户变量”下的Path中用D:\nodejs\node_global替换C:\Users\17590\AppData\Roaming\npm。 环境变量修改完成之后，打开一个新的命令行窗口，先输入node，按回车进入nodejs的交互式命令控制台，然后输入require(&#39;express&#39;),如果能够正常显示express模块的信息，则说明环境变量的修改也成功了。 使用淘宝镜像接下来修改npm配置，使用国内的淘宝镜像以保证模块下载的稳定性和速度，下列两种方式二选一即可。 123456# 安装cnpm模块# 以后使用cnpm替代npmnpm install -g cnpm --registry=https://registry.npm.taobao.org# 或者修改npm源地址为淘宝镜像npm config set registry https://registry.npm.taobao.org]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git的安装及配置]]></title>
    <url>%2Fposts%2F6749cdaf%2F</url>
    <content type="text"><![CDATA[Git的安装首先附上Git的下载链接 在Git下载完成之后，除了对安装位置进行更改之外，其他的按照默认选项来就可以。当安装完成之后，打开命令行，输入git,如果看到有关Git的相关信息就说明安装成功了！ Git的配置安装成功后要配置Git的用户名与邮箱，相当于自报家门，在进行这一配置时可以通过参数指定配置的作用域。作用域：--system &gt; --global &gt; --local。优先级：--local &gt; --global &gt; --system。 以github和gitlab为例，由于我在两个网站的注册用户名与邮箱均为为aadonkeyz和aadonkeyz@gmail.com，所以我选择进行一次全局配置即可。 全局配置指令： 12git config --global user.name "aadonkeyz"git config --global user.email "aadonkeyz@gmail.com" SSH 配置因为我们需要在同一台电脑中同时使用github和gitlab，为了保证两个网站在使用SSH时不产生冲突，需要为两个网站生成两对不同的秘钥，并在SSH的config文件中指定Git在访问不同的网站时要使用相对应的秘钥。 1ssh-keygen -t rsa -C aadonkeyz@github -t = The type of the key to generate-C = comment to identify the key 注释内容一般填写注册邮箱，不过我在两个网站的注册邮箱相同，所以我的注释分为了： 1234# githubaadonkeyz@github# gitlabaadonkeyz@gitlab 上面是我为github生成秘钥的过程，在过程中我没有修改秘钥的默认保存位置，但是为了对秘钥进行区分修改了秘钥的名称，并设定了密码（passphrase），一旦为秘钥设置了密码，那么以后每次使用SSH时都会要求输入秘钥。请读者自行将生成的秘钥添加到github中去，并在gitlab上进行相同的操作。 接下来开始自定义config文件，首先在保存秘钥的文件夹下创建一个名为config的文件，注意不要任何后缀（可以先创建名为config的文本文档，之后删除“.txt”后缀），然后填写如下内容： 1234567Host github.com User git IdentityFile ~/.ssh/github_rsaHost gitlab.com User git IdentityFile ~/.ssh/gitlab_rsa 保存并退出，最后我们来通过指令，ssh -T github.com和ssh -T gitlab.com测试一下是否成功。 大功告成！]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
</search>
